# FANUC  GENERIC Heidenhain Base HEIDENHAIN TNC640
# Okuma Base OKUMA_OSP_L  OKUMA_OSP_M  OKUMA_OSP_S
# SIEMENS828D  SIEMENS840D Sinumerik Base
# TEMPLATE

# ctrl_fanuc_base.tcl

proc LIB_SPF_set_initial_globals_LIB {} {

  uplevel #0 {

    set mom_system_tolerance                      0.0000001
    set mom_sys_control_out                       "("
    set mom_sys_control_in                        ")"

    ########## SYSTEM VARIABLE DECLARATIONS ##############
    set mom_sys_rapid_code                        "0"
    set mom_sys_linear_code                       "1"
    set mom_sys_circle_code(CLW)                  "2"
    set mom_sys_circle_code(CCLW)                 "3"
    set mom_sys_delay_code(SECONDS)               "4"
    set mom_sys_delay_code(REVOLUTIONS)           "4"
    set mom_sys_cutcom_plane_code(XY)             "17"
    set mom_sys_cutcom_plane_code(ZX)             "18"
    set mom_sys_cutcom_plane_code(XZ)             "18"
    set mom_sys_cutcom_plane_code(YZ)             "19"
    set mom_sys_cutcom_plane_code(ZY)             "19"
    set mom_sys_lathe_thread_advance_type(1)      "33"
    set mom_sys_lathe_thread_advance_type(2)      "34"
    set mom_sys_lathe_thread_advance_type(3)      "35"
    set mom_sys_cutcom_code(OFF)                  "40"
    set mom_sys_cutcom_code(LEFT)                 "41"
    set mom_sys_cutcom_code(RIGHT)                "42"
    set mom_sys_adjust_code                       "43"
    set mom_sys_adjust_code_minus                 "44"
    set mom_sys_adjust_cancel_code                "49"
    set mom_sys_unit_code(IN)                     "20"
    set mom_sys_unit_code(MM)                     "21"
    set mom_sys_cycle_start_code                  "79"
    set mom_sys_cycle_off                         "80"
    set mom_sys_cycle_drill_code                  "81"
    set mom_sys_cycle_drill_dwell_code            "82"
    set mom_sys_cycle_drill_deep_code             "83"
    set mom_sys_cycle_drill_break_chip_code       "73"
    set mom_sys_cycle_tap_code                    "84"
    set mom_sys_cycle_bore_code                   "85"
    set mom_sys_cycle_bore_drag_code              "86"
    set mom_sys_cycle_bore_no_drag_code           "76"
    set mom_sys_cycle_bore_dwell_code             "89"
    set mom_sys_cycle_bore_manual_code            "88"
    set mom_sys_cycle_bore_back_code              "87"
    set mom_sys_cycle_bore_manual_dwell_code      "88"
    set mom_sys_output_code(ABSOLUTE)             "90"
    set mom_sys_output_code(INCREMENTAL)          "91"
    set mom_sys_cycle_ret_code(AUTO)              "98"
    set mom_sys_cycle_ret_code(MANUAL)            "99"
    set mom_sys_reset_code                        "92"
    set mom_sys_feed_rate_mode_code(FRN)          "93"
    set mom_sys_spindle_mode_code(SFM)            "96"
    set mom_sys_spindle_mode_code(RPM)            "97"
    set mom_sys_spindle_max_rpm_code              "92"
    set mom_sys_spindle_cancel_sfm_code           "97"
    set mom_sys_return_code                       "28"
    set mom_sys_feed_rate_mode_code(DPM)          "94"
    set mom_sys_feed_rate_mode_code(IPM)          "94"
    set mom_sys_feed_rate_mode_code(IPR)          "95"
    set mom_sys_feed_rate_mode_code(MMPM)         "94"
    set mom_sys_feed_rate_mode_code(MMPR)         "95"
    set mom_sys_polar_mode(ON)                    "112"
    set mom_sys_polar_mode(OFF)                   "113"
    set mom_sys_program_stop_code                 "0"
    set mom_sys_optional_stop_code                "1"
    set mom_sys_end_of_program_code               "2"
    set mom_sys_start_of_subprogram               "98"
    set mom_sys_end_of_subprogram                 "99"
    set mom_sys_spindle_direction_code(CLW)       "3"
    set mom_sys_spindle_direction_code(CCLW)      "4"
    set mom_sys_spindle_direction_code(OFF)       "5"
    set mom_sys_spindle_orient_code               "19"
    set mom_sys_tool_change_code                  "6"
    set mom_sys_coolant_code(ON)                  "8"
    set mom_sys_coolant_code(FLOOD)               "8"
    set mom_sys_coolant_code(MIST)                "7"
    set mom_sys_coolant_code(THRU)                "26"
    set mom_sys_coolant_code(TAP)                 "27"
    set mom_sys_coolant_code(AIR)                 "7"
    set mom_sys_coolant_code(AIRTHRU)             "26"
    set mom_sys_coolant_code(OFF)                 "9"
    set mom_sys_tap_rigid_code                    "29"
    set mom_sys_rewind_code                       "30"
    set mom_sys_unclamp_code_fourth               "10"
    set mom_sys_clamp_code_fourth                 "11"
    set mom_sys_unclamp_code_fifth                "50"
    set mom_sys_clamp_code_fifth                  "51"
    set mom_sys_4th_axis_has_limits               "1"
    set mom_sys_5th_axis_has_limits               "1"
    set mom_sys_sim_cycle_drill                   "0"
    set mom_sys_sim_cycle_drill_dwell             "0"
    set mom_sys_sim_cycle_drill_deep              "0"
    set mom_sys_sim_cycle_drill_break_chip        "0"
    set mom_sys_sim_cycle_tap                     "1"
    set mom_sys_sim_cycle_bore                    "0"
    set mom_sys_sim_cycle_bore_drag               "0"
    set mom_sys_sim_cycle_bore_nodrag             "0"
    set mom_sys_sim_cycle_bore_manual             "0"
    set mom_sys_sim_cycle_bore_dwell              "0"
    set mom_sys_sim_cycle_bore_manual_dwell       "0"
    set mom_sys_sim_cycle_bore_back               "0"
    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
    set mom_sys_helix_pitch_type                  "rise_revolution"
    set mom_sys_spindle_ranges                    "9"
    set mom_sys_rewind_stop_code                  "\#"
    set mom_sys_zero                              "0"
    set mom_sys_opskip_block_leader               "/"
    set mom_sys_seqnum_start                      "10"
    set mom_sys_seqnum_incr                       "10"
    set mom_sys_seqnum_freq                       "1"
    set mom_sys_seqnum_max                        "9999"
    set mom_sys_lathe_x_double                    "1"
    set mom_sys_lathe_i_double                    "1"
    set mom_sys_lathe_y_double                    "1"
    set mom_sys_lathe_j_double                    "1"
    set mom_sys_lathe_x_factor                    "1"
    set mom_sys_lathe_y_factor                    "1"
    set mom_sys_lathe_z_factor                    "1"
    set mom_sys_lathe_i_factor                    "1"
    set mom_sys_lathe_j_factor                    "1"
    set mom_sys_lathe_k_factor                    "1"
    set mom_sys_leader(N)                         "N"
    set mom_sys_leader(M)           "M"
    set mom_sys_leader(M_spindle)                 "M"
    set mom_sys_leader(G)           "G"
    set mom_sys_leader(X)                         "X"
    set mom_sys_leader(Y)                         "Y"
    set mom_sys_leader(Z)                         "Z"
    set mom_sys_leader(fourth_axis)               "A"
    set mom_sys_leader(fifth_axis)                "B"
    set mom_sys_leader(sixth_axis)                "C"
    set mom_sys_trailer(M)            ""
    set mom_sys_trailer(M_spindle)                ""
    set mom_sys_trailer(G)            ""
    set mom_sys_trailer(X)                        ""
    set mom_sys_trailer(Y)                        ""
    set mom_sys_trailer(Z)                        ""
    set mom_sys_trailer(fourth_axis)              ""
    set mom_sys_trailer(fifth_axis)               ""
    set mom_sys_trailer(sixth_axis)               ""
    if {[info exists pc_initial_library_release_of_post] && $pc_initial_library_release_of_post > 50306} {
      set mom_sys_contour_feed_mode(LINEAR)         "AUTO"
      set mom_sys_rapid_feed_mode(LINEAR)           "AUTO"
      set mom_sys_cycle_feed_mode                   "AUTO"
    } else {
      set mom_sys_contour_feed_mode(LINEAR)         "MMPM"
      set mom_sys_rapid_feed_mode(LINEAR)           "MMPM"
      set mom_sys_cycle_feed_mode                   "MMPM"
    }
    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
    set mom_sys_feed_param(FRN,format)            "Feed_INV"
    set mom_sys_vnc_rapid_dogleg                  "1"
    set mom_sys_prev_mach_head                    ""
    set mom_sys_curr_mach_head                    ""
    set mom_sys_output_cycle95                    "1"
    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
    set mom_sys_retract_distance                  "10"
    set mom_sys_linearization_method              "angle"
    set mom_sys_post_description                  "This is a 5-Axis Milling Machine With\n\Dual Rotary Heads."
    set mom_sys_ugpadvkins_used                   "0"
    set mom_sys_post_builder_version              "9.0.1"
    set mom_sys_linear_turbo_command              "FALSE"
    set mom_sys_rapid_turbo_command               "FALSE"
    set mom_sys_circular_turbo_command            "FALSE"
    # will be added to post core later
    set mom_sys_turbo_global_add_vars_list        "mom_feedrate_mode mom_feedrate mom_motion_type mom_current_motion mom_pos_arc_center mom_pos_arc_axis oper_mcs_matrix"
    set mom_sys_output_transition_path            "0"
    set mom_sys_post_output_subprogram_enabled    "1"
    set mom_sys_lathe_thread_cycle                "92"
    set mom_sys_lathe_multiple_thread_cycle       "76"

    ####### KINEMATIC VARIABLE DECLARATIONS ##############
    set mom_kin_4th_axis_ang_offset               "0.0"
    set mom_kin_4th_axis_center_offset(0)         "0.0"
    set mom_kin_4th_axis_center_offset(1)         "0.0"
    set mom_kin_4th_axis_center_offset(2)         "0.0"
    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_4th_axis_incr_switch              "OFF"
    set mom_kin_4th_axis_leader                   "A"
    set mom_kin_4th_axis_max_limit                "360"
    set mom_kin_4th_axis_min_incr                 "0.001"
    set mom_kin_4th_axis_min_limit                "0"
    set mom_kin_4th_axis_plane                    "YZ"
    set mom_kin_4th_axis_point(0)                 "0.0"
    set mom_kin_4th_axis_point(1)                 "0.0"
    set mom_kin_4th_axis_point(2)                 "0.0"
    set mom_kin_4th_axis_rotation                 "standard"
    set mom_kin_4th_axis_type                     "Head"
    set mom_kin_4th_axis_vector(0)                "1"
    set mom_kin_4th_axis_vector(1)                "0"
    set mom_kin_4th_axis_vector(2)                "0"
    set mom_kin_4th_axis_zero                     "0.0"
    set mom_kin_5th_axis_ang_offset               "0.0"
    set mom_kin_5th_axis_center_offset(0)         "0.0"
    set mom_kin_5th_axis_center_offset(1)         "0.0"
    set mom_kin_5th_axis_center_offset(2)         "0.0"
    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_5th_axis_incr_switch              "OFF"
    set mom_kin_5th_axis_leader                   "B"
    set mom_kin_5th_axis_max_limit                "360"
    set mom_kin_5th_axis_min_incr                 "0.001"
    set mom_kin_5th_axis_min_limit                "0"
    set mom_kin_5th_axis_plane                    "ZX"
    set mom_kin_5th_axis_point(0)                 "0.0"
    set mom_kin_5th_axis_point(1)                 "0.0"
    set mom_kin_5th_axis_point(2)                 "0.0"
    set mom_kin_5th_axis_rotation                 "standard"
    set mom_kin_5th_axis_type                     "Head"
    set mom_kin_5th_axis_vector(0)                "0"
    set mom_kin_5th_axis_vector(1)                "1"
    set mom_kin_5th_axis_vector(2)                "0"
    set mom_kin_5th_axis_zero                     "0.0"
    set mom_kin_arc_output_mode                   "FULL_CIRCLE"
    set mom_kin_arc_valid_plane                   "XYZ"
    set mom_kin_clamp_time                        "2.0"
    set mom_kin_cycle_plane_change_per_axis       "0"
    set mom_kin_cycle_plane_change_to_lower       "0"
    set mom_kin_dependent_head                    "NONE"
    set mom_kin_flush_time                        "2.0"
    set mom_kin_helical_arc_output_mode           "FULL_CIRCLE"
    set mom_kin_ind_to_dependent_head_x           "0"
    set mom_kin_ind_to_dependent_head_z           "0"
    set mom_kin_independent_head                  "NONE"
    set mom_kin_linearization_flag                "1"
    ###set mom_kin_linearization_tol                 "0.01"
    set mom_kin_machine_type                      "5_axis_dual_head"
    set mom_kin_machine_zero_offset(0)            "0.0"
    set mom_kin_machine_zero_offset(1)            "0.0"
    set mom_kin_machine_zero_offset(2)            "0.0"
    set mom_kin_max_dpm                           "1000000"
    set mom_kin_max_frn                           "1000"
    set mom_kin_min_dpm                           "0.0"
    set mom_kin_min_frn                           "0.01"
    set mom_kin_output_unit                       "MM"
    set mom_kin_pivot_gauge_offset                "0.0"
    set mom_kin_pivot_guage_offset                ""
    set mom_kin_post_data_unit                    "MM"
    set mom_kin_retract_distance                  "500"
    set mom_kin_rotary_axis_method                "PREVIOUS"
    set mom_kin_spindle_axis(0)                   "0.0"
    set mom_kin_spindle_axis(1)                   "0.0"
    set mom_kin_spindle_axis(2)                   "1.0"
    set mom_kin_tool_change_time                  "12.0"
    set mom_kin_x_axis_limit                      "1000"
    set mom_kin_y_axis_limit                      "1000"
    set mom_kin_z_axis_limit                      "1000"
    set mom_kin_head_spindle_axis_correction      "ON"
    set mom_kin_head_gauge_point_correction       "ON"
    set mom_kin_combine_rapid_arc_motion          "Yes"

  }
}
proc MOM_start_of_program_LIB {} {

  global lib_flag mom_kin_machine_type
  set commandcheck(MOM_start_of_program_LIB_ENTRY) [llength [info commands MOM_start_of_program_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_dnc_header) [llength [info commands LIB_CTRL_dnc_header]]
  set commandcheck(LIB_CTRL_nc_header) [llength [info commands LIB_CTRL_nc_header]]
  set commandcheck(LIB_CTRL_sub_header) [llength [info commands LIB_CTRL_sub_header]]
  set commandcheck(LIB_CTRL_parameter_definition) [llength [info commands LIB_CTRL_parameter_definition]]

  if {[CONF_CTRL_setting tcpm_mode] == "G43.5"} {CONF_CTRL_setting set tcpm_output "vector"}

  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_dnc_header
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_dnc_header)} {LIB_CTRL_dnc_header}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[string match "MOM_start_of_program" [info level -1]]} {
    LIB_GE_command_buffer LIB_CTRL_nc_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_nc_header)} {LIB_CTRL_nc_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Program"}} @EVENT_MESSAGE
    LIB_GE_command_buffer {LIB_SPF_program_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer LIB_CTRL_sub_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sub_header)} {LIB_CTRL_sub_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {LIB_SPF_sub_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  }

  LIB_GE_command_buffer LIB_CTRL_parameter_definition
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition)} {LIB_CTRL_parameter_definition}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
  if {[LIB_PT_get_header_var mom_sequence_mode exists]} {
    if {[LIB_PT_get_header_var mom_sequence_mode] == "OFF"} {
      MOM_set_seq_off
    } else {
      if {[CONF_CTRL_setting sequence_number] == 1} {
        MOM_set_seq_on
      } else {
        MOM_set_seq_off
      }
    }
  }
  } else {
    if {[CONF_CTRL_setting sequence_number] == 1} {
      MOM_set_seq_on
    } else {
      MOM_set_seq_off
    }
  }

  # <NX1201 cam16012> new prereatment local csys
  # set global var lib_flag(plane_output_pos_type), 0 for mom_pos and 1 for mom_mcs_goto.
  if {$lib_flag(local_namespace_output) == 1 && [CONF_CTRL_setting plane_output_supported] != "NONE"} {
    if {[CONF_CTRL_setting plane_output] == "G68.2"} {
      set lib_flag(plane_output_pos_type) 1
    }
    if {[string match "5_axis_head_table" $mom_kin_machine_type] && [CONF_CTRL_setting plane_output] == "G68" && [CONF_CTRL_setting reference_direction] == 1} {
      set lib_flag(plane_output_pos_type) 0
      set lib_flag(plane_reference_direction) 1
    }
  }

  LIB_GE_command_buffer PROGRAMSTART

  LIB_GE_command_buffer {
    MOM_force once G_unit
    LIB_GE_catch_do_template start_of_program "" 1
  } @START_OF_PROGRAM

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_path_LIB {} {
  set commandcheck(MOM_start_of_path_LIB_ENTRY) [llength [info commands MOM_start_of_path_LIB_ENTRY]]

  LIB_calc_lib_cutcom_radius

  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_update_tool_change_template
  # reset address expression
  if {[llength [info commands "MOM_set_address_expression"]]&&[info exists ::save_address_expression]} {
    if {[info exists ::save_address_expression(linear_move,X)]&&\
        [catch {MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" $::save_address_expression(linear_move,X)}]} {
      LIB_SPF_add_warning "Failed to reset address expression of 'X' in BLOCK_TEMPLATE 'linear_move'"
    }

    if {[info exists ::save_address_expression(linear_move,F)] && [catch {
      MOM_set_address_expression [CONF_CTRL_moves linear_template]   "F" $::save_address_expression(linear_move,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" $::save_address_expression(circular_move,F)
    }]} {
      LIB_SPF_add_warning "Failed to reset feed rate address expression , the feed rate address name should be 'F'"
    }
    unset ::save_address_expression
  }

  # Bug 1299 Address H is missing in operations with tool axis change but no toolchange
  if {[MOM_ask_address_value G_adjust] == $::mom_sys_adjust_cancel_code} {MOM_force once H}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_sync_LIB {} {

  set commandcheck(MOM_sync_LIB_ENTRY) [llength [info commands MOM_sync_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SYNC

  LIB_GE_command_buffer {MOM_do_template sync_call} @SYNC_CALL

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_set_csys_LIB {} {


  global lib_flag lib_sav_kin_machine_type mom_kin_machine_type
  global mom_init_pos plane_init_pos

  set commandcheck(MOM_set_csys_LIB_ENTRY) [llength [info commands MOM_set_csys_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![info exist lib_flag(absolute_kin)] || $lib_flag(absolute_kin) == 0} {
    # do nothing
  } else {
    LIB_SPF_calc_4th5th_axis_points
  }

  if {[CONF_CTRL_setting limit_output_angle] == 1} {
    LIB_SPF_limit_output_angle
  }
  # <NX1201 cam16012> new prereatment local csys
  # In new local csys mode, translate mom_pos and mom_mcs_goto from local to G54 in global namespace,
  # and get rotation matrix and origin of local coordinate system relative to G54.
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_csys_rotation_revise_output
  }

  # Move it from MOM_set_csys_LIB_ENTRY(OEM).
  if {[CONF_CTRL_setting fix_on_machine] == 0 && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" \
    && [CONF_CTRL_setting tcpm_output_supported] != "NONE" && [CONF_CTRL_setting tcpm_mode] == "G43.4" \
    && [info exists lib_sav_kin_machine_type] && [string match "*table*" $lib_sav_kin_machine_type] } {

    LIB_SPF_calc_4th5th_axis_points

    if {$lib_sav_kin_machine_type == "5_axis_head_table"} {
      global mom_kin_4th_axis_point
      global mom_kin_pivot_gauge_offset
      array set mom_kin_4th_axis_point "0 0 1 0 2 0"
      set mom_kin_pivot_gauge_offset 0
      MOM_reload_kinematics
    }
  }

  # PR9233975: mom_init_pos is set in event MOM_set_csys from core code if user defined csys exists
  # variable plane_init_pos is used in LIB_CTRL_set_G68_rotate_dir in case mom_init_pos is changed by that function
  array set plane_init_pos "0 $mom_init_pos(0) 1 $mom_init_pos(1) 2 $mom_init_pos(2) 3 $mom_init_pos(3) 4 $mom_init_pos(4)"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_calc_lib_cutcom_radius {} {

  global mom_cutter_data_output_indicator mom_cut_data_type mom_cutcom_type mom_tool_diameter
  global lib_cutcom_radius mom_kin_arc_output_mode mom_sys_cutcom_code

  if {![info exists mom_cutter_data_output_indicator]} {
    set mom_cutter_data_output_indicator 0
  }
  if {![info exists mom_cutcom_type]} {
    set mom_cutcom_type 0
  }
  if {[CONF_CTRL_tool cutcom_actual_radius] == 0} {
    # no cutcom output even it is defined
    if {$mom_cutter_data_output_indicator == 1} {
      LIB_GE_abort_message "Cutcom contact not allowed"
    } else {
      set lib_cutcom_radius 0.0
    }
  } elseif {$mom_cutcom_type > 0} {
    # cutcom defined
    if {$mom_cut_data_type == "contact contour data"} {
      set lib_cutcom_radius 0.0
    } elseif {$mom_cut_data_type == "centerline data"} {
        set lib_cutcom_radius [expr $mom_tool_diameter/2]
    } else {
      set lib_cutcom_radius 0.0
    }
    if {[CONF_CTRL_setting turbo_mode] == 2 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
      LIB_SPF_turbo_status "enable" "advanced"
    }
  } else {
    # no cutcom defined
    if {[info exists lib_cutcom_radius] && $lib_cutcom_radius > 0.0} {
      set lib_cutcom_radius 0.0
    } else {
      set lib_cutcom_radius 0.0
    }
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_tool_LIB {} {

  global lib_flag mom_operation_is_interop

  set commandcheck(MOM_first_tool_LIB_ENTRY) [llength [info commands MOM_first_tool_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set lib_flag(tool_path_motion) 0

  # <17013.16 Interop path> As transition path has a given tool change point, it is not necessary to goto default tool change position.
  if {![info exists mom_operation_is_interop] && [CONF_CTRL_moves return_before_first_tool_change_pos] != ""} {
    LIB_RETURN_move CONF_CTRL_moves return_before_first_tool_change_pos
  }

  set lib_flag(first_tool_change) 1
  MOM_tool_change
  set lib_flag(first_tool_change) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag mom_next_tool_status lib_prev_tool_name

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }

  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {![info exists mom_cutcom_type]} {set mom_cutcom_type 0}
  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_from_move_LIB {} {

  global feed_mode mom_feed_rate mom_kin_rapid_feed_rate

  set commandcheck(MOM_from_move_LIB_ENTRY) [llength [info commands MOM_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_moves output_from_position] == 1 } {
    if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
      if {[EQ_is_ge $mom_feed_rate $mom_kin_rapid_feed_rate]} {
        MOM_rapid_move_LIB
      } else {
        MOM_linear_move_LIB
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_update_tool_change_template {} {

  global lib_prev_feed_cut_value mom_feed_cut_value mom_tool_name

  LIB_GE_command_buffer UPDATE_TOOL

  LIB_GE_command_buffer {
      LIB_CTRL_set_feed_parameter
      set lib_prev_feed_cut_value $mom_feed_cut_value
  } @SET_FEED_PARAM
  LIB_GE_command_buffer {
      LIB_CHECK_adjust_register
  } @SET_ADJUST_REGISTER

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_move_LIB {} {
  global mom_motion_event mom_operation_name mom_output_mcs_name
  global mom_motion_type

  set commandcheck(MOM_first_move_LIB_ENTRY) [llength [info commands MOM_first_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check move

  LIB_SPF_check_decompose_first_move

  if {[info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])] && $mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])} {
    LIB_main_origin_call
  }

  LIB_CHECK_adjust_register

  if {$mom_motion_event == "cycle_plane_change"} {
    LIB_SPF_add_warning "It is recommended to define a motion before first cycle."
  }
  catch {MOM_$mom_motion_event}
  # Handle the case user specify feed for rapid
  if {$mom_motion_type == "RAPID"} {
    LIB_SPF_last_rapid_pos
  }
  LIB_SPF_calc_abs_move_parameter
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_initial_move_LIB {} {

  global lib_flag mom_programmed_feed_rate mom_motion_event
  global mom_motion_type

  set commandcheck(MOM_initial_move_LIB_ENTRY) [llength [info commands MOM_initial_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CHECK_adjust_register
  LIB_SPF_spindle_set

  # <NX1201 cam17013> new prereatment local csys
  if {$lib_flag(local_namespace_output) && [CONF_CTRL_setting tcpm_output_supported] != "NONE" &&\
  ([CONF_CTRL_setting tcpm_mode] == "G43.5" ||\
  ([CONF_CTRL_setting tcpm_mode] == "G43.4" && [CONF_CTRL_setting fix_on_machine] != 0))} {
    if {[CONF_CTRL_setting turbo_mode] == 3 && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }
  }

  LIB_CTRL_handle_cycle_check move

  if {[EQ_is_zero $mom_programmed_feed_rate]} {
    MOM_rapid_move
    set mom_motion_event "rapid_move"
  } else {
    MOM_linear_move
    set mom_motion_event "linear_move"
    # Handle the case user specify feed for rapid
    if {$mom_motion_type == "RAPID"} {
      LIB_SPF_last_rapid_pos
    }
  }
  LIB_SPF_calc_abs_move_parameter

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_handle_cycle_check {arg} {

  global mom_cycle_type mom_spindle_status mom_spindle_startup_status

  if {([info exists mom_cycle_type] && ([string match "Exp_Deep_Drill_Breakchip" $mom_cycle_type] || [string match "Exp_Deep_Drill" $mom_cycle_type])) ||\
  ([info exists mom_spindle_startup_status] && $mom_spindle_startup_status == "OFF")} {

    switch -- $arg {
      "move"    {
            if {$mom_spindle_status == "OFF"} {MOM_disable_address S M_spindle}
          }
      "spindle" {
            MOM_enable_address S M_spindle
          }
      default   {
            LIB_GE_abort_message "Call LIB_CTRL_handle_cycle_check without the right arguments" "Please check"
          }
    }

  }
}
# <Internal Documentation>
#
# This function controlls the spindle rotation.
# The spindle should never be activated with the first movement if a single-lip drill is used.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_turbo {} {

  if {$::lib_ge_pretreatment_runtime} {return}
  if {![info exists ::mom_sys_advanced_turbo_output] || $::mom_sys_advanced_turbo_output != "TRUE"} {
    return
  }

  if {[CONF_CTRL_moves always_center_for_circle] == 1} {
    MOM_disable_address R
    MOM_enable_address I J K
  } else {
    MOM_enable_address R
    #MOM_disable_address I J K
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {$::mom_kin_arc_output_mode == "FULL_CIRCLE" } {
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {[CONF_CTRL_feed feed_linear] == 2} {
    # Before NX1899, set MOM_linear_move_turbo_LIB at turbo block to output parameterized feed value
    # From NX1899, use advanced callback function to do the same thing
    if {$::lib_ge_env(major_version) < 1899} {
      set ::mom_sys_linear_turbo_command "TRUE"
      set ::mom_sys_circular_turbo_command "TRUE"
    } else {
      # In advanced turbo mode, LIB_SPF_feedrate_set is called in callback function, so disable feedrate setting in core code
      if {[llength [info commands MOM_set_turbo_feedrate_set]]} {
        MOM_set_turbo_feedrate_set OFF
      }
    }
  }

  if {$::lib_flag(first_transmit_move) == 0} {
  if {$::mom_sys_rapid_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry] "MOM_rapid_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry]]
  }
  } else {
    if {$::mom_sys_linear_turbo_command == "TRUE"} {
      MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry] "MOM_linear_move_turbo_LIB"]
    } else {
      MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry]]
    }
  }

  if {$::mom_sys_rapid_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry] "MOM_rapid_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry]]
  }

  if {$::mom_sys_linear_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry] "MOM_linear_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry]]
  }

  if {$::mom_sys_circular_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment [CONF_Turbo_Templates circular_template_turbo] [CONF_Turbo_Templates circular_template_entry] "MOM_circular_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment [CONF_Turbo_Templates circular_template_turbo] [CONF_Turbo_Templates circular_template_entry]]
  }

  # The address X[$mom_pos(0)*$x_factor] will slow down turbo mode, x_factor only used in turning
  if {[llength [info commands "MOM_set_address_expression"]]} {
    if {$::x_factor == 1} {
      catch {
        set ::save_address_expression(linear_move,X) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" "\$mom_pos(0)"]
      }
    }
  if {[CONF_CTRL_feed feed_linear] != 2} {
    if {[catch {
      set ::save_address_expression(linear_move,F) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "F" "\$mom_feedrate"]
      set ::save_address_expression(circular_move,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" "\$mom_feedrate"]
    }]} {
      LIB_SPF_add_warning "Please use 'F' as feed rate address name in linear and circular block template"
    }
  }

    #when feedrate in one operation change from mmpm to mmpr we must write mom_feedrate_mode in to the advanced and set feed the mode into the G_feed Address
    set ::save_address_expression(linear_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]
    set ::save_address_expression(circular_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]
  }
}
# <Internal Documentation>
#
# This procedure is executed at MOM_initial_move MOM_first_move MOM_lock_axis.
# It is used to config turbo blocks in advanced turbo mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB {} {

  global mom_machine_mode mom_pos mom_nxt_motion_event
  global lib_flag lib_param lib_last_rapid_pos
  global dpp_return_motion_start lib_spf
  global mom_output_pos_type mom_namespace_name

  set commandcheck(MOM_rapid_move_LIB_ENTRY) [llength [info commands MOM_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        MOM_suppress always S
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves rapid_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        }
        MOM_suppress off S
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
          switch -- $lib_flag(mode_current_status) {
            "std" {
              LIB_ROTARY_positioning_first_move
            }
            "pos" {
              LIB_ROTARY_positioning_first_move_pos
            }
            "sim" {
              LIB_ROTARY_positioning_first_move_sim
            }
          }
        } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized RAPID_MOVE]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer RAPID_MOVE
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {
      if {[info exists dpp_return_motion_start] && $dpp_return_motion_start} {
        LIB_CTRL_output_return_motion_for_rough_turn_cycle
      }

    } @ROUGH_TURN_CYCLE
    LIB_GE_command_buffer {
      if {![info exists dpp_return_motion_start] || !$dpp_return_motion_start} {
        if {$lib_flag(first_transmit_move) == 0} {
          if {$lib_flag(lathe_thread_motion) && [CONF_CTRL_turn thread_cycle] == "G76/G78"} {
            if {$mom_nxt_motion_event == "none"} {
              LIB_CTRL_g76_cycle
            }
          } elseif {[CONF_CTRL_turn thread_cycle] == "G92"} {
            MOM_abort_event
          } else {
            MOM_do_template [CONF_CTRL_moves rapid_template]
          }
        } else {
          LIB_CTRL_feed_output
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
      }
    } @MOVE
    LIB_GE_command_buffer_output

    # PR9873228: Reload mom variables in lib_spf_convert_point_snapshot for every rapid motion within standard_path_between_rotary_motions,
    # then rotary axis leaders will always keep the same as real machine setting.
    if {$lib_flag(local_namespace_output) == 0 && [info exists lib_spf(do_convert_point)] && $lib_spf(do_convert_point) == 1} {
      LIB_SPF_convert_point "reload"
    }
  } else {
    LIB_GE_command_buffer RAPID_MOVE_SINGLE
    LIB_GE_command_buffer {
      if {[info exists dpp_return_motion_start] && $dpp_return_motion_start} {
        LIB_CTRL_output_return_motion_for_rough_turn_cycle
      }

    } @ROUGH_TURN_CYCLE
    LIB_GE_command_buffer {
      if {![info exists dpp_return_motion_start] || !$dpp_return_motion_start} {
        if {$lib_flag(first_transmit_move) == 0} {
          if {$lib_flag(lathe_thread_motion) && [CONF_CTRL_turn thread_cycle] == "G76/G78"} {
            if {$mom_nxt_motion_event == "none"} {
              LIB_CTRL_g76_cycle
            }
          } elseif {[CONF_CTRL_turn thread_cycle] == "G92"} {
            MOM_abort_event
          } else {
            MOM_do_template [CONF_CTRL_moves rapid_template]
          }
        } else {
          LIB_CTRL_feed_output
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  LIB_SPF_last_rapid_pos

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_linear_move_turbo {} {

  set commandcheck(LIB_CTRL_linear_move_turbo_ENTRY) [llength [info commands LIB_CTRL_linear_move_turbo_ENTRY]]

  LIB_GE_command_buffer LINEAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @LINEAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_linear_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_linear_move_turbo_ENTRY)} {LIB_CTRL_linear_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_linear_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_turbo {} {

  set commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY) [llength [info commands LIB_CTRL_rapid_move_turbo_ENTRY]]

  LIB_GE_command_buffer RAPID_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @RAPID_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_rapid_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY)} {LIB_CTRL_rapid_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_rapid_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_circular_move_turbo {} {

  set commandcheck(LIB_CTRL_circular_move_turbo_ENTRY) [llength [info commands LIB_CTRL_circular_move_turbo_ENTRY]]

  LIB_GE_command_buffer CIRCULAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @CIRCULAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_circular_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_circular_move_turbo_ENTRY)} {LIB_CTRL_circular_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_circular_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_linear_move_turbo_LIB {} {

  set commandcheck(MOM_linear_move_turbo_LIB_ENTRY) [llength [info commands MOM_linear_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_linear_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_turbo_LIB {} {

  set commandcheck(MOM_rapid_move_turbo_LIB_ENTRY) [llength [info commands MOM_rapid_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_rapid_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_turbo_LIB {} {


  set commandcheck(MOM_circular_move_turbo_LIB_ENTRY) [llength [info commands MOM_circular_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  if {[CONF_CTRL_moves always_center_for_circle] != 1} {
    global mom_arc_radius
    set mom_arc_radius [expr abs($mom_arc_radius)]

    MOM_suppress once I J K
    switch -- $::tool_axis {
      0 {MOM_force once Y Z}
      1 {MOM_force once X Z}
      2 {MOM_force once X Y}
    }

    # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
    if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

      global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
      global mom_namespace_name mom_output_pos_type
      if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
        if {$mom_namespace_name == "::"} {
          set namespace ::
        } else {
          set namespace ::LOCAL_CSYS::
        }
        if {$mom_output_pos_type == "mom_pos"} {
          VMOV 3 ${namespace}mom_prev_pos prev_pos
          VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
        } else {
          VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
          VMOV 3 ${namespace}mom_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
        }
        VMOV 3 ${namespace}$mom_output_pos_type save_pos
      } else {
        set namespace ::
        set mom_output_pos_type mom_pos
        VMOV 3 mom_prev_pos prev_pos
        VMOV 3 mom_pos_arc_center pos_arc_center
        VMOV 3 mom_pos_arc_axis pos_arc_axis
        VMOV 3 mom_pos save_pos
      }
      VEC3_sub prev_pos pos_arc_center tmp_vec
      VEC3_unitize tmp_vec tmp_vec1
      VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
      VEC3_scale mom_arc_radius tmp_vec tmp_vec1
      VEC3_add pos_arc_center tmp_vec1 tmp_vec
      VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

      MOM_do_template [CONF_Turbo_Templates circular_template_turbo]

      VMOV 3 save_pos  ${namespace}$mom_output_pos_type
      MOM_suppress once I J K
      switch -- $::tool_axis {
        0 {MOM_force once Y Z}
        1 {MOM_force once X Z}
        2 {MOM_force once X Y}
      }

      set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]
    }

    if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
      LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
    }

    if {[EQ_is_gt $::mom_arc_angle 180.0]} {
      set mom_arc_radius [expr -1.0*$mom_arc_radius]
    }

  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_circular_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB_MODIF_first_move_turn {} {

  return 0

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_TURNING_mode {{option default}} {

  global x_factor lib_flag

  switch -- $option {
    "start" {

      set x_factor [LIB_SPF_check_x_factor TURN]

      if {![info exist lib_flag(save_rapid_template)]} {set lib_flag(save_rapid_template) [CONF_CTRL_moves rapid_template]}
      CONF_CTRL_moves set rapid_template [CONF_CTRL_moves rapid_template_turn]

      if {![info exist lib_flag(save_linear_template)]} {set lib_flag(save_linear_template) [CONF_CTRL_moves linear_template]}
      CONF_CTRL_moves set linear_template [CONF_CTRL_moves linear_template_turn]

      if {![info exist lib_flag(save_circular_template)]} {set lib_flag(save_circular_template) [CONF_CTRL_moves circular_template]}
      CONF_CTRL_moves set circular_template [CONF_CTRL_moves circular_template_turn]
    }
    "end" {
      set x_factor [LIB_SPF_check_x_factor MILL]

      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        unset lib_flag(save_rapid_template)
      }

      if {[info exists lib_flag(save_linear_template)]} {
        CONF_CTRL_moves set linear_template $lib_flag(save_linear_template)
        unset lib_flag(save_linear_template)
      }

      if {[info exists lib_flag(save_circular_template)]} {
        CONF_CTRL_moves set circular_template $lib_flag(save_circular_template)
        unset lib_flag(save_circular_template)
      }
    }
  }
}
# <Internal Documentation>
# Controls the turning mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_start {{option default}} {

  global mom_machine_mode mom_spindle_mode mom_spindle_preset_rpm_toggle mom_spindle_preset_rpm
  global mom_spindle_maximum_rpm mom_spindle_speed mom_mcs_goto mom_spindle_status
  global PI mom_spindle_maximum_rpm_toggle lib_flag mom_current_motion

  if {$mom_spindle_status == "OFF"} {return}

  set commandcheck(LIB_SPINDLE_start_ENTRY) [llength [info commands LIB_SPINDLE_start_ENTRY]]

  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY start_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SPINDLE
  switch -- $option {
    "preset" {
      # turning only
      LIB_GE_command_buffer {
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {[EQ_is_zero $mom_spindle_speed]} {
            LIB_GE_error_message "Spindle speed should not be = 0.0" "Please check"
          }
          if {$mom_spindle_preset_rpm_toggle == 0 || [EQ_is_zero $mom_spindle_preset_rpm]} {
            set rval [expr abs($mom_mcs_goto(0))]
            if {$rval < 0.1} {set rval 1}
            set mom_spindle_preset_rpm [expr $mom_spindle_speed * 1000 / $PI / $rval / 2]
          }
          MOM_do_template spindle_rpm_preset
        } else {
          MOM_do_template spindle_rpm_preset CREATE
        }
      } @PRESET
    }
    "cycle" {
      LIB_GE_command_buffer {
        switch -- $mom_machine_mode {
          "MILL" {
            if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
              MOM_do_template spindle_rpm CREATE
            } else {
              MOM_do_template spindle_rpm
            }
          }
          "TURN" {
            if {$mom_spindle_mode == "RPM"} {
              MOM_do_template spindle_rpm_turn
            } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
            if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
              set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
            }
              # PR9564861: Output block spindle_smm_turn only if spindle mode is SFM/SMM before cycle under turning
            MOM_do_template spindle_smm_turn
            }
          }
        }
      } @CYCLE
    }
    "limit" {
      LIB_GE_command_buffer {
        # turning only
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {([info exists mom_spindle_maximum_rpm_toggle] && $mom_spindle_maximum_rpm_toggle == 1) || [CONF_CTRL_spindle spindle_max_rpm_output_always]} {
            if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
              set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
            }
            # PR9868806: Output spindle maximum rpm in first move for turning operation
            if {$mom_current_motion == "first_move"} {
              MOM_force_block once spindle_max_rpm
            }
            MOM_do_template spindle_max_rpm
          }
        }
      } @LIMIT
    }
    "default" {
      switch -- $mom_machine_mode {
        "MILL" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm CREATE
            } else {
              # Always RPM output for milling
              if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
                MOM_do_template spindle_rpm CREATE
              } elseif {[CONF_CTRL_spindle spindle_output_alone] == 1 || [info level 1] == "MOM_spindle_rpm"} {
                MOM_do_template spindle_rpm
              }
            }
            set ::check_list(spindle,status) 1
          } @DEFAULTMILL
        }
        "TURN" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm_turn CREATE
            } elseif {$mom_spindle_mode == "RPM"} {
              if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
                MOM_force_block once spindle_rpm_turn
                MOM_do_template spindle_rpm_turn
              }

            } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {

              if {[MOM_do_template spindle_smm_turn CREATE] != ""} {
                MOM_force_block once spindle_smm_turn
                MOM_do_template spindle_smm_turn
              }

            }
          } @DEFAULTTURN
        }
      }
    }
  }
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY end_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Controls the spindle start conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_end {} {

  LIB_GE_command_buffer SPINDLE_END
  LIB_GE_command_buffer {
    if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
      MOM_do_template spindle_off CREATE
    } else {
      MOM_do_template spindle_off
    }
  } @SPINDLE_OFF_1
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the spindle end conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_spindle_orient {} {

  global mom_machine_mode

  LIB_GE_command_buffer SPINDLE_ORIENT

  LIB_GE_command_buffer {
    if {$mom_machine_mode == "MILL"} {MOM_do_template spindle_off}
  } @SPINDLE_OFF

  LIB_GE_command_buffer {
    MOM_force Once M_spindle
    MOM_do_template spindle_orient
  } @M19_S

  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# It used to output spindle orient code M19 S.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {
      # first tool_path motion with same tool and configuration as previous operation
      if {$lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_xlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXLU
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_ylu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYLU
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_zlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZLU
            }
        }
      } else {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_xul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXUL
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_yul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYUL
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_zul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZUL
            }
        }
      }
      unset lib_flag(current_plane_upper_than_previous)
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDXI
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_yi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDYI
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDZI
          }
      }
    }
    set lib_flag(current_safety_position) 0
  }
  LIB_GE_command_buffer {
      LIB_CTRL_clamp_axis
  } @CLAMP
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the standard case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_pos {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_POS

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_pos) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z H
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {
      # first tool_path motion with same tool and configuration as previous operation
      if {$lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_xlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXLU
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_ylu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYLU
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_zlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZLU
            }
        }
      } else {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_xul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXUL
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_yul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYUL
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_zul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZUL
            }
        }
        unset lib_flag(current_plane_upper_than_previous)
      }
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSXI
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_yi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSYI
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSZI
          }
      }
    }
    set lib_flag(current_safety_position) 0
  }
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_sim {} {

  global mom_motion_event
  global lib_flag

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_SIM

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_sim) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    LIB_GE_command_buffer {
      set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
      LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
    } @DECOMPOSE
  }
  LIB_GE_command_buffer_output
  set lib_flag(current_safety_position) 0
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning simultanous first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_check_cutcom_condition {} {

  global mom_kin_is_turbo_output mom_cutcom_adjust_register_defined mom_tool_cutcom_register mom_tool_number
  global mom_motion_event mom_path_name
  global mom_pos mom_prev_pos tool_axis
  global lib_flag

  if {([LIB_SPF_get_pretreatment mom_cutcom_status] == "LEFT" || [LIB_SPF_get_pretreatment mom_cutcom_status] == "RIGHT")\
     && $mom_kin_is_turbo_output == "TRUE" && $mom_cutcom_adjust_register_defined == 0} {
    if {$mom_tool_cutcom_register != $mom_tool_number} {
      LIB_SPF_add_warning "Tool cutcom register 'INS->$mom_tool_cutcom_register<-' is different to tool number 'INS->$mom_tool_number<-' and it's not output. With turbo mode activated, Switch it to ON in the operation"
    }
  }

  if {[info exists lib_flag(check_cutcom_start_move)] && $lib_flag(check_cutcom_start_move) == 1} {
    if {$mom_motion_event == "circular_move" && [CONF_CTRL_setting cutcom_on_with_circle_allowed] == 0} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- has to be a linear move"

    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_mag move] > 0 && [VEC3_is_parallel move tool_vector] == 1 && [CONF_CTRL_setting cutcom_on_with_tool_axis_allowed] == 0} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_start_move) 2
  } elseif {[info exists lib_flag(check_cutcom_end_move)] && $lib_flag(check_cutcom_end_move)} {
    if {$mom_motion_event == "circular_move" && [CONF_CTRL_setting cutcom_on_with_circle_allowed] == 0} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- has to be a linear move"
    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_is_parallel move tool_vector] == 1 && [CONF_CTRL_setting cutcom_on_with_tool_axis_allowed] == 0} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_end_move) 0
  }

}
# <Internal Documentation>
#
# This allows to check the first move after cutcom is switched on or off
# This is meant to do checks like first move has not to be a circular move
# The flags lib_flag(check_cutcom_start_move) and lib_flag(check_cutcom_end_move) are triggering this check
# those flags are set in MOM_cutcom_on and MOM_cutcom_off
#
# Proc has to be moved to controller level to implement controller specific checks
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_generic_cycle_LIB {} {

  set commandcheck(MOM_generic_cycle_LIB_ENTRY) [llength [info commands MOM_generic_cycle_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_generic_cycle_status
  global mom_sys_output_contour_motion
  global mom_from_status
  global mom_start_status
  global mom_motion_type
  global mom_operation_name
  global dpp_return_motion_list
  global dpp_return_motion_start
  global dpp_first_buffer_for_return_motion
  global mom_post_oper_path

  if {$mom_generic_cycle_status == 1} {

    # Initialize G71/G72 output at generic cycle start
    LIB_CTRL_init_rough_turn_cycle_output

    # Check whether a start point has been set
    if {([info exists mom_from_status] && $mom_from_status == 1) || \
      ([info exists mom_start_status] && $mom_start_status == 1) || \
      ([info exists mom_motion_type] && [string match "APPROACH" $mom_motion_type])} {

      ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      # When posting both rough and finish turning cycle operation (Scenario 2), contour data of finish operation will be used for rough.
      # So NX will use extended command MOM_post_oper_path to post the finish operation in the rough operation to get contour data
      # and mom_post_oper_path is set to 1 in subpost run by MOM_post_oper_path.
      #
      # Then NX will use NC codes between events MOM_generic_cycle as contour data.
      # Because MOM_contour_start and MOM_contour_end don't output in MOM_post_oper_path.
      #
      # In other scenarios, skip the events between MOM_generic_cycle
      # and use NC codes between events MOM_contour_start and MOM_contour_end as contour data.
      ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      if {[info exists mom_post_oper_path] && ($mom_post_oper_path == 1)} {

        # Set start mark of finish contour data in output file
        LIB_CTRL_finish_turn_cycle_contour_start

      } else {

        # Skip to next generic which should be cycle off
        MOM_skip_handler_to_event generic_cycle
      }

    } else {

      LIB_GE_abort_message "$mom_operation_name: None of from point, start point or approach path is defined before turning cycle in this operation."
    }
  }

  if {$mom_generic_cycle_status == 0} {

    if {[info exist mom_sys_output_contour_motion] && \
      ($mom_sys_output_contour_motion == 1 || $mom_sys_output_contour_motion == 2)} {

      if {[info exists mom_post_oper_path] && ($mom_post_oper_path == 1)} {

        # Set end mark of finish contour data in output file
        LIB_CTRL_finish_turn_cycle_contour_end
      }

      # Flag to indicate return motion begin
      set dpp_return_motion_start 1

      # Flag to indicate the first buffer for return motion
      set dpp_first_buffer_for_return_motion 1

      # Create a list to store the return motion NC codes
      set dpp_return_motion_list [list]
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is used to handle turn rough and finish cycle with generic cycle enhancement.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_init_rough_turn_cycle_output {} {

  global mom_machine_control_motion_output
  global mom_sys_output_cycle95
  global mom_sys_output_contour_motion
  global mom_template_subtype
  global dpp_record_rough_cycle_seq
  global mom_machine_cycle_subroutine_name
  global dpp_finish_feed
  global mom_feed_cut_value
  global dpp_turn_cycle_g_code
  global mom_operation_name

  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # "mom_sys_output_contour_motion" can be set [ 0 | 1 | 2 ].
  #  0: No contour output
  #  1: Part contour
  #  2: Tracking path contour
  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  # Initialize mom_sys_output_contour_motion to 0 as default.
  set mom_sys_output_contour_motion 0

  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # So far, machine cycle motion has been supported in following three scenarios.
  #
  # Scenario 1: single rough turning cycle operation.
  # Scenario 2: both rough and finish turning cycle operation.
  #             (The following two conditions should be fulfilled in this scenario.)
  #             Condition 1: contour data of rough and finish operations should be same.
  #                          This is checked by user when operations are created, not checked by post processor.
  #             Condition 2: subroutine name of rough operation should be same as the finish operation name.
  # Scenario 3: single finish turning cycle operation.
  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  # When "Machine Cycle" is selected as Motion Output in Machine control and
  # post processor is equipped with the ability to output rough turning cycle, then:
  if {([info exists mom_machine_control_motion_output] && $mom_machine_control_motion_output == 2) && \
    ([info exists mom_sys_output_cycle95] && $mom_sys_output_cycle95)} {

    # Check scenario 1
    if {[string match "FACING" $mom_template_subtype] || [string match "*ROUGH*" $mom_template_subtype]} {

      LIB_CTRL_set_contour_motion

    # Check scenario 2 or 3
    } elseif {[string match "*FINISH*" $mom_template_subtype]} {

      # Scenario 2
      if {[info exists dpp_record_rough_cycle_seq(begin,$mom_operation_name)]} {

        # Output G70 command
        set dpp_finish_feed $mom_feed_cut_value
        set dpp_turn_cycle_g_code 70

        LIB_GE_command_buffer TURN_CYCLE_FINISHING_IN_INITIAL
        LIB_GE_command_buffer {MOM_do_template turn_cycle_finishing} @TURN_CYCLE_FINISHING_IN_INITIAL
        LIB_GE_command_buffer_output

        MOM_force once G_motion X Z

      # Scenario 3
      } else {

        LIB_CTRL_set_contour_motion
      }

    # Other scenarios
    } else {

      LIB_GE_abort_message "$mom_operation_name: The machine cycle motion has not been supported in current operation type so far."
    }

    # Don't output cutcom until rough turning cycle called
    MOM_disable_address G_cutcom
  }

}
# <Internal Documentation>
# This command is used to prepare to generate contour data and customize sequence number output mode.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_set_contour_motion {} {

  global mom_cutcom_status
  global dpp_save_cutcom_status
  global mom_sys_output_contour_motion

  if {$mom_cutcom_status=="LEFT" || $mom_cutcom_status=="RIGHT"} {

    # If user adds cutcom UDE, save the status and notify NX/Post to process part contour data.
    set dpp_save_cutcom_status $mom_cutcom_status
    set mom_sys_output_contour_motion 1

  } else {

    # If user does not add cutcom UDE, notify NX/Post to process tracking path data.
    set mom_sys_output_contour_motion 2
  }

}
# <Internal Documentation>
# This command is to set contour motion as part contour data (value 1) or tracking path data (value 2)
# depending on whether cutter compensation UDE has been set or not.
#
# This command is used in LIB_CTRL_init_rough_turn_cycle_output.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_finish_turn_cycle_contour_start {} {

  global mom_template_subtype

  if {[string match "*FINISH*" $mom_template_subtype]} {

    # Set the start mark of finish contour data
    MOM_set_seq_off

    LIB_GE_command_buffer TURN_CYCLE_CONTOUR_START_TAG
    LIB_GE_command_buffer {MOM_output_literal "(CONTOUR TURN START)"} @TURN_CYCLE_CONTOUR_START_TAG
    LIB_GE_command_buffer_output

    MOM_force once G_motion X Z
  }

}
# <Internal Documentation>
# This command is to set start mark of finish contour data in output file in subpost run by MOM_post_oper_path.
#
# This command is used in proc MOM_generic_cycle when mom_generic_cycle_status is 1.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_finish_turn_cycle_contour_end {} {

  global mom_template_subtype

  if {[string match "*FINISH*" $mom_template_subtype]} {

    # Set the end mark of finish contour data
    LIB_GE_command_buffer TURN_CYCLE_CONTOUR_END_TAG
    LIB_GE_command_buffer {MOM_output_literal "(CONTOUR TURN END)"} @TURN_CYCLE_CONTOUR_END_TAG
    LIB_GE_command_buffer_output

    MOM_set_seq_on
  }

}
# <Internal Documentation>
# This command is to set end mark of finish contour data in output file in subpost run by MOM_post_oper_path.
#
# This command is used in proc MOM_generic_cycle when mom_generic_cycle_status is 0.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_linear_move_LIB {} {

  global lib_flag lib_param
  global mom_machine_mode

  set commandcheck(MOM_linear_move_LIB_ENTRY) [llength [info commands MOM_linear_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$::mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        MOM_suppress always S
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves linear_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
        MOM_suppress off S
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
          switch -- $lib_flag(mode_current_status) {
            "std" {
              LIB_ROTARY_positioning_first_move
            }
            "pos" {
              LIB_ROTARY_positioning_first_move_pos
            }
            "sim" {
              LIB_ROTARY_positioning_first_move_sim
            }
          }
        } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer TURN
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } elseif {($lib_flag(lathe_thread_motion) && [CONF_CTRL_turn thread_cycle] == "G76/G78") || [CONF_CTRL_turn thread_cycle] == "G92"} {

        MOM_abort_event

      } else {

        MOM_do_template [CONF_CTRL_moves linear_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } elseif {($lib_flag(lathe_thread_motion) && [CONF_CTRL_turn thread_cycle] == "G76/G78") || [CONF_CTRL_turn thread_cycle] == "G92"} {

        MOM_abort_event

      } else {

        MOM_do_template [CONF_CTRL_moves linear_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_LIB {} {

  global lib_param

  set commandcheck(MOM_circular_move_LIB_ENTRY) [llength [info commands MOM_circular_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } else {

        MOM_do_template [CONF_CTRL_moves circular_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } else {

        MOM_do_template [CONF_CTRL_moves circular_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_output_contour_for_rough_turn_cycle {} {

  global dpp_contour_list
  global mom_motion_event

  set o_buffer [MOM_do_template ${mom_motion_event}_rough_turn_cycle CREATE]
  lappend dpp_contour_list $o_buffer

}
# <Internal Documentation>
# This command is used to output the contour data for rough turn cycle.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_return_motion_for_rough_turn_cycle {} {

  global dpp_return_motion_list
  global mom_motion_event
  global dpp_motion_event

  LIB_CTRL_check_first_buffer_for_return_motion

  set dpp_motion_event [string range $mom_motion_event 0 [expr [string length $mom_motion_event]-6]]

  set o_buffer [MOM_do_template [CONF_CTRL_moves ${dpp_motion_event}_template] CREATE]
  lappend dpp_return_motion_list $o_buffer

}
# <Internal Documentation>
# This command is used to output the return motion for rough turn cycle.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_check_first_buffer_for_return_motion {} {

  global dpp_first_buffer_for_return_motion

  if {[info exists dpp_first_buffer_for_return_motion] && $dpp_first_buffer_for_return_motion == 1} {

    MOM_force once G_motion X Z
    set dpp_first_buffer_for_return_motion 0
  }

}
# <Internal Documentation>
# This command is used to check whether it is the first time to buffer MOM_do_template for return motion.
# if so, then force output G_motion, X and Z.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_helix_move_LIB {} {

  global mom_helix_turn_number
  global tool_axis

  set commandcheck(MOM_helix_move_LIB_ENTRY) [llength [info commands MOM_helix_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer OUTPUT
  LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
  LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
  LIB_GE_command_buffer {LIB_HELIX_nturn $tool_axis} @HELIX_NTURN
  LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]} @MOVE
  LIB_GE_command_buffer_output

  unset mom_helix_turn_number

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_HELIX_nturn {axis} {

  global mom_prev_pos mom_pos mom_helix_pitch mom_arc_angle
  global mom_helix_turn_number mom_kin_machine_resolution

  set delta [expr abs($mom_pos($axis) - $mom_prev_pos($axis))]

  if {![EQ_is_equal $mom_helix_pitch 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number [expr floor([LIB_SPF_round [expr $delta / [expr abs($mom_helix_pitch)]] $mom_kin_machine_resolution])]
  } elseif {![EQ_is_equal $delta 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number 1
  } else {
    set mom_helix_turn_number 0
  }

  if {[EQ_is_le $mom_arc_angle 360.0 $mom_kin_machine_resolution]} {
    MOM_suppress once helix_turn
  }
}
# <Internal Documentation>
# Calculate number of turns
# Linked to helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_on_ENTRY {option} {

  global mom_cutcom_adjust_register mom_tool_cutcom_register mom_tool_number
  global cutcom_adjust_register

  switch -- $option {
    "start" {
      if {[CONF_CTRL_setting cutcom_output] == 1} {
        if {$mom_tool_cutcom_register == 0} {
          set cutcom_adjust_register $mom_tool_number
        } else {
          set cutcom_adjust_register $mom_tool_cutcom_register
        }
      } else {
        set cutcom_adjust_register 0
      }
      if {[hiset mom_cutcom_adjust_register]} {set cutcom_adjust_register $mom_cutcom_adjust_register}
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning and at the end of MOM_cutcom_on procedure
# depending of the argument: start or end
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_off_ENTRY {option} {

  global cutcom_adjust_register

  switch -- $option {
    "end" {
      if {[hiset cutcom_adjust_register]} {unset cutcom_adjust_register}
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning and at the end of MOM_cutcom_off procedure
# depending of the argument: start or end
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_opstop_LIB {mess} {
  global mom_opstop_text mom_opstop_text_defined

  set commandcheck(MOM_opstop_LIB_ENTRY) [llength [info commands MOM_opstop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_opstop_text_defined] && $mom_opstop_text_defined == 1} {
      LIB_GE_command_buffer MOM_opstop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "along_with_stop"} {
          MOM_do_template opstop BUFFER
        } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_opstop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_opstop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_opstop_LIB
      LIB_GE_command_buffer {
        MOM_do_template opstop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_opstop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "along_with_opstop"} {
        MOM_do_template opstop BUFFER
      } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_AFTER_MSG
  }

  LIB_GE_command_buffer MOM_opstop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_opstop_text]} {unset mom_opstop_text}
  if {[hiset mom_opstop_text_defined]} {unset mom_opstop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_stop_LIB {mess} {
  global mom_stop_text mom_stop_text_defined

  set commandcheck(MOM_stop_LIB_ENTRY) [llength [info commands MOM_stop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_stop_text_defined] && $mom_stop_text_defined == 1} {
      LIB_GE_command_buffer MOM_stop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
          MOM_do_template stop BUFFER
        } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_stop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_stop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_stop_LIB
      LIB_GE_command_buffer {
        MOM_do_template stop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_stop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
        MOM_do_template stop BUFFER
      } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_AFTER_MSG
  }
  LIB_GE_command_buffer MOM_stop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_stop_text]} {unset mom_stop_text}
  if {[hiset mom_stop_text_defined]} {unset mom_stop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_nurbs_move_LIB {} {

  set commandcheck(MOM_nurbs_move_LIB_ENTRY) [llength [info commands MOM_nurbs_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_start_LIB {} {

  set commandcheck(MOM_contour_start_LIB_ENTRY) [llength [info commands MOM_contour_start_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_turn_cycle_contour_start

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_end_LIB {} {

  set commandcheck(MOM_contour_end_LIB_ENTRY) [llength [info commands MOM_contour_end_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_turn_cycle_contour_end

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_turn_cycle_contour_start {} {

  global dpp_turn_cycle_g_code
  global dpp_rough_turn_cycle_start
  global dpp_contour_list
  global dpp_return_motion_start

  # Flag to indicate return motion end
  set dpp_return_motion_start 0

  # Flag to indicate rough turning cycle contour begin
  set dpp_rough_turn_cycle_start 1

  # Set default G motion type for rough turning cycle
  set dpp_turn_cycle_g_code 71

  # Set rough turning cycle type according to the step angle
  LIB_CTRL_set_turning_cycle_type

  # Calculate the parameters for turning cycle block
  LIB_CTRL_calculate_parameters_for_turning_cycle_block

  # Create a list to store the contour NC codes, start tag and end tag
  set dpp_contour_list [list]

  # Store the start tag
  set o_buffer [MOM_do_template turn_cycle_start_tag CREATE]

  lappend dpp_contour_list $o_buffer

}
# <Internal Documentation>
# This command is used to detect the rough turning cycle type, calculate the cycle parameters
# and create a list to store the contour datas and start tag and end tag.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_set_turning_cycle_type {} {

  global mom_level_step_angle
  global dpp_turn_cycle_g_code
  global dpp_turn_cycle_retract
  global mom_clearance_from_faces
  global mom_clearance_from_diameters
  global dpp_turn_cycle_msg
  global mom_operation_name

  # Set rough turning cycle type according to the step angle
  if {[info exists mom_level_step_angle]} {

    if {[EQ_is_equal $mom_level_step_angle 270] || [EQ_is_equal $mom_level_step_angle 90]} {

      set dpp_turn_cycle_g_code 72
      set dpp_turn_cycle_retract $mom_clearance_from_faces
      set dpp_turn_cycle_msg "ROUGH FACE CYCLE"

    } elseif {[EQ_is_equal $mom_level_step_angle 180] || [EQ_is_equal $mom_level_step_angle 0]} {

      set dpp_turn_cycle_g_code 71
      set dpp_turn_cycle_retract $mom_clearance_from_diameters
      set dpp_turn_cycle_msg "ROUGH TURN CYCLE"

    } else {

      LIB_GE_abort_message "$mom_operation_name: Turning cycle type could not be set by variable mom_level_step_angle now."
    }
  }

}
# <Internal Documentation>
# This command is used to set turning cycle type according to the step angle.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_start.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_calculate_parameters_for_turning_cycle_block {} {

  global dpp_turn_cycle_cut_feed dpp_turn_cycle_cut_speed
  global mom_feed_cut_value mom_spindle_speed
  global dpp_turn_cycle_stock_x dpp_turn_cycle_stock_z
  global mom_stock_part mom_face_stock mom_radial_stock
  global dpp_save_cutcom_status
  global mom_level_step_angle
  global mom_cutcom_status

  # Set value for F and S.
  set dpp_turn_cycle_cut_feed $mom_feed_cut_value
  set dpp_turn_cycle_cut_speed $mom_spindle_speed

  # Calculate stocks for U and W.
  set dpp_turn_cycle_stock_x [expr [LIB_SPF_check_x_factor TURN] * ($mom_stock_part + $mom_radial_stock)]
  set dpp_turn_cycle_stock_z [expr $mom_stock_part + $mom_face_stock]

  # Adjust the sign of U and W and output tool nose radius compensation code.
  if {[info exists dpp_save_cutcom_status]} {

    if { $dpp_save_cutcom_status == "RIGHT"} {

      if {[EQ_is_equal $mom_level_step_angle 0]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]
        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]

      } elseif {[EQ_is_equal $mom_level_step_angle 90]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]

      } elseif {[EQ_is_equal $mom_level_step_angle 270]} {

        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]
      }

      set mom_cutcom_status $dpp_save_cutcom_status
      MOM_enable_address G_cutcom
      MOM_force once G_cutcom D

      LIB_GE_command_buffer TURN_CYCLE_CUTCOM_ON_RIGHT
      LIB_GE_command_buffer {MOM_do_template cutcom_on} @TURN_CYCLE_CUTCOM_ON_RIGHT
      LIB_GE_command_buffer_output
    }

    if {$dpp_save_cutcom_status == "LEFT"} {

      if {[EQ_is_equal $mom_level_step_angle 0]} {

        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]

      } elseif {[EQ_is_equal $mom_level_step_angle 90]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]
        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]

      } elseif {[EQ_is_equal $mom_level_step_angle 180]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]
      }

      set mom_cutcom_status $dpp_save_cutcom_status
      MOM_enable_address G_cutcom
      MOM_force once G_cutcom D

      LIB_GE_command_buffer TURN_CYCLE_CUTCOM_ON_LEFT
      LIB_GE_command_buffer {MOM_do_template cutcom_on} @TURN_CYCLE_CUTCOM_ON_LEFT
      LIB_GE_command_buffer_output
    }
  }

}
# <Internal Documentation>
# This command is used to calculate the parameters for rough turning cycle block.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_start.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_turn_cycle_contour_end {} {

  global dpp_rough_turn_cycle_start
  global dpp_contour_list
  global dpp_contour_list_length
  global mom_sys_output_contour_motion
  global mom_cutcom_status
  global mom_template_subtype
  global mom_profiling
  global mom_operation_name_list
  global mom_machine_cycle_subroutine_name

  # Flag to indicate rough turning cycle contour end
  set dpp_rough_turn_cycle_start 0

  # Store the end tag in the list
  set o_buffer [MOM_do_template turn_cycle_end_tag CREATE]
  lappend dpp_contour_list $o_buffer

  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # When cutter compensation UDE isn't set, rough operation's contour data will be overridden
  # with associated finish operation by using extended command MOM_post_oper_path.
  # So far, NX will only override the contour data for roughing OD & ID,
  # because FACING does not have associated finishing operation.
  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  # Override rough contour data with finish operation
  if {[string match "*ROUGH*" $mom_template_subtype] && \
    ($mom_sys_output_contour_motion == 2)} {

    if {[lsearch $mom_operation_name_list $mom_machine_cycle_subroutine_name] >= 0} {

      LIB_CTRL_override_rough_contour_data_with_finish
    }
  }

  # Get the length of the list
  set dpp_contour_list_length [llength $dpp_contour_list]

  # Calculate start and end line number of contour
  LIB_CTRL_calculate_contour_line_number

  # Output G70 G71 or G72 command depending on operation type
  LIB_CTRL_output_turning_cycle_command

  # Output the contour NC codes
  if {[CONF_CTRL_turn sequence_number_output_mode] == 0} {

    for {set i 0} {$i<$dpp_contour_list_length} {incr i} {
      if {$i==0 || $i==$dpp_contour_list_length-1} {
        MOM_set_seq_on
      }
      set line [lindex $dpp_contour_list $i]
      MOM_output_literal $line
      MOM_set_seq_off
    }

  } else {

    foreach line $dpp_contour_list {
      MOM_output_literal $line
    }
  }

  # Restore outputing sequence number
  MOM_set_seq_on

  # Output the return motion NC codes
  global dpp_return_motion_list
  foreach line $dpp_return_motion_list {
    MOM_output_literal $line
  }

  # Additional profiling can be selected in a rough opeation and output after rough turning cycle.
  # If user adds profile in tool path, some conditions should be checked to fulfill.
  if {[info exists mom_profiling] && ($mom_profiling == 1)} {

    LIB_CTRL_output_additional_profiling
  }

  # Set NX/Post to end contour output mode
  set mom_sys_output_contour_motion 0

  # Cancle tool nose radius compensation
  if {[info exists mom_cutcom_status]} {

    if {$mom_cutcom_status=="LEFT" || $mom_cutcom_status=="RIGHT"} {

      MOM_force once G_cutcom

      LIB_GE_command_buffer TURN_CYCLE_CUTCOM_OFF
      LIB_GE_command_buffer {MOM_do_template cutcom_off} @TURN_CYCLE_CUTCOM_OFF
      LIB_GE_command_buffer_output

      set mom_cutcom_status "UNDEFINED"
    }
  }

}
# <Internal Documentation>
# This command is used to output the contour data and adjust the sequence number.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_override_rough_contour_data_with_finish {} {

  global mom_machine_cycle_subroutine_name
  global dpp_contour_list
  global mom_operation_name

  # Run a finish operation with MOM_post_oper_path in rough operation
  set res [MOM_post_oper_path $mom_machine_cycle_subroutine_name "finish_operation_program.ptp"]

  # Flag to find the begin of contour data in output file
  global mom_finish_contour_data_start
  set mom_finish_contour_data_start 0

  # Get contour data from "finish_operation_program.ptp"
  if {$res == 1} {

    set dpp_contour_list [list]

    lappend dpp_contour_list [MOM_do_template turn_cycle_start_tag CREATE]

    # Open output file "finish_operation_program.ptp"
    if {[catch {set src [open "finish_operation_program.ptp" RDONLY]} fid]} {

      LIB_GE_abort_message "$mom_operation_name: Fail to open the file finish_operation_program.ptp."
    }

    # Only capture NC codes between "(CONTOUR TURN START)" and "(CONTOUR TURN END)"
    # and append them into contour list
    while {[eof $src] == 0} {

      set line [gets $src]

      if {[string match "*(CONTOUR TURN START)*" $line]} {

        set mom_finish_contour_data_start 1
        continue

      }

      if {[string match "*(CONTOUR TURN END)*" $line]} {

        set mom_finish_contour_data_start 0
        break
      }

      if {$mom_finish_contour_data_start == 1} {

        if {[string trim $line] != ""} {
          lappend dpp_contour_list $line
        }
      }
    }

    close $src

    catch {file delete "finish_operation_program.ptp"}

    lappend dpp_contour_list [MOM_do_template turn_cycle_end_tag CREATE]

  } else {

    LIB_GE_abort_message "$mom_operation_name: Fail to run the operation $mom_machine_cycle_subroutine_name with extended command MOM_post_oper_path."
  }

}
# <Internal Documentation>
# This command is used to override rough contour data with corresponding finish when cutter compensation UDE is not set.
# Rough operation's subroutine name should be the same as the associated finish operation's name.
# Use MOM_post_oper_path to run a finish operation in rough operation and output the NC codes into "finish_operation_program.ptp".
# Read the contour data from this file and append into a list used for rough operation.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_calculate_contour_line_number {} {

  global mom_seqnum
  global dpp_turn_cycle_seqno_begin
  global dpp_turn_cycle_seqno_end
  global mom_sys_seqnum_incr
  global dpp_record_rough_cycle_seq
  global mom_machine_cycle_subroutine_name
  global dpp_contour_list_length

  # Calculate start and end line number of contour in NC code
  # which will be output as the parameters of rough turning cycle command.

  if {[CONF_CTRL_turn sequence_number_output_mode] == 0} {

    if {![info exists mom_seqnum]} {

      global mom_def_sequence_start
      set dpp_turn_cycle_seqno_begin [expr $mom_def_sequence_start+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_def_sequence_start+3*$::mom_def_sequence_increment]

    } else {

      set dpp_turn_cycle_seqno_begin [expr $mom_seqnum+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_seqnum+3*$::mom_def_sequence_increment]
    }

  } else {

    if {![info exists mom_seqnum]} {

      global mom_def_sequence_start
      set dpp_turn_cycle_seqno_begin [expr $mom_def_sequence_start+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_def_sequence_start+(1+$dpp_contour_list_length)*$::mom_def_sequence_increment]

    } else {

      set dpp_turn_cycle_seqno_begin [expr $mom_seqnum+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_seqnum+(1+$dpp_contour_list_length)*$::mom_def_sequence_increment]
    }
  }

  # Record the rough turning cycle start seq and end seq.
  set dpp_record_rough_cycle_seq(begin,$mom_machine_cycle_subroutine_name) $dpp_turn_cycle_seqno_begin
  set dpp_record_rough_cycle_seq(end,$mom_machine_cycle_subroutine_name) $dpp_turn_cycle_seqno_end

}
# <Internal Documentation>
# This command is used to calculate and record start and end line number of contour in NC codes.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_turning_cycle_command {} {

  global mom_template_subtype
  global dpp_finish_feed
  global mom_feed_cut_value
  global dpp_turn_cycle_g_code

  if {[string match "FACING" $mom_template_subtype] || \
    [string match "*ROUGH*" $mom_template_subtype]} {

    # Output G71 or G72 command
    LIB_CTRL_lathe_roughing
  }

  if {[string match "*FINISH*" $mom_template_subtype]} {

    # Output G70 command

    LIB_GE_command_buffer TURN_CYCLE_FINISHING_TAG
    LIB_GE_command_buffer {MOM_output_literal "(Finish Turn Cycle)"} @TURN_CYCLE_FINISHING_TAG
    LIB_GE_command_buffer_output

    set dpp_finish_feed $mom_feed_cut_value
    set dpp_turn_cycle_g_code 70

    LIB_GE_command_buffer TURN_CYCLE_FINISHING
    LIB_GE_command_buffer {MOM_do_template turn_cycle_finishing} @TURN_CYCLE_FINISHING
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This command is used to output turning cycle command depending on the operation template type.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_additional_profiling {} {

  global mom_operation_name
  global mom_template_subtype
  global mom_sys_output_contour_motion
  global mom_finishing_cut_method
  global mom_stock_part mom_face_stock mom_radial_stock
  global mom_finish_equidistant_stock mom_finish_face_stock mom_finish_radial_stock
  global dpp_turn_cycle_g_code
  global dpp_finish_feed
  global mom_feedrate_profile_cut

  # Check Condition 1.
  if {[string match "FACING" $mom_template_subtype] || [string match "*ROUGH*" $mom_template_subtype]} {

    # Check Condition 2.
    if {$mom_sys_output_contour_motion == 1} {

      # Check Condition 3.
      if {$mom_finishing_cut_method == 7} {

        # Check Condition 4.
        if {[EQ_is_equal $mom_finish_equidistant_stock $mom_stock_part] && \
          [EQ_is_equal $mom_finish_face_stock $mom_face_stock] && \
          [EQ_is_equal $mom_finish_radial_stock $mom_radial_stock]} {

          # Output additional profiling.
          set dpp_turn_cycle_g_code 70
          set dpp_finish_feed $mom_feedrate_profile_cut

          LIB_GE_command_buffer TURN_CYCLE_FINISHING_IN_ADDITIONAL_PROFILING
          LIB_GE_command_buffer {MOM_do_template turn_cycle_finishing} @TURN_CYCLE_FINISHING_IN_ADDITIONAL_PROFILING
          LIB_GE_command_buffer_output

        } else {

          LIB_GE_abort_message "$mom_operation_name: Profile stock should be the same with rough stock."
        }

      } else {

        LIB_GE_abort_message "$mom_operation_name: Strategy of path settings should be Finish All."
      }

    } else {

      LIB_GE_abort_message "$mom_operation_name: Additional Profiling can only be used when Cutter Compensation UDE is set."
    }

  } else {

    LIB_GE_abort_message "$mom_operation_name: Additional Profiling can only be used in FACING or ROUGH operation."
  }

}
# <Internal Documentation>
# This command is used to check whether output additional profiling data or not.
# If add profile in toolpath, the following conditions should be checked to fulfill.
#
# ==>> Condition 1: Operation type is FACING or ROUGH
# ==>> Condition 2: Cutter compensation UDE has been set
# ==>> Condition 3: Strategy of path settings is Finish All
# ==>> Condition 4: Profile stock is the same with rough stock
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_lathe_roughing {} {

  LIB_GE_command_buffer TURN_CYCLE_LATHE_ROUGHING
  LIB_GE_command_buffer {
    MOM_do_template lathe_roughing
    MOM_force Once G_motion
    MOM_do_template lathe_roughing_1
  } @TURN_CYCLE_LATHE_ROUGHING
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command is used to run lathe roughing cycle function.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_gohome_move_LIB {} {

  global mom_motion_type

  set commandcheck(MOM_gohome_move_LIB_ENTRY) [llength [info commands MOM_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_motion_type == "GOHOME_DEFAULT"} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
  } else {
    MOM_rapid_move
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_path_LIB {} {

  global lib_flag
  global mom_next_oper_has_tool_change mom_current_oper_is_last_oper_in_program mom_next_main_mcs mom_main_mcs
  global mom_path_name mom_operation_name mom_machine_mode mom_out_angle_pos mom_kin_is_turbo_output mom_tool_axis
  global mom_flip_a_axis mom_tool_holder_angle_for_cutting
  global lib_pretreatment mom_tool_pitch mom_polar_status mom_coordinate_output_mode
  global mom_output_mcs_name lib_parameter nxt_oper_tool_axis
  global lib_prev_tool_name mom_next_tool_name mom_operation_is_interop
  global lib_prev_tool_adjust_register mom_tool_adjust_register

  set commandcheck(MOM_end_of_path_LIB_ENTRY) [llength [info commands MOM_end_of_path_LIB_ENTRY]]
  set commandcheck(LIB_unset_variables_in_end_of_path) [llength [info commands LIB_unset_variables_in_end_of_path]]

  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check "spindle" ;# to be sure S and M_spindle addresses are enable for next operation

  if {[CONF_CTRL_setting turbo_mode] == 1} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode disable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {[info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE"} {
    if {[llength [info commands MOM_set_turbo_feedrate_set]]} {MOM_set_turbo_feedrate_set ON}
  }

  if {$mom_machine_mode != "TURN" && [CONF_CTRL_moves polar_off_end_of_path] == "OFF"} {
    set mom_polar_status OFF
    set mom_coordinate_output_mode OFF
  }

  if {![info exists mom_output_mcs_name($mom_operation_name)]}      {set mom_output_mcs_name($mom_operation_name) $mom_main_mcs}
  if {![info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1])]} {set mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) $mom_next_main_mcs}

  # mom_pos(3) and mom_pos(4) are not overwritten if there is an CSYS-Rotation with Toolaxis Z and parallel to TA
  # PR10021397: compare last tool axis of current operation with first tool axis of next operation,
  # because mom_tool_axis saved in pretreatment is always from last motion event.
  if {[LIB_SPF_get_pretreatment "init_tool_axis,0" 1] == ""} {
    array set nxt_oper_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  } else {
    array set nxt_oper_tool_axis "0 [LIB_SPF_get_pretreatment "init_tool_axis,0" 1] 1 [LIB_SPF_get_pretreatment "init_tool_axis,1" 1] 2 [LIB_SPF_get_pretreatment "init_tool_axis,2" 1]"
  }
  if {([CONF_CTRL_moves reset_rotary_axis_end_of_path] == "ON" && ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] &&\
    [LIB_SPF_get_pretreatment axis_mode next] != "SIMULTANEOUS") ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
    set lib_prev_tool_adjust_register $mom_tool_adjust_register
  }

  if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES" ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) && [CONF_CTRL_moves safety_motion_when_mcs_changes] == 1)} {

    switch -- $mom_machine_mode {
      "TURN" {
        LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,TURN
        LIB_GE_command_buffer {LIB_TURNING_mode end} @TURN_END
        LIB_GE_command_buffer_output
      }
      "MILL" {
        LIB_CTRL_polar_transmit "off"
        if {$lib_flag(tool_path_motion) > 0} {
          if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,SIM
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_simultaneous_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          } else {
            #!!! if next op has different mom_out_angle_pos reset as well
            # (maybe compare current and next angle from Pretreatment)
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,POS
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $::lib_sav_kin_machine_type == "3_axis_mill" || $lib_flag(tool_axis_zm) == 1} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_positioning_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          }
        }
      }
    }

    # <17013.16 Interop path> Inter-operation doesn't need postprocessor defined return NC codes.
    if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
      return
    }

    LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,COMMON

    if {$::mom_oper_tool != "NONE" || ([info exist lib_prev_tool_name] && $lib_prev_tool_name != $mom_next_tool_name) } {
      LIB_GE_command_buffer {LIB_local_origin_reset} @LOCAL_ORIG_RESET
      LIB_GE_command_buffer {
        if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
          LIB_WRITE_coolant off
        }
      } @COOLANT_OFF
      LIB_GE_command_buffer {
        if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
          LIB_SPINDLE_end
        }
      } @SPINDLE_OFF
      LIB_GE_command_buffer {
        if {$mom_current_oper_is_last_oper_in_program == "YES"} {
          if {[CONF_CTRL_moves return_end_of_pgm] != ""} {
            LIB_RETURN_move CONF_CTRL_moves return_end_of_pgm
          }
        } else {
          if {[CONF_CTRL_moves return_tool_change_pos] != ""} {
            LIB_RETURN_move CONF_CTRL_moves return_tool_change_pos
          }
        }
      } @RETURN_MOVE
    }
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 0

  } else {

    switch -- $mom_machine_mode {
      "TURN" {

        set nxt_flip_a_axis [LIB_SPF_get_pretreatment mom_flip_a_axis 1]
        set nxt_tool_holder_angle_for_cutting [LIB_SPF_get_pretreatment mom_tool_holder_angle_for_cutting 1]
        # PR9295960: Check existence of mom_flip_a_axis and mom_tool_holder_angle_for_cutting in current operation
        if {$nxt_flip_a_axis == "" && [info exists mom_flip_a_axis]} {
          set nxt_flip_a_axis $mom_flip_a_axis
        }
        if {$nxt_tool_holder_angle_for_cutting == "" && [info exists mom_tool_holder_angle_for_cutting]} {
          set nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting
        }

        if {![info exists mom_tool_holder_angle_for_cutting] || ![EQ_is_equal $nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting]} {

          LIB_GE_command_buffer TURN_HOLDER_ORIENT_CHANGE

          # check if B axis position change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {
            if {[CONF_CTRL_moves return_safety_pos] != ""} {
              LIB_RETURN_move CONF_CTRL_moves return_safety_pos
            }
          } @RETURN_MOVE
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output

        } elseif {[info exists mom_flip_a_axis] && $nxt_flip_a_axis != $mom_flip_a_axis} {

          LIB_GE_command_buffer TURN_TOOL_FLIP_CHANGE
          # check if spindle direction change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output
        }

      }
      "MILL" {
        if {$lib_flag(first_transmit_move) == 1 && ([CONF_CTRL_moves polar_off_end_of_path] == "OFF" || ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] || [LIB_SPF_get_pretreatment axis_mode next] == "SIMULTANEOUS") ||\
        ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
          LIB_CTRL_polar_transmit "off"
        }

        LIB_GE_command_buffer MILL_AXIS_CHANGE

        # If the variable does not exist in the query, an blank is returned

        LIB_GE_command_buffer {

          if {[LIB_SPF_pt_exists_not_empty "out_angle_pos_last,0" 0]} {
            set out_angle_pos(0) [LIB_SPF_get_pretreatment "out_angle_pos_last,0" 0]
            set out_angle_pos(1) [LIB_SPF_get_pretreatment "out_angle_pos_last,1" 0]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set out_angle_pos(0) $mom_out_angle_pos(0)
            set out_angle_pos(1) $mom_out_angle_pos(1)
          }

          if {[LIB_SPF_pt_exists_not_empty "mom_out_angle_pos,0" 1]} {
            set nxt_out_angle_pos(0) [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 1]
            set nxt_out_angle_pos(1) [LIB_SPF_get_pretreatment "mom_out_angle_pos,1" 1]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set nxt_out_angle_pos(0) $out_angle_pos(0)
            set nxt_out_angle_pos(1) $out_angle_pos(1)
          }

          # PR#9554274 incase operation's current status is not same as axis mode. It happened if there is only rapid motions in operation like GMC operation.
          if {([LIB_SPF_get_pretreatment axis_mode] != [LIB_SPF_get_pretreatment axis_mode 1] && ([LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || [LIB_SPF_get_pretreatment axis_mode 1] == "SIMULTANEOUS") )||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(0)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(0) $out_angle_pos(0) $::mom_kin_4th_axis_min_incr] ||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(1)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(1) $out_angle_pos(1) $::mom_kin_5th_axis_min_incr] ||\
            ($lib_flag(mode_current_status) == "sim" &&  [LIB_SPF_get_pretreatment axis_mode] == "POSITIONING")} {
            if {$mom_machine_mode == "MILL" && $lib_flag(tool_path_motion) > 0} {
              if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
                if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                  LIB_ROTARY_absolute_reset
                } else {
                  LIB_ROTARY_simultaneous_reset
                }
              } else {
                #!!! if next op has different mom_out_angle_pos reset as well
                # (maybe compare current and next angle from Pretreatment)

                if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {
                  LIB_ROTARY_absolute_reset
                } else {
                  LIB_ROTARY_positioning_reset
                }
              }
              set lib_flag(tool_path_motion) 0
              if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
            }
          }
        } @RESET

        LIB_GE_command_buffer_output

      }
    }

  }

  # unset Variables if needed
  LIB_GE_command_buffer LIB_unset_variables_in_end_of_path
  LIB_GE_command_buffer {if {$commandcheck(LIB_unset_variables_in_end_of_path)} {LIB_unset_variables_in_end_of_path}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# * store oper info (for operation list)
# * mom_next_oper_has_tool_change == "YES"
# * mom_next_oper_is_last_oper_in_program == "YES"
# * mom_next_main_mcs != mom_main_mcs
# * check rot axis change PT
# if abs
# LIB_ROTARY_absolute_reset
# if sim
# LIB_ROTARY_simultaneous_reset
# if pos
# LIB_ROTARY_positioning_reset
# * retract before set axes (if needed) PT
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_unset_variables_in_end_of_path {} {

  if {[info exists ::lib_spf(do_convert_point)]}    {unset ::lib_spf(do_convert_point)}

  set ::lib_parameter(special_cycle,name) ""

  if {$::mom_next_oper_has_tool_change == "YES" || $::mom_current_oper_is_last_oper_in_program == "YES"} {
    if {[info exists ::mom_tool_pitch]} {unset ::mom_tool_pitch}
  }
}
# <Internal Documentation>
#
#  Unset Variables in End_of_path
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_program_LIB {} {

  set commandcheck(MOM_end_of_program_LIB_ENTRY) [llength [info commands MOM_end_of_program_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer TOOL_CHANGE_EOP
  LIB_GE_command_buffer {
    MOM_force once T M
    switch -- [join [CONF_CTRL_tool tool_change_eop]] {
      "off" {
        # nothing
      }
      "first_tool" {
        set ::mom_tool_name $::mom_next_tool_name
        set ::mom_tool_number $::mom_next_tool_number
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "unload_tool" {
        set ::mom_tool_number 0
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "default" {
        if {[string is integer -strict [CONF_CTRL_tool tool_change_eop]]} {
          set ::mom_tool_number [CONF_CTRL_tool tool_change_eop]
          LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
        }
      }
    }
  } @TOOL_CHANGE_END_OF_PROGRAM
  LIB_GE_command_buffer_output
  LIB_GE_command_buffer END_OF_PROGRAM
  LIB_GE_command_buffer {MOM_do_template end_of_program} @END_OF_PROG
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_reset {} {
  global lib_flag

  set commandcheck(LIB_ROTARY_absolute_reset_ENTRY) [llength [info commands LIB_ROTARY_absolute_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_mode] == "G43.5"} {
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_reset {} {

  global lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_mode] == "G43.4"} {
      LIB_GE_command_buffer SIMULTANEOUS_RESET_G434
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @ADJUST_OFF
      LIB_GE_command_buffer_output
    } elseif {[CONF_CTRL_setting tcpm_mode] == "G43.5"} {
      LIB_GE_command_buffer SIMULTANEOUS_RESET_G435
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @ADJUST_OFF
      LIB_GE_command_buffer_output
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
    # <NX1201 cam16012> new prereatment local csys
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAFOOF
# Heidenhain: M129 / TCPM
# Fanuc: G49
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset {} {

  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_reset_ENTRY) [llength [info commands LIB_ROTARY_positioning_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    LIB_CSYS_plane_output_reset
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch off positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global tcpm_type lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_init_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_mode] == "G43.4" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  LIB_CTRL_unclamp_axis

  if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {return}
  if {$lib_flag(mode_current_status) != "sim"} {
    if {[CONF_CTRL_setting tcpm_mode] != "G43.4" && [CONF_CTRL_setting tcpm_mode] != "G43.5"} {
      LIB_SPF_add_warning "The entry 'INS->[CONF_CTRL_setting tcpm_mode]<-' for tcpm_output is not allowed, G43.4 will be used"
    }
    if {[CONF_CTRL_setting tcpm_mode] == "G43.4"} {
      set tcpm_type 1
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    } elseif {[CONF_CTRL_setting tcpm_mode] == "G43.5"} {
      set tcpm_type 2
      MOM_enable_address X_vector Y_vector Z_vector
      MOM_force once  X_vector Y_vector Z_vector
      MOM_disable_address fourth_axis fifth_axis
    }

    LIB_GE_command_buffer MILL,SIMULTANEOUS

    LIB_GE_command_buffer {
      MOM_do_template tool_length_adjust CREATE
      MOM_force once H
    } @TOOL_LENGTH_ADJUST
    LIB_GE_command_buffer {
      MOM_set_address_format G_csys_rot Zero_real
      MOM_do_template set_tcpm_on
      MOM_set_address_format G_csys_rot Digit_2
    } @ROTARY_SIMULTANEOUS

    LIB_GE_command_buffer_output
    # <NX1201 cam16012> new prereatment local csys
    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_mode] == "G43.5" ||\
      ([CONF_CTRL_setting tcpm_mode] == "G43.4" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    set lib_flag(mode_current_status) "sim"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAORI
# Heidenhain: M128 / TCPM
# Fanuc: G43.4
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_init {} {
  global mom_kin_is_turbo_output mom_post_in_simulation
  global tcpm_type lib_flag

  set commandcheck(LIB_ROTARY_absolute_init_ENTRY) [llength [info commands LIB_ROTARY_absolute_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_mode] == "G43.4" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {
    MOM_disable_address X_vector Y_vector Z_vector
  } else {
    MOM_enable_address fourth_axis fifth_axis
    MOM_force once fourth_axis fifth_axis
    MOM_disable_address X_vector Y_vector Z_vector
  }

  LIB_CTRL_polar_transmit "start"

  LIB_GE_command_buffer TOOL_ADJUST
  LIB_GE_command_buffer {
    MOM_do_template tool_length_adjust CREATE
    MOM_force once G_adjust H
  } @OUTPUT
  LIB_GE_command_buffer_output

  set lib_flag(mode_current_status) "std"

  LIB_GE_command_buffer UNCLAMP
  LIB_GE_command_buffer {LIB_CTRL_unclamp_axis} @UNCLAMP
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global lib_flag
  global mom_kin_machine_type mom_sys_leader
  global mom_init_pos mom_init_alt_pos mom_pos mom_alt_pos mom_out_angle_pos mom_prev_out_angle_pos
  global mom_kin_4th_axis_direction mom_kin_4th_axis_leader mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_kin_5th_axis_direction mom_kin_5th_axis_leader mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit

  if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {return}

  set commandcheck(LIB_ROTARY_positioning_init_ENTRY) [llength [info commands LIB_ROTARY_positioning_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  MOM_disable_address X_vector Y_vector Z_vector

  if {$lib_flag(mode_current_status) != "pos"} {
    LIB_CTRL_set_G68_rotate_dir
    LIB_CSYS_plane_output_init
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: AROT / CYCLE800
# Heidenhain: CYCL DEF 19 or PLANE SPATIAL
# Fanuc: G68 / G68.1 / G68.2
#____________________________________________________________________________________________
proc LIB_CTRL_KINEMATICS_set_simultanous_kin {} {


  global mom_sys_leader lib_sav_kin_4th_axis_leader lib_sav_kin_5th_axis_leader
  global lib_sav_kin_machine_type mom_kin_4th_axis_point
  set commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY) [llength [info commands LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_sim_kin 4th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 4th_axis_has_limit $::mom_sys_4th_axis_has_limits}
  if {[CONF_SPF_sim_kin 5th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 5th_axis_has_limit $::mom_sys_5th_axis_has_limits}
  if {![CONF_SPF_sim_kin 4th_axis_has_limit] || ![CONF_SPF_sim_kin 5th_axis_has_limit]} {
    #     set optimized rotary axis on
  }

  # Move it from LIB_SPF_KINEMATICS_set_simultanous_kin_ENTRY(OEM).
  if {[CONF_CTRL_setting fix_on_machine] == 0 && [CONF_CTRL_setting tcpm_mode] == "G43.4"} {
    if {[string match "5_axis*" $lib_sav_kin_machine_type] && $lib_sav_kin_machine_type != "5_axis_dual_head"} {
      if {[CONF_SPF_sim_kin 4th_axis] == "real" && [CONF_SPF_sim_kin 5th_axis] == "real"} {
        set mom_sys_leader(fourth_axis) $lib_sav_kin_4th_axis_leader
        set mom_sys_leader(fifth_axis) $lib_sav_kin_5th_axis_leader
      }
      LIB_GE_copy_var_range mom_kin lib_sav_kin

      LIB_SPF_calc_4th5th_axis_points
      if {$lib_sav_kin_machine_type == "5_axis_head_table"} {
        global mom_kin_4th_axis_point
        global mom_kin_pivot_gauge_offset
        array set mom_kin_4th_axis_point "0 0 1 0 2 0"
        set mom_kin_pivot_gauge_offset 0
        MOM_reload_kinematics
      }
    } elseif { $lib_sav_kin_machine_type == "4_axis_table"} {
      if {[CONF_SPF_sim_kin 4th_axis] == "real"} {
        set mom_sys_leader(fourth_axis) $lib_sav_kin_4th_axis_leader
      }
      LIB_GE_copy_var_range mom_kin lib_sav_kin
      LIB_SPF_calc_4th5th_axis_points
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on shortest distance for simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: Leader "C=DC("  Trailer ")"
# Heidenhain: M126
#____________________________________________________________________________________________
proc LIB_RETURN_move {Addresses {property ""}} {

  global mom_sys_home_pos mom_prev_pos mom_prev_out_angle_pos
  global tool_axis lib_flag mom_operation_type

  set commandcheck(LIB_RETURN_move_ENTRY) [llength [info commands LIB_RETURN_move_ENTRY]]

  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[string match $mom_operation_type "Device Generic Motion"]} {
      return
  }

  if {$property != ""} {
    set object $Addresses
    set Addresses [$Addresses $property]
  } else {
    set object ""
  }

  set line_nbr -1
  set break_it 0

        foreach axes $Addresses {
          incr line_nbr

    if {[catch {foreach axis $axes {}}]} {
      set axes [list $axes]
    }

    foreach axis $axes {
            MOM_force once G_return
      switch -- $axis {
        "Z" {
                #WRITE_coolant off
                if {[CONF_CTRL_moves return_mode] == "value"} {
                  if {[hiset tool_axis] && $tool_axis == 2} {MOM_do_template tool_length_adjust_off}
                              MOM_force once Z
            MOM_suppress once X Y
            LIB_GE_command_buffer AXIS_MOVE_Z
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Z
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Z
            LIB_GE_command_buffer {MOM_do_template return_home_Z} @RETURN_HOME_Z
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
                MOM_force once Z
        }
        "Y" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 1} {MOM_do_template tool_length_adjust_off}
            MOM_force once Y
            MOM_suppress once X Z
            LIB_GE_command_buffer AXIS_MOVE_Y
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Y
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Y
            LIB_GE_command_buffer {MOM_do_template return_home_Y} @RETURN_HOME_Y
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once Y
        }
        "X" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0} {MOM_do_template tool_length_adjust_off}
            MOM_force once X
            MOM_suppress once Y Z
            LIB_GE_command_buffer AXIS_MOVE_X
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_X
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_X
            LIB_GE_command_buffer {MOM_do_template return_home_X} @RETURN_HOME_X
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once X
        }
        "YX" -
        "XY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0 || [hiset tool_axis] && $tool_axis == 1} {MOM_do_template tool_length_adjust_off}
            MOM_force once X Y
            MOM_suppress once Z
            LIB_GE_command_buffer AXIS_MOVE_XY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_XY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_XY
            LIB_GE_command_buffer {MOM_do_template return_home_XY} @RETURN_HOME_XY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once X Y
        }
        "XZ" -
        "ZX" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0 || [hiset tool_axis] && $tool_axis == 2} {MOM_do_template tool_length_adjust_off}
            MOM_force once X Z
            MOM_suppress once Y
            LIB_GE_command_buffer AXIS_MOVE_ZX
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZX
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZX
            LIB_GE_command_buffer {MOM_do_template return_home_ZX} @RETURN_HOME_ZX
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once Z X
        }
        "YZ" -
        "ZY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 1 || [hiset tool_axis] && $tool_axis == 2} {MOM_do_template tool_length_adjust_off}
            MOM_force once Y Z
            MOM_suppress once X
            LIB_GE_command_buffer AXIS_MOVE_ZY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZY
            LIB_GE_command_buffer {MOM_do_template return_home_ZY} @RETURN_HOME_ZY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          MOM_force once Y Z
        }
        "4th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]]} {
            MOM_force once fourth_axis
            LIB_GE_command_buffer AXIS_HOME_4TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th} @RETURN_HOME_4TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            MOM_force once fourth_axis
          }
        }
        "5th" {
          if {![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fifth_axis
            LIB_GE_command_buffer AXIS_HOME_5TH
            LIB_GE_command_buffer {MOM_do_template return_home_5th} @RETURN_HOME_5TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fifth_axis
          }
        }
        "4th5th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]] || ![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fourth_axis fifth_axis
            LIB_GE_command_buffer AXIS_HOME_45TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th5th} @RETURN_HOME_45TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fourth_axis fifth_axis
          }
        }
        "" {
                #Do Nothing
        }
        "default" {
          if {[LIB_SPF_exists_block_template $axes 1] == 1} {
            MOM_do_template $axes
          } elseif {[LIB_SPF_exists_block_template $axes 1] == -1 && ![catch {set dummy [MOM_do_template $axes CREATE]}]} {
            # Thats the case when 'MOM_has_definition_element' command does not exist (older NX versions)
            #legacy
            MOM_output_literal $dummy
          } else {
            if {$object == ""} {
              #when LIB_RETURN_move is not called with a conf_object as argument
              LIB_RETURN_move_LIB_ENTRY $axes
            } else {
              if {[info proc LIB_RETURN_move_LIB_ENTRY] == "LIB_RETURN_move_LIB_ENTRY"} {
                #legacy
                LIB_RETURN_move_LIB_ENTRY $axes
              } else {
                LIB_CONF_do_prop_custom_proc $object $property "no_special_syntax" $line_nbr
                set break_it 1
                break
              }
            }
          }
        }
      }
    }
    if {$break_it} {break}
  }
  set lib_flag(current_safety_position) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Documentation>
# This procedure writes the NC code for return motions to the output file. Settings for home motions [CONF_CTRL_moves return_mode]
# are taken into consideration for the output format of the return motions.
#
# <Arguments>
# Addresses
# String with space to separate axis names that perform a return move.
# Valid options:
# X / Y / Z / XY / ZX / ZY or a template name
# property
# Reserved argument.
#
# <Returnvalue>
# None.
#
# <Example>
# name: Example using axis names
# code: LIB_RETURN_move "Z XY"
# desc: Writes return moves for Z and then XY to the output file in Fanuc format.
#      Result is:
#      G0 G28 G91 Z0.
#      G0 G28 G91 X0. Y0.
# <Example>
# name: Example using template names
# code: LIB_RETURN_move "custom_return_template1 custom_return_template2"
# desc: Assuming we have two custom specific block templates custom_return_template1 and custom_return_template2,
# you can call them in this command by their name. It's okay to mix template names and axes names (see example 1).
#____________________________________________________________________________________________
proc LIB_main_origin_call {{offset_nbr ""} {create ""}} {

  global mom_fixture_offset_value mom_sys_leader
  global lib_main_zero_register lib_flag

  if {[CONF_CTRL_origin use_main] == 1} {
    if {$mom_fixture_offset_value <= 6} {
      set lib_main_zero_register [expr $mom_fixture_offset_value + 53]
      set mom_sys_leader(G_zero) "G"
    } elseif {$mom_fixture_offset_value <= 306} {
      #set leader_origin_def "G10L20P"
      set lib_main_zero_register [expr $mom_fixture_offset_value - 6]
      set mom_sys_leader(G_zero) "G54.1 P"
    } else {
      if {![hiset lib_flag(error_main_zero_register)]} {
        set error [LIB_SPF_add_warning "Fixture offset value should be < 306 : G54 is used"]
        set lib_flag(error_main_zero_register) 1
      }
      set lib_main_zero_register 1
    }
    LIB_GE_command_buffer MAIN_ZERO
    LIB_GE_command_buffer {MOM_do_template main_zero $create} @OUTPUT
    LIB_GE_command_buffer_output
  }
}
# <Documentation>
# This procedure writes the NC code for the fixture offset of the active coordinate system to the output file, when the property
# CONF_CTRL_origin use_main is set to On.
# <Arguments>
# offset_nbr
# Reserved argument.
# create
# Reserved argument.
# <Example>
# name: Output active origin
# code: LIB_main_origin_call
# desc: Outputs G54 when the fixture offset is set to 1.
#____________________________________________________________________________________________
proc LIB_local_origin_call {} {

  global mom_origin mom_tool_axis mom_csys_matrix mom_sys_csys_rot_code
  global lib_flag
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z

  if {[LIB_SPF_csys_examine_local] == "default" && [EQ_is_equal $mom_tool_axis(2) 1.0]} {
    set mom_origin(0) 0.0
    set mom_origin(1) 0.0
    set mom_origin(2) 0.0
  }

  switch -- [CONF_CTRL_setting plane_output] {
    "G68" {
      if {$lib_flag(local_namespace_output)} {
        LIB_SPF_local_csys_rotation "XYZ"
      } else {
      LIB_SPF_csys_3D_rotation "XYZ"
      }
      set mom_sys_csys_rot_code(ON) 68
      CONF_FANUC_G68 set rotate_before 1
    }
    "G68.1" {
      if {$lib_flag(local_namespace_output)} {
        LIB_SPF_local_csys_rotation "XYZ"
      } else {
      LIB_SPF_csys_3D_rotation "XYZ"
      }
      set mom_sys_csys_rot_code(ON) 68.1
      CONF_FANUC_G68 set rotate_before 1
    }
    "G68.2" {
      if {$lib_flag(local_namespace_output)} {
        LIB_SPF_local_csys_rotation "ZXZ" "euler"
      } else {
      LIB_SPF_csys_3D_rotation "ZXZ" "euler"
      }
      set mom_sys_csys_rot_code(ON) 68.2
    }
  }
  set mom_origin(0) $lib_coord_ref_X
  set mom_origin(1) $lib_coord_ref_Y
  set mom_origin(2) $lib_coord_ref_Z

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 0 && [CONF_CTRL_setting plane_output] != "G68.2"} {
    # not yet implemented
    MOM_force once X Y Z
    set lib_flag(local_origin_activated) 1
  }
}
# <Internal Documentation>
# Output the local origin call (CYCL DEF 7)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_local_origin_reset {} {

  global lib_flag

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 1 && [CONF_CTRL_setting plane_output] != "G68.2"} {
    # not yet implemented
    # MOM_output_literal "TRANS"
    set lib_flag(local_origin_activated) 0
  }
}
# <Internal Documentation>
# Output the main origin reset (CYCL DEF 7)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_init {} {

  global mom_sys_csys_rot_code
  global lib_flag lib_parameter lib_sav_kin_machine_type
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3 lib_coord_ang_4
  # <NX1201 cam16012> new prereatment local csys
  # In new local csys mode, enter local namespace and switch output mode before plane init
  LIB_GE_command_buffer LOCAL_CSYS_INIT
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_set}} @LOCAL_POS_SET
  LIB_GE_command_buffer_output

  LIB_CTRL_unclamp_axis

  if {[CONF_FANUC_G68 rotate_dir] == "+"} {
    set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 1
  } elseif {[CONF_FANUC_G68 rotate_dir] == "-"} {
    set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) -1
  } else {
    set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 0
  }
  switch -- [CONF_CTRL_setting plane_output] {
    "G68" -
    "G68.1" {
      # <NX1201 cam16012> new prereatment local csys
      if {$lib_flag(local_namespace_output)} {
        LIB_rotate_axis_before_plane
      } else {
      LIB_SPF_convert_point "plane"
      LIB_rotate_axis_before_plane
      LIB_SPF_convert_point "reload"
      }
      if {[CONF_CTRL_origin use_local] == 1} {
        set lib_parameter(csys_rot,_X0) $lib_coord_ref_X; set lib_parameter(csys_rot,_Y0) $lib_coord_ref_Y; set lib_parameter(csys_rot,_Z0) $lib_coord_ref_Z
      } else {
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.0
      }
        if {[string match "*table*" $lib_sav_kin_machine_type]} {
        LIB_SPF_add_warning "With G68, only kinematics with head is supported in the core"
        }
      set lib_parameter(csys_rot,retract) 1
      # use the same address in circular move ?
      MOM_disable_address fourth_axis fifth_axis
      #
      if {![EQ_is_zero $lib_coord_ang_C]} {
        set lib_coord_ang_1 0.0; set lib_coord_ang_2 0.0; set lib_coord_ang_3 1.0
        set lib_coord_ang_4 $lib_coord_ang_C
        MOM_force once G_csys_rot X Y Z I_rot J_rot K_rot R_rot
        if {[string match "*.*" $mom_sys_csys_rot_code(ON)]} {
          MOM_set_address_format G_csys_rot Zero_real
          LIB_GE_command_buffer CSYS_ON_G68_1
          LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT_REAL
          LIB_GE_command_buffer_output
          MOM_set_address_format G_csys_rot Digit_2
        } else {
          LIB_GE_command_buffer CSYSC_ON
          LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT
          LIB_GE_command_buffer_output
        }
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.0
        unset lib_coord_ang_4
      }
      #
      if {![EQ_is_zero $lib_coord_ang_A]} {
        set lib_coord_ang_1 1.0; set lib_coord_ang_2 0.0; set lib_coord_ang_3 0.0
        set lib_coord_ang_4 $lib_coord_ang_A
        MOM_force once G_csys_rot X Y Z I_rot J_rot K_rot R_rot
        if {[string match "*.*" $mom_sys_csys_rot_code(ON)]} {
          MOM_set_address_format G_csys_rot Zero_real
          LIB_GE_command_buffer CSYSA_ROT_REAL
          LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT
          LIB_GE_command_buffer_output
          MOM_set_address_format G_csys_rot Digit_2
        } else {
          LIB_GE_command_buffer CSYSA_ROT
          LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT
          LIB_GE_command_buffer_output
        }
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.0
        unset lib_coord_ang_4
      }
      #
      if {![EQ_is_zero $lib_coord_ang_B]} {
        set lib_coord_ang_1 0.0; set lib_coord_ang_2 1.0; set lib_coord_ang_3 0.0
        set lib_coord_ang_4 $lib_coord_ang_B
        MOM_force once G_csys_rot X Y Z I_rot J_rot K_rot R_rot
        if {[string match "*.*" $mom_sys_csys_rot_code(ON)]} {
          MOM_set_address_format G_csys_rot Zero_real
          LIB_GE_command_buffer CSYSB_ROT_REAL
          LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT
          LIB_GE_command_buffer_output
          MOM_set_address_format G_csys_rot Digit_2
        } else {
          LIB_GE_command_buffer CSYSB_ROT
          LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT
          LIB_GE_command_buffer_output
        }
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.0
        unset lib_coord_ang_4
      }
      MOM_force once X Y Z I_rot J_rot K_rot
    }
    "G68.2" {
      LIB_rotate_axis_before_plane
      # Output rotate angle to affect G53.1 choose solution
      if {([CONF_FANUC_G68 rotate_before] != "1" && [CONF_FANUC_G68 rotate_dir] != 0) || ([info exists ::lib_flag(preferred_solution)] && $::lib_flag(preferred_solution) != "OFF") } {
        LIB_CTRL_rotate_axis
      }
      if {[CONF_CTRL_origin use_local] == 1} {
        set lib_parameter(csys_rot,_X0) $lib_coord_ref_X; set lib_parameter(csys_rot,_Y0) $lib_coord_ref_Y; set lib_parameter(csys_rot,_Z0) $lib_coord_ref_Z
      } else {
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.
      }
      set lib_parameter(csys_rot,retract) 1
      MOM_disable_address fourth_axis fifth_axis
      MOM_force once X Y Z I_rot J_rot K_rot
      MOM_set_address_format G_csys_rot Zero_real
      LIB_GE_command_buffer CSYS2_ON
      LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT1
      LIB_GE_command_buffer {MOM_do_template set_csys_on_2} @OUTPUT2
      LIB_GE_command_buffer_output
      MOM_set_address_format G_csys_rot Digit_2
      MOM_force once X Y Z I_rot J_rot K_rot
    }
    default {
      if {[info command [CONF_CTRL_setting plane_output]] == [CONF_CTRL_setting plane_output]} {
        [CONF_CTRL_setting plane_output] init
      } else {
        LIB_GE_abort_message "INS->LIB_CSYS_plane_output_init<- wrong parameter" "Please check INS->lib_parameter(plane_output) = [CONF_CTRL_setting plane_output]<-"
      }
    }
  }

  LIB_rotate_axis_after_plane

  LIB_CTRL_clamp_axis

  set lib_flag(mode_current_status) "pos"
}
# <Internal Documentation>
# output the plane
#
# lib_parameter(plane_output)
#           == "G68"
#           == "G68.1"
#           == "G68.2"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_reset {} {

  global mom_sys_csys_rot_code
  global lib_flag lib_sav_kin_machine_type

  #OUT [LIB_SPF_csys_examine_local] mom_tool_axis(2)
  if {$lib_flag(mode_current_status) == "std"} {return}

  LIB_local_origin_reset

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer LOCAL_CSYS_RESET
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_reset}} @LOCAL_POS_RESET
  LIB_GE_command_buffer_output

  switch -- [CONF_CTRL_setting plane_output] {
    "G68" -
    "G68.1" -
    "G68.2" {
      if {[string match "*.*" $mom_sys_csys_rot_code(OFF)]} {
        MOM_set_address_format G_csys_rot Zero_real
        LIB_GE_command_buffer CSYS_OFF_REAL
        LIB_GE_command_buffer {MOM_do_template set_csys_off} @OUTPUT
        LIB_GE_command_buffer_output
        MOM_set_address_format G_csys_rot Digit_2
      } else {
        LIB_GE_command_buffer CSYS_OFF
        LIB_GE_command_buffer {MOM_do_template set_csys_off} @OUTPUT
        LIB_GE_command_buffer_output
      }
    }
    default {
      [CONF_CTRL_setting plane_output] reset
    }
  }
  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis
  } else {
    MOM_enable_address fourth_axis fifth_axis
  }
  set lib_flag(mode_current_status) "std"

}
# <Internal Documentation>
# reset plane
#
# lib_parameter(plane_output)
#           == "G68"
#           == "G68.1"
#           == "G68.2"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_pos {} {

  global mom_prev_out_angle_pos mom_out_angle_pos mom_polar_status mom_current_motion
  global lib_flag mom_operation_type

  if {[string match $mom_operation_type "Device Generic Motion"]} {
    return
  }

  if {$mom_current_motion == "initial_move"} {
    if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1} {
      set lib_flag(safety_retract_status) 1
    } else {
      set lib_flag(safety_retract_status) 0
    }
  }

  if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1 || $mom_current_motion != "initial_move"} {
  if {[info exists mom_prev_out_angle_pos] && $mom_polar_status != "ON" && [CONF_CTRL_moves standard_path_between_rotary_motions] == 0} {
    if {[CONF_CTRL_moves safety_retract_before_fourth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)]} {
      if {[EQ_is_gt [expr abs($mom_out_angle_pos(0) - $mom_prev_out_angle_pos(0))] [CONF_CTRL_moves safety_retract_before_fourth_axis_minimum_value]]} {
        set lib_flag(safety_retract_status) 1
      }
    }

    if {[CONF_CTRL_moves safety_retract_before_fifth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(1) $mom_out_angle_pos(1)]} {
      if {[EQ_is_gt [expr abs($mom_out_angle_pos(1) - $mom_prev_out_angle_pos(1))] [CONF_CTRL_moves safety_retract_before_fifth_axis_minimum_value]]} {
        set lib_flag(safety_retract_status) 1
      }
    }
  }

  if {[info exists lib_flag(safety_retract_status)] && $lib_flag(safety_retract_status) == 1} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
    set lib_flag(tool_path_motion) 1
    set lib_flag(safety_retract_status) 0
    }
  }

  # only possible with G68.2 for this controller
  if {[CONF_CTRL_setting plane_output] == "G68.2"} {
    LIB_CTRL_prepos_before_plane
  }

}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_prepos_before_plane {} {
  if {[CONF_SPF_plane_kin plane_prepos] == 1} {
    global lib_flag mom_pos oper_mcs_matrix mom_origin
    if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_dual_head" || \
      [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_head_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HH
      LIB_GE_command_buffer {
        LIB_ROTARY_positioning_init
      } @INIT_PLANE
      LIB_GE_command_buffer {
        set tmp_local_origin_activated $lib_flag(local_origin_activated)
        set lib_flag(local_origin_activated) 0
        LIB_ROTARY_positioning_reset
        set lib_flag(local_origin_activated) $tmp_local_origin_activated
      } @RESET_PLANE
      LIB_GE_command_buffer {LIB_ROTARY_simultaneous_init} @INIT_SIM
      LIB_GE_command_buffer {
        LIB_SPF_convert_point "simultaneous"
        VMOV 3 mom_pos tmp_pos
        MTX3_transpose oper_mcs_matrix tmp_matrix
        MTX3_vec_multiply tmp_pos tmp_matrix mom_pos
        if {[CONF_CTRL_setting plane_output] == "G68.2"} {
          VEC3_add mom_origin mom_pos mom_pos
        }
      } @CP_SIM
      LIB_GE_command_buffer {
        set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
        LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $::mom_motion_event] FORCE "[join $decompose] fourth_axis fifth_axis"
      } @MOTION
      LIB_GE_command_buffer {LIB_SPF_convert_point "reload"} @CP_RELOAD
      LIB_GE_command_buffer {
        LIB_ROTARY_simultaneous_reset
      } @RESET_SIM
      LIB_GE_command_buffer_output
      set ::lib_flag(preset_save_pos) 0
    } elseif {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_head_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HT
      LIB_GE_command_buffer_output
    } else {
      # do nothing
    }
  }
}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion_pos
# Preposition tool axis when property plane_prepos is set
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_sim {} {
  global lib_flag

  if {[CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    LIB_GE_command_buffer TCPM_PREPOS_PLANE
    # <NX1201 cam16012> new prereatment local csys
    LIB_GE_command_buffer {
      switch -- [CONF_CTRL_setting plane_output] {
        "G68" {
          if {$lib_flag(local_namespace_output)} {
            LIB_SPF_local_csys_rotation "XYZ"
          } else {
            LIB_SPF_convert_point "plane_no_reset"
            LIB_SPF_csys_3D_rotation "XYZ"
            LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
          }
        }
        "G68.1" {
          if {$lib_flag(local_namespace_output)} {
            LIB_SPF_local_csys_rotation "XYZ"
          } else {
            LIB_SPF_convert_point "plane_no_reset"
            LIB_SPF_csys_3D_rotation "XYZ"
            LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
          }
        }
        "G68.2" {
          if {$lib_flag(local_namespace_output)} {
            LIB_SPF_local_csys_rotation "ZXZ" "euler"
          } else {
            LIB_SPF_convert_point "plane_no_reset"
            LIB_SPF_csys_3D_rotation "ZXZ" "euler"
            LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
          }
          MOM_force once fourth_axis fifth_axis
          LIB_CTRL_rotate_axis
        }
      }
    } @CP_PLANE
    LIB_GE_command_buffer {LIB_ROTARY_positioning_init} @INIT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
    LIB_GE_command_buffer {LIB_ROTARY_positioning_first_move_pos} @MOTION
    LIB_GE_command_buffer {LIB_ROTARY_positioning_reset} @RESET
    # <NX1201 cam16012> new prereatment local csys
    if {$lib_flag(local_namespace_output) == 0} {
      LIB_GE_command_buffer {LIB_SPF_convert_point "reload"} @CP_RELOAD
      LIB_GE_command_buffer {
        if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
          LIB_SPF_KINEMATICS_set_absolut_output_kin
        } else {
          LIB_SPF_KINEMATICS_set_simultanous_kin
        }
      } @KIN_SIM
    } else {
      #LIB_SPF_convert_point "simultanous"
      global mom_mcs_goto mom_pos
      VMOV 3 mom_mcs_goto mom_pos
    }
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_dwell_set {} {

  global mom_cycle_delay_mode ;# SECONDS, REVOLUTIONS, OFF ,ON
  global mom_cycle_delay mom_cycle_delay_revs mom_spindle_rpm

  if {$mom_cycle_delay_mode == "ON"} {set mom_cycle_delay [CONF_CTRL_drill default_cycle_delay]}

  if {$mom_cycle_delay_mode == "OFF"} {
    set mom_cycle_delay 0
    return
  }

  if {$mom_cycle_delay_mode == "REVOLUTIONS"} {
    catch {set mom_cycle_delay [expr $mom_cycle_delay_revs * (60 / $mom_spindle_rpm)]}
  }

  if {$mom_cycle_delay > [CONF_CTRL_drill max_delay]} {set mom_cycle_delay [CONF_CTRL_drill max_delay]}
  if {$mom_cycle_delay < [CONF_CTRL_drill min_delay]} {set mom_cycle_delay [CONF_CTRL_drill min_delay]}
}
# <Internal Documentation>
# This procedure is executed at the cycle event.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill : output CYCLE81 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_move_LIB {} {

  global lib_flag
  set commandcheck(MOM_drill_move_LIB_ENTRY) [llength [info commands MOM_drill_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_dwell : output CYCLE82 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell_move_LIB {} {

  set commandcheck(MOM_drill_dwell_move_LIB_ENTRY) [llength [info commands MOM_drill_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_deep_LIB {} {

  global mom_cycle_step1 mom_tool_diameter mom_cycle_feed_to

  LIB_CYCLE_set

  if {[hiset mom_cycle_step1]} {
    set mom_cycle_step1 [expr abs($mom_cycle_step1)]
  } else {
    set mom_cycle_step1 0
  }

}
# <Internal Documentation>
# MOM_drill_deep : output CYCLE83_Deep (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep_move_LIB {} {

  global mom_cycle_feed_to mom_cycle_step1 mom_tool_diameter

  if {$mom_cycle_step1 == 0} {
    if {[info exists mom_tool_diameter]} {set mom_cycle_step1 [expr $mom_tool_diameter / 2]} else {set mom_cycle_step1 2}
    LIB_SPF_add_warning "With CYCLE/DEEP, STEP1 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step1]<-'"
  }
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_drill_deep_move_LIB_ENTRY) [llength [info commands MOM_drill_deep_move_LIB_ENTRY]]


  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_LIB {} {

  global mom_cycle_step1 mom_tool_diameter mom_cycle_feed_to

  LIB_CYCLE_set

  if {[hiset mom_cycle_step1]} {
    set mom_cycle_step1 [expr abs($mom_cycle_step1)]
  } else {
    set mom_cycle_step1 0
  }

}
# <Internal Documentation>
# MOM_drill_break_chip : output CYCLE83_Break_Chip (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_mill_hole_move_LIB {} {

    set commandcheck(MOM_mill_hole_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_move_LIB_ENTRY]]

    LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_SPF_add_warning "Hole milling machine cycle is not supported on this controller"

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# This function outputs a warning as hole milling subprogram is not supported on this controller
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_mill_hole_thread_move_LIB {} {

    set commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_thread_move_LIB_ENTRY]]

    LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_SPF_add_warning "Thread milling machine cycle is not supported on this controller"

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# This function outputs a warning as thread milling subprogram is not supported on this controller
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_move_LIB {} {

  global mom_cycle_feed_to mom_cycle_step1 mom_tool_diameter

  if {$mom_cycle_step1 == 0} {
    if {[info exists mom_tool_diameter]} {set mom_cycle_step1 [expr $mom_tool_diameter / 2]} else {set mom_cycle_step1 2}
    LIB_SPF_add_warning "With CYCLE/BREAKCHIP, STEP1 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step1]<-'"
  }
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_drill_break_chip_move_LIB_ENTRY) [llength [info commands MOM_drill_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_tap
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_move_LIB {} {

  set commandcheck(MOM_tap_move_LIB_ENTRY) [llength [info commands MOM_tap_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_float_LIB {} {

  LIB_CYCLE_set

}
# <Internal Documentation>
# MOM_tap_float
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float_move_LIB {} {

  set commandcheck(MOM_tap_float_move_LIB_ENTRY) [llength [info commands MOM_tap_float_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_deep_LIB {} {
  global mom_cycle_step1 mom_cycle_feed_to

  LIB_CYCLE_set

  if {![info exists mom_cycle_step1] || [EQ_is_zero $mom_cycle_step1]} {
    LIB_SPF_add_warning "Step value of Tap Deep cycle cannot be zero!"
  }
}
# <Internal Documentation>
# MOM_tap_deep
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep_move_LIB {} {

  global mom_cycle_feed_to mom_cycle_step1

  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_tap_deep_move_LIB_ENTRY) [llength [info commands MOM_tap_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_break_chip_LIB {} {
  global mom_cycle_step1 mom_cycle_feed_to

  if {![info exists mom_cycle_step1] || [EQ_is_zero $mom_cycle_step1]} {
    LIB_SPF_add_warning "Step value of Tap Break Chip cycle cannot be zero!"
  }

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_tap_break_chip
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip_move_LIB {} {

  global mom_cycle_feed_to mom_cycle_step1

  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_tap_break_chip_move_LIB_ENTRY) [llength [info commands MOM_tap_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore : output CYCLE85_Bore (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_move_LIB {} {

  set commandcheck(MOM_bore_move_LIB_ENTRY) [llength [info commands MOM_bore_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_dwell_LIB {} {

  LIB_CYCLE_set

}
# <Internal Documentation>
# MOM_bore_dwell : output CYCLE85_Bore_Dwell (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell_move_LIB {} {

  set commandcheck(MOM_bore_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_drag_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_drag : output CYCLE89 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag_move_LIB {} {

  set commandcheck(MOM_bore_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_no_drag_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_no_drag : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag_move_LIB {} {

  set commandcheck(MOM_bore_no_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_no_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_back_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_back : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back_move_LIB {} {

  set commandcheck(MOM_bore_back_move_LIB_ENTRY) [llength [info commands MOM_bore_back_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual : output CYCLE87 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_move_LIB {} {

  set commandcheck(MOM_bore_manual_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual_dwell : output CYCLE88 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_move_LIB {} {

  set commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_text_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text_move_LIB {} {

  set commandcheck(MOM_drill_text_move_LIB_ENTRY) [llength [info commands MOM_drill_text_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_thread_LIB {} {

  global mom_path_name mom_machine_control_use_machine_cycle
  global lib_flag

  if {$lib_flag(lathe_thread_motion)} {return}

  if {[CONF_CTRL_turn thread_cycle] == "G76/G78"} {
    set lib_flag(lathe_thread_motion) 1
  } else {
    LIB_GE_abort_message "INS->$mom_path_name<- : With [CONF_CTRL_turn thread_cycle] Thread Cycle, option 'Machine Cycle From Post' should not be set." "Please Check Operation setting."
  }

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_move_LIB {} {

  global mom_prev_pos mom_pos mom_lathe_thread_lead_i mom_lathe_thread_lead_k
  global mom_cycle_feed_to_pos mom_machine_control_use_machine_cycle mom_current_motion mom_nxt_motion_event
  global cycle_multiple_prev_pos cycle_multiple_pos lib_flag
  global thread_type

  set commandcheck(MOM_thread_move_LIB_ENTRY) [llength [info commands MOM_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_turn thread_cycle] == "G76/G78" && $lib_flag(lathe_thread_motion)} {
    if {[info exists mom_machine_control_use_machine_cycle] && $mom_machine_control_use_machine_cycle == 1} {
      if {[info exists mom_cycle_feed_to_pos]} {
        if {![info exists cycle_multiple_prev_pos]} {
          set cycle_multiple_prev_pos(0) $mom_cycle_feed_to_pos(0)
          set cycle_multiple_prev_pos(2) $mom_cycle_feed_to_pos(2)
        }
        if {$mom_current_motion == "thread_move" && $mom_nxt_motion_event == "thread_move"} {
          set cycle_multiple_pos(0) $mom_cycle_feed_to_pos(0)
          set cycle_multiple_pos(2) $mom_cycle_feed_to_pos(2)
        }
      }
    } else {
      set cycle_multiple_pos(0) $mom_pos(0)
      set cycle_multiple_pos(2) $mom_pos(2)
      set cycle_multiple_prev_pos(0) $mom_prev_pos(0)
      set cycle_multiple_prev_pos(2) $mom_prev_pos(2)
    }
    MOM_abort_event
  }
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# MOM_thread_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_off_LIB {} {

  global lib_flag

  set commandcheck(MOM_cycle_off_LIB_ENTRY) [llength [info commands MOM_cycle_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer CYCLE_OFF
  LIB_GE_command_buffer {
    if {$lib_flag(lathe_thread_motion) && [CONF_CTRL_turn thread_cycle] == "G76/G78"} {
      LIB_CTRL_g76_cycle
      MOM_do_template cycle_off CREATE
    }
  } @OUTPUT_THREAD_CYCLE
  LIB_GE_command_buffer {
    if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
      MOM_do_template spindle_tap_rigid_init CREATE
    }
    if {[CONF_CTRL_drill cancel_cycle] == "G80"} {
      MOM_do_template cycle_off
    } elseif {[MOM_ask_address_value G_motion] > 1 } {
      MOM_do_template cycle_off
    }
  } @OFF
  LIB_GE_command_buffer {MOM_do_template cycle_init CREATE} @INIT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CYCLE_set {} {
  LIB_GE_command_buffer CYCLE_SET_start
  LIB_GE_command_buffer {
  global mom_cycle_feed_rate mom_cycle_feed_rate_mode mom_cycle_feed_rate_per_rev mom_spindle_rpm
    if {[string match *PR* [string toupper $mom_cycle_feed_rate_mode]]} {
      set mom_cycle_feed_rate [expr $mom_cycle_feed_rate_per_rev * $mom_spindle_rpm]
    }
  } @CYCLE_FEED
  LIB_GE_command_buffer_output

  LIB_CYCLE_dwell_set
}
# <Internal Documentation>
# Controls the drilling cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_set {} {
  global mom_tool_pitch mom_cycle_feed_rate_per_rev
  global mom_cycle_thread_pitch
  global mom_cycle_thread_right_handed
  global mom_spindle_direction
  global mom_spindle_rpm mom_spindle_speed
  global mom_retract_spindle
  global mom_path_name
  global feed_mode
  global feed

  if {[info exists mom_tool_pitch]} {
    set pitch $mom_tool_pitch
  } elseif {[info exists mom_cycle_thread_pitch]} {
    set pitch $mom_cycle_thread_pitch
  } else {
    if {[CONF_CTRL_drill tool_pitch_used] == 0} {
      set pitch $mom_cycle_feed_rate_per_rev
    } else {
      set pitch 0
      LIB_GE_abort_message "INS->$mom_path_name<- : No pitch defined on the tool." "Please use Tap tool."
    }
  }

  if {![info exists mom_spindle_speed] || [EQ_is_zero $mom_spindle_speed]} {
    LIB_GE_abort_message "INS->$mom_path_name<- : spindle speed is 0." "Please verify."
  }

  if {[string match "*PR" [CONF_CTRL_drill cycle_tap_feed_type]]} {
    set feed $pitch
    MOM_set_address_format F Feed_[CONF_CTRL_drill cycle_tap_feed_type]
          #<lili 05-20-2019> In this case, G95 should be outputed, reset feed_mode.
          set feed_mode [CONF_CTRL_drill cycle_tap_feed_type]
  } elseif {[string match "*PR" $feed_mode]} {
    set feed $pitch
  } else {
    set feed [expr $pitch*$mom_spindle_rpm]
  }

  LIB_CYCLE_tap_g_code_string_determine_for_standard
}
# <Internal Documentation>
# Controls the tapping cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move {} {

  global mom_cycle_feed_to mom_cycle_retract_to_pos mom_cycle_rapid_to_pos
  global mom_sys_cycle_tap_code mom_sys_cycle_tap_rigid_code mom_spindle_direction
  global mom_motion_event mom_sys_tap_rigid_code
  global cycle_peck_size lib_parameter cycle_factor
  global lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos lib_flag tool_axis
  global mom_namespace_name mom_cycle_rapid_to mom_cycle_clearance_plane mom_pos

  LIB_GE_command_buffer START_CYCLE
  LIB_GE_command_buffer {LIB_SPINDLE_start cycle} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer PREPOS_IN_CYCLE
  LIB_GE_command_buffer {
  if {$lib_flag(tool_path_motion) == 1} {
    switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z} {G_adjust X H}" "cycle_move" FORCE "G_adjust X Y Z H"}
        1 {LIB_SPF_decompose_block_template "{X Z} {G_adjust Y H}" "cycle_move" FORCE "G_adjust X Y Z H"}
        2 {LIB_SPF_decompose_block_template "{X Y} {G_adjust Z H}" "cycle_move" FORCE "G_adjust X Y Z H"}
    }
  }
  } @PREPOS_DEFAULT
  LIB_GE_command_buffer_output
  set lib_flag(tool_path_motion) 2

  switch -- $tool_axis {
    0 {set cycle_factor [LIB_SPF_check_x_factor MILL]}
    1 {set cycle_factor 1}
    2 {set cycle_factor 1}
  }

  # <NX1201 cam16012> new prereatment local csys
  # PR9772886: Override feed_to_pos/rapid_to_pos/retract_to_pos by related value in local namespace
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_recalculate_cycle_pos
  }

  LIB_SPF_retract_to_pos

  # PR9439021: Replace negative rapid_to by clearance_plane to keep safety distance in Cycle.
  LIB_GE_command_buffer RAPIDTOPOS_IN_CYCLE
  LIB_GE_command_buffer {
    if {$mom_cycle_rapid_to < 0} {
      set mom_cycle_rapid_to $mom_cycle_clearance_plane
      set mom_cycle_rapid_to_pos($tool_axis)  [expr $mom_pos($tool_axis) + $mom_cycle_rapid_to]
    }
  } @RAPIDTOPOS_ADJUST
  LIB_GE_command_buffer_output

  set cycle_peck_size [expr ($mom_cycle_feed_to*(-1.0))]     ;# single peck size most cycles

  LIB_WRITE_coolant on

  if {[info exists lib_parameter(special_cycle,name)] && $lib_parameter(special_cycle,name) != ""} {
    LIB_CYCLE_move_special_$lib_parameter(special_cycle,name)
  } else {
    switch -- $mom_motion_event {
      "drill_move"    {
              LIB_GE_command_buffer DRILL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_dwell_move"  {
              LIB_GE_command_buffer DRILL_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_deep_move"   {
              LIB_GE_command_buffer DRILL_DEEP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_deep} @OUTPUT
              LIB_GE_command_buffer_output

            }
      "drill_break_chip_move" {
              LIB_GE_command_buffer DRILL_BREAK_CHIP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_break_chip} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_move"    {
              if {[CONF_CTRL_drill cycle_tap] == "rigid"} {
                LIB_GE_command_buffer TAP_MOVE_RIGID
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Coordinate
                  set mom_sys_cycle_tap_code $mom_sys_cycle_tap_rigid_code($mom_spindle_direction)
                } @SETTING_BEFORE
                LIB_GE_command_buffer {
                  if {[MOM_ask_address_value M_rigid_tap] != $mom_sys_tap_rigid_code} {MOM_force once S}
                  MOM_do_template spindle_tap_rigid
                } @RIGID_MODE_OUTPUT
                LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Digit_2
                  set mom_sys_cycle_tap_code 84
                }  @SETTING_AFTER
                LIB_GE_command_buffer_output
              } else {
                LIB_GE_command_buffer TAP_MOVE
                LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
                LIB_GE_command_buffer_output
              }
            }
      "tap_float_move"  {
              if {[CONF_CTRL_drill cycle_tap] == "rigid"} {
                LIB_GE_command_buffer TAP_FLOAT_MOVE_RIGID
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Coordinate
                  set mom_sys_cycle_tap_code $mom_sys_cycle_tap_rigid_code($mom_spindle_direction)
                } @SETTING_BEFORE
                LIB_GE_command_buffer {
                  if {[MOM_ask_address_value M_rigid_tap] != $mom_sys_tap_rigid_code} {MOM_force once S}
                  MOM_do_template spindle_tap_rigid
                } @RIGID_MODE_OUTPUT
                LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Digit_2
                  set mom_sys_cycle_tap_code 84
                }  @SETTING_AFTER
                LIB_GE_command_buffer_output
              } else {
              LIB_GE_command_buffer TAP_FLOAT_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
              LIB_GE_command_buffer_output
              }
            }
      "tap_deep_move"   {
              if {[CONF_CTRL_drill cycle_tap] == "rigid"} {
                LIB_GE_command_buffer TAP_DEEP_MOVE_RIGID
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Coordinate
                  set mom_sys_cycle_tap_code $mom_sys_cycle_tap_rigid_code($mom_spindle_direction)
                } @SETTING_BEFORE
                LIB_GE_command_buffer {
                  if {[MOM_ask_address_value M_rigid_tap] != $mom_sys_tap_rigid_code} {MOM_force once S}
                  MOM_do_template spindle_tap_rigid
                } @RIGID_MODE_OUTPUT
                LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Digit_2
                  set mom_sys_cycle_tap_code 84
                }  @SETTING_AFTER
                LIB_GE_command_buffer_output
              } else {
              LIB_GE_command_buffer TAP_DEEP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
              LIB_GE_command_buffer_output
              }
            }
      "tap_break_chip_move"   {
              if {[CONF_CTRL_drill cycle_tap] == "rigid"} {
                LIB_GE_command_buffer TAP_BREAK_CHIP_MOVE_RIGID
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Coordinate
                  set mom_sys_cycle_tap_code $mom_sys_cycle_tap_rigid_code($mom_spindle_direction)
                } @SETTING_BEFORE
                LIB_GE_command_buffer {
                  if {[MOM_ask_address_value M_rigid_tap] != $mom_sys_tap_rigid_code} {MOM_force once S}
                  MOM_do_template spindle_tap_rigid
                } @RIGID_MODE_OUTPUT
                LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Digit_2
                  set mom_sys_cycle_tap_code 84
                }  @SETTING_AFTER
                LIB_GE_command_buffer_output
              } else {
              LIB_GE_command_buffer TAP_BREAK_CHIP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
              LIB_GE_command_buffer_output
              }
            }
      "bore_move"     {
              LIB_GE_command_buffer BORE_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_dwell_move"   {
              LIB_GE_command_buffer BORE_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_drag_move"  {
              LIB_GE_command_buffer BORE_DRAG_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_drag} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_no_drag_move"   {
              LIB_GE_command_buffer BORE_NO_DRAG_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_no_drag} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_back_move"  {
              LIB_GE_command_buffer BORE_BACK_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_back} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_manual_move"  {
              LIB_GE_command_buffer BORE_MANUAL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_manual} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_manual_dwell_move" {
              LIB_GE_command_buffer BORE_MANUAL_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_manual_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_text_move"   {# nothing for the moment}
      "thread_move"     {# nothing for the moment}
    }
  }

  LIB_CTRL_cycle_retract_handling

  if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
    namespace eval $::mom_namespace_name {
      array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
      array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
    }
  } else {
    array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
    array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]

}
# <Internal Documentation>
# Controls the drilling move setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_g_code_string_determine_for_standard {} {

  global mom_cycle_thread_right_handed
  global mom_spindle_direction
  global mom_sys_cycle_tap_code

  if {[info exists mom_cycle_thread_right_handed]} {

    if {$mom_cycle_thread_right_handed == "TRUE"} {

      set mom_sys_cycle_tap_code "84"

    } else {

      set mom_sys_cycle_tap_code "74"
    }

  } elseif {[info exists mom_spindle_direction]} {

    if {$mom_spindle_direction == "CLW"} {

      set mom_sys_cycle_tap_code "84"

    }

    if {$mom_spindle_direction == "CCLW"} {

      set mom_sys_cycle_tap_code "74"
    }
  } else {
      set mom_sys_cycle_tap_code "84"
  }

}
# <Internal Documentation>
# Controls the tapping cycle setting conditions.
#
# Determine the tapping G code according to thread direction for standard mode in tap move.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_retract_handling {} {
  global mom_cycle_retract_to_pos mom_cycle_rapid_to_pos tool_axis
  global mom_cycle_retract_to mom_cycle_rapid_to mom_pos
  global mom_cycle_retract_mode mom_namespace_name

  # If mom_cycle_retract_mode is "AUTO", for continuous drilling in local csys namespace,
  # rapidTo and retractTo are recalculated and may be different, but we don't need to output redundant NC code "G0 Z.."
  if {$mom_cycle_retract_mode == "AUTO"} {return}

# 31.01.2018 HES Why we retract only if mom_cycle_retract_mode is "MANUAL"
# change it if rapid and retract is different
# if {![EQ_is_equal $mom_cycle_retract_to $mom_cycle_rapid_to] && $mom_cycle_retract_mode == "MANUAL"} {}
  if {![EQ_is_equal $mom_cycle_retract_to $mom_cycle_rapid_to]} {
    # <NX1201 cam16012> new prereatment local csys
    if {[info exists mom_namespace_name] && [namespace exists $mom_namespace_name]} {
      # Should set mom_pos or mom_mcs_goto in specify namespace mom_namespace_name if exist
      uplevel #0 {
        namespace eval $::mom_namespace_name {
          set tmp_posz $mom_pos($tool_axis)
          set tmp_mcs_gotoz $mom_mcs_goto($tool_axis)
          set mom_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
          set mom_mcs_goto($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
          MOM_do_template [CONF_CTRL_moves rapid_template]
          set mom_pos($tool_axis) $tmp_posz
          set mom_mcs_goto($tool_axis) $tmp_mcs_gotoz
        }
      }
    } else {
      set tmpz $mom_pos($tool_axis)
      set mom_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
      LIB_GE_command_buffer CYCLE_RETRACT
      LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
      LIB_GE_command_buffer_output
      set mom_pos($tool_axis) $tmpz
    }
    MOM_force once R_cycle Q_cycle
  }

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CHECK_adjust_register {} {

  global mom_path_name mom_tool_adjust_register mom_tool_length_adjust_register mom_tool_number
  global lib_flag

  LIB_GE_command_buffer CHECK_adjust_register
  LIB_GE_command_buffer {
    if {$mom_tool_length_adjust_register == 0} {set mom_tool_adjust_register $mom_tool_number}

    if {[CONF_CTRL_tool max_d_number] != 0 && $mom_tool_length_adjust_register > [CONF_CTRL_tool max_d_number]} {
      if {![hiset lib_flag(error_adjust_register,$mom_path_name)]} {
        set error [LIB_SPF_add_warning "Adjust register $mom_tool_length_adjust_register not possible ([CONF_CTRL_tool max_d_number] max) ... Adjust register $mom_tool_number (same as tool_number) is used"]
        set lib_flag(error_adjust_register,$mom_path_name) 1
      }
      set mom_tool_adjust_register $mom_tool_number
    }
  } @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Check for adjust register
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_tool_number {} {

  global mom_tool_number mom_tool_name

  if {[CONF_CTRL_tool max_tool_number] != 0 && $mom_tool_number > [CONF_CTRL_tool max_tool_number]} {
    set error [LIB_SPF_add_warning "Maximum tool number allowed : [CONF_CTRL_tool max_tool_number]. Check tool $mom_tool_name"]
  }
}
# <Internal Documentation>
# Check the tool number
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_before_plane {} {

  if {[CONF_FANUC_G68 rotate_before] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis before plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_after_plane {} {

  if {[CONF_FANUC_G68 rotate_after] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis after plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_WRITE_coolant {{option default}} {

  global mom_coolant_mode mom_coolant_status mom_kin_is_turbo_output

  switch -- $option {
    "on"  {
      if {![hiset mom_coolant_mode] || $mom_coolant_mode == ""} {set mom_coolant_mode [CONF_CTRL_coolant coolant_status]}
      if {$mom_coolant_mode == "OFF"} {return}

      LIB_GE_command_buffer COOLNT_on
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_output_before_motion] != 0} {
          MOM_do_template coolant_on
        }
      } @COOLNT_on_std
      LIB_GE_command_buffer_output
    }
    "off" {
      LIB_GE_command_buffer COOLNT_off
      LIB_GE_command_buffer {
        if {[info exists mom_kin_is_turbo_output] && $mom_kin_is_turbo_output == "TRUE" && [MOM_ask_address_value M_coolant] != $::mom_sys_coolant_code(OFF)} {
          MOM_force once M_coolant ; #needs when turbo mode is activated (Bug#669)
        }
        MOM_do_template coolant_off
      } @COOLNT_on_std
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_auto] == 0} {
          set mom_coolant_mode "OFF"
          set mom_coolant_status "OFF"
        }
      } @COOLNT_on_std_2
      LIB_GE_command_buffer_output
    }
  }
}
# <Internal Documentation>
# This procedure is executed to output coolant on or off
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {


  global lib_arc_axis mom_arc_radius

  switch -- $lib_arc_axis {
    0 {MOM_suppress once I}
    1 {MOM_suppress once J}
    2 {MOM_suppress once K}
  }

  switch -- $lib_arc_axis {
    0 {MOM_force once Y Z J K}
    1 {MOM_force once X Z I K}
    2 {MOM_force once X Y I J}
  }
  LIB_SPF_check_arc_radius
  if {[info level -1] == "MOM_helix_move_LIB"} {
    if {[CONF_CTRL_moves always_center_for_circle] != 1 && ![EQ_is_equal [expr fmod($::mom_arc_angle,360)] 360 0.1] && ![EQ_is_equal [expr fmod($::mom_arc_angle,360)] 180 0.1]} {
      MOM_suppress once I J K
      MOM_force once X Y Z R
      if {[expr fmod($::mom_arc_angle,360)] > 180} {
        set mom_arc_radius [expr abs($mom_arc_radius) * -1]
      } else {
        set mom_arc_radius [expr abs($mom_arc_radius) * +1]
      }

    } else {
      MOM_suppress once R
      MOM_force once X Y Z
    }
  } else {
    if {[CONF_CTRL_moves always_center_for_circle] != 1} {
      set mom_arc_radius [expr abs($mom_arc_radius)]

      if {[CONF_CTRL_feed feed_linear] == 2} {
        set ::feed $::mom_feedrate
        LIB_CTRL_feed_output
      }

      MOM_suppress once I J K

      # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
      if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

        global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
        global mom_namespace_name mom_output_pos_type
        if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
          if {$mom_namespace_name == "::"} {
            set namespace ::
          } else {
            set namespace ::LOCAL_CSYS::
          }
          if {$mom_output_pos_type == "mom_pos"} {
            VMOV 3 ${namespace}mom_prev_pos prev_pos
            VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
          } else {
            VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
            VMOV 3 ${namespace}mom_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
          }
          VMOV 3 ${namespace}$mom_output_pos_type save_pos
        } else {
          set namespace ::
          set mom_output_pos_type mom_pos
          VMOV 3 mom_prev_pos prev_pos
          VMOV 3 mom_pos_arc_center pos_arc_center
          VMOV 3 mom_pos_arc_axis pos_arc_axis
          VMOV 3 mom_pos save_pos
        }
        VEC3_sub prev_pos pos_arc_center tmp_vec
        VEC3_unitize tmp_vec tmp_vec1
        VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
        VEC3_scale mom_arc_radius tmp_vec tmp_vec1
        VEC3_add pos_arc_center tmp_vec1 tmp_vec
        VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

        MOM_do_template [CONF_CTRL_moves circular_template]
        MOM_suppress once I J K
        VMOV 3 save_pos  ${namespace}$mom_output_pos_type
        set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]

        switch -- $::lib_arc_axis {
          0 {
            MOM_force once Y Z
          }
          1 {
            MOM_force once X Z
          }
          2 {
            MOM_force once X Y
          }
        }
      }

      if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
        LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
      }

      if {[EQ_is_gt $::mom_arc_angle 180.0]} {
        set mom_arc_radius [expr -1.0*$mom_arc_radius]
      }
    } else {
      MOM_suppress once R
    }
  }
}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_clamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {return}

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer CLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template clamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fifth_axis] == 1} {

    LIB_GE_command_buffer CLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template clamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called before each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_unclamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}

  if {[CONF_CTRL_clamp fifth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template unclamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template unclamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called after each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_rotate_axis {} {

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer RAPID_ROTARY
  LIB_GE_command_buffer {MOM_do_template rapid_rotary} @OUTPUT
  LIB_GE_command_buffer_output

  if {[string compare "LIB_rotate_axis_before_plane" [info level -1]]} {
    LIB_CTRL_clamp_axis
  }

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_nc_header {} {

  global mom_attr_PROGRAMVIEW_PROGRAM_NUMBER
  global mom_output_file_basename lib_nc_header_number
  global lib_selected_group_name mom_dnc_program_name
  global mom_lib_program_name lib_flag

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
    if {[LIB_PT_get_header_var lib_selected_group_name exists]} {
      set lib_selected_group_name [LIB_PT_get_header_var lib_selected_group_name]
    } else {
      set lib_selected_group_name [LIB_PT_get_header_var mom_oper_program]
    }
  }
  if {![info exists lib_selected_group_name]} {set lib_selected_group_name ""}
  set lib_nc_header_number $mom_output_file_basename

  switch -- [CONF_CTRL_setting header_name] {
    "mom_attr_PROGRAMVIEW_PROGRAM_NUMBER" {
      if {$lib_flag(load_pretreatment)} {
      if { ![LIB_PT_get_header_var mom_attr_PROGRAMVIEW_PROGRAM_NUMBER exists] } {
        set lib_nc_header_number "0001"
      } else {
        set lib_nc_header_number [LIB_PT_get_header_var mom_attr_PROGRAMVIEW_PROGRAM_NUMBER]
        }
      } else {
        set lib_nc_header_number "0001"
      }
    }
    "output_file_basename" {set lib_nc_header_number $mom_output_file_basename}
    "selected_group" {
      set lib_nc_header_number $lib_selected_group_name
    }
    "ude_dnc_header" {
      if {[info exists mom_dnc_program_name]} {set lib_nc_header_number $mom_dnc_program_name}
    }
    "ude" {
      if {[info exists mom_lib_program_name]} {set lib_nc_header_number $mom_lib_program_name}
    }
    "ignore" {
                  return 0
    }
                "default" {
      LIB_CONF_do_prop_custom_proc CONF_CTRL_setting header_name "short_template_syntax"
    }
  }
  # Variable lib_nc_header_number is empty that means that mom_output_file_basename is used
  # and you are not in PP
  # for this case selected_group is used -- this is not ""

  if {$lib_nc_header_number == ""} {set lib_nc_header_number $lib_selected_group_name}

  if {![LIB_SPF_is_number $lib_nc_header_number]} {
    LIB_SPF_add_warning "The entry 'INS->$lib_nc_header_number<-' for the header with argument 'INS->[CONF_CTRL_setting header_name]<-' need a number as value. 0001 will be used"
    set lib_nc_header_number 0001
  }

  if {[EQ_is_gt $lib_nc_header_number 9999]} {LIB_SPF_add_warning "Header_number 'INS->$lib_nc_header_number<-' should be < 9999: 9999 will be used"}

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_program
      } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_MPF
#   Heidenhain  BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O${lib_nc_header_number}
#
#____________________________________________________________________________________________
proc LIB_CTRL_sub_header {} {

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_subprogram
  } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_SPF
#   Heidenhain    BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O1234
#
#____________________________________________________________________________________________
proc LIB_SPF_pt_additional_variables_fanuc {} {

  #PR9239197 Add mom_lock_axis to pretreatment
  LIB_SPF_pretreatment_add_var MOM_lock_axis mom_lock_axis 0
}
# <Internal Documentation>
#
# Entrypoint to define additional variables which should be stored in pretreatment
# Controller specific
#
# LIB_SPF_pretreatment_add_var in this proc to add return variables from pretreatment
#
# <Internal Example>
# Sample code as comment in proc body
#______________________________________________________________________________
proc LIB_CTRL_set_feed_parameter {} {

  global mom_feed_cut_unit mom_output_unit mom_feed_rate feed
  global mom_cycle_feed_rate mom_cycle_feed_rate_per_rev
  global mom_feed_engage_value mom_feed_cut_value mom_feed_retract_value mom_feed_cycle_value
  global mom_feed_engage_unit mom_feed_cut_unit mom_feed_retract_unit mom_feed_cycle_value
  global mom_operation_type mom_motion_type lib_motion_type_list
  global lib_prev_feed_cut_value lib_flag mom_tool_name mom_kin_is_turbo_output
  global mom_feed_rate_output_mode mom_feed_rate_per_rev
  global lib_prev_feed_engage_value lib_prev_feed_retract_value
  global lib_prev_cycle_definition_mode mom_cycle_definition_mode
  global lib_prev_feed_engage_value lib_prev_feed_retract_value

  set lib_flag(feed_turbo_mode_disable) 0
  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {

    foreach type $lib_motion_type_list {
      set tmp_motion_type [string tolower $type]
      if {[CONF_CTRL_feed exists feed_$tmp_motion_type]} {
        if {[CONF_CTRL_feed feed_$tmp_motion_type] != "NX"} {
          set lib_flag(feed_turbo_mode_disable) 1
          set mom_kin_is_turbo_output "FALSE"
        }
      }
    }
    if {$lib_flag(feed_turbo_mode_disable) == 1} {MOM_reload_kinematics_variable mom_kin_is_turbo_output}

    # check if "drilling" "Thread Milling" "Cylinder Milling" are the previous operation and the current cycle output is different
    # to the previous operation
    if {($mom_operation_type == "Drilling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Thread Milling")} {
      if {![info exists lib_prev_cycle_definition_mode] || $lib_prev_cycle_definition_mode != $mom_cycle_definition_mode } {
        set check_cycle_definition_mode 1
      } else {
        set check_cycle_definition_mode 0
      }
      set lib_prev_cycle_definition_mode $mom_cycle_definition_mode
    } else {
      set check_cycle_definition_mode 0
      set lib_prev_cycle_definition_mode 1
    }
    if {[info level 1] != "MOM_start_of_path" || ($mom_tool_name == [LIB_SPF_get_pretreatment mom_tool_name -1]        && \
      (([info exist lib_prev_feed_cut_value]    && ![EQ_is_equal $mom_feed_cut_value $lib_prev_feed_cut_value])          || \
      ([info exist lib_prev_feed_engage_value]  && ![EQ_is_equal $mom_feed_engage_value $lib_prev_feed_engage_value])    || \
      ([info exist lib_prev_feed_retract_value] && ![EQ_is_equal $mom_feed_retract_value $lib_prev_feed_retract_value])  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Hole Making"                                                  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Point to Point"                                               || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Drilling"))                                                    || \
      $check_cycle_definition_mode == 1} {

      MOM_force once F
      if {[CONF_CTRL_feed feed_engage] != "NX" && [CONF_CTRL_feed feed_engage] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_engage_value/25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_engage_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_engage_value
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_engage_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_engage_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_engage] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Engage Move"])" "output_0" "1"
      }

      if {$mom_operation_type == "Thread Milling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Hole Making" || $mom_operation_type == "Point to Point" || ($mom_operation_type == "Drilling" && $::mom_cycle_definition_mode == 0)} {
        set mom_feed_rate $mom_feed_cut_value
        set mom_cycle_feed_rate $mom_feed_cut_value
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_cut_value
          set mom_cycle_feed_rate_per_rev $mom_feed_cut_value
          set mom_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
          set mom_cycle_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
        set mom_motion_type "CYCLE"
        LIB_SPF_feedrate_set
        if {[CONF_CTRL_feed feed_cycle] != "NX" && [CONF_CTRL_feed feed_cycle] != "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cycle] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cycle Move"])" "output_0" "1"
        } elseif {[CONF_CTRL_feed feed_cycle] == "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cycle Move"])" "output_0" "1"
        }
      } else {
        set mom_kin_is_turbo_output "FALSE"
        if {[CONF_CTRL_feed feed_cut] != "NX" && [CONF_CTRL_feed feed_cut] != "P_CUT"} {
          if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
            set mom_feed_rate [expr $mom_feed_cut_value/25.4]
          } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
            set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
          } else {
            set mom_feed_rate $mom_feed_cut_value
          }
          if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
            set mom_feed_rate_per_rev $mom_feed_cut_value
          }
          set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
          set mom_motion_type "UNKNOWN"
          LIB_SPF_feedrate_set
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cutting"])" "output_0" "1"
        }
      }

      if {[CONF_CTRL_feed feed_retract] != "NX" && [CONF_CTRL_feed feed_retract] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_retract_value/25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_retract_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_retract_value
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_retract_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_retract_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_retract] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Retract Move"])" "output_0" "1"
      }

      set lib_prev_feed_cut_value $mom_feed_cut_value
      set lib_prev_feed_engage_value $mom_feed_engage_value
      set lib_prev_feed_retract_value $mom_feed_retract_value
    }
  }
}
# <Internal Documentation>
#
# Set the feed parameter if nessesary
# only if property feed_linear is set to 2(parameter)
#
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (F[#21])
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_feed_output {} {

  global mom_motion_type mom_motion_event mom_feed_cut_value mom_feed_cut_unit mom_feed_rate mom_feed_rate_per_rev
  global mom_cycle_feed_rate mom_output_unit feed_mode
  global feed lib_prev_feed lib_prev_feed_percent
  global mom_feed_engage_value mom_feed_engage_unit
  global mom_feed_retract_value mom_feed_retract_unit

  set commandcheck(LIB_CTRL_feed_output_ENTRY) [llength [info commands LIB_CTRL_feed_output_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {
    set tmp_motion_type [string tolower $mom_motion_type]

    if {[CONF_CTRL_feed feed_$tmp_motion_type] == "NX"} {
      if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
        MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
      } else {
        switch -- $feed_mode {
          IPM     -
          MMPM    -
          IPR     -
          MMPR    -
          DPM     -
          FRN     {
            MOM_set_address_format F Feed_${feed_mode}
            }
          INVERSE {MOM_set_address_format F Feed_INV}
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "P_CUT"} {
      if {(![string match "rapid" $tmp_motion_type] && ![string match "traverse" $tmp_motion_type] && ![string match "approach" $tmp_motion_type] \
      && ![string match "departure" $tmp_motion_type]) || $mom_feed_rate != $::mom_kin_rapid_feed_rate} {
      MOM_set_address_format F String
      if {![info exist lib_prev_feed] || (![EQ_is_equal $feed $mom_feed_cut_value] && $feed != $lib_prev_feed)} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
          set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
          set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
          if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
            MOM_force once F
          }
          set feed "\[[CONF_CTRL_feed feed_cut]*$tmp_feed_percent\]"
          set lib_prev_feed_percent $tmp_feed_percent
        } else {
          set feed "\[[CONF_CTRL_feed feed_cut]\]"
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "MAX"} {
      MOM_set_address_format F String
      set feed [CONF_CTRL_feed feed_$tmp_motion_type]
    } else {
      MOM_set_address_format F String
      set tmp_feed $feed
      if {$tmp_motion_type == "cycle"} {
        set mom_cycle_feed_rate "\[[CONF_CTRL_feed feed_$tmp_motion_type]\]"
      }
      set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]\]"
      if {$tmp_motion_type == "cut" && ![EQ_is_equal $mom_feed_rate $mom_feed_cut_value]} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      if {$tmp_motion_type == "engage" && ![EQ_is_equal $mom_feed_rate $mom_feed_engage_value]} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_engage_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      if {$tmp_motion_type == "retract" && ![EQ_is_equal $mom_feed_rate $mom_feed_retract_value]} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_retract_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      set lib_prev_feed $tmp_feed
    }

  } else {
    # use only NX-Values
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Output the feed dependent on the setting
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (FQ21)
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_cut_move_LIB {} {

  set commandcheck(LIB_CTRL_cut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_LIB {} {

  set commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY) [llength [info commands LIB_CTRL_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_engage_move_LIB {} {

  set commandcheck(LIB_CTRL_engage_move_LIB_ENTRY) [llength [info commands LIB_CTRL_engage_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_retract_move_LIB {} {

  set commandcheck(LIB_CTRL_retract_move_LIB_ENTRY) [llength [info commands LIB_CTRL_retract_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_firstcut_move_LIB {} {

  set commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_firstcut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_approach_move_LIB {} {

  set commandcheck(LIB_CTRL_approach_move_LIB_ENTRY) [llength [info commands LIB_CTRL_approach_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_stepover_move_LIB {} {

  set commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY) [llength [info commands LIB_CTRL_stepover_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_departure_move_LIB {} {

  set commandcheck(LIB_CTRL_departure_move_LIB_ENTRY) [llength [info commands LIB_CTRL_departure_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_return_move_LIB {} {

  set commandcheck(LIB_CTRL_return_move_LIB_ENTRY) [llength [info commands LIB_CTRL_return_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_traversal_move_LIB {} {

  set commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY) [llength [info commands LIB_CTRL_traversal_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sidecut_move_LIB {} {

  set commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_sidecut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_from_move_LIB {} {

  set commandcheck(LIB_CTRL_from_move_LIB_ENTRY) [llength [info commands LIB_CTRL_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_default_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_default_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_move_LIB {} {

  set commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cycle_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_lift_move_LIB {} {

  set commandcheck(LIB_CTRL_lift_move_LIB_ENTRY) [llength [info commands LIB_CTRL_lift_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_undefined_move_LIB {} {

  set commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY) [llength [info commands LIB_CTRL_undefined_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_standard_path_between_rotary_motions_checking {{option default}} {

  global mom_out_angle_pos mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global prev_convert_mom_out_angle_pos mom_prev_pos mom_pos

  switch -- $option {
    "pos_to_sim"  {
      # motion POS to SIM

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_prev_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_prev_pos(3) 0
      }

      MOM_reload_variable -a mom_prev_pos

    }
    "pos_to_sim_next" {
      # motion POS to SIM

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_pos(3) 0
      }

      MOM_reload_variable -a mom_pos

    }
    "sim_to_pos" {
      # motion SIM to POS
    }
  }
}
# <Internal Documentation>
#
# Used when [CONF_CTRL_moves standard_path_between_rotary_motions] == 1 for internal tool path
# Set right rotary position when lib_flag(mode_current_status) changes
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_config_millturn {} {

  if {[CONF_SPF_advanced_settings chain_init] != "0"} {
    LIB_CONF_do_prop_custom_proc CONF_SPF_advanced_settings chain_init
    LIB_GE_copy_var_range lib_sav_sys_leader mom_sys_leader
  }
}
# <Internal Documentation>
# This procedure is called at each start_of_path and machine_mode events.
# It's implemented for multi chains. Content of [CONF_SPF_advanced_settings chain_init] is executed
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_version_mom_sys {} {
  global mom_sys_feed_rate_mode_code mom_sys_spindle_max_rpm_code mom_sys_output_code mom_sys_cycle_ret_code
  global mom_sys_lathe_thread_advance_type mom_sys_lathe_multiple_thread_cycle

  switch -- [CONF_FANUC_controller fanuc_control_system] {
    "System_A" {
      set mom_sys_lathe_thread_advance_type(1) 32
      set mom_sys_feed_rate_mode_code(MMPM) 98
      set mom_sys_feed_rate_mode_code(IPM) 98
      set mom_sys_feed_rate_mode_code(MMPR) 99
      set mom_sys_feed_rate_mode_code(IPR) 99
      set mom_sys_spindle_max_rpm_code 50
      set mom_sys_lathe_multiple_thread_cycle 76
      MOM_disable_address G_mode
      catch {unset mom_sys_cycle_ret_code(AUTO)}
      catch {unset mom_sys_cycle_ret_code(MANUAL)}
    }
    "System_B" {
      set mom_sys_lathe_thread_advance_type(1) 33
      set mom_sys_feed_rate_mode_code(MMPM) 94
      set mom_sys_feed_rate_mode_code(IPM) 94
      set mom_sys_feed_rate_mode_code(MMPR) 95
      set mom_sys_feed_rate_mode_code(IPR) 95
      set mom_sys_spindle_max_rpm_code 92
      set mom_sys_lathe_multiple_thread_cycle 76
    }
    "System_C" {
      set mom_sys_lathe_thread_advance_type(1) 33
      set mom_sys_feed_rate_mode_code(MMPM) 94
      set mom_sys_feed_rate_mode_code(IPM) 94
      set mom_sys_feed_rate_mode_code(MMPR) 95
      set mom_sys_feed_rate_mode_code(IPR) 95
      set mom_sys_spindle_max_rpm_code 92
      set mom_sys_lathe_multiple_thread_cycle 78
    }
  }
}
# <Internal Documentation>
# It used to update mom_sys variables depending on [CONF_FANUC_controller fanuc_control_system] property
# This proc is called by LIB_SPF_default_initial_setting "default"
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_polar_transmit {{mess "on"}} {
  global mom_motion_event mom_motion_type mom_prev_pos mom_pos mom_machine_mode
  global mom_sys_leader mom_sys_rapid_code
  global polar_mode_status lib_flag

  if {$mom_machine_mode == "TURN" || [string match "point*" [LIB_SPF_ask_operation_type]] || [string match "probe*" [LIB_SPF_ask_operation_type]]} {return}

  if {[CONF_CTRL_moves polar_transmit] == "ON"} {
    if {$mess == "on"} {
      if {$lib_flag(first_transmit_move) == 0} {
        set polar_mode_status "ON"
        set lib_flag(first_transmit_move) 1 ;# first motion is not recalculated in polar mode anymore
      }
    } elseif {$mess == "start" && [info exists polar_mode_status] && $polar_mode_status == "ON"} {
      LIB_GE_command_buffer POLAR_MODE
      LIB_GE_command_buffer {
        set mom_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        set mom_prev_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        MOM_reload_variable -a mom_prev_pos
        MOM_reload_variable -a mom_pos

        if {[CONF_CTRL_moves prepos_before_transmit] == "5th" || [CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
          if {$lib_flag(polar_rotary_axis) == 0} {
            set lib_flag(save_clamp_fourth_axis_setting) [CONF_CTRL_clamp fourth_axis]
            if {[CONF_CTRL_clamp fourth_axis] == 1} {
              MOM_do_template unclamp_fourth_axis
              MOM_do_template fourth_axis_rotate_move
              CONF_CTRL_clamp set fourth_axis 0
            } else {
              MOM_do_template fourth_axis_rotate_move
            }
          } else {
            set lib_flag(save_clamp_fifth_axis_setting) [CONF_CTRL_clamp fifth_axis]
            if {[CONF_CTRL_clamp fifth_axis] == 1} {
              MOM_do_template unclamp_fifth_axis
              MOM_do_template fifth_axis_rotate_move
              CONF_CTRL_clamp set fifth_axis 0
            } else {
              MOM_do_template fifth_axis_rotate_move
            }
          }
          if {[CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
            LIB_SPF_decompose_block_template "{Z} {X}" prepos_transmit FORCE [join "{Z} {X}"]
          }
        } elseif {[CONF_CTRL_moves prepos_before_transmit] != ""} {
          LIB_CONF_do_prop_custom_proc CONF_CTRL_moves prepos_before_transmit "short_template_syntax"
        }

        set mom_sys_leader(Y) "C"
        if {$mom_motion_event == "rapid_move"} {set mom_motion_event "linear_move"}

        set lib_flag(save_rapid_template)  [CONF_CTRL_moves rapid_template]
        CONF_CTRL_moves set rapid_template [CONF_CTRL_moves linear_template]
        set mom_sys_rapid_code 1 ;# advanced turbo mode
      } @OUTPUT_ROTARY_AXIS

      LIB_GE_command_buffer {
        MOM_do_template polar_mode
      } @OUTPUT
      LIB_GE_command_buffer_output

      set lib_flag(first_transmit_move) 1
      if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_enable_address Y}
    }
  }

  if {$mess == "off" && [info exists lib_flag(first_transmit_move)] && $lib_flag(first_transmit_move) == 1} {
    set polar_mode_status "OFF"

    LIB_GE_command_buffer TRAFOFF
    LIB_GE_command_buffer {
      MOM_do_template polar_mode

      set mom_sys_leader(Y) "Y"
      if {$lib_flag(polar_rotary_axis) == 0} {
        MOM_force once fourth_axis
        if {[info exists lib_flag(save_clamp_fourth_axis_setting)]} {CONF_CTRL_clamp set fourth_axis $lib_flag(save_clamp_fourth_axis_setting)}
      } else {
        MOM_force once fifth_axis
        if {[info exists lib_flag(save_clamp_fifth_axis_setting)]} {CONF_CTRL_clamp set fifth_axis $lib_flag(save_clamp_fifth_axis_setting)}
      }
      #PR9261330 check if exists lib_flag(save_rapid_template)
      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        set mom_sys_rapid_code 0 ;# advanced turbo mode
        unset lib_flag(save_rapid_template)
      }
    } @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(first_transmit_move) 0
    if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_disable_address Y}
  }
}
# <Internal Documentation>
# It's used to output polar code with axial mode when [CONF_CTRL_moves polar_transmit] property is set to 1
# This proc is called by LIB_SPF_polar_cart
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread_LIB {} {

  set commandcheck(MOM_lathe_thread_LIB_ENTRY) [llength [info commands MOM_lathe_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_thread_LIB {} {

  global mom_path_name mom_sys_lathe_multiple_thread_cycle

  set commandcheck(MOM_start_of_thread_LIB_ENTRY) [llength [info commands MOM_start_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_turn thread_cycle] == "G76/G78"} {
    LIB_GE_abort_message "INS->$mom_path_name<- : G${mom_sys_lathe_multiple_thread_cycle} Thread Cycle is required by the Post, option 'Machine Cycle From Post' should be set." "Please Check Operation setting."
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_lathe_thread_move_LIB {} {

  global mom_prev_pos mom_pos mom_lathe_thread_lead_i mom_lathe_thread_lead_k
  global thread_type

  set commandcheck(MOM_lathe_thread_move_LIB_ENTRY) [llength [info commands MOM_lathe_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  switch [CONF_CTRL_turn thread_cycle] {
    "G32/G33" {
      if { [EQ_is_zero $mom_lathe_thread_lead_i] } {
        MOM_suppress once I ; MOM_force once K
      } elseif { [EQ_is_zero $mom_lathe_thread_lead_k] } {
        MOM_suppress once K ; MOM_force once I
      } else {
        MOM_force once I ; MOM_force once K
      }

      LIB_GE_command_buffer OUTPUT
      LIB_GE_command_buffer { MOM_do_template lathe_thread_move } @MOVE
      LIB_GE_command_buffer_output

    }
    "G92" {
      MOM_do_template cycle_thread
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_thread_LIB {} {

  set commandcheck(MOM_end_of_thread_LIB_ENTRY) [llength [info commands MOM_end_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_channel_init {} {

  LIB_GE_command_buffer LIB_CTRL_channel_init
  LIB_GE_command_buffer {MOM_do_template channel_init CREATE} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_program event
#
# Specially useful for multichannels machine to reset addresses at the beginning of for each channel
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sys_leader_home {} {
  #this proc is only here for documentation purposes.
  #the real proc should be created in service layer
}
# <Internal Documentation>
# This function is called from MOM_start_of_path event
#
# Helpful to redefine mom_sys_leader variables overwritten by the original ones with the normal run
# This procedure should be redefined in service layer
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_subop_path_LIB {} {

  set commandcheck(MOM_start_of_subop_path_LIB_ENTRY) [llength [info commands MOM_start_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag mom_move_type mom_tool_adjust_register cur_tool_adjust_register
  global mom_interop_has_tool_change


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_subop_path_LIB {} {

  set commandcheck(MOM_end_of_subop_path_LIB_ENTRY) [llength [info commands MOM_end_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_transition_path_LIB {} {

  set commandcheck(MOM_start_of_transition_path_LIB_ENTRY) [llength [info commands MOM_start_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag mom_path_name lib_pretreatment tcpm_type
  global mom_interop_has_tool_change mom_interop_has_tool_change_container
  global mom_interop_has_tool_change_position

  set lib_flag(tool_path_motion) 0
  set lib_flag(tcpm_mode) 0
  set lib_flag(tool_change) 0
  set lib_flag(is_first_rotary_point) 0

  # Consider three cases if subop list contains tool change event
  # case1: have tool change event with a given tool change point, skip the first subop rotary_point_vector_move.
  # case2: have tool change event without tool change point, regard the first subop rotary_point_vector_move as default.
  # case3: no defined tool change event, trigger a tool change mom event before subop rotary_point_vector_move.




  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_transition_path_LIB {} {

  set commandcheck(MOM_end_of_transition_path_LIB_ENTRY) [llength [info commands MOM_end_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_transition_rapid_move_LIB {} {

  set commandcheck(MOM_transition_rapid_move_LIB_ENTRY) [llength [info commands MOM_transition_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_transition_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_LIB_ENTRY)} {MOM_transition_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_inter_opr_rule_intent
  global mom_move_axis_rtcp_mode
  global mom_move_output_x
  global mom_out_angle_pos


  # Set output axis
  set output_status 0
  foreach axis {x y z a b c} {
    if {[set ::mom_move_output_$axis] == 0} {
      MOM_suppress Once [string toupper $axis]_AXIS
    } else {
      set output_status 1
    }
  }

  if {[info exists ::mom_fixture_offset_value]} {
    LIB_main_origin_call
  }

  # Output rapid motion
  if {$output_status == 1 } {
    LIB_GE_command_buffer TRANSITION_RAPID_MOVE
    LIB_GE_command_buffer {
          if {$::lib_ge_transition_rtcp_mode == 1 && $::lib_flag(transition_rtcp_output) ==0} {
                set ::tcpm_type 1
            MOM_do_template set_tcpm_on
            set ::lib_flag(transition_rtcp_output) 1
          }
     } @SET_RTCP
          LIB_GE_command_buffer { } @SET_CSYS
    LIB_GE_command_buffer {MOM_do_template transition_rapid_move} @TRANSITION_RAPID_MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_transition_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_LIB_ENTRY)} {MOM_transition_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_transition_rapid_move.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_machine_axis_move_LIB {} {

  set commandcheck(MOM_machine_axis_move_LIB_ENTRY) [llength [info commands MOM_machine_axis_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_xaxis_status mom_yaxis_status mom_zaxis_status
  global mom_aaxis_status mom_baxis_status mom_caxis_status
  global mom_xaxis_value mom_yaxis_value  mom_zaxis_value
  global mom_aaxis_value mom_baxis_value  mom_caxis_value

  if {$mom_xaxis_status == 0} {
    #MOM_suppress once X
  }
  if {$mom_yaxis_status == 0} {
    #MOM_suppress once Y
  }
  if {$mom_zaxis_status == 0} {
    #MOM_suppress once Z
  }
  if {$mom_aaxis_status == 0} {
    MOM_suppress once machine_axis_a
  }
  if {$mom_baxis_status == 0} {
    MOM_suppress once machine_axis_b
  }
  if {$mom_caxis_status == 0} {
    MOM_suppress once machine_axis_c
  }

  LIB_GE_command_buffer MACHINE_AXIS_INIT
  LIB_GE_command_buffer {
    MOM_force once G_return
    MOM_do_template machine_axis_move
  } @MACHINE_AXIS
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_machine_axis_move.
# mom_xaxis_status 1 - have a user defined axis value: machine limit or specify
#                  0 - not active
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_set_tcpm_mode {{option "ON"}} {

  global lib_flag lib_kin_4th_axis_point lib_kin_5th_axis_point
  global mom_kin_4th_axis_point mom_kin_5th_axis_point

  if {$option == "ON"} {
    LIB_GE_command_buffer INTEROP_TCPM_INIT
    LIB_GE_command_buffer {
      MOM_do_template tool_length_adjust CREATE
      MOM_force once H
    } @INTEROP_TOOL_LENGTH_ADJUST
    LIB_GE_command_buffer {
      MOM_set_address_format G_csys_rot Zero_real
      MOM_do_template set_tcpm_on
      MOM_set_address_format G_csys_rot Digit_2
    } @INTEROP_ROTARY_SIMULTANEOUS
    LIB_GE_command_buffer_output

    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_mode] == "G43.5" ||\
    ([CONF_CTRL_setting tcpm_mode] == "G43.4" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    if {[info exists lib_kin_4th_axis_point]} {
      array set mom_kin_4th_axis_point "0 $lib_kin_4th_axis_point(0) 1 $lib_kin_4th_axis_point(1) 2 $lib_kin_4th_axis_point(2)"
      array set mom_kin_5th_axis_point "0 $lib_kin_5th_axis_point(0) 1 $lib_kin_5th_axis_point(1) 2 $lib_kin_5th_axis_point(2)"
      # Update mom_kin_4th/5th_axis_point in core code
      MOM_reload_kinematics_variable mom_kin_4th_axis_point mom_kin_5th_axis_point
    }

    set lib_flag(tcpm_mode) 1
  } else {
    if {[CONF_CTRL_setting tcpm_mode] == "G43.4"} {
      LIB_GE_command_buffer INTEROP_RESET_G434
      LIB_GE_command_buffer {
        MOM_force once G_csys_rot
        MOM_do_template set_tcpm_off
      } @INTEROP_TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @INTEROP_ADJUST_OFF
      LIB_GE_command_buffer_output
    } elseif {[CONF_CTRL_setting tcpm_mode] == "G43.5"} {
      LIB_GE_command_buffer INTEROP_RESET_G435
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @INTEROP_TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @INTEROP_ADJUST_OFF
      LIB_GE_command_buffer_output
    }

    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_mode] == "G43.5" ||\
      ([CONF_CTRL_setting tcpm_mode] == "G43.4" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos
    }

    set lib_flag(tcpm_mode) 0
  }
}
# <Internal Documentation>
# This function is used to set tcpm mode status (ON/OFF) in transition path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_set_G68_rotate_dir {} {

  global mom_kin_machine_type mom_sys_leader
  global mom_init_pos mom_init_alt_pos mom_pos mom_alt_pos mom_out_angle_pos mom_prev_out_angle_pos
  global mom_kin_4th_axis_direction mom_kin_4th_axis_leader mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_kin_5th_axis_direction mom_kin_5th_axis_leader mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_operation_is_interop plane_init_pos lib_sav_kin_4th_axis_leader lib_sav_kin_5th_axis_leader
    global lib_flag

  set mom_sys_leader(fourth_axis) $lib_sav_kin_4th_axis_leader
  set mom_sys_leader(fifth_axis) $lib_sav_kin_5th_axis_leader

  # for simultaneous operation, if enabling prepositioning tool, forbid fourth and fifth axis rotation direction setting
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    return
  }

  # Don't reselect solution if transition path exists
  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
    return
  }
  set rotate_dir [CONF_FANUC_G68 rotate_dir]
  if {[info exists lib_flag(preferred_solution)] && $lib_flag(preferred_solution) != "OFF"} {
    if {[CONF_FANUC_G68 rotate_dir] == "-" || [CONF_FANUC_G68 rotate_dir] == "+"} {
      LIB_SPF_add_warning "Set Preferred Solution is using, G68/G68.1/G68/2 DIR set to Auto"
      set rotate_dir 0
    }
  }

  if {[LIB_SPF_csys_examine_local] == "rotation"} {
    if {![string compare "5_axis_dual_head" $mom_kin_machine_type]} {
      set master_axis 4
    } else {
      set master_axis 3
    }
    if {$lib_flag(local_namespace_output) == 1} {
      set mom_init_pos(3) 0
      set mom_init_pos(4) 0
    } else {
      set plane_init_pos(3) [LIB_SPF_rotset $plane_init_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
                            $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
                            $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

      set plane_init_pos(4) [LIB_SPF_rotset $plane_init_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
                            $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
                            $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]

      if {($rotate_dir == "-" && [EQ_is_gt $plane_init_pos($master_axis) 0.0]) || \
        ($rotate_dir == "+" && [EQ_is_lt $plane_init_pos($master_axis) 0.0])} {

        set mom_init_pos(3) [LIB_SPF_rotset $mom_init_alt_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
                          $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
                          $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

        set mom_init_pos(4) [LIB_SPF_rotset $mom_init_alt_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
                          $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
                          $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]
      } else {
        # If user defines a local coordinate system, $mom_init_pos won't be zero and may excess angle limit.
          set mom_init_pos(3) [LIB_SPF_rotset $mom_init_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
                            $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
                            $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

          set mom_init_pos(4) [LIB_SPF_rotset $mom_init_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
                            $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
                            $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]
      }
    }

  } else {
    if {![string compare "5_axis_dual_head" $mom_kin_machine_type]} {
      set master_axis 1
    } else {
      set master_axis 0
    }
    if {($rotate_dir == "-" && [EQ_is_gt $mom_out_angle_pos($master_axis) 0.0]) || \
      ($rotate_dir == "+" && [EQ_is_lt $mom_out_angle_pos($master_axis) 0.0])} {

      set mom_out_angle_pos(0) [LIB_SPF_rotset $mom_alt_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
                          $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
                          $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

      set mom_out_angle_pos(1) [LIB_SPF_rotset $mom_alt_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
                          $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
                          $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]

      if {$lib_flag(local_namespace_output) == 1} {
        VMOV 5 mom_pos tmp_pos
        VMOV 5 mom_alt_pos mom_pos
        VMOV 5 tmp_pos mom_alt_pos
        MOM_reload_variable -a mom_pos
        MOM_reload_variable -a mom_alt_pos
      }
    }
  }

}
# <Internal Documentation>
# This function is used to set fourth and fifth axis angles output value according to user option.
# It is called from LIB_ROTARY_positioning_init.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_abs_move_table { } {
  global lib_parameter lib_flag mom_pos mom_prev_pos mom_sys_leader mom_sys_trailer mom_out_angle_pos

  set tmp_sys_leader_restore($lib_parameter(abs_move,axis)) $mom_sys_leader($lib_parameter(abs_move,axis))
  set tmp_sys_trailer_restore($lib_parameter(abs_move,axis)) $mom_sys_trailer($lib_parameter(abs_move,axis))

  LIB_GE_command_buffer AXIS_FOR_5TH_AXIS_MOVE
  LIB_GE_command_buffer {
    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "real"
    }

    set tmp_sys_leader_real($lib_parameter(abs_move,axis)) $mom_sys_leader($lib_parameter(abs_move,axis))
    set tmp_sys_trailer_real($lib_parameter(abs_move,axis)) $mom_sys_trailer($lib_parameter(abs_move,axis))
    VMOV 2 mom_out_angle_pos save_out_angle_pos

    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "reload"
    }
    set mom_out_angle_pos($lib_parameter(abs_move,angle_pos)) $save_out_angle_pos($lib_parameter(abs_move,angle_pos))

    if {($lib_parameter(abs_move,axis) == "fourth_axis" && $::mom_sys_4th_axis_has_limits == 0) || ($lib_parameter(abs_move,axis) == "fifth_axis" && $::mom_sys_5th_axis_has_limits == 0)} {
      set mom_sys_leader($lib_parameter(abs_move,axis)) $tmp_sys_leader_real($lib_parameter(abs_move,axis))
#     set mom_sys_leader($lib_parameter(abs_move,axis)) "[lindex [split "$tmp_sys_leader_real($lib_parameter(abs_move,axis))" "="] 0]=DC("
#     set mom_sys_trailer($lib_parameter(abs_move,axis)) ")"
    } else {
      set mom_sys_leader($lib_parameter(abs_move,axis)) $tmp_sys_leader_real($lib_parameter(abs_move,axis))
    }
  } @CalcAngle

  LIB_GE_command_buffer {
    MOM_enable_address $lib_parameter(abs_move,axis)
    if {[EQ_is_equal $::mom_prev_pos(0) $mom_pos(0)]} {MOM_suppress once X}
    if {[EQ_is_equal $::mom_prev_pos(1) $mom_pos(1)]} {MOM_suppress once Y}
    if {[EQ_is_equal $::mom_prev_pos(2) $mom_pos(2)]} {MOM_suppress once Z}
    MOM_do_template rapid_move
    MOM_do_template rapid_move CREATE
    MOM_disable_address $lib_parameter(abs_move,axis)
  } @AbsMoveMCS

  LIB_GE_command_buffer_output

  set $mom_sys_leader($lib_parameter(abs_move,axis)) $tmp_sys_leader_restore($lib_parameter(abs_move,axis))
  set $mom_sys_trailer($lib_parameter(abs_move,axis)) $tmp_sys_trailer_restore($lib_parameter(abs_move,axis))

}
# <Internal Documentation>
#
#
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_g76_cycle {} {
  global mom_nxt_motion_event mom_je_thread_cycle mom_tool_left_angle mom_number_of_chases
  global mom_total_depth mom_total_depth_percentage_minimum mom_total_depth_percentage_maximum
  global mom_machine_control_use_machine_cycle mom_lathe_thread_lead mom_turn_thread_pitch_lead
  global cycle_thread_P cycle_thread_P cycle_thread_Q cycle_thread_R cycle_thread_U cycle_thread_W
  global cycle_multiple_pos cycle_multiple_prev_pos lib_flag RAD2DEG

# m: Repetitive count in finishing (1 to 99)
  set cycle_finish_passes $mom_number_of_chases
  if {$cycle_finish_passes == 0} {set cycle_finish_passes 1}

# r: Chamfering amount (0 to 99)
  set cycle_chamfering_amount 0 ;#default

# a: Angle of tool nose
  set angle_tool_nose [format %.0f [expr $mom_tool_left_angle*$RAD2DEG]]

# m+r+a:
  set cycle_thread_P(1) [expr ($cycle_finish_passes * 10000) + ($cycle_chamfering_amount * 100) + $angle_tool_nose]

# dmin: Minimum cutting depth
  set cycle_thread_Q(1) [format %.0f [expr $mom_total_depth_percentage_minimum * 1000]]

# d: Finishing allowance
  set cycle_thread_R(1) 99

# X: Coordinate of the end point
  # cycle_multiple_prev_pos(0)

# U: Travel distance to the cutting end point
  if {[info exists cycle_thread_U]} {unset cycle_thread_U}

  if {![info exists mom_machine_control_use_machine_cycle] || $mom_machine_control_use_machine_cycle == 0} {
    if {![EQ_is_equal $cycle_multiple_pos(0) $cycle_multiple_prev_pos(0)]} {
      set cycle_thread_U [expr $cycle_multiple_pos(0) - $cycle_multiple_prev_pos(0)]
    }
  }

# Z: Coordinate of the end point
  # cycle_multiple_prev_pos(2)

# W: Travel distance to the cutting end point
  if {[info exists cycle_thread_W]} {unset cycle_thread_W}
  if {![info exists mom_machine_control_use_machine_cycle] || $mom_machine_control_use_machine_cycle == 0} {
    if {[info exists cycle_thread_U]} {
      set cycle_thread_W [expr $cycle_multiple_pos(2) - $cycle_multiple_prev_pos(2)]
    }
  }

# i: Taper amount
  set cycle_thread_R(2) 0

# k: Height of thread
  set cycle_thread_P(2) [format %.0f [expr $mom_total_depth * 1000]]

# d2: Depth of cut in 1st cut
  set cycle_thread_Q(2) [format %.0f [expr $mom_total_depth_percentage_maximum * 1000]]

# L: Lead of thread
  # mom_lathe_thread_lead
  if {[info exists mom_machine_control_use_machine_cycle] && $mom_machine_control_use_machine_cycle == 1} {
    set mom_lathe_thread_lead $mom_turn_thread_pitch_lead
  }

  MOM_do_template cycle_multiple_thread1

  MOM_force once G_motion
  MOM_do_template cycle_multiple_thread2

  set lib_flag(lathe_thread_motion) 0

}
# <Internal Documentation>
#
# G76 P020060 Q500 R500
# G76 X21.098 Z-55. R0.0 P1840 Q010 F3.

# G76 P(m)(r)(a) Q(dmin) R(d)
# G76 X(U)_ Z(W)_ R(i) P(k) Q(d2) F(L)
# m: Repetitive count in finishing (1 to 99)
# r: Chamfering amount (0 to 99)
# a: Angle of tool nose
# dmin: Minimum cutting depth
# d: Finishing allowance
# X,Z: Coordinate of the end point
# U,W: Travel distance to the cutting end point
# i: Taper amount
# k: Height of thread
# d2: Depth of cut in 1st cut
# L: Lead of thread
#
#____________________________________________________________________________________________

# oem_ootb_5ax_fanuc.tcl

proc OOTB_program_header {} {
#-------------------------------------------------------------
   global program_header_output

   if [info exists program_header_output] { return }

   set program_header_output 0

   LIB_GE_command_buffer OOTB_OEM_program_header
   LIB_GE_command_buffer {
      MOM_set_seq_off
      MOM_output_literal "%"} @rewind_output
   LIB_GE_command_buffer_output

}
proc OOTB_reset_rotary_to_zero {} {
#-------------------------------------------------------------
   LIB_SPF_reset_motions_to_zero "rot"
}

# template_service_fanuc.tcl

proc postcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "9999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         "N"
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "0"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "0"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "10000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0.0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "12.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}

# ctrl_heidenhain_base.tcl

proc LIB_SPF_set_initial_globals_LIB {} {

  uplevel #0 {

    set mom_system_tolerance                      0.0000001
    set mom_sys_control_out                       "; "
    set mom_sys_control_in                        ""

    ########## SYSTEM VARIABLE DECLARATIONS ##############
    set mom_sys_rapid_code                        "L"
    set mom_sys_linear_code                       "L"
    set mom_sys_circle_code(CLW)                  "DR-"
    set mom_sys_circle_code(CCLW)                 "DR+"
    set mom_sys_delay_code(SECONDS)               "4"
    set mom_sys_delay_code(REVOLUTIONS)           "4"
    set mom_sys_cutcom_plane_code(XY)             "17"
    set mom_sys_cutcom_plane_code(ZX)             "18"
    set mom_sys_cutcom_plane_code(XZ)             "18"
    set mom_sys_cutcom_plane_code(YZ)             "19"
    set mom_sys_cutcom_plane_code(ZY)             "19"
    set mom_sys_cutcom_code(OFF)                  "R0"
    set mom_sys_cutcom_code(LEFT)                 "RL"
    set mom_sys_cutcom_code(RIGHT)                "RR"
    set mom_sys_adjust_code                       "43"
    set mom_sys_adjust_code_minus                 "44"
    set mom_sys_adjust_cancel_code                "49"
    set mom_sys_unit_code(IN)                     "70"
    set mom_sys_unit_code(MM)                     "71"
    set mom_sys_output_code(ABSOLUTE)             "90"
    set mom_sys_output_code(INCREMENTAL)          "91"
    set mom_sys_cycle_ret_code(AUTO)              "98"
    set mom_sys_cycle_ret_code(MANUAL)            "99"
    set mom_sys_reset_code                        "92"
    set mom_sys_feed_rate_mode_code(FRN)          "93"
    set mom_sys_spindle_mode_code(SFM)            "96"
    set mom_sys_spindle_mode_code(RPM)            "97"
    set mom_sys_return_code                       "28"
    set mom_sys_feed_rate_mode_code(DPM)          "137"
    set mom_sys_feed_rate_mode_code(IPM)          "137"
    set mom_sys_feed_rate_mode_code(IPR)          "136"
    set mom_sys_feed_rate_mode_code(MMPM)         "137"
    set mom_sys_feed_rate_mode_code(MMPR)         "136"
    set mom_sys_program_stop_code                 "0"
    set mom_sys_optional_stop_code                "1"
    set mom_sys_end_of_program_code               "2"
    set mom_sys_start_of_subprogram               "BEGIN PGM"
    set mom_sys_end_of_subprogram                 "END PGM"
    set mom_sys_spindle_direction_code(CLW)       "3"
    set mom_sys_spindle_direction_code(CCLW)      "4"
    set mom_sys_spindle_direction_code(OFF)       "5"
    set mom_sys_spindle_orient_code               "19"
    set mom_sys_tool_change_code                  "6"
    set mom_sys_coolant_code(ON)                  "8"
    set mom_sys_coolant_code(FLOOD)               "8"
    set mom_sys_coolant_code(MIST)                "7"
    set mom_sys_coolant_code(THRU)                "26"
    set mom_sys_coolant_code(TAP)                 "8"
    set mom_sys_coolant_code(AIR)         "7"
    set mom_sys_coolant_code(AIRTHRU)             "26"
    set mom_sys_coolant_code(OFF)                 "9"
    set mom_sys_rewind_code                       "30"
    set mom_sys_unclamp_code_fourth               "10"
    set mom_sys_clamp_code_fourth                 "11"
    set mom_sys_unclamp_code_fifth                "50"
    set mom_sys_clamp_code_fifth                  "51"
    set mom_sys_4th_axis_has_limits               "1"
    set mom_sys_5th_axis_has_limits               "1"
    set mom_sys_sim_cycle_drill                   "0"
    set mom_sys_sim_cycle_drill_dwell             "0"
    set mom_sys_sim_cycle_drill_deep              "0"
    set mom_sys_sim_cycle_drill_break_chip        "0"
    set mom_sys_sim_cycle_tap                     "0"
    set mom_sys_sim_cycle_bore                    "0"
    set mom_sys_sim_cycle_bore_drag               "0"
    set mom_sys_sim_cycle_bore_nodrag             "0"
    set mom_sys_sim_cycle_bore_manual             "0"
    set mom_sys_sim_cycle_bore_dwell              "0"
    set mom_sys_sim_cycle_bore_manual_dwell       "0"
    set mom_sys_sim_cycle_bore_back               "0"
    set mom_sys_cir_vector                        "Vector - Absolute Arc Center"
    set mom_sys_helix_pitch_type                  "rise_revolution"
    set mom_sys_spindle_ranges                    "0"
    set mom_sys_rewind_stop_code                  "\#"
    set mom_sys_zero                              "0"
    set mom_sys_opskip_block_leader               "/"
    set mom_sys_seqnum_start                      "10"
    set mom_sys_seqnum_incr                       "10"
    set mom_sys_seqnum_freq                       "1"
    set mom_sys_seqnum_max                        "999999"
    set mom_sys_lathe_x_double                    "1"
    set mom_sys_lathe_i_double                    "1"
    set mom_sys_lathe_y_double                    "1"
    set mom_sys_lathe_j_double                    "1"
    set mom_sys_lathe_x_factor                    "1"
    set mom_sys_lathe_y_factor                    "1"
    set mom_sys_lathe_z_factor                    "1"
    set mom_sys_lathe_i_factor                    "1"
    set mom_sys_lathe_j_factor                    "1"
    set mom_sys_lathe_k_factor                    "1"
    set mom_sys_leader(N)                         ""
    set mom_sys_leader(M)           "M"
    set mom_sys_leader(G)           ""
    set mom_sys_leader(X)                         "X"
    set mom_sys_leader(Y)                         "Y"
    set mom_sys_leader(Z)                         "Z"
    set mom_sys_leader(fourth_axis)               "A"
    set mom_sys_leader(fifth_axis)                "B"
    set mom_sys_leader(sixth_axis)                "C"
    set mom_sys_trailer(M)            ""
    set mom_sys_trailer(G)            ""
    set mom_sys_trailer(X)                        ""
    set mom_sys_trailer(Y)                        ""
    set mom_sys_trailer(Z)                        ""
    set mom_sys_trailer(fourth_axis)              ""
    set mom_sys_trailer(fifth_axis)               ""
    set mom_sys_trailer(sixth_axis)               ""
    if {[info exists pc_initial_library_release_of_post] && $pc_initial_library_release_of_post > 50306} {
      set mom_sys_contour_feed_mode(LINEAR)         "AUTO"
      set mom_sys_rapid_feed_mode(LINEAR)           "AUTO"
      set mom_sys_cycle_feed_mode                   "AUTO"
    } else {
      set mom_sys_contour_feed_mode(LINEAR)         "MMPM"
      set mom_sys_rapid_feed_mode(LINEAR)           "MMPM"
      set mom_sys_cycle_feed_mode                   "MMPM"
    }
    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
    set mom_sys_feed_param(FRN,format)            "Feed_INV"
    set mom_sys_vnc_rapid_dogleg                  "1"
    set mom_sys_prev_mach_head                    ""
    set mom_sys_curr_mach_head                    ""
    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
    set mom_sys_retract_distance                  "10"
    set mom_sys_linearization_method              "angle"
    set mom_sys_post_description                  "This is a 5-Axis Milling Machine With\n\Dual Rotary Heads."
    set mom_sys_ugpadvkins_used                   "0"
    set mom_sys_post_builder_version              "9.0.1"
    set mom_sys_linear_turbo_command              "FALSE"
    set mom_sys_rapid_turbo_command               "FALSE"
    set mom_sys_circular_turbo_command            "FALSE"
    # will be added to post core later
    set mom_sys_turbo_global_add_vars_list        "mom_feedrate mom_motion_type mom_current_motion mom_pos_arc_center mom_pos_arc_axis oper_mcs_matrix"
    set mom_sys_output_transition_path            "0"
    set mom_sys_post_output_subprogram_enabled    "1"

    ####### KINEMATIC VARIABLE DECLARATIONS ##############
    set mom_kin_4th_axis_ang_offset               "0.0"
    set mom_kin_4th_axis_center_offset(0)         "0.0"
    set mom_kin_4th_axis_center_offset(1)         "0.0"
    set mom_kin_4th_axis_center_offset(2)         "0.0"
    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_4th_axis_incr_switch              "OFF"
    set mom_kin_4th_axis_leader                   "A"
    set mom_kin_4th_axis_max_limit                "360"
    set mom_kin_4th_axis_min_incr                 "0.001"
    set mom_kin_4th_axis_min_limit                "0"
    set mom_kin_4th_axis_plane                    "YZ"
    set mom_kin_4th_axis_point(0)                 "0.0"
    set mom_kin_4th_axis_point(1)                 "0.0"
    set mom_kin_4th_axis_point(2)                 "0.0"
    set mom_kin_4th_axis_rotation                 "standard"
    set mom_kin_4th_axis_type                     "Head"
    set mom_kin_4th_axis_vector(0)                "1"
    set mom_kin_4th_axis_vector(1)                "0"
    set mom_kin_4th_axis_vector(2)                "0"
    set mom_kin_4th_axis_zero                     "0.0"
    set mom_kin_5th_axis_ang_offset               "0.0"
    set mom_kin_5th_axis_center_offset(0)         "0.0"
    set mom_kin_5th_axis_center_offset(1)         "0.0"
    set mom_kin_5th_axis_center_offset(2)         "0.0"
    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_5th_axis_incr_switch              "OFF"
    set mom_kin_5th_axis_leader                   "B"
    set mom_kin_5th_axis_max_limit                "360"
    set mom_kin_5th_axis_min_incr                 "0.001"
    set mom_kin_5th_axis_min_limit                "0"
    set mom_kin_5th_axis_plane                    "ZX"
    set mom_kin_5th_axis_point(0)                 "0.0"
    set mom_kin_5th_axis_point(1)                 "0.0"
    set mom_kin_5th_axis_point(2)                 "0.0"
    set mom_kin_5th_axis_rotation                 "standard"
    set mom_kin_5th_axis_type                     "Head"
    set mom_kin_5th_axis_vector(0)                "0"
    set mom_kin_5th_axis_vector(1)                "1"
    set mom_kin_5th_axis_vector(2)                "0"
    set mom_kin_5th_axis_zero                     "0.0"
    set mom_kin_arc_output_mode                   "QUADRANT"
    set mom_kin_arc_valid_plane                   "XYZ"
    set mom_kin_clamp_time                        "2.0"
    set mom_kin_cycle_plane_change_per_axis       "0"
    set mom_kin_cycle_plane_change_to_lower       "0"
    set mom_kin_dependent_head                    "NONE"
    set mom_kin_flush_time                        "2.0"
    set mom_kin_helical_arc_output_mode           "END_POINT"
    set mom_kin_ind_to_dependent_head_x           "0"
    set mom_kin_ind_to_dependent_head_z           "0"
    set mom_kin_independent_head                  "NONE"
    set mom_kin_linearization_flag                "1"
    ###set mom_kin_linearization_tol                 "0.01"
    set mom_kin_machine_resolution_metric         "0.0001"
    set mom_kin_machine_type                      "5_axis_dual_head"
    set mom_kin_machine_zero_offset(0)            "0.0"
    set mom_kin_machine_zero_offset(1)            "0.0"
    set mom_kin_machine_zero_offset(2)            "0.0"
    set mom_kin_max_dpm                           "1000000"
    set mom_kin_max_frn                           "1000"
    set mom_kin_min_dpm                           "0.0"
    set mom_kin_min_frn                           "0.01"
    set mom_kin_output_unit                       "MM"
    set mom_kin_pivot_gauge_offset                "0.0"
    set mom_kin_pivot_guage_offset                ""
    set mom_kin_post_data_unit                    "MM"
    set mom_kin_retract_distance                  "500"
    set mom_kin_rotary_axis_method                "PREVIOUS"
    set mom_kin_spindle_axis(0)                   "0.0"
    set mom_kin_spindle_axis(1)                   "0.0"
    set mom_kin_spindle_axis(2)                   "1.0"
    set mom_kin_tool_change_time                  "10.0"
    set mom_kin_x_axis_limit                      "1000"
    set mom_kin_y_axis_limit                      "1000"
    set mom_kin_z_axis_limit                      "1000"
    set mom_kin_head_spindle_axis_correction      "ON"
    set mom_kin_head_gauge_point_correction       "ON"
    set mom_kin_combine_rapid_arc_motion          "Yes"
  }
}
proc CONF_ITNC530_setting {args} {

  if {[llength $args] == 1} {
      set prop_name $args
      set first_arg ""
      set remaining_args ""
  } else {
    set prop_name [lindex $args 1]
    set first_arg [lindex $args 0]
    set remaining_args [lrange $args 2 end]

  }

  switch -- $prop_name {
    "feed_max" -
    "feed_linear" {
      if {$first_arg == ""} {
        set new_command "CONF_CTRL_feed $args"
      } else {
        set new_command "CONF_CTRL_feed $first_arg $prop_name $remaining_args"
      }
    }
    default {
      set new_command "CONF_CTRL_setting $args"
    }
  }
  if {$::lib_ge_pretreatment_runtime} {
    LIB_GE_wish "LEGACY PROPERTY !!!" "'CONF_ITNC530_setting $args' is used. Value is mapped to new CONF  - please use '$new_command' from now on - see .def File" "PP-MESSAGE" 2 2
  }
  return [if {1} $new_command]
}
proc MOM_start_of_program_LIB {} {
  global lib_flag mom_kin_machine_type
  set commandcheck(MOM_start_of_program_LIB_ENTRY) [llength [info commands MOM_start_of_program_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_dnc_header) [llength [info commands LIB_CTRL_dnc_header]]
  set commandcheck(LIB_CTRL_nc_header) [llength [info commands LIB_CTRL_nc_header]]
  set commandcheck(LIB_CTRL_sub_header) [llength [info commands LIB_CTRL_sub_header]]
  set commandcheck(LIB_CTRL_parameter_definition) [llength [info commands LIB_CTRL_parameter_definition]]

  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_dnc_header
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_dnc_header)} {LIB_CTRL_dnc_header}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[string match "MOM_start_of_program" [info level -1]]} {
    LIB_GE_command_buffer LIB_CTRL_nc_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_nc_header)} {LIB_CTRL_nc_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Program"}} @EVENT_MESSAGE
    LIB_GE_command_buffer {LIB_SPF_program_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer LIB_CTRL_sub_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sub_header)} {LIB_CTRL_sub_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {LIB_SPF_sub_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  }

  LIB_GE_command_buffer LIB_CTRL_parameter_definition
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition)} {LIB_CTRL_parameter_definition}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
  if {[LIB_PT_get_header_var mom_sequence_mode exists]} {
    if {[LIB_PT_get_header_var mom_sequence_mode] == "OFF"} {
      MOM_set_seq_off
    } else {
      if {[CONF_CTRL_setting sequence_number] == 1} {
        MOM_set_seq_on
      } else {
        MOM_set_seq_off
      }
    }
    }
  }

  if {$lib_flag(local_namespace_output) == 1 && [CONF_CTRL_setting plane_output_supported] != "NONE"} {
    set lib_flag(plane_output_pos_type) 1
    if {[string match "5_axis_head_table" $mom_kin_machine_type] && [CONF_CTRL_setting plane_output] == "CYCLE_19" && [CONF_CTRL_setting reference_direction] == 1} {
      set lib_flag(plane_output_pos_type) 0
      set lib_flag(plane_reference_direction) 1
    }
  }


  LIB_GE_command_buffer PROGRAMSTART
  LIB_GE_command_buffer {
    if {[CONF_CTRL_setting block_form] == 1 && [string match "MOM_start_of_program" [info level -1]]} {
      LIB_SPF_start_of_program_blank
    }
  } @BLANKGEO

  LIB_GE_command_buffer {LIB_GE_catch_do_template start_of_program "" 1} @START_OF_PROGRAM

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY) && [string match "MOM_start_of_program" [info level -1]] } {MOM_start_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_path_LIB {} {

  LIB_calc_lib_cutcom_radius

  LIB_CTRL_activate_feed_rate_modes

  set commandcheck(MOM_start_of_path_LIB_ENTRY) [llength [info commands MOM_start_of_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------


  # Preset: CONF_SPF_plane_kin rot: Set rotation about real or inclined axis
  # e.g. Hermle C-Series
  if {[CONF_ITNC530_PLANE definition] == "AXIAL"} {
    CONF_SPF_csys_3d_rot set rot_real_axis "1"
  } elseif {[CONF_ITNC530_PLANE definition] == "SPATIAL"} {
    CONF_SPF_csys_3d_rot set rot_real_axis "0"
  }

  LIB_update_tool_change_template

  # reset address expression
  if {[llength [info commands "MOM_set_address_expression"]]&&[info exists ::save_address_expression]} {
    if {[info exists ::save_address_expression(linear_move,X)]&&\
        [catch {MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" $::save_address_expression(linear_move,X)}]} {
          LIB_SPF_add_warning "Failed to reset address expression of 'X' in BLOCK_TEMPLATE 'linear_move'"
    }
    if {[info exists ::save_address_expression(linear_move,F)] && [catch {
      MOM_set_address_expression [CONF_CTRL_moves linear_template]   "F" $::save_address_expression(linear_move,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" $::save_address_expression(circular_move,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template]_1  "F"  $::save_address_expression(circular_move_1,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template]_radius  "F"  $::save_address_expression(circular_move_radius,F)
    }]} {
      LIB_SPF_add_warning "Failed to reset feed rate address expression , the feed rate address name should be 'F'"
    }
    unset ::save_address_expression
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_sync_LIB {} {

  set commandcheck(MOM_sync_LIB_ENTRY) [llength [info commands MOM_sync_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SYNC

  LIB_GE_command_buffer {LIB_GE_message "MOM_sync is not implemented for this controller" "output_1"} @SYNC_CALL

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_set_csys_LIB {} {
  global lib_flag mom_kin_machine_type

  set commandcheck(MOM_set_csys_LIB_ENTRY) [llength [info commands MOM_set_csys_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![info exist lib_flag(absolute_kin)] || $lib_flag(absolute_kin) == 0} {
    # do nothing
  } else {
    LIB_SPF_calc_4th5th_axis_points
  }

  # In new local csys mode, translate mom_pos and mom_mcs_goto from local to G54 in global namespace,
  # and get rotation matrix and origin of local coordinate system relative to G54.
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_csys_rotation_revise_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output


}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_calc_lib_cutcom_radius {} {

  global mom_cutter_data_output_indicator mom_cut_data_type mom_cutcom_type mom_tool_diameter
  global lib_cutcom_radius mom_kin_arc_output_mode mom_sys_cutcom_code lib_flag
  global mom_machine_mode

  if {$mom_machine_mode == "TURN"} {

    set lib_cutcom_radius 0.0

  } else {

    MOM_enable_address DR_tool_call
    if {![info exists mom_cutter_data_output_indicator]} {
      set mom_cutter_data_output_indicator 0
    }
    if {![info exists mom_cutcom_type]} {
      set mom_cutcom_type 0
    }

    if {[CONF_CTRL_tool cutcom_actual_radius] == 0} {
      # no cutcom output even it is defined
      if {$mom_cutter_data_output_indicator == 1} {
        LIB_GE_abort_message "Cutcom contact not allowed"
      } else {
        set lib_cutcom_radius 0.0
      }
    } elseif {$mom_cutcom_type > 0} {
      # cutcom defined
      if {$mom_cut_data_type == "centerline data"} {
        set lib_cutcom_radius [expr $mom_tool_diameter/2]
      } else {
        set lib_cutcom_radius 0.0
      }
      if {[CONF_CTRL_setting read_ahead_number] > 0} {
        if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_arc_output_mode] == "FULL_CIRCLE"} {
          set mom_kin_arc_output_mode  "QUADRANT"
          MOM_reload_kinematics_variable mom_kin_arc_output_mode
        } elseif {$::mom_kin_arc_output_mode == "FULL_CIRCLE"} {
          set mom_kin_arc_output_mode  "QUADRANT"
          MOM_reload_kinematics_variable mom_kin_arc_output_mode
        }
        }
      if {[CONF_CTRL_setting turbo_mode] == 2 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
        LIB_SPF_turbo_status "enable" "advanced"
      }
    } else {
      # no cutcom defined
      if {[info exists lib_cutcom_radius] && $lib_cutcom_radius > 0.0} {
        set lib_cutcom_radius 0.0
      } else {
        set lib_cutcom_radius 0.0
        MOM_disable_address DR_tool_call
      }
      if {[CONF_CTRL_setting read_ahead_number] > 0} {
        if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_arc_output_mode] == "FULL_CIRCLE" && $mom_kin_arc_output_mode == "QUADRANT"} {
          set mom_kin_arc_output_mode  "FULL_CIRCLE"
          MOM_reload_kinematics_variable mom_kin_arc_output_mode
        }
      }
    }

  }

  if {$mom_cutter_data_output_indicator == 2 && [CONF_CTRL_setting 3d_cutcom_output] != 0} {
    if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [CONF_CTRL_setting tcpm_output] != "vector"} {
      set error [LIB_SPF_add_warning "For 3D correction with 5 axis simultaneous: tool axis vector has been used"]
      set lib_flag(initial_tcpm_output) [CONF_CTRL_setting tcpm_output]
      CONF_CTRL_setting set tcpm_output "vector"
    }
    MOM_enable_address NX_vector NY_vector NZ_vector
    MOM_force always X Y Z
    if {[CONF_CTRL_setting turbo_mode] >= 2 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
      LIB_SPF_turbo_status "enable" "advanced"
    } else {
      LIB_SPF_turbo_status "disable"
    }
    set lib_flag(current_3d_correction) 1
  } else {
    if {$lib_flag(current_3d_correction) == 1} {
      if {[info exist lib_flag(initial_tcpm_output)]} {CONF_CTRL_setting set tcpm_output $lib_flag(initial_tcpm_output)}
      MOM_disable_address NX_vector NY_vector NZ_vector
      MOM_force off X Y Z
      set lib_flag(current_3d_correction) 0
    }
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_update_tool_change_template {} {


  global mom_spindle_speed mom_feed_cut_value mom_cutcom_type mom_cut_data_type
  global lib_prev_feed_cut_value lib_prev_cutcom_type lib_prev_cut_data_type
  global mom_tool_name mom_tool_adjust_register mom_tool_change_type lib_cutcom_radius lib_prev_cutcom_radius lib_prev_tool_adjust_register
  global mom_feed_rate mom_feed_cut_unit mom_feed_rate_output_mode mom_output_unit mom_feed_rate_per_rev
  global mom_motion_type mom_oper_tool feed
  global mom_machine_mode mom_cycle_type mom_spindle_startup_status
  global lib_tool_length_adjust_template
  # Save mom_* variables here and restore in the end of the proc
  set tmp_sav_feed_cut_value $mom_feed_cut_value

  #MAN enable/disable output of adresses for turning tools
  if {$mom_machine_mode == "TURN"} {
    MOM_disable_address Tooldirection
    MOM_disable_address S
    MOM_disable_address F_tool_call
    MOM_disable_address DL_tool_call
    MOM_disable_address DR_tool_call
  } else {
    MOM_enable_address Tooldirection
    MOM_enable_address S
    MOM_enable_address DL_tool_call
    MOM_enable_address DR_tool_call
    MOM_enable_address H
    MOM_enable_address Blank
    # HES Enable/disable output of Feedrate with TOOL CALL
    # Customer can change [CONF_CTRL_feed feed_linear] with an UDE

    if {[CONF_CTRL_feed feed_linear] != 1} {
      MOM_disable_address F_tool_call
    } else {
      MOM_enable_address F_tool_call
    }

    if {$::mom_tool_status == 0 || $mom_tool_name != [LIB_SPF_get_pretreatment mom_tool_name -1]} {
      return
    }
    # disable all addresses first then enable that address which is changed
    MOM_suppress once T T_name H Blank Tooldirection S DL_tool_call DR_tool_call

    # for Gun drilling
    if {[LIB_SPF_pt_exists mom_cycle_Q427]} {
      set tmp_speed $mom_spindle_speed
      set mom_spindle_speed [LIB_SPF_get_pretreatment mom_cycle_Q427]
    }

    if {[LIB_SPF_pt_exists first_spindle_rpm($::mom_path_name)] && ![info exists tmp_speed]} {
      set tmp_speed $mom_spindle_speed
      set mom_spindle_speed [LIB_SPF_get_pretreatment first_spindle_rpm($::mom_path_name)]
    }

    if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
      set mom_feed_rate [expr $mom_feed_cut_value/25.4]
    } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
      set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
    } else {
      set mom_feed_rate $mom_feed_cut_value
    }
    if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
      set mom_feed_rate_per_rev $mom_feed_cut_value
    }

    set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
    set mom_motion_type "RAPID"
    LIB_SPF_feedrate_set
    if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
      set mom_feed_cut_value [expr $feed * $::mom_spindle_rpm]
    } else {
      set mom_feed_cut_value $feed
    }

    set tmp_output 0

    LIB_GE_command_buffer UPDATE_TOOL

    LIB_GE_command_buffer {

      LIB_GE_command_buffer ADJUST_REGISTER_CHANGE
      LIB_GE_command_buffer {

        LIB_CHECK_adjust_register

        if {$mom_tool_adjust_register != $lib_prev_tool_adjust_register} {
          MOM_force once T T_name H Blank DR_tool_call
          set lib_prev_tool_adjust_register $mom_tool_adjust_register
          set tmp_output 1
        }

      } @OUTPUT
      LIB_GE_command_buffer_output

      LIB_GE_command_buffer FEED_AUTO_CHANGE
      LIB_GE_command_buffer {
        if {[CONF_CTRL_feed feed_linear] == 1 && ![EQ_is_equal $mom_feed_cut_value $lib_prev_feed_cut_value]} {
          MOM_force once T T_name H Blank F_tool_call
          set tmp_output 1

          if {$mom_oper_tool != "NONE"} {
            if {[CONF_CTRL_feed feed_linear] != 2} {
              set lib_prev_feed_cut_value $mom_feed_cut_value
            }
          }
        }
      } @OUPUT
      LIB_GE_command_buffer_output

      LIB_GE_command_buffer CUTCOM_RADIUS_CHANGE
      LIB_GE_command_buffer {
        if {![EQ_is_equal $lib_cutcom_radius $lib_prev_cutcom_radius]} {
          MOM_force once T T_name H Blank DR_tool_call
          set tmp_output 1
          set lib_prev_cutcom_radius $lib_cutcom_radius
        }
      } @OUPUT
      LIB_GE_command_buffer_output

      LIB_GE_command_buffer SPINDLE_SPEED_CHANGE
      LIB_GE_command_buffer {
        if {![EQ_is_equal [MOM_ask_address_value S] $mom_spindle_speed 0.9999]} {
          if {([info exists mom_cycle_type] && ($mom_cycle_type == "Exp_Deep_Drill_Breakchip" || $mom_cycle_type == "Exp_Deep_Drill")) || \
            ([info exists mom_spindle_startup_status] && $mom_spindle_startup_status == "OFF") &&\
          [LIB_SPF_get_pretreatment mom_spindle_speed -1] != $::mom_spindle_speed} {
            MOM_do_template tool_change_spindle_speed_change CREATE ;# bug 1777
          } else {
            MOM_force once S
            set tmp_output 1
          }
        }
      } @OUTPUT
      LIB_GE_command_buffer_output

      LIB_GE_command_buffer TOOL_CHANGE_TEMPLATE
      LIB_GE_command_buffer {
        if {![CONF_CTRL_tool output_adjust_register]} {MOM_suppress once H}
        if {[regexp -- "^tool_change|^tool_change_name|^tool_change_number_name" [CONF_CTRL_tool [string tolower $mom_tool_change_type]_change_template]] && $tmp_output == 1} {
          LIB_CONF_do_prop_custom_proc CONF_CTRL_tool [string tolower $mom_tool_change_type]_change_template "short_template_syntax"
        } else {
          if {$tmp_output == 1} {
            MOM_do_template $lib_tool_length_adjust_template
          }
        }
      } @OUTPUT
      LIB_GE_command_buffer_output


    } @UPDATE_TOOL

    LIB_GE_command_buffer {
      # for Gun drilling
      if {[info exists tmp_speed]} {
        set mom_spindle_speed $tmp_speed
      }
      # Restore mom_* variables which was saved in the start of the Procedure
      set mom_feed_cut_value $tmp_sav_feed_cut_value
    } @RESET_TO_SAVE
    LIB_GE_command_buffer {
      LIB_CTRL_set_feed_parameter
    } @SET_FEED_PARAM

    LIB_GE_command_buffer_output
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_tool_LIB {} {

  global lib_flag mom_sys_home_pos lib_sys_tool_change_pos

  set commandcheck(MOM_first_tool_LIB_ENTRY) [llength [info commands MOM_first_tool_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set lib_flag(tool_path_motion) 0

  if {[CONF_CTRL_moves return_before_first_tool_change_pos] != ""} {
    VMOV 3 mom_sys_home_pos tmp_sys_home_pos
    VMOV 3 lib_sys_tool_change_pos mom_sys_home_pos
    LIB_RETURN_move CONF_CTRL_moves return_before_first_tool_change_pos
    VMOV 3 tmp_sys_home_pos mom_sys_home_pos
  }

  set lib_flag(first_tool_change) 1
  MOM_tool_change
  set lib_flag(first_tool_change) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type mom_tool_adjust_register
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_cut_data_type lib_prev_tool_adjust_register lib_tool_length_adjust_template
  global lib_flag lib_cutcom_radius lib_prev_cutcom_radius lib_prev_tool_name
  global mom_next_tool_status mom_motion_type feed
  global mom_feed_rate mom_feed_cut_unit mom_feed_rate_output_mode mom_output_unit mom_feed_rate_per_rev
  global mom_machine_mode mom_sys_advanced_postprocessing

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  # Save mom_* variables here and restore in the enf of the proc
  set tmp_sav_feed_cut_value $mom_feed_cut_value
  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  MOM_force_block once tool_change_init
  MOM_do_template tool_change_init CREATE

  # for Gun drilling
  if {[LIB_SPF_pt_exists mom_cycle_Q427]} {
    set tmp_speed $mom_spindle_speed
    set mom_spindle_speed [LIB_SPF_get_pretreatment mom_cycle_Q427]
    }
    if {[LIB_SPF_pt_exists first_spindle_rpm($::mom_path_name)] && ![info exists tmp_speed]} {
      set tmp_speed $mom_spindle_speed
      set mom_spindle_speed [LIB_SPF_get_pretreatment first_spindle_rpm($::mom_path_name)]
  }


  if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
    set mom_feed_rate [expr $mom_feed_cut_value/25.4]
  } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
    set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
  } else {
    set mom_feed_rate $mom_feed_cut_value
  }
  if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
    set mom_feed_rate_per_rev $mom_feed_cut_value
  }

  set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
  set mom_motion_type "RAPID"
  LIB_SPF_feedrate_set

  if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
    set mom_feed_cut_value [expr $feed * $::mom_spindle_rpm]
  } else {
    set mom_feed_cut_value $feed
  }

  if {![CONF_CTRL_tool output_adjust_register]} {MOM_suppress once H}
  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      if {[regexp -- "^tool_change|^tool_change_name|^tool_change_number_name" [CONF_CTRL_tool manual_change_template]]} {
        set lib_tool_length_adjust_template "tool_length_adjust_[CONF_CTRL_tool manual_change_template]"
      } else {
        set lib_tool_length_adjust_template "tool_change"
      }

      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"
      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output


    } else {
      if {[regexp -- "^tool_change|^tool_change_name|^tool_change_number_name" [CONF_CTRL_tool auto_change_template]]} {
        set lib_tool_length_adjust_template "tool_length_adjust_[CONF_CTRL_tool auto_change_template]"
      } else {
        set lib_tool_length_adjust_template "tool_change"
      }

      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }
  } @TOOL_CHANGE

  LIB_GE_command_buffer {
    # Restore mom_* variables which was saved in the start of the Procedure
    set mom_feed_cut_value $tmp_sav_feed_cut_value
  } @RESET_TO_SAVE

  LIB_GE_command_buffer {
    LIB_CTRL_set_feed_parameter
  } @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {$mom_machine_mode == "TURN"} {
    MOM_enable_address S
  }

  # For gun drilling reset speed to orginal
  if {[info exists tmp_speed]} {
    set mom_spindle_speed $tmp_speed
  }

  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_cutcom_radius $lib_cutcom_radius
  set lib_prev_tool_name $mom_tool_name
  set lib_prev_tool_adjust_register $::mom_tool_adjust_register
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_from_move_LIB {} {

  global feed_mode mom_feed_rate mom_kin_rapid_feed_rate

  set commandcheck(MOM_from_move_LIB_ENTRY) [llength [info commands MOM_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_moves output_from_position] == 1 } {
  if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
    if {[EQ_is_ge $mom_feed_rate $mom_kin_rapid_feed_rate]} {
      MOM_rapid_move_LIB
    } else {
      MOM_linear_move_LIB
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_first_move_LIB {} {
  global mom_motion_event mom_operation_name mom_output_mcs_name
  global mom_motion_type

  set commandcheck(MOM_first_move_LIB_ENTRY) [llength [info commands MOM_first_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check move

  LIB_SPF_check_decompose_first_move

  if {[info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])] && $mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])} {
    LIB_main_origin_call
  }

  LIB_CHECK_adjust_register

  if {$mom_motion_event == "cycle_plane_change"} {
    LIB_SPF_add_warning "It is recommended to define a motion before first cycle."
  }
  catch {MOM_$mom_motion_event}

  # Handle the case user specify feed for rapid
  if {$mom_motion_type == "RAPID"} {
    LIB_SPF_last_rapid_pos
  }
  LIB_SPF_calc_abs_move_parameter
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_initial_move_LIB {} {

  global lib_flag mom_programmed_feed_rate mom_motion_event
  global mom_motion_type

  set commandcheck(MOM_initial_move_LIB_ENTRY) [llength [info commands MOM_initial_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_spindle_set

  #<cam17013 new pretreatment>
  if {$lib_flag(local_namespace_output) == 1} {
    if {[CONF_CTRL_setting turbo_mode] == 3  && [CONF_CTRL_setting tcpm_output_supported] != "NONE" && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }
  }

  LIB_CTRL_handle_cycle_check move

  if {[EQ_is_zero $mom_programmed_feed_rate]} {
    MOM_rapid_move
    set mom_motion_event "rapid_move"
  } else {
    MOM_linear_move
    set mom_motion_event "linear_move"
    # Handle the case user specify feed for rapid
    if {$mom_motion_type == "RAPID"} {
      LIB_SPF_last_rapid_pos
    }
  }
  LIB_SPF_calc_abs_move_parameter

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_handle_cycle_check {arg} {

  global mom_cycle_type mom_spindle_status mom_spindle_startup_status

  if {([info exists mom_cycle_type] && ([string match "Exp_Deep_Drill_Breakchip" $mom_cycle_type] || [string match "Exp_Deep_Drill" $mom_cycle_type])) ||\
  ([info exists mom_spindle_startup_status] && $mom_spindle_startup_status == "OFF")} {

    switch -- $arg {
      "move"    {
            if {$mom_spindle_status == "OFF"} {MOM_disable_address S M_spindle}
          }
      "spindle" {
            MOM_enable_address S M_spindle
          }
      default   {
            LIB_GE_abort_message "Call LIB_CTRL_handle_cycle_check without the right arguments" "Please check"
          }
    }

  }
}
# <Internal Documentation>
#
# This function controlls the spindle rotation.
# The spindle should never be activated with the first movement if a single-lip drill is used.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_turbo {} {
  if {$::lib_ge_pretreatment_runtime} {return}
    # The mom variable mom_sys_advanced_turbo_output is set in MOM_Start_of_path from core code
  if {![info exists ::mom_sys_advanced_turbo_output] || $::mom_sys_advanced_turbo_output != "TRUE"} {
    return
  }

  if {[CONF_CTRL_moves always_center_for_circle] == 1} {
    # call different block, no need to suppress address
    # since we can't get correct block template for circular move, it is hardcoded here

    set ::mom_sys_circular_turbo_blocks [CONF_Turbo_Templates circular_template_turbo]
    lappend ::mom_sys_circular_turbo_blocks [CONF_Turbo_Templates circular_template_turbo]_1

  } else {
    # call different block , no need to suppress address
    set ::mom_sys_circular_turbo_command "TRUE"
    set ::mom_sys_circular_turbo_blocks [CONF_Turbo_Templates circular_template_turbo]_radius

  }

  if {$::mom_kin_arc_output_mode == "FULL_CIRCLE" } {
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {[CONF_CTRL_feed feed_linear] == 2} {
    # Before NX1899, set MOM_linear_move_turbo_LIB at turbo block to output parameterized feed value
    # From NX1899, use advanced callback function to do the same thing
    if {$::lib_ge_env(major_version) < 1899} {
      if {[llength [info commands MOM_set_turbo_feedrate_set]] && [CONF_CTRL_feed feed_motion_type] == 1} {
        MOM_set_turbo_feedrate_set OFF
        MOM_set_turbo_before_motion ON
      } else {
        set ::mom_sys_linear_turbo_command "TRUE"
        set ::mom_sys_circular_turbo_command "TRUE"
      }
    } else {
      # In advanced turbo mode, LIB_SPF_feedrate_set is called in callback function, so disable feedrate setting in core code
      # If the command MOM_set_turbo_feedrate_set does not exists or property feed_motion_type is set to 0 than use the previous methode
      if {[llength [info commands MOM_set_turbo_feedrate_set]]} {
        MOM_set_turbo_feedrate_set OFF
      }
    }
  }

  if {$::mom_sys_rapid_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry] "MOM_rapid_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry]]
  }

  if {$::mom_sys_linear_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry] "MOM_linear_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry]]
  }

  if {$::mom_sys_circular_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment $::mom_sys_circular_turbo_blocks [CONF_Turbo_Templates circular_template_entry] "MOM_circular_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment $::mom_sys_circular_turbo_blocks [CONF_Turbo_Templates circular_template_entry]]
  }

  # The address X[$mom_pos(0)*$x_factor] will slow down turbo mode, x_factor only used in turning
  if {[llength [info commands "MOM_set_address_expression"]]} {
    if {$::x_factor == 1} {
      catch {
        set ::save_address_expression(linear_move,X) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" "\$mom_pos(0)"]
      }
    }

    if {[CONF_CTRL_feed feed_linear] != 2} {
      if {[catch {
        set ::save_address_expression(linear_move,F) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "F" "\$mom_feedrate"]
        set ::save_address_expression(circular_move,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" "\$mom_feedrate"]
        set ::save_address_expression(circular_move_1,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template]_1 "F" "\$mom_feedrate"]
        set ::save_address_expression(circular_move_radius,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template]_radius "F" "\$mom_feedrate"]
      }]} {
        LIB_SPF_add_warning "Please use 'F' as feed rate address name in linear and circular block template"
      }
    }

  }
}
# <Internal Documentation>
#
# This procedure is executed at MOM_initial_move MOM_first_move MOM_lock_axis.
# It is used to config turbo blocks in advanced turbo mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB {} {

  global mom_machine_mode mom_pos
  global lib_flag lib_param

  set commandcheck(MOM_rapid_move_LIB_ENTRY) [llength [info commands MOM_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {LIB_ROTARY_positioning_turn} @ROTARY_POS_TURN
      LIB_GE_command_buffer {
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves rapid_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        }
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
        switch -- $lib_flag(mode_current_status) {
          "std" {
            LIB_ROTARY_positioning_first_move
          }
          "pos" {
            LIB_ROTARY_positioning_first_move_pos
          }
          "sim" {
            LIB_ROTARY_positioning_first_move_sim
          }
        }
      } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer FIRST_MOVE_COOLANT
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized RAPID_MOVE]} {
    LIB_GE_command_buffer RAPID_MOVE
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output
  } else {

    LIB_GE_command_buffer RAPID_MOVE_SINGLE
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output

  }

  LIB_SPF_last_rapid_pos

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_linear_move_turbo {} {

  set commandcheck(LIB_CTRL_linear_move_turbo_ENTRY) [llength [info commands LIB_CTRL_linear_move_turbo_ENTRY]]

  LIB_GE_command_buffer LINEAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_linear_move_turbo" "output_1"} @LINEAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_linear_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_linear_move_turbo_ENTRY)} {LIB_CTRL_linear_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_linear_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_turbo {} {

  set commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY) [llength [info commands LIB_CTRL_rapid_move_turbo_ENTRY]]

  LIB_GE_command_buffer RAPID_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_rapid_move_turbo" "output_1"} @RAPID_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_rapid_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY)} {LIB_CTRL_rapid_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_rapid_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_circular_move_turbo {} {

  set commandcheck(LIB_CTRL_circular_move_turbo_ENTRY) [llength [info commands LIB_CTRL_circular_move_turbo_ENTRY]]

  LIB_GE_command_buffer CIRCULAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @CIRCULAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_circular_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_circular_move_turbo_ENTRY)} {LIB_CTRL_circular_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_circular_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_linear_move_turbo_LIB {} {

  set commandcheck(MOM_linear_move_turbo_LIB_ENTRY) [llength [info commands MOM_linear_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_linear_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_turbo_LIB {} {

  set commandcheck(MOM_rapid_move_turbo_LIB_ENTRY) [llength [info commands MOM_rapid_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_rapid_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_turbo_LIB {} {

  set commandcheck(MOM_circular_move_turbo_LIB_ENTRY) [llength [info commands MOM_circular_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  # Made sure that Circle Cordinates are output
  MOM_force Once G_motion X Y Z circle_direction

  switch -- $::tool_axis {
    0 {MOM_suppress once X}
    1 {MOM_suppress once Y}
    2 {MOM_suppress once Z}
  }

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  if {[CONF_CTRL_moves always_center_for_circle] != 1} {
    global mom_arc_radius
    set mom_arc_radius [expr abs($mom_arc_radius)]

    # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
    if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

      global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
      global mom_namespace_name mom_output_pos_type
      if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
        if {$mom_namespace_name == "::"} {
          set namespace ::
        } else {
          set namespace ::LOCAL_CSYS::
        }
        if {$mom_output_pos_type == "mom_pos"} {
          VMOV 3 ${namespace}mom_prev_pos prev_pos
          VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
        } else {
          VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
          VMOV 3 ${namespace}mom_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
        }
        VMOV 3 ${namespace}$mom_output_pos_type save_pos
      } else {
        set namespace ::
        set mom_output_pos_type mom_pos
        VMOV 3 mom_prev_pos prev_pos
        VMOV 3 mom_pos_arc_center pos_arc_center
        VMOV 3 mom_pos_arc_axis pos_arc_axis
        VMOV 3 mom_pos save_pos
      }
      VEC3_sub prev_pos pos_arc_center tmp_vec
      VEC3_unitize tmp_vec tmp_vec1
      VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
      VEC3_scale mom_arc_radius tmp_vec tmp_vec1
      VEC3_add pos_arc_center tmp_vec1 tmp_vec
      VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

      MOM_do_template [CONF_Turbo_Templates circular_template_turbo]_radius

      VMOV 3 save_pos  ${namespace}$mom_output_pos_type

      MOM_force Once G_motion X Y Z R circle_direction
      switch -- $::tool_axis {
        0 {MOM_suppress once X}
        1 {MOM_suppress once Y}
        2 {MOM_suppress once Z}
      }

      set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]
    }

    if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
      LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
    }

    if {[EQ_is_gt $::mom_arc_angle 180.0]} {
      set mom_arc_radius [expr -1.0*$mom_arc_radius]
    }

  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_circular_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB_MODIF_first_move_turn {} {

  return 0

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_TURNING_mode {{option default}} {

  global x_factor lib_flag

  switch -- $option {
    "start" {

      set x_factor [LIB_SPF_check_x_factor TURN]

      if {![info exist lib_flag(save_rapid_template)]} {set lib_flag(save_rapid_template) [CONF_CTRL_moves rapid_template]}
      CONF_CTRL_moves set rapid_template [CONF_CTRL_moves rapid_template_turn]

      if {![info exist lib_flag(save_linear_template)]} {set lib_flag(save_linear_template) [CONF_CTRL_moves linear_template]}
      CONF_CTRL_moves set linear_template [CONF_CTRL_moves linear_template_turn]

      if {![info exist lib_flag(save_circular_template)]} {set lib_flag(save_circular_template) [CONF_CTRL_moves circular_template]}
      CONF_CTRL_moves set circular_template [CONF_CTRL_moves circular_template_turn]

      LIB_GE_command_buffer FUNCTION_MODE_TURN
      LIB_GE_command_buffer {
        set ::lib_var(machine_mode) TURN
        MOM_do_template function_mode
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
    "end" {
      set x_factor [LIB_SPF_check_x_factor MILL]

      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        unset lib_flag(save_rapid_template)
      }

      if {[info exists lib_flag(save_linear_template)]} {
        CONF_CTRL_moves set linear_template $lib_flag(save_linear_template)
        unset lib_flag(save_linear_template)
      }

      if {[info exists lib_flag(save_circular_template)]} {
        CONF_CTRL_moves set circular_template $lib_flag(save_circular_template)
        unset lib_flag(save_circular_template)
      }

      LIB_GE_command_buffer FUNCTION_MODE_MILL
      LIB_GE_command_buffer {
        set ::lib_var(machine_mode) MILL
        MOM_do_template function_mode
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  }
}
# <Internal Documentation>
# Controls the turning mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_start {{option default}} {

  global mom_machine_mode mom_spindle_mode mom_spindle_preset_rpm_toggle mom_spindle_preset_rpm
  global mom_spindle_maximum_rpm mom_spindle_speed mom_mcs_goto mom_spindle_status
  global PI mom_spindle_maximum_rpm_toggle lib_flag

  if {$mom_spindle_status == "OFF"} {return}

  set commandcheck(LIB_SPINDLE_start_ENTRY) [llength [info commands LIB_SPINDLE_start_ENTRY]]

  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY start_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  # for Gun drilling
  if {[LIB_SPF_pt_exists mom_cycle_Q427]} {
    set tmp_speed $mom_spindle_speed
    set mom_spindle_speed [LIB_SPF_get_pretreatment mom_cycle_Q427]
  }
  LIB_GE_command_buffer SPINDLE
  switch -- $option {
    "preset" {
      # turning only
      LIB_GE_command_buffer {
        if {[EQ_is_zero $mom_spindle_speed]} {
          LIB_GE_error_message "Spindle speed should not be = 0.0" "Please check"
        }

        if {$mom_spindle_mode == "RPM"} {
          if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
            MOM_force_block once spindle_rpm_turn
            MOM_do_template spindle_rpm_turn
          }

        } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
            set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
          }

          if {[MOM_do_template spindle_smm_turn CREATE] != ""} {
            MOM_force_block once spindle_smm_turn
            MOM_do_template spindle_smm_turn
          }

        }
      } @PRESET
    }
    "cycle" {
      LIB_GE_command_buffer {
        # be sure spindle rpm output before cycle
        if {![EQ_is_equal [MOM_ask_address_value S] $mom_spindle_speed 0.9999]} {
          MOM_do_template tool_change_spindle_speed_change
        }
        MOM_do_template spindle_rpm
      }  @CYCLE
    }
    "default" {

      switch -- $mom_machine_mode {
        "MILL" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm CREATE
            } else {
              # Always RPM output for milling
              if {![EQ_is_equal [MOM_ask_address_value S] $mom_spindle_speed 0.9999]} {
                MOM_do_template tool_change_spindle_speed_change
              }
              if {[CONF_CTRL_spindle spindle_output_alone] == 1 || [info level 1] == "MOM_spindle_rpm"} {
                MOM_do_template spindle_rpm
              }
            }
          } @DEFAULTMILL
        }
        "TURN" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm_turn CREATE
            } else {

              if {$mom_spindle_mode == "RPM"} {
                if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
                  MOM_force_block once spindle_rpm_turn
                  MOM_do_template spindle_rpm_turn
                }

              } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
                if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
                  set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
                }

                if {[MOM_do_template spindle_smm_turn CREATE] != ""} {
                  MOM_force_block once spindle_smm_turn
                  MOM_do_template spindle_smm_turn
                }

              }

              if {[CONF_CTRL_spindle spindle_output_alone] == 1} {
                MOM_do_template spindle_rpm
              }
            }
          } @DEFAULTTURN
        }
      }
    }
  }
  LIB_GE_command_buffer_output
  # for Gun drilling

  if {[LIB_SPF_pt_exists mom_cycle_Q427]} {
    set mom_spindle_speed $tmp_speed
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY end_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Controls the spindle start conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_end {} {

  LIB_GE_command_buffer SPINDLE_END
  LIB_GE_command_buffer {MOM_do_template spindle_off} @SPINDLE_OFF_1
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the spindle end conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_spindle_orient {} {

  global mom_machine_mode

  LIB_GE_command_buffer SPINDLE_ORIENT

  LIB_GE_command_buffer {
    if {$mom_machine_mode == "MILL"} {MOM_do_template spindle_off}
  } @SPINDLE_OFF

  LIB_GE_command_buffer {
    MOM_do_template cycl_def_13_0
    MOM_do_template cycl_def_13_1
  } @CYCL_13
  LIB_GE_command_buffer {MOM_do_template spindle_orient} @M19

  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# It used to output spindle orient code M19.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)] && $lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXLU
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_ylu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYLU
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZLU
          }
      }
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXUL
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_yul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYUL
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZUL
          }
      }
      set lib_flag(current_safety_position) 0
    }
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {unset lib_flag(current_plane_upper_than_previous)}
  }
  LIB_GE_command_buffer {
    LIB_CTRL_clamp_axis
  } @CLAMP
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the standard case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_pos {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_POS

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_pos) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)] && $lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXLU
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_ylu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYLU
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZLU
          }
      }
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXUL
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_yul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYUL
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZUL
          }
      }
      set lib_flag(current_safety_position) 0
    }
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {unset lib_flag(current_plane_upper_than_previous)}
  }
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_sim {} {

  global mom_motion_event
  global lib_flag

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_SIM

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_sim) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    LIB_GE_command_buffer {
      set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
      LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
    } @DECOMPOSE
  }
  LIB_GE_command_buffer_output
  set lib_flag(current_safety_position) 0
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning simultanous first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_turn {} {

}
# <Internal Documentation>
#
# Switch on positioning rotary mode for turning
#  (link to the controller)
#
# <Internal Example>
#
# Heidenhain: CYCL DEF 800
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset_turn {} {

}
# <Internal Documentation>
#
# Switch off positioning rotary mode for turning
#  (link to the controller)
#
# <Internal Example>
#
# Heidenhain: CYCL DEF 801
#
#____________________________________________________________________________________________
proc MOM_generic_cycle_LIB {} {

  set commandcheck(MOM_generic_cycle_LIB_ENTRY) [llength [info commands MOM_generic_cycle_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_error_message "Machine Cycle in turning not supported for this controller" "Please check"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is used to handle turn rough and finish cycle with generic cycle enhancement.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_linear_move_LIB {} {

  global mom_machine_mode mom_pos lib_last_rapid_pos
  global lib_param lib_flag

  set commandcheck(MOM_linear_move_LIB_ENTRY) [llength [info commands MOM_linear_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {LIB_ROTARY_positioning_turn} @ROTARY_POS_TURN
      LIB_GE_command_buffer {
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves linear_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
          switch -- $lib_flag(mode_current_status) {
            "std" {
              LIB_ROTARY_positioning_first_move
            }
            "pos" {
              LIB_ROTARY_positioning_first_move_pos
            }
            "sim" {
              LIB_ROTARY_positioning_first_move_sim
            }
          }
        } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves linear_template]} @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves linear_template]} @MOVE
    LIB_GE_command_buffer_output
  }

  #
  # Capture previous pos for use in cycles
  # can't always use the simple mom_prev_pos in cycles so need
  # a dedicated variable

  if {[info exists mom_pos(0)]} {
    set lib_last_rapid_pos(0)  $mom_pos(0)
    set lib_last_rapid_pos(1)  $mom_pos(1)
    set lib_last_rapid_pos(2)  $mom_pos(2)
  } else {
    set lib_last_rapid_pos(0)  0.0
    set lib_last_rapid_pos(1)  0.0
    set lib_last_rapid_pos(2)  0.0
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_LIB {} {


  global tool_axis tool_axis_direction mom_sys_circle_code mom_arc_radius

  set commandcheck(MOM_circular_move_LIB_ENTRY) [llength [info commands MOM_circular_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_WRITE_coolant on

  LIB_CIRCLE_set

  set mom_arc_radius [expr abs($mom_arc_radius)]

  if {[CONF_CTRL_moves always_center_for_circle] == 1} {

    LIB_GE_command_buffer CIRCULAR_MOVE_CENTER
    LIB_GE_command_buffer {
      switch -- $tool_axis {
        0 {MOM_force once Text J K}
        1 {MOM_force once Text K I}
        2 {MOM_force once Text I J}
      }

      MOM_do_template [CONF_CTRL_moves circular_template]

      switch -- $tool_axis {
        0 {MOM_force once G_motion Y Z circle_direction}
        1 {MOM_force once G_motion Z X circle_direction}
        2 {MOM_force once G_motion X Y circle_direction}
      }
      MOM_suppress once R
      MOM_do_template [CONF_CTRL_moves circular_template]_1
    } @OUTPUT
    LIB_GE_command_buffer_output

  } else {
    # Divide Circle to 90 and 270 degree (for full circle) or 90 and 90 degree (for half circle)
    # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
    if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {
      global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
        global mom_namespace_name mom_output_pos_type
        if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
          if {$mom_namespace_name == "::"} {
            set namespace ::
          } else {
            set namespace ::LOCAL_CSYS::
          }
          if {$mom_output_pos_type == "mom_pos"} {
            VMOV 3 ${namespace}mom_prev_pos prev_pos
            VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
          } else {
            VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
            VMOV 3 ${namespace}mom_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
          }
          VMOV 3 ${namespace}$mom_output_pos_type save_pos
        } else {
          set namespace ::
          set mom_output_pos_type mom_pos
          VMOV 3 mom_prev_pos prev_pos
          VMOV 3 mom_pos_arc_center pos_arc_center
          VMOV 3 mom_pos_arc_axis pos_arc_axis
          VMOV 3 mom_pos save_pos
        }
        VEC3_sub prev_pos pos_arc_center tmp_vec
        VEC3_unitize tmp_vec tmp_vec1
        VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
        VEC3_scale mom_arc_radius tmp_vec tmp_vec1
        VEC3_add pos_arc_center tmp_vec1 tmp_vec
        VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

      switch -- $tool_axis {
        0 {MOM_force Once G_motion Y Z R circle_direction}
        1 {MOM_force Once G_motion Z X R circle_direction}
        2 {MOM_force Once G_motion X Y R circle_direction}
      }
      LIB_GE_command_buffer CIRCULAR_MOVE_RADIUS_SEPARATED
      LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]_radius} @OUTPUT
      LIB_GE_command_buffer_output
      VMOV 3 save_pos  ${namespace}$mom_output_pos_type
      set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]
      switch -- $tool_axis {
        0 {MOM_suppress once X I}
        1 {MOM_suppress once Y J}
        2 {MOM_suppress once Z K}
      }
    }

    if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
      LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
    }

    if {[EQ_is_gt $::mom_arc_angle 180.0]} {
      set mom_arc_radius [expr -1.0*$mom_arc_radius]
    }

    switch -- $tool_axis {
      0 {MOM_force once G_motion Y Z R circle_direction}
      1 {MOM_force once G_motion Z X R circle_direction}
      2 {MOM_force once G_motion X Y R circle_direction}
    }

    LIB_GE_command_buffer CIRCULAR_MOVE_RADIUS
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]_radius} @OUTPUT
    LIB_GE_command_buffer_output
  }

  switch -- $tool_axis {
    0 {MOM_force once Y Z}
    1 {MOM_force once Z X}
    2 {MOM_force once X Y}
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_helix_move_LIB {} {
  global mom_pos mom_prev_pos mom_helix_pitch mom_sys_leader mom_sys_circle_code mom_output_unit
  global nturn helix_angle helix_direction tool_axis ipa_repeat helix_height tool_axis_direction

  set commandcheck(MOM_helix_move_LIB_ENTRY) [llength [info commands MOM_helix_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_WRITE_coolant on

  LIB_HELIX_set

  switch -- $tool_axis {
    0 {MOM_force Once Text J K
        set mom_sys_leader(helix_height) "IX"
      }
    1 {MOM_force Once Text K I
        set mom_sys_leader(helix_height) "IY"
      }
    2 {MOM_force Once Text I J
        set mom_sys_leader(helix_height) "IZ"
      }
  }

  LIB_GE_command_buffer HELIX_MOVE_1
  LIB_GE_command_buffer {MOM_do_template helix_move_1} @OUTPUT
  LIB_GE_command_buffer_output
  MOM_force Once circle_direction G_motion

  switch -- $tool_axis_direction {
    "-" {
        set mom_sys_circle_code(CLW)                  "DR-"
        set mom_sys_circle_code(CCLW)                 "DR+"
        set helix_direction [expr $helix_direction*+1]
        }
    "+" {
        set mom_sys_circle_code(CLW)                  "DR-"
        set mom_sys_circle_code(CCLW)                 "DR+"
        set helix_direction [expr $helix_direction*+1]
        }
  }

  # Workaround for Problem that the circle on the bottom of the helix is not cut
  # if FULL_CIRCLE is activ
  if {$::mom_kin_arc_output_mode == "FULL_CIRCLE" } {
    set tmp_add_angle 0.005
  } else {
    set tmp_add_angle 0.000
  }
  set helix_angle [expr $helix_angle + $tmp_add_angle]

  if {$helix_angle > 5400.0 || $helix_angle < -5400.0} {
    if {[EQ_is_zero $mom_helix_pitch]} {
      set nturn 0.0
    } else {
      set nturn [expr abs($mom_pos($tool_axis) - $mom_prev_pos($tool_axis)) / [expr abs($mom_helix_pitch)]]
    }
    set total_helix_angle $helix_angle
    # IPA Address: maxi degres is +/- 5400 deg. on helix interpolation
    set ipa_repeat [expr abs(int($nturn+$tmp_add_angle/360.0))+1]
    for {set i 1} {$i <= [expr abs($ipa_repeat) - 15]} {incr i 15} {
      set helix_angle [expr $helix_direction * 5400]
      set current_pos [expr $mom_prev_pos($tool_axis) + ($mom_helix_pitch * 15)]
      set helix_height [expr $current_pos - $mom_prev_pos($tool_axis)]
      LIB_GE_command_buffer HELIX_MOVE
      LIB_GE_command_buffer {MOM_do_template helix_move} @OUTPUT
      LIB_GE_command_buffer_output
      set mom_prev_pos($tool_axis) $current_pos
    }
    set helix_angle [expr (abs($total_helix_angle) - (($i-1)*360)) * $helix_direction]

    set helix_height [expr $mom_pos($tool_axis) - $mom_prev_pos($tool_axis)]
  }

  if {($mom_output_unit == "MM" && ![EQ_is_equal $helix_height 0 0.001]) ||\
      ($mom_output_unit == "IN" && ![EQ_is_equal $helix_height 0 0.00004])} {
    LIB_GE_command_buffer HELIX_MOVE_END
    LIB_GE_command_buffer {MOM_do_template helix_move} @OUTPUT
    LIB_GE_command_buffer_output
  }

  # reset XYZ otherwise TA will not be output
  LIB_GE_command_buffer STOP_INIT
  LIB_GE_command_buffer {MOM_do_template stop_init CREATE} @OUTPUT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_opstop_LIB {mess} {
  global mom_opstop_text mom_opstop_text_defined

  set commandcheck(MOM_opstop_LIB_ENTRY) [llength [info commands MOM_opstop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_opstop_text_defined] && $mom_opstop_text_defined == 1} {
      LIB_GE_command_buffer MOM_opstop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "along_with_stop"} {
          MOM_do_template opstop BUFFER
        } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_opstop_text" "output_1"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_opstop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_opstop_LIB
      LIB_GE_command_buffer {
        MOM_do_template opstop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_opstop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "along_with_opstop"} {
        MOM_do_template opstop BUFFER
      } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_1"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_AFTER_MSG
  }

  LIB_GE_command_buffer MOM_opstop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_opstop_text]} {unset mom_opstop_text}
  if {[hiset mom_opstop_text_defined]} {unset mom_opstop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_stop_LIB {mess} {
  global mom_stop_text mom_stop_text_defined

  set commandcheck(MOM_stop_LIB_ENTRY) [llength [info commands MOM_stop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_stop_text_defined] && $mom_stop_text_defined == 1} {
      LIB_GE_command_buffer MOM_stop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
          MOM_do_template stop BUFFER
        } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_stop_text" "output_1"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_stop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_stop_LIB
      LIB_GE_command_buffer {
        MOM_do_template stop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_stop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
        MOM_do_template stop BUFFER
      } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_1"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_AFTER_MSG
  }
  LIB_GE_command_buffer MOM_stop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_stop_text]} {unset mom_stop_text}
  if {[hiset mom_stop_text_defined]} {unset mom_stop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_nurbs_move_LIB {} {

  set commandcheck(MOM_nurbs_move_LIB_ENTRY) [llength [info commands MOM_nurbs_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_start_LIB {} {

  set commandcheck(MOM_contour_start_LIB_ENTRY) [llength [info commands MOM_contour_start_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_end_LIB {} {

  set commandcheck(MOM_contour_end_LIB_ENTRY) [llength [info commands MOM_contour_end_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_cutcom_on_LIB {} {
  global mom_kin_is_turbo_output mom_operation_type mom_path_name
  global lib_flag

  set commandcheck(MOM_cutcom_on_LIB_ENTRY) [llength [info commands MOM_cutcom_on_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cutcom_on_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_on_LIB_ENTRY)} {MOM_cutcom_on_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_kin_is_turbo_output} {
    LIB_SPF_turbo_status "disable"
  }
  if {[CONF_CTRL_setting read_ahead_number] > 0} {
    if { ![string match "Thread Milling" $mom_operation_type] && ![string match "Cylinder Milling" $mom_operation_type]} {
      MOM_add_to_line_buffer end " M120 LA[CONF_CTRL_setting read_ahead_number]"
    }
  }

  LIB_GE_command_buffer MOM_cutcom_on_LIB_CHECK,SIM
  LIB_GE_command_buffer {
    if {$lib_flag(mode_current_status) == "sim"} {
      LIB_GE_abort_message "INS->$mom_path_name<- : CUTCOM event is generated with simultaneous mode activated" "Not allowed, Please check"
    }
  } @ABORT_MESSAGE
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cutcom_on_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_on_LIB_ENTRY)} {MOM_cutcom_on_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_gohome_move_LIB {} {
  global feed_mode mom_feed_rate mom_kin_rapid_feed_rate mom_motion_type

  set commandcheck(MOM_gohome_move_LIB_ENTRY) [llength [info commands MOM_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_motion_type == "GOHOME_DEFAULT"} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
  } else {
    if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
      if {[EQ_is_ge $mom_feed_rate $mom_kin_rapid_feed_rate]} {
        MOM_rapid_move_LIB
      } else {
        MOM_linear_move_LIB
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_path_LIB {} {

  global lib_flag
  global mom_next_oper_has_tool_change mom_current_oper_is_last_oper_in_program mom_next_main_mcs mom_main_mcs
  global mom_path_name mom_operation_name mom_machine_mode mom_out_angle_pos mom_kin_is_turbo_output mom_tool_axis
  global mom_flip_a_axis mom_tool_holder_angle_for_cutting
  global lib_pretreatment mom_tool_pitch mom_polar_status mom_coordinate_output_mode lib_flag
  global lib_sys_tool_change_pos mom_sys_home_pos
  global mom_output_mcs_name lib_parameter nxt_oper_tool_axis
  global lib_prev_tool_name mom_next_tool_name

  set commandcheck(MOM_end_of_path_LIB_ENTRY) [llength [info commands MOM_end_of_path_LIB_ENTRY]]
  set commandcheck(LIB_unset_variables_in_end_of_path) [llength [info commands LIB_unset_variables_in_end_of_path]]

  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check "spindle" ;# to be sure S and M_spindle addresses are enable for next operation

  if {[CONF_CTRL_setting turbo_mode] == 1} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode disable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {[info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE"} {
          if {[llength [info commands MOM_set_turbo_feedrate_set]]} {MOM_set_turbo_feedrate_set ON}
  }

  if {$mom_machine_mode != "TURN" && [CONF_CTRL_moves polar_off_end_of_path] == "OFF"} {
    set mom_polar_status OFF
    set mom_coordinate_output_mode OFF
  }

  if {![info exists mom_output_mcs_name($mom_operation_name)]}      {set mom_output_mcs_name($mom_operation_name) $mom_main_mcs}
  if {![info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1])]} {set mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) $mom_next_main_mcs}

  # mom_pos(3) and mom_pos(4) are not overwritten if there is an CSYS-Rotation with Toolaxis Z and parallel to TA
  # PR10021397: compare last tool axis of current operation with first tool axis of next operation,
  # because mom_tool_axis saved in pretreatment is always from last motion event.
  if {[LIB_SPF_get_pretreatment "init_tool_axis,0" 1] == ""} {
    array set nxt_oper_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  } else {
    array set nxt_oper_tool_axis "0 [LIB_SPF_get_pretreatment "init_tool_axis,0" 1] 1 [LIB_SPF_get_pretreatment "init_tool_axis,1" 1] 2 [LIB_SPF_get_pretreatment "init_tool_axis,2" 1]"
  }
  if {([CONF_CTRL_moves reset_rotary_axis_end_of_path] == "ON" && ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] &&\
    [LIB_SPF_get_pretreatment axis_mode next] != "SIMULTANEOUS") ||\
     ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

  if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES" ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) && [CONF_CTRL_moves safety_motion_when_mcs_changes] == 1)} {
    switch -- $mom_machine_mode {
      "TURN" {
        LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,TURN
        LIB_GE_command_buffer {LIB_ROTARY_positioning_reset_turn} @RESET_POS_TURN
        LIB_GE_command_buffer {LIB_TURNING_mode end} @TURN_END
        LIB_GE_command_buffer_output
      }
      "MILL" {
        if {$lib_flag(tool_path_motion) > 0} {
          if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,SIM
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_simultaneous_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,POS
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $::lib_sav_kin_machine_type == "3_axis_mill" || $lib_flag(tool_axis_zm) == 1} {
                LIB_ROTARY_absolute_reset
              } else {
                set tmp_parameter(plane,motion_reset) [CONF_ITNC530_PLANE motion_reset]
                CONF_ITNC530_PLANE set motion_reset [CONF_ITNC530_PLANE motion_reset_last]
                LIB_ROTARY_positioning_reset
                set lib_flag(tool_path_motion) 0
                if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
                CONF_ITNC530_PLANE set motion_reset $tmp_parameter(plane,motion_reset)
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          }
        }
      }
    }

    LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,COMMON

    if {$::mom_oper_tool != "NONE" || ([info exist lib_prev_tool_name] && $lib_prev_tool_name != $mom_next_tool_name) } {
    LIB_GE_command_buffer {LIB_local_origin_reset} @LOCAL_ORIG_RESET
    LIB_GE_command_buffer {
      if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
        LIB_WRITE_coolant off
      }
    } @COOLANT_OFF
    LIB_GE_command_buffer {
      if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
        LIB_SPINDLE_end
      }
    } @SPINDLE_OFF
    LIB_GE_command_buffer {
      if {$mom_current_oper_is_last_oper_in_program == "YES"} {
        if {[CONF_CTRL_moves return_end_of_pgm] != ""} {
          VMOV 3 mom_sys_home_pos tmp_sys_home_pos
          VMOV 3 lib_sys_tool_change_pos mom_sys_home_pos
          LIB_RETURN_move CONF_CTRL_moves return_end_of_pgm
          VMOV 3 tmp_sys_home_pos mom_sys_home_pos
        }
      } else {
        if {[CONF_CTRL_moves return_tool_change_pos] != ""} {
          VMOV 3 mom_sys_home_pos tmp_sys_home_pos
          VMOV 3 lib_sys_tool_change_pos mom_sys_home_pos
          LIB_RETURN_move CONF_CTRL_moves return_tool_change_pos
          VMOV 3 tmp_sys_home_pos mom_sys_home_pos
        }
      }
    } @RETURN_MOVE
    LIB_GE_command_buffer {
      if {$mom_current_oper_is_last_oper_in_program == "YES" && [CONF_CTRL_CYCL32 cycle32_reset_end] && $lib_flag(cycl32,status)} {

        set ::lib_parameter_cycle(32) "OFF"
        LIB_CTRL_cycle_32 1

        set lib_flag(cycl32,status) 0
      }
    } @CYC32_OFF
    }

    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 0

  } else {

    switch -- $mom_machine_mode {
      "TURN" {

        set nxt_flip_a_axis [LIB_SPF_get_pretreatment mom_flip_a_axis 1]
        set nxt_tool_holder_angle_for_cutting [LIB_SPF_get_pretreatment mom_tool_holder_angle_for_cutting 1]

        if {![info exists mom_tool_holder_angle_for_cutting] || ![EQ_is_equal $nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting]} {

          LIB_GE_command_buffer TURN_HOLDER_ORIENT_CHANGE

          # check if B axis position change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {
            if {[CONF_CTRL_moves return_safety_pos] != ""} {
              LIB_RETURN_move CONF_CTRL_moves return_safety_pos
            }
          } @RETURN_MOVE
          LIB_GE_command_buffer {LIB_ROTARY_positioning_reset_turn} @RESET_POS_TURN

          LIB_GE_command_buffer_output

        } elseif {[info exists mom_flip_a_axis] && $nxt_flip_a_axis != $mom_flip_a_axis} {

          LIB_GE_command_buffer TURN_TOOL_FLIP_CHANGE
          # check if spindle direction change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_ROTARY_positioning_reset_turn} @RESET_POS_TURN

          LIB_GE_command_buffer_output
        }

      }
      "MILL" {

        LIB_GE_command_buffer MILL_AXIS_CHANGE

        # If the variable does not exist in the query, an blank is returned

        LIB_GE_command_buffer {

          if {[LIB_SPF_pt_exists_not_empty "out_angle_pos_last,0" 0]} {
            set out_angle_pos(0) [LIB_SPF_get_pretreatment "out_angle_pos_last,0" 0]
            set out_angle_pos(1) [LIB_SPF_get_pretreatment "out_angle_pos_last,1" 0]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set out_angle_pos(0) $mom_out_angle_pos(0)
            set out_angle_pos(1) $mom_out_angle_pos(1)
          }

          if {[LIB_SPF_pt_exists_not_empty "mom_out_angle_pos,0" 1]} {
            set nxt_out_angle_pos(0) [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 1]
            set nxt_out_angle_pos(1) [LIB_SPF_get_pretreatment "mom_out_angle_pos,1" 1]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set nxt_out_angle_pos(0) $out_angle_pos(0)
            set nxt_out_angle_pos(1) $out_angle_pos(1)
          }

          # PR#9554274 incase operation's current status is not same as axis mode. It happened if there is only rapid motions in operation like GMC operation.
          if {([LIB_SPF_get_pretreatment axis_mode] != [LIB_SPF_get_pretreatment axis_mode 1] && ([LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || [LIB_SPF_get_pretreatment axis_mode 1] == "SIMULTANEOUS") )||\
              [LIB_SPF_is_floating $nxt_out_angle_pos(0)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(0) $out_angle_pos(0) $::mom_kin_4th_axis_min_incr] ||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(1)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(1) $out_angle_pos(1) $::mom_kin_5th_axis_min_incr] ||\
            ($lib_flag(mode_current_status) == "sim" &&  [LIB_SPF_get_pretreatment axis_mode] == "POSITIONING")} {
            if {$mom_machine_mode == "MILL" && $lib_flag(tool_path_motion) > 0} {
              if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
                if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                  LIB_ROTARY_absolute_reset
                } else {
                LIB_ROTARY_simultaneous_reset
                }
              } else {
                #!!! if next op has different mom_out_angle_pos reset as well
                # (maybe compare current and next angle from Pretreatment)

                if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {
                  LIB_ROTARY_absolute_reset
                } else {
                LIB_ROTARY_positioning_reset
                }
              }
              set lib_flag(tool_path_motion) 0
              if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
            }
          }
        } @RESET

        LIB_GE_command_buffer_output

      }
    }

  }

  # unset Variables if needed
  LIB_GE_command_buffer LIB_unset_variables_in_end_of_path
  LIB_GE_command_buffer {if {$commandcheck(LIB_unset_variables_in_end_of_path)} {LIB_unset_variables_in_end_of_path}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
# * store oper info (for operation list)
# * mom_next_oper_has_tool_change == "YES"
# * mom_next_oper_is_last_oper_in_program == "YES"
# * mom_next_main_mcs != mom_main_mcs
# * check rot axis change PT
# if abs
# LIB_ROTARY_absolute_reset
# if sim
# LIB_ROTARY_simultaneous_reset
# if pos
# LIB_ROTARY_positioning_reset
# * retract before set axes (if needed) PT
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_unset_variables_in_end_of_path {} {
  if {[info exists ::lib_last_rapid_pos]}   {unset ::lib_last_rapid_pos}
  if {[info exists ::lib_parameter_cycle]}  {unset ::lib_parameter_cycle}
  if {[info exists ::lib_isset_params]}     {unset ::lib_isset_params}
  if {[info exists ::mom_cutcom_type]}    {unset ::mom_cutcom_type}
  if {[info exists ::mom_cycle_Q202]}     {unset ::mom_cycle_Q202}
  unset -nocomplain ::mom_cycle_Q253
  if {[info exists ::lib_spf(do_convert_point)]}    {unset ::lib_spf(do_convert_point)}

  set ::lib_parameter(special_cycle,name) ""
  set ::lib_parameter(special_cycle,call) ""

  if {$::mom_next_oper_has_tool_change == "YES" || $::mom_current_oper_is_last_oper_in_program == "YES"} {
    if {[info exists ::mom_tool_pitch]} {unset ::mom_tool_pitch}
  }
}

# <Internal Documentation>
#
#  Unset Variables in End_of_path
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_program_LIB {} {

  global lib_nc_header_name

  set commandcheck(MOM_end_of_program_LIB_ENTRY) [llength [info commands MOM_end_of_program_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer TOOL_CHANGE_EOP
  LIB_GE_command_buffer {
    MOM_suppress once S F_tool_call DL_tool_call DR_tool_call
    switch -- [join [CONF_CTRL_tool tool_change_eop]] {
      "off" {
        # nothing
      }
      "first_tool" {
        set ::mom_tool_name $::mom_next_tool_name
        set ::mom_tool_number $::mom_next_tool_number
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "unload_tool" {
        set ::lib_tool_number_zero 0
        MOM_do_template tool_change_zero
      }
      "default" {
        if {[string is integer -strict [CONF_CTRL_tool tool_change_eop]]} {
          set ::mom_tool_number [CONF_CTRL_tool tool_change_eop]
        } else {
          set ::mom_tool_name [CONF_CTRL_tool tool_change_eop]
        }
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
    }
  } @TOOL_CHANGE_END_OF_PROGRAM
  LIB_GE_command_buffer_output
  LIB_GE_command_buffer END_OF_PROGRAM
  LIB_GE_command_buffer {
    MOM_do_template end_of_program
  } @END_OF_PROG
  LIB_GE_command_buffer {
    #MOM_suppress once N
    MOM_do_template trailer_program
  } @OUTPUT_END
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_reset {} {
  global mom_sys_rapid_code mom_sys_linear_code
  global lib_flag

  set commandcheck(LIB_ROTARY_absolute_reset_ENTRY) [llength [info commands LIB_ROTARY_absolute_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
      MOM_force off X Y Z
      set mom_sys_rapid_code "L"
      set mom_sys_linear_code "L"
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
#  Switch off absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_reset {} {

  global mom_sys_rapid_code mom_sys_linear_code
  global lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
      MOM_force off X Y Z
      set mom_sys_rapid_code "L"
      set mom_sys_linear_code "L"
    }
    if {[CONF_SPF_sim_kin 4th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 4th_axis_has_limit $::mom_sys_4th_axis_has_limits}
    if {[CONF_SPF_sim_kin 5th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 5th_axis_has_limit $::mom_sys_5th_axis_has_limits}
    if {(![CONF_SPF_sim_kin 4th_axis_has_limit] || ![CONF_SPF_sim_kin 5th_axis_has_limit]) && [CONF_CTRL_setting m126_output_supported] == 1} {
      LIB_GE_command_buffer OPTIMIZED_ROT_AXIS_OFF
      LIB_GE_command_buffer {MOM_do_template optimized_rot_axis_off} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer FUNCTION_RESET
    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_mode] == "TCPM"} {
        MOM_output_literal "FUNCTION RESET TCPM"
      } else {
        MOM_do_template output_m129
      }
    } @OUTPUT
    LIB_GE_command_buffer_output
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
#  Switch off simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAFOOF
# Heidenhain: M129 / TCPM
# Fanuc: G49
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset {} {

  global mom_cutter_data_output_indicator mom_sys_rapid_code mom_sys_linear_code
  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_reset_ENTRY) [llength [info commands LIB_ROTARY_positioning_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {$mom_cutter_data_output_indicator == 2 && [CONF_CTRL_setting 3d_cutcom_output] != 0} {
      set mom_sys_rapid_code "L"
      set mom_sys_linear_code "L"
    }
    LIB_CSYS_plane_output_reset
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
# Switch off positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_init {} {
  global mom_sys_rapid_code mom_sys_linear_code mom_kin_is_turbo_output
  global lib_flag mom_post_in_simulation

  set commandcheck(LIB_ROTARY_absolute_init_ENTRY) [llength [info commands LIB_ROTARY_absolute_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting absolute_output] != "vector" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }
  if {[CONF_CTRL_setting absolute_output] == "vector"} {
    MOM_force once X_vector Y_vector Z_vector
    MOM_enable_address X_vector Y_vector Z_vector
    MOM_disable_address fourth_axis fifth_axis
    set mom_sys_rapid_code "LN"
    set mom_sys_linear_code "LN"
    MOM_force always X Y Z
  } else {
    MOM_force once fourth_axis fifth_axis
    if {[string match "*4_axis*" $::lib_sav_kin_machine_type]} {
      MOM_enable_address fourth_axis
    } elseif {[string match "*5_axis*" $::lib_sav_kin_machine_type]} {
      MOM_enable_address fourth_axis fifth_axis
    }
    MOM_disable_address X_vector Y_vector Z_vector
  }
  set lib_flag(mode_current_status) "std"

  LIB_GE_command_buffer UNCLAMP
  LIB_GE_command_buffer {LIB_CTRL_unclamp_axis} @UNCLAMP
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
# Switch on simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAORI
# Heidenhain: M128 / TCPM
# Fanuc: G43.4
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_init {} {

  global mom_sys_rapid_code mom_sys_linear_code mom_kin_is_turbo_output mom_post_in_simulation
  global lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_init_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_output] != "vector" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }
  LIB_CTRL_unclamp_axis

  if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {return}
  if {$lib_flag(mode_current_status) != "sim"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_force once X_vector Y_vector Z_vector
      MOM_enable_address X_vector Y_vector Z_vector
      MOM_disable_address fourth_axis fifth_axis
      MOM_force always X Y Z
      set mom_sys_rapid_code "LN"
      set mom_sys_linear_code "LN"
      #  XYZ must always be output with LN , cannot do decompose
      set lib_flag(decompose_first_move_sim) 0
    } else {
      MOM_force once fourth_axis fifth_axis
      MOM_enable_address fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }

    LIB_GE_command_buffer MILL,SIMULTANEOUS

    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_mode] == "TCPM"} {
        MOM_do_template set_tcpm_on
      } else {
        MOM_do_template output_m128
      }
      MOM_force once X Y Z
    } @ROTARY_SIMULTANEOUS

    LIB_GE_command_buffer_output
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    set lib_flag(mode_current_status) "sim"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
# Switch on simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAORI
# Heidenhain: M128 / TCPM
# Fanuc: G43.4
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation mom_cutter_data_output_indicator mom_sys_rapid_code mom_sys_linear_code
  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_init_ENTRY) [llength [info commands LIB_ROTARY_positioning_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  MOM_disable_address X_vector Y_vector Z_vector

  if {$mom_cutter_data_output_indicator == 2 && [CONF_CTRL_setting 3d_cutcom_output] != 0} {
     set mom_sys_rapid_code "LN"
     set mom_sys_linear_code "LN"
  }

  if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {return}
  if {$lib_flag(mode_current_status) != "pos"} {
    if {[CONF_ITNC530_PLANE reset_before] == 1} {
      LIB_CSYS_plane_output_reset
    }
    LIB_CSYS_plane_output_init
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
# Switch on positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: AROT / CYCLE800
# Heidenhain: CYCL DEF 19 or PLANE SPATIAL
# Fanuc: G68.2
#____________________________________________________________________________________________
proc LIB_CTRL_KINEMATICS_set_simultanous_kin {} {

  global lib_sav_kin_machine_type lib_spf lib_flag
  global mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_4th_axis_output_limit_min mom_4th_axis_output_limit_max mom_5th_axis_output_limit_min mom_5th_axis_output_limit_max
  global mom_sys_rapid_code mom_sys_linear_code

  set commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY) [llength [info commands LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_sim_kin 4th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 4th_axis_has_limit $::mom_sys_4th_axis_has_limits}
  if {[CONF_SPF_sim_kin 5th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 5th_axis_has_limit $::mom_sys_5th_axis_has_limits}

  if {[CONF_CTRL_setting m126_output_supported] == 1} {
    if {$lib_flag(local_namespace_output)} {
      if {![CONF_SPF_sim_kin 4th_axis_has_limit]} {
        LIB_GE_command_buffer OPTIMIZED_ROT_AXIS_4TH
        LIB_GE_command_buffer {MOM_do_template optimized_rot_axis_on} @OUTPUT
        LIB_GE_command_buffer_output
        if {![info exists lib_spf(do_convert_point)]} {
          if {[llength [info commands "MOM_limit_output_angle"]]} {
            MOM_limit_output_angle ON 4 [expr 360.0-$::mom_kin_4th_axis_min_incr] 0.0
          # set mom_kin_4th_axis_min_limit $mom_4th_axis_output_limit_min
          # set mom_kin_4th_axis_max_limit $mom_4th_axis_output_limit_max
          } else {
            set mom_kin_4th_axis_min_limit 0.0
            set mom_kin_4th_axis_max_limit 359.9999
          }
        }
      }

      if {![CONF_SPF_sim_kin 5th_axis_has_limit]} {
        LIB_GE_command_buffer OPTIMIZED_ROT_AXIS_5TH
        LIB_GE_command_buffer {MOM_do_template optimized_rot_axis_on} @OUTPUT
        LIB_GE_command_buffer_output
        if {![info exists lib_spf(do_convert_point)]} {
          if {[llength [info commands "MOM_limit_output_angle"]]} {
            MOM_limit_output_angle ON 5 [expr 360.0-$::mom_kin_5th_axis_min_incr] 0.0
          # set mom_kin_5th_axis_min_limit $mom_5th_axis_output_limit_min
          # set mom_kin_5th_axis_max_limit $mom_5th_axis_output_limit_max
          } else {
            set mom_kin_5th_axis_min_limit 0.0
            set mom_kin_5th_axis_max_limit 359.9999
          }
        }
      }

    } else {
      if {![CONF_SPF_sim_kin 4th_axis_has_limit]} {
        LIB_GE_command_buffer OPTIMIZED_ROT_AXIS_4TH
        LIB_GE_command_buffer {MOM_do_template optimized_rot_axis_on} @OUTPUT
        LIB_GE_command_buffer_output
        if {![info exists lib_spf(do_convert_point)]} {
          if {$lib_sav_kin_machine_type != "5_axis_dual_head" && ([CONF_SPF_sim_kin 4th_axis] == "real" && [CONF_SPF_sim_kin 5th_axis] == "real")} {
            if {[llength [info commands "MOM_limit_output_angle"]]} {
              MOM_limit_output_angle ON 5 [expr 360.0-$::mom_kin_5th_axis_min_incr] 0.0
            # set mom_kin_5th_axis_min_limit $mom_5th_axis_output_limit_min
            # set mom_kin_5th_axis_max_limit $mom_5th_axis_output_limit_max
            } else {
              set mom_kin_5th_axis_min_limit 0.0
              set mom_kin_5th_axis_max_limit 359.9999
            }
          } else {
            if {[llength [info commands "MOM_limit_output_angle"]]} {
              MOM_limit_output_angle ON 4 [expr 360.0-$::mom_kin_4th_axis_min_incr] 0.0
            # set mom_kin_4th_axis_min_limit $mom_4th_axis_output_limit_min
            # set mom_kin_4th_axis_max_limit $mom_4th_axis_output_limit_max
            } else {
              set mom_kin_4th_axis_min_limit 0.0
              set mom_kin_4th_axis_max_limit 359.9999
            }
          }
        }
      }

      if {![CONF_SPF_sim_kin 5th_axis_has_limit]} {
        LIB_GE_command_buffer OPTIMIZED_ROT_AXIS_5TH
        LIB_GE_command_buffer {MOM_do_template optimized_rot_axis_on} @OUTPUT
        LIB_GE_command_buffer_output
        if {![info exists lib_spf(do_convert_point)]} {
          if {$lib_sav_kin_machine_type != "5_axis_dual_head" && ([CONF_SPF_sim_kin 4th_axis] == "real" && [CONF_SPF_sim_kin 5th_axis] == "real")} {
            if {[llength [info commands "MOM_limit_output_angle"]]} {
              MOM_limit_output_angle ON 4 [expr 360.0-$::mom_kin_4th_axis_min_incr] 0.0
            # set mom_kin_4th_axis_min_limit $mom_4th_axis_output_limit_min
            # set mom_kin_4th_axis_max_limit $mom_4th_axis_output_limit_max
            } else {
              set mom_kin_4th_axis_min_limit 0.0
              set mom_kin_4th_axis_max_limit 359.9999
            }
          } else {
            if {[llength [info commands "MOM_limit_output_angle"]]} {
              MOM_limit_output_angle ON 5 [expr 360.0-$::mom_kin_5th_axis_min_incr] 0.0
            # set mom_kin_5th_axis_min_limit $mom_5th_axis_output_limit_min
            # set mom_kin_5th_axis_max_limit $mom_5th_axis_output_limit_max
            } else {
              set mom_kin_5th_axis_min_limit 0.0
              set mom_kin_5th_axis_max_limit 359.9999
            }
          }
        }
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
#
# Switch on shortest distance for simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: Leader "C=DC("  Trailer ")"
# Heidenhain: M126
#____________________________________________________________________________________________
proc LIB_RETURN_move {Addresses {property ""}} {
  global mom_sys_home_pos mom_prev_pos mom_prev_out_angle_pos
  global lib_ta_return_value lib_flag mom_operation_type

  set commandcheck(LIB_RETURN_move_ENTRY) [llength [info commands LIB_RETURN_move_ENTRY]]

  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[string match $mom_operation_type "Device Generic Motion"]} {
       return
  }

  if {$property != ""} {
    set object $Addresses
    set Addresses [$Addresses $property]
  } else {
    set object ""
  }

  set line_nbr -1
  set break_it 0
        foreach axes $Addresses {
    incr line_nbr
    if {[catch {foreach axis $axes {}}]} {
      set axes [list $axes]
    }

    foreach axis $axes {

      switch -- $axis {
        "Z" {
                #WRITE_coolant off
                if {[CONF_CTRL_moves return_mode] == "value"} {
                              MOM_force once Z_home
            MOM_suppress once X_home Y_home
            LIB_GE_command_buffer AXIS_MOVE_Z
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Z
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Z
            LIB_GE_command_buffer {MOM_do_template return_home_Z} @RETURN_HOME_Z
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
                MOM_force once Z_home
        }
        "Y" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once Y_home
            MOM_suppress once X_home Z_home
            LIB_GE_command_buffer AXIS_MOVE_Y
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Y
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Y
            LIB_GE_command_buffer {MOM_do_template return_home_Y} @RETURN_HOME_Y
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once Y_home
        }
        "X" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once X_home
            MOM_suppress once Y_home Z_home
            LIB_GE_command_buffer AXIS_MOVE_X
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_X
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_X
            LIB_GE_command_buffer {MOM_do_template return_home_X} @RETURN_HOME_X
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once X_home
        }
        "YX" -
        "XY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once X_home Y_home
            MOM_suppress once Z_home
            LIB_GE_command_buffer AXIS_MOVE_XY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_XY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_XY
            LIB_GE_command_buffer {MOM_do_template return_home_XY} @RETURN_HOME_XY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once X_home Y_home
        }
        "XZ" -
        "ZX" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once X_home Z_home
            MOM_suppress once Y_home
            LIB_GE_command_buffer AXIS_MOVE_ZX
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZX
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZX
            LIB_GE_command_buffer {MOM_do_template return_home_ZX} @RETURN_HOME_ZX
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once Z_home X_home
        }
        "YZ" -
        "ZY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once Y_home Z_home
            MOM_suppress once X_home
            LIB_GE_command_buffer AXIS_MOVE_ZY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZY
            LIB_GE_command_buffer {MOM_do_template return_home_ZY} @RETURN_HOME_ZY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          MOM_force once Y_home Z_home
        }
        "TA" {
          if {[CONF_CTRL_moves return_mode] == "value"} {
            set lib_ta_return_value "MAX"
          } else {
            set lib_ta_return_value [CONF_CTRL_moves return_mode]
          }
          LIB_GE_command_buffer AXIS_MOVE_TA
            LIB_GE_command_buffer {MOM_do_template return_move_TA} @RETURN_MOVE_TA
            LIB_GE_command_buffer_output
        }
        "4th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]]} {
            MOM_force once fourth_axis
            LIB_GE_command_buffer AXIS_HOME_4TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th} @RETURN_HOME_4TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            MOM_force once fourth_axis
          }
        }
        "5th" {
          if {![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fifth_axis
            LIB_GE_command_buffer AXIS_HOME_5TH
            LIB_GE_command_buffer {MOM_do_template return_home_5th} @RETURN_HOME_5TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fifth_axis
          }
        }
        "4th5th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]] || ![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fourth_axis fifth_axis
            LIB_GE_command_buffer AXIS_HOME_45TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th5th} @RETURN_HOME_45TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fourth_axis fifth_axis
          }
        }
        "" {
                #Do Nothing
        }
        "default" {
          if {[LIB_SPF_exists_block_template $axes 1] == 1} {
            MOM_do_template $axes
          } elseif {[LIB_SPF_exists_block_template $axes 1] == -1 && ![catch {set dummy [MOM_do_template $axes CREATE]}]} {
            # Thats the case when 'MOM_has_definition_element' command does not exist (older NX versions)
            #legacy
            MOM_output_literal $dummy
          } else {
            if {$object == ""} {
              #when LIB_RETURN_move is not called with a conf_object as argument
              LIB_RETURN_move_LIB_ENTRY $axes
            } else {
              if {[info proc LIB_RETURN_move_LIB_ENTRY] == "LIB_RETURN_move_LIB_ENTRY"} {
                #legacy
                LIB_RETURN_move_LIB_ENTRY $axes
              } else {
                LIB_CONF_do_prop_custom_proc $object $property "no_special_syntax" $line_nbr
                set break_it 1
                break
              }
            }
          }
        }
      }
    }
    if {$break_it} {break}
  }
  set lib_flag(current_safety_position) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Documentation>
# Writes return motions to the NC-code. Settings for home motions (CONF_CTRL_moves return_mode)
# are taken into consideration for the output format of the return motions.
#
# <Arguments>
# Addresses
# String with space separated axis names that should perform a return move.
#   Valid options:
#   X / Y / Z / XY / ZX / ZY or a template name
# property
# Reserved argument.
#
# <Returnvalue>
# None.
#
# <Example>
# name: Example using axis names
# code: LIB_RETURN_move "Z XY"
# desc: Writes return moves for Z and then XY to the NC-code in Heidenhain-Format.
#      Result will be:
# L Z99999.9 FMAX M91
# L X99999.9 Y99999.9 FMAX M91
# <Example>
# name: Example using template names
# code: LIB_RETURN_move "custom_return_template1 custom_return_template2"
# desc: Assuming we have two custom specific block templates custom_return_template1 and custom_return_template2,
#      we can call them here by their name. It's okay to mix template names and axes names (see ex. 1)
#____________________________________________________________________________________________
proc LIB_main_origin_call {} {

  global mom_sys_leader mom_sys_trailer
  global mom_fixture_offset_value mom_origin
  global lib_main_zero_register lib_local_zero_register

  set commandcheck(LIB_main_origin_call_ENTRY) [llength [info commands LIB_main_origin_call_ENTRY]]

  LIB_GE_command_buffer LIB_main_origin_call_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_main_origin_call_ENTRY)} {LIB_main_origin_call_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_origin use_main] == 1 && [CONF_CTRL_origin local_origin_with_register] == 0} {
    if {![info exists mom_fixture_offset_value]} {set mom_fixture_offset_value [LIB_PT_get_header_var mom_fixture_offset_value]}
    set lib_main_zero_register $mom_fixture_offset_value
    LIB_GE_command_buffer MAIN_ZERO
    LIB_GE_command_buffer {MOM_do_template main_zero} @ZERO_OUTPUT
    LIB_GE_command_buffer_output
  }
  if {[CONF_CTRL_origin use_main] == 1 && [CONF_CTRL_origin local_origin_with_register] == 1} {
    if {![info exists mom_fixture_offset_value]} {set mom_fixture_offset_value [LIB_PT_get_header_var mom_fixture_offset_value]}
    if {![info exists lib_local_zero_register]} {set lib_local_zero_register -939}
    if {$lib_local_zero_register != $mom_fixture_offset_value} {
      set lib_local_zero_register $mom_fixture_offset_value
      LIB_GE_command_buffer LOCAL_ZERO
      LIB_GE_command_buffer {
        MOM_do_template cycl_def_7_0
      } @DATUM_SHIFT
      LIB_GE_command_buffer {
        MOM_do_template local_zero
      } @ZERO_OUTPUT
      LIB_GE_command_buffer_output
      set mom_origin(0) 0.0
      set mom_origin(1) 0.0
      set mom_origin(2) 0.0
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_main_origin_call_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_main_origin_call_ENTRY)} {LIB_main_origin_call_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Documentation>
# This procedure writes the NC code for the fixture offset of the active origin to the output file, when the property
# CONF_CTRL_origin use_main is set to On.
# <Example>
# name: Output active origin
# code: LIB_main_origin_call
# desc: Output when the fixture offset is set to 1:
# CYCL DEF 247 DATUM SETTING Q339=1 ; DATUM NUMBER
#____________________________________________________________________________________________
proc LIB_local_origin_call {} {
  global mom_fixture_offset_value mom_origin mom_sys_leader
  global lib_local_zero_register lib_flag mom_origin
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global mom_kin_machine_type
  if {$lib_flag(local_namespace_output) == 1} {
    LIB_SPF_local_csys_rotation
  } else {
    LIB_SPF_csys_3D_rotation
  }
  set mom_origin(0) $lib_coord_ref_X
  set mom_origin(1) $lib_coord_ref_Y
  set mom_origin(2) $lib_coord_ref_Z

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 0} {
    #MOM_output_literal "SEL TABLE \"${hermle_file_location}\\$mom_work_coordinate_table\""
    if {[CONF_CTRL_origin local_origin_with_register] == 1 && [CONF_CTRL_origin use_main] == 0} {
      set lib_local_zero_register $mom_fixture_offset_value
      LIB_GE_command_buffer LOCAL_ZERO
      LIB_GE_command_buffer {
        MOM_do_template cycl_def_7_0
      } @DATUM_SHIFT
      LIB_GE_command_buffer {
          MOM_do_template local_zero
      } @ZERO_OUTPUT
      LIB_GE_command_buffer_output
    } else {
      #offset
      set tmp(X) $mom_sys_leader(X)
      set tmp(Y) $mom_sys_leader(Y)
      set tmp(Z) $mom_sys_leader(Z)
      if {[CONF_CTRL_origin local_origin_with_register] == 1 && [CONF_CTRL_origin use_main] == 1} {
        set mom_sys_leader(X) "IX"
        set mom_sys_leader(Y) "IY"
        set mom_sys_leader(Z) "IZ"
      }
      LIB_output_local_zero_offset
        set mom_sys_leader(X) $tmp(X)
        set mom_sys_leader(Y) $tmp(Y)
        set mom_sys_leader(Z) $tmp(Z)

    }
    set lib_flag(local_origin_activated) 1
  }
}

# <Internal Documentation>
# Output the local origin call (CYCL DEF 7)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_local_origin_reset {} {
  global lib_flag mom_origin mom_sys_leader
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global mom_kin_machine_type lib_save_mom_origin mom_origin

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 1} {
    if {[CONF_CTRL_origin local_origin_with_register] == 0} {
      set mom_origin(0) 0.0
      set mom_origin(1) 0.0
      set mom_origin(2) 0.0
      set tmp(X) $mom_sys_leader(X)
      set tmp(Y) $mom_sys_leader(Y)
      set tmp(Z) $mom_sys_leader(Z)
      if {[CONF_CTRL_origin local_origin_with_register] == 1 && [CONF_CTRL_origin use_main] == 1} {
        set mom_sys_leader(X) "IX"
        set mom_sys_leader(Y) "IY"
        set mom_sys_leader(Z) "IZ"
      }
      LIB_output_local_zero_offset
        set mom_sys_leader(X) $tmp(X)
        set mom_sys_leader(Y) $tmp(Y)
        set mom_sys_leader(Z) $tmp(Z)
    } else {
      # reset origin to mcs_G54
      set mom_origin(0) [expr -1*$lib_coord_ref_X]
      set mom_origin(1) [expr -1*$lib_coord_ref_Y]
      set mom_origin(2) [expr -1*$lib_coord_ref_Z]
      set tmp(X) $mom_sys_leader(X)
      set tmp(Y) $mom_sys_leader(Y)
      set tmp(Z) $mom_sys_leader(Z)
      if {[CONF_CTRL_origin local_origin_with_register] == 1 && [CONF_CTRL_origin use_main] == 1} {
        set mom_sys_leader(X) "IX"
        set mom_sys_leader(Y) "IY"
        set mom_sys_leader(Z) "IZ"
      }
      LIB_output_local_zero_offset
      set mom_sys_leader(X) $tmp(X)
      set mom_sys_leader(Y) $tmp(Y)
      set mom_sys_leader(Z) $tmp(Z)
      set mom_origin(0) 0.0
      set mom_origin(1) 0.0
      set mom_origin(2) 0.0
      LIB_GE_copy_var_range lib_save_mom_origin mom_origin
    }
    set lib_flag(local_origin_activated) 0
  }
}

# <Internal Documentation>
# Output the main origin reset (CYCL DEF 7)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_output_local_zero_offset {} {
  global lib_save_mom_origin mom_origin

  if {![info exist lib_save_mom_origin(0)]} {
    if {![EQ_is_zero $mom_origin(0)] || ![EQ_is_zero $mom_origin(1)] || ![EQ_is_zero $mom_origin(2)]} {
      LIB_GE_command_buffer LOCAL_OFFSET
      LIB_GE_command_buffer {
        MOM_do_template cycl_def_7_0
        MOM_force once X Y Z
      } @DATUM_SHIFT
      LIB_GE_command_buffer {
        MOM_do_template local_zero_xoffset ;# mom_origin(0)
      } @OUTPUT_O0
      LIB_GE_command_buffer {
        MOM_do_template local_zero_yoffset ;# mom_origin(1)
      } @OUTPUT_O1
      LIB_GE_command_buffer {
        MOM_do_template local_zero_zoffset ;# mom_origin(2)
      } @OUTPUT_O2
      LIB_GE_command_buffer_output
      MOM_force once X Y Z
    }
    LIB_GE_copy_var_range lib_save_mom_origin mom_origin
  } else {
      if {![VEC3_is_equal lib_save_mom_origin mom_origin]} {
      LIB_GE_command_buffer LOCAL_ZERO_OFFSET
      LIB_GE_command_buffer {
        MOM_do_template cycl_def_7_0
        MOM_force once X Y Z
      } @DATUM_SHIFT
      LIB_GE_command_buffer {
        MOM_do_template local_zero_xoffset ;# mom_origin(0)
      } @OUTPUT_O0
      LIB_GE_command_buffer {
        MOM_do_template local_zero_yoffset ;# mom_origin(1)
      } @OUTPUT_O1
      LIB_GE_command_buffer {
        MOM_do_template local_zero_zoffset ;# mom_origin(2)
      } @OUTPUT_O2
      LIB_GE_command_buffer_output
      MOM_force once X Y Z
      LIB_GE_copy_var_range lib_save_mom_origin mom_origin
    }
  }
}

# <Documentation>
# This procedure writes the NC code for the DATUM SHIFT definition
# for the active local coordinate system to the output file,
# when the property CONF_CTRL_origin use_local is set to On.
# The datum shift output format is also controlled by the property
# CONF_CTRL_origin local_origin_with_register.
# <Returnvalue>
# None.
# <Example>
# name: Example 1
# code: LIB_output_local_zero_offset
# desc: Default output for datum shift of local origin when
# CONF_CTRL_origin local_origin_with_register is set to offset:
# CYCL DEF 7.0 DATUM SHIFT
# CYCL DEF 7.1 X+500.
# CYCL DEF 7.2 Y+500.
# CYCL DEF 7.3 Z+0.
#
# Default output for datum shift of local origin when
# CONF_CTRL_origin local_origin_with_register is set to register:
# CYCL DEF 7.0 DATUM SHIFT
# CYCL DEF 7.1 #1
#
# Default output for reset of local origin:
# CYCL DEF 7.0 DATUM SHIFT
# CYCL DEF 7.1 X+0.
# CYCL DEF 7.2 Y+0.
# CYCL DEF 7.3 Z+0.
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_init {} {


  global lib_flag lib_parameter lib_sav_kin_machine_type
  global mom_sys_leader mom_out_angle_pos
  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_out_ang_fourth lib_coord_out_ang_fifth

  # In new local csys mode, enter local namespace and switch output mode before plane init
  LIB_GE_command_buffer LOCAL_CSYS_INIT
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_set}} @LOCAL_POS_SET
  LIB_GE_command_buffer_output

  LIB_CTRL_unclamp_axis
  LIB_rotate_axis_before_plane

  set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 1

  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_19" {

      LIB_GE_command_buffer CYCLE_19

      LIB_GE_command_buffer {MOM_do_template cycl_def_19_0} @CYCLE_19.0
      if {[CONF_ITNC530_PLANE definition] == "SPATIAL"} {
        LIB_GE_copy_var_range lib_coord_out_ang_ lib_coord_ang_
        LIB_GE_command_buffer {
          MOM_force once A B C
          MOM_do_template cycl_def_19_1_init
        } @CYCLE_19.1
      } else {
        set tmp_fourth [subst $[subst lib_coord_ang_$mom_sys_leader(fourth_axis)]]
        set tmp_fifth  [subst $[subst lib_coord_ang_$mom_sys_leader(fifth_axis)]]
        if {$lib_sav_kin_machine_type == "5_axis_dual_head"} {
          if {[EQ_is_lt $tmp_fifth 0.0]} {set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) -1}
        } else {
          if {[EQ_is_lt $tmp_fourth 0.0]} {set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) -1}
        }
        if {[string match "*5_axis*" [LIB_PT_get_header_var mom_kin_machine_type]] || [string match "*5_AXIS*" [LIB_PT_get_header_var mom_kin_machine_type]]} {

          LIB_GE_command_buffer {
            switch -- [lsort -dictionary [list $mom_sys_leader(fourth_axis) $mom_sys_leader(fifth_axis)]] {
              "B C" {
                if {![EQ_is_zero $lib_coord_ang_A]} {
                  LIB_GE_abort_message "INS->$::mom_path_name A[format %.3f $lib_coord_ang_A]\n<-The calculated angles cannot be processed by the machine" "The coordinate system must be defined in such a way that the machine can achieve this kinematically"
                }
              }
              "A C" {
                if {![EQ_is_zero $lib_coord_ang_B]} {
                  LIB_GE_abort_message "INS->$::mom_path_name B[format %.3f $lib_coord_ang_B]\n<-The calculated angles cannot be processed by the machine" "The coordinate system must be defined in such a way that the machine can achieve this kinematically"
                }
              }
              "A B" {
                if {![EQ_is_zero $lib_coord_ang_C]} {
                  LIB_GE_abort_message "INS->$::mom_path_name C[format %.3f $lib_coord_ang_C]\n<-The calculated angles cannot be processed by the machine" "The coordinate system must be defined in such a way that the machine can achieve this kinematically"
                }
              }
            }
          } @CYCLE_19_5axis_check

          LIB_GE_command_buffer {
            set lib_coord_out_ang_fourth $tmp_fourth ; set lib_coord_out_ang_fifth $tmp_fifth
            MOM_force once fourth_axis fifth_axis
            MOM_do_template cycl_def_19_1
          } @CYCLE_19.1

        } else {

          LIB_GE_command_buffer {
            switch -- $mom_sys_leader(fourth_axis) {
              "A" {
                if {![EQ_is_zero $lib_coord_ang_B] || ![EQ_is_zero $lib_coord_ang_C]} {
                  LIB_GE_abort_message "INS->$::mom_path_name B[format %.3f $lib_coord_ang_B] C[format %.3f $lib_coord_ang_C]\n<-The calculated angles cannot be processed by the machine" "The coordinate system must be defined in such a way that the machine can achieve this kinematically"
                }
              }
              "B" {
                if {![EQ_is_zero $lib_coord_ang_A] || ![EQ_is_zero $lib_coord_ang_C]} {
                  LIB_GE_abort_message "INS->$::mom_path_name A[format %.3f $lib_coord_ang_A] C[format %.3f $lib_coord_ang_C]\n<-The calculated angles cannot be processed by the machine" "The coordinate system must be defined in such a way that the machine can achieve this kinematically"
                }
              }
              "C" {
                if {![EQ_is_zero $lib_coord_ang_A] || ![EQ_is_zero $lib_coord_ang_B]} {
                  LIB_GE_abort_message "INS->$::mom_path_name A[format %.3f $lib_coord_ang_A] B[format %.3f $lib_coord_ang_B]\n<-The calculated angles cannot be processed by the machine" "The coordinate system must be defined in such a way that the machine can achieve this kinematically"
                }
              }
            }
          } @CYCLE_19_4axis_check

          LIB_GE_command_buffer {
            MOM_suppress once fifth_axis
            set lib_coord_out_ang_fourth $tmp_fourth
            MOM_do_template cycl_def_19_1
          } @CYCLE_19.1
          MOM_force once M_spindle
        }
      }

      LIB_GE_command_buffer_output
      MOM_disable_address fourth_axis fifth_axis
    }
    "PLANE" {
      switch -- [CONF_ITNC530_PLANE definition] {

        "SPATIAL" -
        "AXIAL" {
          LIB_GE_command_buffer PLANE_INIT
          # legacy
          if {[CONF_ITNC530_PLANE seq] == "0"} {
            CONF_ITNC530_PLANE set seq_type "OFF"
          }
          if {[CONF_ITNC530_PLANE seq] == "1"} {
            CONF_ITNC530_PLANE set seq_type "AUTO"
          }
          #
          if {[CONF_ITNC530_PLANE seq_type] == "AUTO"} {
            # PR#9594659 master axis is the 2nd rotary axis from the table, or the 1st axis from the tool
                          if {[string match "*table*" $::mom_kin_machine_type]} {
                              set master_axis 0
                          } else {
                              set master_axis 1
                          }
            if {[EQ_is_gt $mom_out_angle_pos($master_axis) 0]} {
              CONF_ITNC530_PLANE set seq "+"
            } else {
              CONF_ITNC530_PLANE set seq "-"
            }
          } elseif {[CONF_ITNC530_PLANE seq_type] == "OFF"} {
            MOM_suppress once plane_seq
          } else {
            if {[info exists ::lib_flag(preferred_solution)] && $::lib_flag(preferred_solution) != "OFF"} {
              LIB_SPF_add_warning "Set Preferred Solution is using, SEQ type set to auto"
              if {[string match "*table*" $::mom_kin_machine_type]} {
                set master_axis 0
              } else {
                set master_axis 1
              }
              if {[EQ_is_gt $mom_out_angle_pos($master_axis) 0]} {
                CONF_ITNC530_PLANE set seq "+"
              } else {
                CONF_ITNC530_PLANE set seq "-"
              }
            }
          }
          if {[CONF_ITNC530_PLANE seq_type] != "OFF" && [CONF_ITNC530_PLANE seq] == "-"} {set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) -1}
          if {[CONF_ITNC530_PLANE dist_init] == 0} {
            MOM_suppress once plane_dist
          }
          if {[CONF_ITNC530_PLANE motion_init] == "STAY"} {
            MOM_suppress once plane_dist plane_feed
          } elseif {[CONF_ITNC530_PLANE motion_init] == "TURN"} {
            MOM_suppress once plane_dist
          } else {
            # do nothing
          }
          if {[CONF_ITNC530_PLANE rot_mode] != ""} {
            MOM_force once plane_rot
          } else {
            CONF_ITNC530_PLANE set rot_mode ""
          }
          LIB_GE_command_buffer {MOM_do_template plane_init} @PLANE_INIT
          LIB_GE_command_buffer {MOM_do_template rapid_rotary CREATE} @ROTATE_CREATE
          MOM_disable_address X_vector Y_vector Z_vector
          LIB_GE_command_buffer_output
        }
      }
      MOM_disable_address fourth_axis fifth_axis
    }
    default {
      if {[info command [CONF_CTRL_setting plane_output]] == [CONF_CTRL_setting plane_output]} {
        [CONF_CTRL_setting plane_output] init
      } else {
        LIB_GE_abort_message "INS->LIB_CSYS_plane_output_init<- wrong parameter" "Please check INS->lib_parameter(plane_output) = [CONF_CTRL_setting plane_output]<-"
      }
      MOM_disable_address fourth_axis fifth_axis
    }
  }

  LIB_rotate_axis_after_plane
  if {[CONF_ITNC530_PLANE feed] != "MAX"} {MOM_force once F_param F}
  LIB_CTRL_clamp_axis
  set lib_flag(mode_current_status) "pos"

}

# <Internal Documentation>
# output the plane
#
# lib_parameter(plane_output)
#           -> CYCLE_19
#           -> PLANE_SPATIAL
#
# lib_parameter(plane,motion_init)
#           -> TURN
#           -> MOVE
#           -> STAY
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_reset {} {
  global mom_sys_leader
  global lib_parameter lib_flag lib_sav_kin_machine_type
  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_out_ang_fourth lib_coord_out_ang_fifth

  if {$lib_flag(mode_current_status) == "std"} {return}

  LIB_GE_command_buffer LOCAL_CSYS_RESET
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_reset}} @LOCAL_POS_RESET
  LIB_GE_command_buffer_output
  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_19" {
      LIB_CTRL_unclamp_axis

      LIB_GE_command_buffer CYCLE_19

      MOM_enable_address fourth_axis fifth_axis
      set lib_coord_out_ang_fourth 0.0 ; set lib_coord_out_ang_fifth 0.0

      LIB_GE_command_buffer {
        MOM_force once A B C
        MOM_do_template cycl_def_19_0
      } @CYCLE_19.0
      if {[CONF_ITNC530_PLANE definition] == "SPATIAL"} {
        LIB_GE_command_buffer {MOM_do_template cycl_def_19_1_reset} @CYCLE_19.1
      } else {
        if {[string match "*5_axis*" [LIB_PT_get_header_var mom_kin_machine_type]] || [string match "*5_AXIS*" [LIB_PT_get_header_var mom_kin_machine_type]]} {
          LIB_GE_command_buffer {
            MOM_force once fourth_axis fifth_axis
            MOM_do_template cycl_def_19_1
          } @CYCLE_19.1

        } else {
          LIB_GE_command_buffer {
            MOM_force once fourth_axis
            MOM_suppress once fifth_axis
            MOM_do_template cycl_def_19_1
          } @CYCLE_19.1
        }
      }

      LIB_GE_command_buffer {MOM_do_template cycl_def_19_0} @CYCLE_19.2
      LIB_GE_command_buffer {
        MOM_suppress once A B C
        MOM_do_template cycl_def_19_1_reset
      } @CYCLE_19.3

      LIB_GE_command_buffer_output
    }
    "PLANE" {
      switch -- [CONF_ITNC530_PLANE definition] {
        "SPATIAL" -
        "AXIAL" {
          if {[CONF_ITNC530_PLANE motion_reset] == "TURN"} {LIB_CTRL_unclamp_axis}
          if {[CONF_ITNC530_PLANE dist_init] == 0} {
            MOM_suppress once plane_dist
          }
          if {[CONF_ITNC530_PLANE motion_reset] == "STAY"} {
            MOM_suppress once plane_dist plane_feed
          } elseif {[CONF_ITNC530_PLANE motion_reset] == "TURN"} {
            if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
            MOM_suppress once plane_dist
            MOM_do_template return_home_4th5th CREATE
          } else {
            #do nothing
          }
          LIB_GE_command_buffer PLANE_RESET
          LIB_GE_command_buffer {MOM_do_template plane_reset} @OUTPUT
          LIB_GE_command_buffer_output
          if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
            MOM_enable_address fourth_axis
          } else {
            MOM_enable_address fourth_axis fifth_axis
          }
        }
      }
    }
    default {
      if {[info command [CONF_CTRL_setting plane_output]] == [CONF_CTRL_setting plane_output]} {
        LIB_CTRL_unclamp_axis
        [CONF_CTRL_setting plane_output] reset
      } else {
        LIB_GE_abort_message "INS->LIB_CSYS_plane_output_init<- wrong parameter" "Please check INS->lib_parameter(plane_output) = [CONF_CTRL_setting plane_output]<-"
      }
    }
  }
  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis
  } elseif {[string match "*5_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis fifth_axis
  }
  MOM_force once fourth_axis fifth_axis
  LIB_local_origin_reset
  set lib_flag(mode_current_status) "std"

}

# <Internal Documentation>
# reset plane
#
# lib_parameter(plane_output)
#           == "CYCLE_19"
#           == "PLANE_SPATIAL"
#
# lib_parameter(plane,motion_reset)
#           == "TURN"
#           == "STAY"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_pos {} {

  global mom_prev_out_angle_pos mom_out_angle_pos mom_polar_status mom_current_motion
  global lib_flag mom_operation_type

  if {[string match $mom_operation_type "Device Generic Motion"]} {
    return
  }

  if {$mom_current_motion == "initial_move"} {
    if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1} {
      set lib_flag(safety_retract_status) 1
    } else {
      set lib_flag(safety_retract_status) 0
    }
  }
  if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1 || $mom_current_motion != "initial_move"} {
      if {[info exists mom_prev_out_angle_pos] && $mom_polar_status != "ON" && [CONF_CTRL_moves standard_path_between_rotary_motions] == 0} {
        if {[CONF_CTRL_moves safety_retract_before_fourth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)]} {
          if {[EQ_is_gt [expr abs($mom_out_angle_pos(0) - $mom_prev_out_angle_pos(0))] [CONF_CTRL_moves safety_retract_before_fourth_axis_minimum_value]]} {
            set lib_flag(safety_retract_status) 1
          }
        }

        if {[CONF_CTRL_moves safety_retract_before_fifth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(1) $mom_out_angle_pos(1)]} {
          if {[EQ_is_gt [expr abs($mom_out_angle_pos(1) - $mom_prev_out_angle_pos(1))] [CONF_CTRL_moves safety_retract_before_fifth_axis_minimum_value]]} {
            set lib_flag(safety_retract_status) 1
          }
        }
      }

      if {[info exists lib_flag(safety_retract_status)] && $lib_flag(safety_retract_status) == 1} {
        if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
        set lib_flag(tool_path_motion) 1
        set lib_flag(safety_retract_status) 0
      }
    }

  LIB_CTRL_prepos_before_plane

}

# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_prepos_before_plane {} {
  global lib_flag

  if {[CONF_SPF_plane_kin plane_prepos] == 1} {

    set tmp_motion_init [CONF_ITNC530_PLANE motion_init]
    set tmp_motion_reset [CONF_ITNC530_PLANE motion_reset]
    if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_dual_head" || \
      [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_head_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HH
      LIB_GE_command_buffer {
        CONF_ITNC530_PLANE set motion_init "TURN"
        LIB_ROTARY_positioning_init
      } @INIT_PLANE
      LIB_GE_command_buffer_output

      if {[CONF_CTRL_moves plane_prepos_m130] == 1} {
        LIB_CTRL_prepos_with_m130_before_plane
      } else {
        LIB_CTRL_prepos_with_tcpm_before_plane
      }
    } else {
      # do nothing
    }
    CONF_ITNC530_PLANE set motion_init $tmp_motion_init
    CONF_ITNC530_PLANE set motion_reset $tmp_motion_reset
  }
}

# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion_pos
# Preposition tool axis when property plane_prepos is set
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_prepos_with_m130_before_plane {} {

  global lib_flag single_line_tcpm_code mom_motion_event
  global mom_pos oper_mcs_matrix

  set single_line_tcpm_code 130
  set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
  set template "[CONF_CTRL_moves $mom_motion_event]_prepos_tcpm"

  LIB_GE_command_buffer PREPOS_PLANE_M130

  if {$lib_flag(local_namespace_output) == 0} {
    LIB_GE_command_buffer {
      MOM_suppress once M_axisopt
      LIB_SPF_convert_point "simultaneous"
      VMOV 3 mom_pos tmp_pos
      MTX3_transpose oper_mcs_matrix tmp_matrix
      MTX3_vec_multiply tmp_pos tmp_matrix mom_pos
    } @CP_SIM
    LIB_GE_command_buffer {
      LIB_SPF_decompose_block_template $decompose $template FORCE "[join $decompose] fourth_axis fifth_axis"
    } @MOTION
    LIB_GE_command_buffer {
      LIB_SPF_convert_point "reload"
    } @CP_RELOAD
  } else {
    LIB_GE_command_buffer {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
      LIB_SPF_decompose_block_template $decompose $template FORCE "[join $decompose] fourth_axis fifth_axis"
      LIB_SPF_set_output_pos "::LOCAL_CSYS" "mom_mcs_goto"
    } @LOCAL_MOTION
  }

  LIB_GE_command_buffer_output
}

# <Internal Documentation>
# This command is called with LIB_CTRL_prepos_before_plane
# The output position is refered to non-tilted plane for tool axis preposition
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_prepos_with_tcpm_before_plane {} {

  global lib_flag mom_pos oper_mcs_matrix

  set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
  set template [CONF_CTRL_moves $::mom_motion_event]

  LIB_GE_command_buffer PREPOS_PLANE_M128

  LIB_GE_command_buffer {
    CONF_ITNC530_PLANE set motion_reset "STAY"
    set tmp_local_origin_activated $lib_flag(local_origin_activated)
    set lib_flag(local_origin_activated) 0
    LIB_ROTARY_positioning_reset
    set lib_flag(local_origin_activated) $tmp_local_origin_activated
  } @RESET_PLANE
  LIB_GE_command_buffer {
    LIB_ROTARY_simultaneous_init
  } @INIT_SIM
  LIB_GE_command_buffer {
    if {$lib_flag(local_namespace_output) == 0} {
      MOM_suppress once M_axisopt
      LIB_SPF_convert_point "simultaneous"
      VMOV 3 mom_pos tmp_pos
      MTX3_transpose oper_mcs_matrix tmp_matrix
      MTX3_vec_multiply tmp_pos tmp_matrix mom_pos
    }
  } @CP_SIM
  LIB_GE_command_buffer {
    LIB_SPF_decompose_block_template $decompose $template FORCE "[join $decompose] fourth_axis fifth_axis"
  } @MOTION
  LIB_GE_command_buffer {
    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "reload"
    }
  } @CP_RELOAD
  LIB_GE_command_buffer {
    MOM_suppress once M_axisopt
    LIB_ROTARY_simultaneous_reset
  } @RESET_SIM

  LIB_GE_command_buffer_output
}

# <Internal Documentation>
# This command is called with LIB_CTRL_prepos_before_plane
# The output position is defined by tcpm for tool axis preposition
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_sim {} {
  global lib_flag
  if {[CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    set tmp_motion_init [CONF_ITNC530_PLANE motion_init]
    set tmp_motion_reset [CONF_ITNC530_PLANE motion_reset]
    set tmp_seq [CONF_ITNC530_PLANE seq_type]
    if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_dual_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE
      LIB_GE_command_buffer {
        MOM_force once fourth_axis fifth_axis
        MOM_do_template rapid_rotary
      } @PRE_ROTARY
      LIB_GE_command_buffer {
        if {$lib_flag(local_namespace_output) == 1} {
          LIB_SPF_local_csys_rotation
        } else {
          LIB_SPF_convert_point "plane_no_reset"
          LIB_SPF_csys_3D_rotation
          LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
        }
      } @CP_PLANE
      LIB_GE_command_buffer {
        CONF_ITNC530_PLANE set motion_init "STAY"
        CONF_ITNC530_PLANE set seq_type "OFF"
        LIB_ROTARY_positioning_init
      } @INIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {LIB_ROTARY_positioning_first_move_pos} @MOTION
      LIB_GE_command_buffer {
        CONF_ITNC530_PLANE set motion_reset "STAY"
        set tmp_local_origin_activated $lib_flag(local_origin_activated)
        set lib_flag(local_origin_activated) 0
        LIB_ROTARY_positioning_reset
        set lib_flag(local_origin_activated) $tmp_local_origin_activated
      } @RESET
      LIB_GE_command_buffer {
        if {$lib_flag(local_namespace_output) == 0} {
          LIB_SPF_convert_point "reload"
        } else {
          VMOV 3 ::mom_mcs_goto ::mom_pos
        }
      } @CP_RELOAD
      LIB_GE_command_buffer {
        if {$lib_flag(local_namespace_output) == 0} {
          if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
            LIB_SPF_KINEMATICS_set_absolut_output_kin
          } else {
            LIB_SPF_KINEMATICS_set_simultanous_kin
          }
        }
      } @KIN_SIM
      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HH
      LIB_GE_command_buffer {
        MOM_force once fourth_axis fifth_axis
        MOM_do_template rapid_rotary
      } @PRE_ROTARY
      LIB_GE_command_buffer {LIB_ROTARY_simultaneous_init} @INIT
      LIB_GE_command_buffer_output

    }
    CONF_ITNC530_PLANE set motion_init $tmp_motion_init
    CONF_ITNC530_PLANE set motion_reset $tmp_motion_reset
    CONF_ITNC530_PLANE set seq_type $tmp_seq
  }
}

# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_pt_additional_variables_iTNC {} {

  LIB_SPF_pretreatment_add_var MOM_lib_event_cycle_241 mom_cycle_Q427 0
  LIB_SPF_pretreatment_add_var MOM_spindle_rpm first_spindle_rpm 0

  #PR9239197 Add mom_lock_axis to pretreatment
  LIB_SPF_pretreatment_add_var MOM_lock_axis mom_lock_axis 0
}

# <Internal Documentation>
#
# Entrypoint to define additional variables which should be stored in pretreatment
# Controller specific
#
# LIB_SPF_pretreatment_add_var in this proc to add return variables from pretreatment
#
# <Internal Example>
# Sample code as comment in proc body
#______________________________________________________________________________
proc LIB_CYCLE_dwell_set {} {

  global mom_cycle_delay_mode ;# SECONDS, REVOLUTIONS, OFF ,ON
  global mom_cycle_delay mom_cycle_delay_revs mom_spindle_rpm

  if {$mom_cycle_delay_mode == "ON"} {set mom_cycle_delay [CONF_CTRL_drill default_cycle_delay]}

  if {$mom_cycle_delay_mode == "OFF"} {
    set mom_cycle_delay 0
    return
  }

  if {$mom_cycle_delay_mode == "REVOLUTIONS"} {
    catch {set mom_cycle_delay [expr $mom_cycle_delay_revs * (60 / $mom_spindle_rpm)]}
  }

  if {$mom_cycle_delay > [CONF_CTRL_drill max_delay]} {set mom_cycle_delay [CONF_CTRL_drill max_delay]}
  if {$mom_cycle_delay < [CONF_CTRL_drill min_delay]} {set mom_cycle_delay [CONF_CTRL_drill min_delay]}
}

# <Internal Documentation>
# This procedure is executed at the cycle event.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_LIB {} {

  LIB_CYCLE_set
}


# <Internal Documentation>
# MOM_drill : output CYCL_200 (default)
#   Q202 = total depth
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_move_LIB {} {

  set commandcheck(MOM_drill_move_LIB_ENTRY) [llength [info commands MOM_drill_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_dwell_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_drill_dwell : output CYCL_200 (default)
#   Q202 = total depth
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell_move_LIB {} {

  set commandcheck(MOM_drill_dwell_move_LIB_ENTRY) [llength [info commands MOM_drill_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_deep_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_drill_deep : output CYCL_200 (default)
#   Q202 = tool_diameter or mom_cycle_step1 if it's defined
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep_move_LIB {} {

  set commandcheck(MOM_drill_deep_move_LIB_ENTRY) [llength [info commands MOM_drill_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_drill_break_chip : output CYCL_200 (default)
#   Q202 = tool_diameter or mom_cycle_step1 if it's defined
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_break_chip_move_LIB {} {

  set commandcheck(MOM_drill_break_chip_move_LIB_ENTRY) [llength [info commands MOM_drill_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_LIB {} {

  LIB_CYCLE_set
  LIB_CYCLE_tap_set
}

# <Internal Documentation>
# MOM_tap : output CYCL_207 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_move_LIB {} {

  set commandcheck(MOM_tap_move_LIB_ENTRY) [llength [info commands MOM_tap_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_float_LIB {} {
  global lib_parameter_cycle
  global mom_spindle_rpm

  LIB_CYCLE_set
  LIB_CYCLE_tap_set

  set lib_parameter_cycle(206) [expr abs($lib_parameter_cycle(239)) * $mom_spindle_rpm]
}

# <Internal Documentation>
# MOM_tap_float
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float_move_LIB {} {

  set commandcheck(MOM_tap_float_move_LIB_ENTRY) [llength [info commands MOM_tap_float_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_deep_LIB {} {
  global lib_parameter_cycle
  global mom_cycle_step1
  global mom_cycle_orient

  LIB_CYCLE_set
  LIB_CYCLE_tap_set

  set lib_parameter_cycle(256) 0
  if {[info exists mom_cycle_step1] && ![EQ_is_zero $mom_cycle_step1]} {
    set lib_parameter_cycle(257) $mom_cycle_step1
  } else {
    set lib_parameter_cycle(257) 0
    LIB_SPF_add_warning "Step value of Tap Deep cycle cannot be zero!"
  }

  if {[info exists mom_cycle_orient]} {
    set lib_parameter_cycle(336) $mom_cycle_orient
  }

}

# <Internal Documentation>
# MOM_tap_deep
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep_move_LIB {} {

  set commandcheck(MOM_tap_deep_move_LIB_ENTRY) [llength [info commands MOM_tap_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_break_chip_LIB {} {
  global lib_parameter_cycle
  global mom_cycle_step1
  global mom_cycle_orient
  global mom_cycle_step_clearance

  LIB_CYCLE_set
  LIB_CYCLE_tap_set

  if {[info exists mom_cycle_step_clearance] && ![EQ_is_zero $mom_cycle_step_clearance]} {
    set lib_parameter_cycle(256) $mom_cycle_step_clearance
  } else {
    set lib_parameter_cycle(256) 0.2
  }

  if {[info exists mom_cycle_step1] && ![EQ_is_zero $mom_cycle_step1]} {
    set lib_parameter_cycle(257) $mom_cycle_step1
  } else {
    set lib_parameter_cycle(257) 0
    LIB_SPF_add_warning "Step value of Tap Break Chip cycle cannot be zero!"
  }

  if {[info exists mom_cycle_orient]} {
    set lib_parameter_cycle(336) $mom_cycle_orient
  }
}

# <Internal Documentation>
# MOM_tap_break_chip
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip_move_LIB {} {

  set commandcheck(MOM_tap_break_chip_move_LIB_ENTRY) [llength [info commands MOM_tap_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_bore : output CYCL_201 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_move_LIB {} {

  set commandcheck(MOM_bore_move_LIB_ENTRY) [llength [info commands MOM_bore_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_dwell_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_bore_dwell : output CYCL_201 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell_move_LIB {} {

  set commandcheck(MOM_bore_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_drag_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_bore_drag : output CYCL_202 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag_move_LIB {} {

  set commandcheck(MOM_bore_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_no_drag_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_bore_no_drag : output CYCL_200 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag_move_LIB {} {

  set commandcheck(MOM_bore_no_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_no_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_back_LIB {} {

  LIB_CYCLE_set
}

# <Internal Documentation>
# MOM_bore_back : output CYCL_204 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back_move_LIB {} {

  set commandcheck(MOM_bore_back_move_LIB_ENTRY) [llength [info commands MOM_bore_back_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual : output CYCL_204 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_move_LIB {} {

  set commandcheck(MOM_bore_manual_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual_dwell : output CYCL_204 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_move_LIB {} {

  set commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_text_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text_move_LIB {} {

  set commandcheck(MOM_drill_text_move_LIB_ENTRY) [llength [info commands MOM_drill_text_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_thread_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_move_LIB {} {

  set commandcheck(MOM_thread_move_LIB_ENTRY) [llength [info commands MOM_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# MOM_thread_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_mill_hole_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_mill_hole
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_mill_hole_move_LIB {} {

  set commandcheck(MOM_mill_hole_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_parameter lib_parameter_cycle mom_tool_diameter lib_flag
  if {![string equal [string toupper $::mom_cycle_feed_rate_mode] "MMPM"]&&![string equal [string toupper $::mom_cycle_feed_rate_mode] "IPM"]} {
    LIB_GE_error_message "Unspported mom_cycle_feed_rate_mode in Operation 'INS->$::mom_path_name<-'" "It should be MMPM or IPM"
  }
  if {![string equal [string toupper $::mom_feed_engage_unit] "MMPM"]&&![string equal [string toupper $::mom_feed_engage_unit] "IPM"]} {
    LIB_GE_error_message "Unspported mom_feed_engage_unit in Operation 'INS->$::mom_path_name<-'" "It should be mmpm or ipm"
  }


  set lib_cycle_feature_diameter [expr $::mom_cycle_feature_diameter]
  # modify mom_cycle_feature_start_diameter if equal to mom_cycle_feature_diameter
  if {[EQ_is_equal $::mom_cycle_feature_start_diameter $::mom_cycle_feature_diameter]} {
    set ::mom_cycle_feature_start_diameter [expr $::mom_cycle_feature_start_diameter - $::mom_kin_machine_resolution]
  }

  if {$::mom_cut_direction_type==1} {
    #Climb
    set lib_parameter_cycle(351) +1
  }
  if {$::mom_cut_direction_type==2} {
    #Conventional
    set lib_parameter_cycle(351) -1
  }


  if {$::mom_region_cut_method == 11} {
    #Helical
    set lib_parameter_cycle(name) 208
    set lib_parameter_cycle(335) $lib_cycle_feature_diameter

    if {[info exists ::mom_vertical_pitch_value_source] && $::mom_vertical_pitch_value_source == 4} {
      set lib_parameter_cycle(334) [expr $mom_tool_diameter*$::mom_vertical_pitch_value/100.0]
    } else {
      set lib_parameter_cycle(334) [expr $::mom_vertical_pitch_value]
    }

    if {[info exists ::mom_cycle_feature_start_diameter] && $::mom_cycle_feature_start_diameter != 0} {
      set lib_cycle_feature_start_diameter [expr $::mom_cycle_feature_start_diameter]
    } else {
      set lib_cycle_feature_start_diameter 0
    }
    set lib_parameter_cycle(342) $lib_cycle_feature_start_diameter

    # Calculate the stepover from NX value and the start diameter
    # (hole dia - start_dia) / 2 = Material_thick
    # (Material_thick / stepover)+1 = number_step
    # calc_stepover = Material_thick / number_step
    #

    # examine tool_engage diameter for helical
    if {[info exists ::mom_circle_diameter_source] && $::mom_circle_diameter_source == 4} {
      set tool_engage_diameter [expr $mom_tool_diameter*$::mom_circle_diameter/100.0]
    } else {
      set tool_engage_diameter $::mom_circle_diameter
    }

    if {[info exists ::mom_stepover_distance_source] && $::mom_stepover_distance_source == 4} {
      set lib_stepover_distance [expr $mom_tool_diameter*$::mom_stepover_distance/100.0]
    } else {
      set lib_stepover_distance [expr $::mom_stepover_distance]
    }

    # do an extra pass when the start_diameter is less than the tool diameter
    # otherwise we get an material in the middle of the hole

    if {[EQ_is_le $::mom_cycle_feature_start_diameter $mom_tool_diameter]} {
      set lib_parameter_cycle(342) 0
      set lib_parameter_cycle(335) [expr $tool_engage_diameter + $mom_tool_diameter]
      if {[EQ_is_lt [expr $tool_engage_diameter + $mom_tool_diameter] $::mom_cycle_feature_diameter]} {
        LIB_CYCLE_move
        set lib_flag(output_cycle_call) 1
        if {[info exist ::lib_prev_cycle_retract_to_pos]} {unset ::lib_prev_cycle_retract_to_pos}
      }
      set thickness [expr ($::mom_cycle_feature_diameter - $lib_parameter_cycle(335)) / 2]
      if {[EQ_is_zero [expr fmod([expr $thickness / $lib_stepover_distance],1)]]} {
        set number_step [expr int($thickness / $lib_stepover_distance)]
      } else {
        set number_step [expr int($thickness / $lib_stepover_distance) + 1]
      }
      set step_value [expr $thickness / $number_step]
      set inter_cycle_feature_diameter $lib_parameter_cycle(335)
      set inter_cycle_feature_start_diameter [expr $inter_cycle_feature_diameter - 2 * $step_value]
    } else {
      set thickness [expr ($::mom_cycle_feature_diameter - $::mom_cycle_feature_start_diameter) / 2]
      if {[EQ_is_zero [expr fmod([expr $thickness / $lib_stepover_distance],1)]]} {
        set number_step [expr int($thickness / $lib_stepover_distance)]
      } else {
        set number_step [expr int($thickness / $lib_stepover_distance) + 1]
      }
      if {[EQ_is_zero $thickness]} {
        set step_value 0
      } else {
        set step_value [expr $thickness / $number_step]
      }
      set inter_cycle_feature_start_diameter [expr $::mom_cycle_feature_start_diameter - 2 * $step_value]
      set inter_cycle_feature_diameter [expr $::mom_cycle_feature_diameter - 2 * ($step_value * $number_step)]
    }


    for {set i 1} {$i < $number_step} {incr i} {
      set lib_parameter_cycle(342) [format %.1f [expr $inter_cycle_feature_start_diameter + $step_value * 2]]
      set lib_parameter_cycle(335) [format %.1f [expr $inter_cycle_feature_diameter + $step_value * 2]]
      LIB_GE_command_buffer MILL_HOLE_MOVE_INTER
      LIB_GE_command_buffer {LIB_CYCLE_move} @Output
      LIB_GE_command_buffer_output
      set lib_flag(output_cycle_call) 1
      if {[info exist ::lib_prev_cycle_retract_to_pos]} {unset ::lib_prev_cycle_retract_to_pos}
      set inter_cycle_feature_start_diameter $lib_parameter_cycle(342)
      set inter_cycle_feature_diameter $lib_parameter_cycle(335)
    }
    set lib_parameter_cycle(342) $::mom_cycle_feature_start_diameter
    if {[EQ_is_lt $inter_cycle_feature_start_diameter $::mom_cycle_feature_diameter]} {
    set lib_parameter_cycle(342) [format %.1f [expr $inter_cycle_feature_start_diameter + $step_value * 2]]
    }
    set lib_parameter_cycle(335) $::mom_cycle_feature_diameter

  } elseif {$::mom_region_cut_method == 16} {
    #Circular
    set lib_parameter_cycle(name) 252
    set lib_parameter_cycle(223) $lib_cycle_feature_diameter

    if {[info exists ::mom_cycle_feature_start_diameter] && $::mom_cycle_feature_start_diameter >  $mom_tool_diameter} {
      set lib_cycle_feature_start_diameter [expr $::mom_cycle_feature_start_diameter]
    } else {
      set lib_cycle_feature_start_diameter [expr $mom_tool_diameter]
    }
    #
    # Set the start_diameter to mom_tool_diameter for circular move because
    # CYCL 252 has no start_diameter
    set lib_cycle_feature_start_diameter [expr $mom_tool_diameter]

    #
    # Other circular milling parameter
    # 0 - rough and finish  1 - rough  2 - finish
    set lib_parameter_cycle(215) 1

    # side stock
    set lib_parameter_cycle(368) 0

    # floor stock
    set lib_parameter_cycle(369) 0

    # axial stepover
    if {[info exists ::mom_axial_stepover_distance_source] && $::mom_axial_stepover_distance_source == 4} {
      set lib_parameter_cycle(202) [expr $mom_tool_diameter*$::mom_axial_stepover_distance/100.0]
    } else {
      set lib_parameter_cycle(202) [expr $::mom_axial_stepover_distance]
    }
    # we check also mom_cycle_Q202 in LIB_init_cycle_parameters
    set ::mom_cycle_Q202 $lib_parameter_cycle(202)
    # feedrate for axial stepover
    set lib_parameter_cycle(206) $::mom_feed_engage_value

    # axial stepover for finish
    set lib_parameter_cycle(338) 0

    # evaluate mom_cycle_rapid_to and mom_cycle_retract_to
    # because NX delivers 0 when motion type is Circular
    # use a mom_min_clearance for mom_cycle_rapid_to and
    # and mom_cycle_retract_to
    if {[EQ_is_zero $::mom_cycle_rapid_to]} {
      set ::mom_cycle_rapid_to $::mom_min_clearance
    }
    if {[EQ_is_zero $::mom_cycle_retract_to]} {
      set ::mom_cycle_retract_to $::mom_min_clearance
    }

    # Calculate the stepover from NX value and the start diameter
    # (hole dia - start_dia) / 2 = Material_thick
    # (Material_thick / stepover)+1 = number_step
    # calc_stepover = Material_thick / number_step
    #

    # examine tool_engage diameter for helical
    if {[info exists ::mom_circle_diameter_source] && $::mom_circle_diameter_source == 4} {
      set tool_engage_diameter [expr $mom_tool_diameter*$::mom_circle_diameter/100.0]
    } else {
      set tool_engage_diameter $::mom_circle_diameter
    }

    if {[info exists ::mom_stepover_distance_source] && $::mom_stepover_distance_source == 4} {
      set lib_stepover_distance [expr $mom_tool_diameter*$::mom_stepover_distance/100.0]
    } else {
      set lib_stepover_distance [expr $::mom_stepover_distance]
    }

    # do an extra pass when the start_diameter is less than the tool diameter
    # otherwise we get an material in the middle of the hole

    if {[EQ_is_lt $lib_cycle_feature_start_diameter $mom_tool_diameter]} {
      #for circular move it is now not tested so we never should go in this branch
      set lib_parameter_cycle(342) 0
      set lib_parameter_cycle(223) [expr $tool_engage_diameter + $mom_tool_diameter]
      set thickness [expr ($::mom_cycle_feature_diameter - $lib_parameter_cycle(223)) / 2]
      if {[EQ_is_zero [expr fmod([expr $thickness / $lib_stepover_distance],1)]]} {
        set number_step [expr int($thickness / $lib_stepover_distance)]
      } else {
        set number_step [expr int($thickness / $lib_stepover_distance) + 1]
      }
      set step_value [expr $thickness / $number_step]
      set inter_cycle_feature_diameter $lib_parameter_cycle(223)
      set inter_cycle_feature_start_diameter [expr $inter_cycle_feature_diameter - 2 * $step_value]
    } else {
      set thickness [expr ($::mom_cycle_feature_diameter - $lib_cycle_feature_start_diameter) / 2]
      if {[EQ_is_zero [expr fmod([expr $thickness / $lib_stepover_distance],1)]]} {
        set number_step [expr int($thickness / $lib_stepover_distance)]
      } else {
        set number_step [expr int($thickness / $lib_stepover_distance) + 1]
      }
      set step_value [expr $thickness / $number_step]
      set inter_cycle_feature_start_diameter [expr $::mom_cycle_feature_start_diameter - 2 * $step_value]
      set inter_cycle_feature_diameter [expr $::mom_cycle_feature_diameter - 2 * ($step_value * $number_step)]
    }
    set lib_parameter_cycle(342) $::mom_cycle_feature_start_diameter
    if {[EQ_is_lt $inter_cycle_feature_start_diameter $::mom_cycle_feature_diameter]} {
    set lib_parameter_cycle(342) [format %.1f [expr $inter_cycle_feature_start_diameter + $step_value * 2]]
    }
    set lib_parameter_cycle(223) $::mom_cycle_feature_diameter

    set lib_parameter_cycle(370) [expr $step_value / ($mom_tool_diameter / 2)]
    set lib_parameter_cycle(366) +1
    set lib_parameter_cycle(385) $::feed
  }

  LIB_GE_command_buffer MILL_HOLE_MOVE
  LIB_GE_command_buffer {LIB_CYCLE_move} @Output
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# MOM variables which are important for hole and thread Milling
#  mom_region_cut_method
#  -- 16  Circular output
#  -- 11  Helix output
#
#  mom_cut_finish_type = 1
#  ???
#
#  mom_vertical_pitch_type = 0
#  ???
#
#  -----------------------------------------------------------------------------------------------
#  mom_vertical_pitch_value = 30.0
#  valid for mom_region_cut_method 11
#  --  value of the pitch percentage or mm depends off mom_vertical_pitch_value_source
#
#  mom_vertical_pitch_value_source
#  -- not defined and !4  mom_vertical_pitch_value output in mm
#  -- 4                   mom_vertical_pitch_value output in percent of tool diameter
#
#  -----------------------------------------------------------------------------------------------
#  mom_axial_stepover_distance = 70.0
#  valid for mom_region_cut_method 16
#  --  value of the stepover percentage or mm depends off mom_axial_stepover_distance_source
#
#  mom_axial_stepover_distance_source
#  -- not defined and !4  mom_axial_stepover_distance output in mm
#  -- 4                   mom_axial_stepover_distance output in percent of tool diameter
#
#  -----------------------------------------------------------------------------------------------
#  mom_stepover_distance = 70.0
#  valid for mom_region_cut_method 11 and 16
#  --  value of the stepover percentage or mm depends off mom_stepover_distance_source
#
#  mom_stepover_distance_source
#  -- not defined and !4  mom_stepover_distance output in mm
#  -- 4                   mom_stepover_distance output in percent of tool diameter
#
#  -----------------------------------------------------------------------------------------------
#  mom_cycle_feature_diameter
#  --  diameter of the hole
#
#  mom_cycle_feature_start_diameter
#  --  start diameter of the hole (if predrilled)
#
#  -----------------------------------------------------------------------------------------------
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# MOM_mill_hole_move : Output CYCL 208(helical) or CYCL 252(circular)
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_mill_hole_thread_move_LIB {} {

  set commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_parameter_cycle mom_motion_type mom_feed_rate mom_cycle_Q253
  set lib_parameter_cycle(207)  "$::feed"
  set lib_parameter_cycle(335)  "$::mom_cycle_thread_major_diameter"
  set lib_parameter_cycle(239)  "$::mom_cycle_thread_pitch"
  set lib_parameter_cycle(355)  "0"
  # define feed for approach
  # if ude cycle 262 doesn't exist, calculate feed for Q253
  if {![info exists mom_cycle_Q253]} {
    set mom_motion_type "approach"
    set mom_feed_rate $::mom_feed_approach_value
    LIB_SPF_feedrate_set
    LIB_CTRL_feed_output
    set lib_parameter_cycle(253)  $::feed
  }

  # define feed for engage
  set mom_motion_type "engage"
  set mom_feed_rate $::mom_feed_engage_value
  LIB_SPF_feedrate_set
  LIB_CTRL_feed_output
  set lib_parameter_cycle(512)  $::feed
  if {$::mom_cut_direction_type==1} {
    #Climb
    set lib_parameter_cycle(351) -1
  }
  if {$::mom_cut_direction_type==2} {
    #Conventional
    set lib_parameter_cycle(351) 1
  }


  LIB_GE_command_buffer MILL_HOLE_THREAD_MOVE
  LIB_GE_command_buffer {LIB_CYCLE_move} @Output
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# MOM_mill_hole_thread_move_LIB
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_off_LIB {} {
  global mom_cycle_spindle_axis
  global lib_flag

  set commandcheck(MOM_cycle_off_LIB_ENTRY) [llength [info commands MOM_cycle_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[info exists lib_flag(cycle_mcall_active)] && $lib_flag(cycle_mcall_active) == 1} {
    set lib_flag(cycle_mcall_active) 0
  }
  switch -- $mom_cycle_spindle_axis {
    0 {MOM_force once X}

    1 {MOM_force once Y}

    2 {MOM_force once Z}
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CYCLE_set {} {
  global mom_cycle_delay mom_siemens_cycle_dtb
  global lib_flag

  LIB_GE_command_buffer CYCLE_SET_start
  LIB_GE_command_buffer {
  global mom_cycle_feed_rate mom_cycle_feed_rate_mode mom_cycle_feed_rate_per_rev mom_spindle_rpm
    if {[string match *PR* [string toupper $mom_cycle_feed_rate_mode]]} {
      set mom_cycle_feed_rate [expr $mom_cycle_feed_rate_per_rev * $mom_spindle_rpm]
    }
  } @CYCLE_FEED
  LIB_GE_command_buffer_output

  LIB_CYCLE_dwell_set
  if {![hiset mom_siemens_cycle_dtb]} {set mom_siemens_cycle_dtb $mom_cycle_delay}
  set lib_flag(output_cycle_call) 1
}
# <Internal Documentation>
# Controls the drilling cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_set {} {
  global mom_tool_pitch mom_cycle_feed_rate_per_rev
  global mom_cycle_thread_pitch
  global mom_cycle_thread_right_handed
  global mom_spindle_direction
  global mom_spindle_rpm mom_spindle_speed
  global mom_retract_spindle
  global mom_path_name
  global lib_parameter_cycle
  global feed

  if {[info exists mom_tool_pitch]} {
    set pitch $mom_tool_pitch
  } elseif {[info exists mom_cycle_thread_pitch]} {
    set pitch $mom_cycle_thread_pitch
  } else {
    if {[CONF_CTRL_drill tool_pitch_used] == 0} {
      set pitch $mom_cycle_feed_rate_per_rev
    } else {
      LIB_GE_abort_message "INS->$mom_path_name<- : No pitch defined on the tool." "Please use Tap tool."
    }
  }

  set lib_parameter_cycle(239) $pitch
  if {[info exists mom_cycle_thread_right_handed]} {
    if {$mom_cycle_thread_right_handed == "FALSE"} {
      set lib_parameter_cycle(239)   [expr $pitch * (-1)]
    }
  } elseif {$mom_spindle_direction == "CCLW"} {
    set lib_parameter_cycle(239)  [expr $pitch * (-1)]
  }

  if {![info exists mom_spindle_speed] || [EQ_is_zero $mom_spindle_speed]} {
    LIB_GE_abort_message "INS->$mom_path_name<- : spindle speed is 0." "Please verify."
  }

}
# <Internal Documentation>
# Controls the tapping cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move {} {

  global mom_cycle_feed_to mom_cycle_retract_to_pos mom_cycle_rapid_to_pos mom_motion_event
  global mom_pos mom_prev_pos mom_cycle_clearance_plane_change
  global cycle_axis_address tool_axis_direction
  global lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos lib_flag tool_axis
  global lib_parameter_cycle lib_parameter
  global mom_namespace_name mom_output_pos_type mom_mcs_goto mom_prev_mcs_goto

  LIB_CYCLE_dwell_set
  LIB_SPINDLE_start cycle

  LIB_GE_command_buffer PREPOS_IN_CYCLE
  LIB_GE_command_buffer {
  if {$lib_flag(tool_path_motion) == 1} {
    switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z}" "cycle_move" FORCE "Y Z"}

        1 {LIB_SPF_decompose_block_template "{X Z}" "cycle_move" FORCE "X Z"}

        2 {LIB_SPF_decompose_block_template "{X Y}" "cycle_move" FORCE "X Y"}
    }
  }
  } @PREPOS_DEFAULT
  LIB_GE_command_buffer_output
  set lib_flag(tool_path_motion) 2

  # PR9752109: Override feed_to_pos/rapid_to_pos/retract_to_pos by related value in local namespace
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_recalculate_cycle_pos
  }

  # --> mom_cycle_tool_axis_change and mom_cycle_clearance_plane_change is added
  # to detect the tool axis change and clearance plane change in cycles. They are only available in NX754 and later version.
  # mom_cycle_tool_axis_change = 1 means tool axis is changed.
  # mom_cycle_tool_axis_change = 0 menas no tool axis change.
  # mom_cycle_clearance_plane_change = 0 means no clearance plane change.
  # mom_cycle_clearance_plane_change = 1 means clearance plane change from lower to higher.
  # mom_cycle_clearance_plane_change = -1 means clearance plane change from higher to lower.
  # mom_cycle_clearance_plane_change is only defined if mom_kin_cycle_plane_change_per_axis is set to 1
  # if mom_kin_cycle_plane_change_per_axis is not set to 1 mom_cycle_clearance_plane_change is defined here
  # after this proc mom_cycle_clearance_plane_change is unset
  if {![info exist mom_cycle_clearance_plane_change]} {
    if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
      namespace eval $::mom_namespace_name {
        if {[info exists mom_output_pos_type] && $mom_output_pos_type == "mom_mcs_goto"} {
          if {[EQ_is_gt $mom_prev_mcs_goto($tool_axis) $mom_mcs_goto($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
            set mom_cycle_clearance_plane_change -1
          } elseif {[EQ_is_lt $mom_prev_mcs_goto($tool_axis) $mom_mcs_goto($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
            set mom_cycle_clearance_plane_change 1
          } else {
            set mom_cycle_clearance_plane_change 0
          }
        } else {
    if {[EQ_is_gt $mom_prev_pos($tool_axis) $mom_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
      set mom_cycle_clearance_plane_change -1
    } elseif {[EQ_is_lt $mom_prev_pos($tool_axis) $mom_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
      set mom_cycle_clearance_plane_change 1
          } else {
            set mom_cycle_clearance_plane_change 0
          }
        }
      }
    } else {
      if {[EQ_is_gt $mom_prev_pos($tool_axis) $mom_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
        set mom_cycle_clearance_plane_change -1
      } elseif {[EQ_is_lt $mom_prev_pos($tool_axis) $mom_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
        set mom_cycle_clearance_plane_change 1
      } else {
      set mom_cycle_clearance_plane_change 0
      }
    }
  }
  # Yichao PR9332581 Add check of mom_cycle_retract_to_pos to correct CYCL output
    LIB_SPF_retract_to_pos
  if {$lib_flag(output_cycle_call) == 1 || $mom_cycle_clearance_plane_change != 0 || ![info exists lib_flag(cycle_mcall_active)] || $lib_flag(cycle_mcall_active) == 0 ||\
  [info exist lib_prev_cycle_retract_to_pos] && ![EQ_is_equal $lib_prev_cycle_retract_to_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)]} {

    if {[info exists lib_parameter(special_cycle,name)] && $lib_parameter(special_cycle,name) != ""} {
      LIB_CYCLE_move_special_$lib_parameter(special_cycle,name)
      set lib_parameter_cycle(name) $lib_parameter(special_cycle,name)
      if {[info exists lib_parameter(special_cycle,call)]} {
        set lib_parameter_cycle(call) $lib_parameter(special_cycle,call)
      } else {
        set lib_parameter_cycle(call) ""
      }
    } else {
      if {![info exists lib_parameter_cycle(name)]} {
        switch -- $mom_motion_event {
          "drill_move"      {set lib_parameter_cycle(name) 200}
          "drill_dwell_move"    {set lib_parameter_cycle(name) 200}
          "drill_deep_move"     {set lib_parameter_cycle(name) 203}
          "drill_break_chip_move"   {set lib_parameter_cycle(name) 203}
          "tap_move"      {set lib_parameter_cycle(name) 207}
          "tap_float_move"    {set lib_parameter_cycle(name) 206}
          "tap_deep_move"     {set lib_parameter_cycle(name) 209}
          "tap_break_chip_move"     {set lib_parameter_cycle(name) 209}
          "bore_move"       {set lib_parameter_cycle(name) 201}
          "bore_dwell_move"     {set lib_parameter_cycle(name) 201}
          "bore_drag_move"    {set lib_parameter_cycle(name) 202}
          "bore_no_drag_move"     {set lib_parameter_cycle(name) 202}
          "bore_back_move"    {set lib_parameter_cycle(name) 204}
          "bore_manual_move"    {set lib_parameter_cycle(name) 200}
          "bore_manual_dwell_move"  {set lib_parameter_cycle(name) 200}
          "drill_text_move"     {set lib_parameter_cycle(name) 200}
          "thread_move"       {
                LIB_GE_command_buffer THREAD_MOVE
                LIB_GE_command_buffer {
                  if {[llength [info commands LIB_CTRL_map_cycle831_param]]} {
                    LIB_CTRL_map_cycle831_param
                  }
                  set lib_parameter_cycle(name) 831
                  set lib_flag(cycle_mcall_active) 0
                } @OUTPUT
                LIB_GE_command_buffer_output
            }
          "mill_hole_move"    {
            if {$::mom_region_cut_method == 11} {
              set lib_parameter_cycle(name) 208
            } elseif {$::mom_region_cut_method == 16} {
              set lib_parameter_cycle(name) 252
            }
          }
          "mill_hole_thread_move" {set lib_parameter_cycle(name) 262}
        }
      }
      set lib_parameter_cycle(call) [CONF_CTRL_drill cycle_call]

    LIB_init_cycle_parameters
    if {$tool_axis_direction == "-"} {set mom_cycle_feed_to [expr $mom_cycle_feed_to* (-1)]}

    LIB_SPF_call_cycle CYCL_$lib_parameter_cycle(name) "" "CYCL" ";" "~"

    if {$tool_axis_direction == "-"} {set mom_cycle_feed_to [expr $mom_cycle_feed_to* (-1)]}

    set lib_flag(output_cycle_call) 0
    set lib_flag(cycle_mcall_active) 1
    }
  }

  LIB_WRITE_coolant on

  switch -- $tool_axis {
    0 {MOM_force once Y Z}

    1 {MOM_force once X Z}

    2 {MOM_force once X Y}
  }
  unset mom_cycle_clearance_plane_change

  MOM_suppress once $cycle_axis_address
  switch -- [join $lib_parameter_cycle(call)] {
    "M99" {
      LIB_GE_command_buffer M99
      LIB_GE_command_buffer {
        MOM_add_to_line_buffer end " M99"
        MOM_do_template [CONF_CTRL_moves rapid_template]
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
    "CYCL CALL" {
      LIB_GE_command_buffer CYCL_CALL
      LIB_GE_command_buffer {
        MOM_do_template [CONF_CTRL_moves rapid_template]
        LIB_GE_message "[join [CONF_CTRL_drill cycle_call]]" "output_0" "1"
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
    "CYCL CALL POS" {
      LIB_GE_command_buffer CYCL_CALL_POS
      LIB_GE_command_buffer {
        MOM_force once X Y Z
        MOM_suppress once G_motion
        MOM_add_to_line_buffer start "[join [CONF_CTRL_drill cycle_call]] "
        MOM_do_template [CONF_CTRL_moves rapid_template]
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
    "default" {
      if {[info command CYCL_CALL_$lib_parameter_cycle(call)] == "CYCL_CALL_$lib_parameter_cycle(call)"} {
        CYCL_CALL_$lib_parameter_cycle(call)
      }
    }
  }
  if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
    namespace eval $::mom_namespace_name {
      array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
      array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
    }
  } else {
    array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
    array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
  }

}
# <Internal Documentation>
# Controls the drilling move setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_adjust_register {} {

  global mom_tool_adjust_register mom_tool_length_adjust_register mom_tool_number

  LIB_GE_command_buffer CHECK_adjust_register
  LIB_GE_command_buffer {
    if {$mom_tool_length_adjust_register == 0} {set mom_tool_adjust_register $mom_tool_number}
  } @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Check for adjust register
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_tool_number {} {

  global mom_tool_number mom_tool_name

  if {[CONF_CTRL_tool max_tool_number] != 0 && $mom_tool_number > [CONF_CTRL_tool max_tool_number]} {
    set error [LIB_SPF_add_warning "Maximum tool number allowed : [CONF_CTRL_tool max_tool_number]. Check tool $mom_tool_name"]
  }
}
# <Internal Documentation>
# Check the tool number
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_before_plane {} {

  if {[CONF_ITNC530_PLANE rotate_before] == "1"} {
    LIB_GE_command_buffer AXIS_BEFORE_PLANE
    LIB_GE_command_buffer {MOM_do_template rapid_rotary} @OUTPUT
    LIB_GE_command_buffer_output
  }
}
# <Internal Documentation>
# Check to rotate the axis before plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_after_plane {} {

  global mom_kin_machine_type

  if {[CONF_ITNC530_PLANE rotate_after] == "1"} {
    set Q_param(A) 120
    set Q_param(B) 121
    set Q_param(C) 122
    if {[string match "5_axis*" [LIB_PT_get_header_var mom_kin_machine_type]] || [string match "5_AXIS*" [LIB_PT_get_header_var mom_kin_machine_type]]} {
        MOM_output_literal "L $::mom_sys_leader(fourth_axis)Q$Q_param($::mom_sys_leader(fourth_axis)) $::mom_sys_leader(fifth_axis)Q$Q_param($::mom_sys_leader(fifth_axis)) F[CONF_ITNC530_PLANE feed]"
    } else {
        MOM_output_literal "L $::mom_sys_leader(fourth_axis)Q$Q_param($::mom_sys_leader(fourth_axis)) F[CONF_ITNC530_PLANE feed]"
    }
    LIB_GE_command_buffer AXIS_AFTER_PLANE
    LIB_GE_command_buffer {MOM_do_template rapid_rotary CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }
}
# <Internal Documentation>
# Check to rotate the axis after plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_init_cycle_parameters {} {
  global mom_cycle_feed_to mom_cycle_rapid_to mom_cycle_retract_to mom_cycle_spindle_axis
  global mom_cycle_step1 mom_cycle_step2 mom_cycle_step3
  global mom_cycle_delay
  global mom_tool_diameter mom_spindle_direction mom_motion_event
  global mom_prev_pos mom_pos mom_cycle_feed_rate_per_rev mom_cycle_retract_mode
  global cycle_peck_size tool_axis js_return_pos mom_cycle_step
  global mom_cycle_Q202
  global mom_namespace_name mom_output_pos_type mom_mcs_goto
  global lib_parameter_cycle

  LIB_GE_command_buffer INIT_CYCLE_PARAMETER
  LIB_GE_command_buffer {
  #---------- peck sizes ---------
  set cycle_peck_size [expr ($mom_cycle_feed_to*(-1.0))]     ;# single peck size most cycles

  if {![string compare "drill_deep_move" $mom_motion_event] ||\
    ![string compare "drill_break_chip_move" $mom_motion_event]} {

    if {$mom_cycle_step1 == 0} {
      set cycle_peck_size  $mom_tool_diameter  ;# default peck  if not set
    } else {
      set cycle_peck_size  $mom_cycle_step1    ;# real peck
    }
  }
  } @PECK_SIZE

  # for all cycles

  LIB_GE_command_buffer {
  if {![info exists mom_cycle_Q202]} {
    set lib_parameter_cycle(202) [expr ($mom_cycle_feed_to*(-1.0))]
    if {[info exists mom_cycle_step1] && $mom_cycle_step1 != 0} {set lib_parameter_cycle(202) $mom_cycle_step1}
  } else {
    if {[EQ_is_ge [expr abs($mom_cycle_Q202)] [expr abs($mom_cycle_feed_to)]]} {
      set lib_parameter_cycle(202) [expr ($mom_cycle_feed_to*(-1.0))]
    } else {
      set lib_parameter_cycle(202) [expr ($mom_cycle_Q202)]
    }
  }
  } @DEFINE_Q202

  LIB_GE_command_buffer {
  switch -- $lib_parameter_cycle(name) {
    "200" {
      if {![info exists lib_parameter_cycle(210)]} {
        set lib_parameter_cycle(210) 0
      }
    }
    "201" {
      if {![info exists lib_parameter_cycle(208)]} {
        if {[CONF_CTRL_drill retract_feedrate] == "OP"} {
          if {$::mom_feed_retract_nominal_unit == "Rapid"} {
            set lib_parameter_cycle(208) [string range [CONF_CTRL_feed feed_max] 1 end]
          } else {
            set lib_parameter_cycle(208) [format %g $::mom_feed_retract_value]
          }
        } else {
          set lib_parameter_cycle(208) [CONF_CTRL_drill retract_feedrate]
        }
      }
    }
    "202" {
      if {![info exists lib_parameter_cycle(208)]} {
        if {[CONF_CTRL_drill retract_feedrate] == "OP"} {
          if {$::mom_feed_retract_nominal_unit == "Rapid"} {
            set lib_parameter_cycle(208) [string range [CONF_CTRL_feed feed_max] 1 end]
          } else {
            set lib_parameter_cycle(208) [format %g $::mom_feed_retract_value]
          }
        } else {
          set lib_parameter_cycle(208) [CONF_CTRL_drill retract_feedrate]
        }
      }
      if {![info exists lib_parameter_cycle(214)]} {
        set lib_parameter_cycle(214) 1
      }
      if {![info exists lib_parameter_cycle(336)]} {
        set lib_parameter_cycle(336) 0
      }
    }
    "203" {
      if {![info exists lib_parameter_cycle(210)]} {
        set lib_parameter_cycle(210) 0
      }
      if {![info exists lib_parameter_cycle(212)]} {
        set lib_parameter_cycle(212) 0.2
        if {[info exists mom_cycle_step1] && $mom_cycle_step2 != 0} {set lib_parameter_cycle(212) $mom_cycle_step2}
      }
      if {![info exists lib_parameter_cycle(213)]} {
        set lib_parameter_cycle(213) 0
        if {$mom_motion_event == "drill_deep_move"} {set lib_parameter_cycle(213) 0}
        if {$mom_motion_event == "drill_break_chip_move"} {set lib_parameter_cycle(213) 99}
        if {[info exists mom_cycle_step3] && $mom_cycle_step3 != 0} {set lib_parameter_cycle(213) $mom_cycle_step2}
      }
      if {![info exists lib_parameter_cycle(205)]} {
        set lib_parameter_cycle(205) [expr $mom_tool_diameter/2]
      }
      if {![info exists lib_parameter_cycle(208)]} {
        if {[CONF_CTRL_drill retract_feedrate] == "OP"} {
          if {$::mom_feed_retract_nominal_unit == "Rapid"} {
            set lib_parameter_cycle(208) [string range [CONF_CTRL_feed feed_max] 1 end]
          } else {
            set lib_parameter_cycle(208) [format %g $::mom_feed_retract_value]
          }
        } else {
          set lib_parameter_cycle(208) [CONF_CTRL_drill retract_feedrate]
        }
      }
      if {![info exists lib_parameter_cycle(256)]} {
        set lib_parameter_cycle(256) 0.2
      }
    }
    "204" {
      if {![info exists lib_parameter_cycle(255)]} {
        set lib_parameter_cycle(255) $mom_cycle_delay
      }

      if {![info exists lib_parameter_cycle(250)]} {
        LIB_SPF_add_warning "Operation INS->$::mom_path_name<- , Cycle 'Dril,Bore,Back' requires UDE 'CYCL DEF 204 BACK BORING'"
      }
    }
    "205" {
      if {![info exists lib_parameter_cycle(208)]} {
        if {[CONF_CTRL_drill retract_feedrate] == "OP"} {
          if {$::mom_feed_retract_nominal_unit == "Rapid"} {
            set lib_parameter_cycle(208) [string range [CONF_CTRL_feed feed_max] 1 end]
          } else {
            set lib_parameter_cycle(208) [format %g $::mom_feed_retract_value]
          }
        } else {
          set lib_parameter_cycle(208) [CONF_CTRL_drill retract_feedrate]
        }
      }
      if {![info exists lib_parameter_cycle(395)]} {
        set lib_parameter_cycle(395) 0
      }
    }
    "209" {
      if {![info exists lib_parameter_cycle(336)]} {
        set lib_parameter_cycle(336) 0
      }
    }
    }
  } @DEFINE_PARAMETER

  LIB_GE_command_buffer {
  if {[string match "AUTO" $mom_cycle_retract_mode]} {
    set js_return_pos [expr $mom_prev_pos($tool_axis) - $mom_pos($tool_axis)] ;# calc incr retract
  } else {
    set js_return_pos $mom_cycle_rapid_to
  }

  if {[info exists mom_cycle_feed_rate_per_rev]} {
    if {[string match "CCLW" $mom_spindle_direction]} {
      set mom_cycle_feed_rate_per_rev  [expr $mom_cycle_feed_rate_per_rev * (-1)]
    }
  }
# insert next step to overcame the possibility that mom_cycle_rapid_to is negative (FBM)
# -- set mom_cycle_rapid_to tp 0.0 and change the retract_to,feed_to,mom_pos
# -- set mom_pos
# -- set mom_cycle_rapid_to,mom_cycle_retract_to,mom_cycle_feed_to
  #<cam16012>
  if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
    if {[info exists mom_output_pos_type] && $mom_output_pos_type == "mom_mcs_goto"} {
      set mom_pos($mom_cycle_spindle_axis) [expr $${mom_namespace_name}::mom_mcs_goto($mom_cycle_spindle_axis)]
    } else {
      set mom_pos($mom_cycle_spindle_axis) [expr $${mom_namespace_name}::mom_pos($mom_cycle_spindle_axis)]
    }
  }
  if {$mom_cycle_rapid_to <= 0} {
    set mom_pos($mom_cycle_spindle_axis) [expr $mom_pos($mom_cycle_spindle_axis) + $mom_cycle_rapid_to]
    set mom_cycle_feed_to [expr $mom_cycle_feed_to - $mom_cycle_rapid_to]
    set mom_cycle_retract_to [expr $mom_cycle_retract_to - $mom_cycle_rapid_to]
    set mom_cycle_rapid_to [expr $mom_cycle_rapid_to - $mom_cycle_rapid_to]
  }
  } @OTHER_SETTING
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is used to set cycle parameters
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_WRITE_coolant {{option default}} {

  global mom_coolant_mode mom_coolant_status mom_kin_is_turbo_output

  switch -- $option {
    "on"  {
      if {![hiset mom_coolant_mode] || $mom_coolant_mode == ""} {set mom_coolant_mode [CONF_CTRL_coolant coolant_status]}
      if {$mom_coolant_mode == "OFF"} {return}

      LIB_GE_command_buffer COOLNT_on
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_output_before_motion] != 0} {
          MOM_do_template coolant_on
        }
      } @COOLNT_on_std
      LIB_GE_command_buffer_output
    }
    "off" {
      LIB_GE_command_buffer COOLNT_off
      LIB_GE_command_buffer {
        if {[info exists mom_kin_is_turbo_output] && $mom_kin_is_turbo_output == "TRUE" && [MOM_ask_address_value M_coolant] != $::mom_sys_coolant_code(OFF)} {
          MOM_force once M_coolant ; #needs when turbo mode is activated (Bug#669)
        }
        MOM_do_template coolant_off
      } @COOLNT_on_std
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_auto] == 0} {
          set mom_coolant_mode "OFF"
          set mom_coolant_status "OFF"
        }
      } @COOLNT_on_std_2
      LIB_GE_command_buffer_output
    }
  }
}
# <Internal Documentation>
# This procedure is executed to output coolant on or off
#
# Equivalent default output command list with argument "on" is  : LIB_GE_command_buffer_seq COOLNT_on @COOLNT_on_std
# Equivalent default output command list with argument "off" is : LIB_GE_command_buffer_seq COOLNT_off @COOLNT_off_std
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_delay_ENTRY {option} {

  switch -- $option {
    "start" {
      MOM_do_template cycl_def_9_0
    }
    "end" {
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning of MOM_delay procedure
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {

  global tool_axis

  switch -- $tool_axis {
    0 {MOM_suppress once X I}
    1 {MOM_suppress once Y J}
    2 {MOM_suppress once Z K}
  }
  LIB_SPF_check_arc_radius
}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_HELIX_set {} {

  global mom_pos mom_prev_pos
  global mom_helix_direction
  global mom_pos_arc_plane
  global mom_sys_cir_vector
  global mom_sys_helix_pitch_type
  global mom_helix_pitch
  global mom_prev_pos mom_pos_arc_center
  global helix_height helix_angle helix_direction
  global PI tool_axis nturn

  switch -- $mom_sys_helix_pitch_type {
    none {}
    rise_revolution {set pitch $mom_helix_pitch}
    rise_radian {set pitch [expr $mom_helix_pitch / ($PI * 2.0)]}
    other {
      #
      #    Place your custom helix pitch code here
      #
    }
    default {set mom_sys_helix_pitch_type "none"}
  }

  switch -- $tool_axis {
    0 {MOM_force Once J K; MOM_suppress Once I}
    1 {MOM_force Once K I; MOM_suppress Once J}
    2 {MOM_force Once I J; MOM_suppress Once K}
  }

  set helix_height [expr $mom_pos($tool_axis) - $mom_prev_pos($tool_axis)]

  switch -- $mom_helix_direction {
    CLW     {set helix_direction -1}
    CCLW    {set helix_direction 1 }
    default {}
  }

  set helix_angle [expr 360*$helix_direction*$helix_height/$mom_helix_pitch]

  LIB_SPF_check_arc_radius
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # You will need to construct the required block templates and
  # revise the lines below accordingly.

  # MOM_do_template coolant_on
  # MOM_do_template circular_move
  # MOM_force Once circle_direction
  # MOM_do_template helix_move
}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_clamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {return}

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer CLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template clamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fifth_axis] == 1} {

    LIB_GE_command_buffer CLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template clamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called before each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_unclamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}

  if {[CONF_CTRL_clamp fifth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template unclamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template unclamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called after each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_rotate_axis {} {

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer RAPID_ROTARY
  LIB_GE_command_buffer {MOM_do_template rapid_rotary} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_CTRL_clamp_axis

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_nc_header {} {

  global mom_output_file_basename lib_nc_header_name
  global mom_output_unit mom_user_output_unit
  global lib_selected_group_name mom_dnc_program_name
  global mom_lib_program_name lib_flag

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
    if {[LIB_PT_get_header_var lib_selected_group_name exists]} {
       set lib_selected_group_name [LIB_PT_get_header_var lib_selected_group_name]
    } else {
      set lib_selected_group_name [LIB_PT_get_header_var mom_oper_program]
    }
  }
  if {![info exists lib_selected_group_name]} {set lib_selected_group_name ""}
  set lib_nc_header_name $mom_output_file_basename
  switch -- $mom_output_unit {
    IN {set mom_user_output_unit INCH}
    MM {set mom_user_output_unit MM}
  }

  switch -- [CONF_CTRL_setting header_name] {
    "output_file_basename" {set lib_nc_header_name $mom_output_file_basename}
    "selected_group" {
      set lib_nc_header_name $lib_selected_group_name
    }
    "ude_dnc_header" {
      if {[info exists mom_dnc_program_name]} {set lib_nc_header_name $mom_dnc_program_name}
    }
    "ude" {
      if {[info exists mom_lib_program_name]} {set lib_nc_header_name $mom_lib_program_name}
    }
    "ignore" {
                  return 0
    }
                "default" {
      LIB_CONF_do_prop_custom_proc CONF_CTRL_setting header_name "short_template_syntax"
    }
  }

  set lib_nc_header_name [string trim $lib_nc_header_name]
  #
  # Variable lib_nc_header_name is empty that means that mom_output_file_basename is used
  # and you are not in PP
  # for this case selected_group is used -- this is not ""

  if {$lib_nc_header_name == ""} {set lib_nc_header_name $lib_selected_group_name}
  if {$lib_nc_header_name == ""} {set lib_nc_header_name [file rootname [LIB_SPF_get_partnname]]}
  switch -- $::mom_output_unit {
    IN {set mom_user_output_unit INCH}
    MM {set mom_user_output_unit MM}
  }

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_program
  } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens   %_N_${lib_nc_header_name}_MPF
#   Heidenhain    BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O1234
#
#____________________________________________________________________________________________
proc LIB_CTRL_sub_header {} {

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_subprogram
  } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_SPF
#   Heidenhain    BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O1234
#
#____________________________________________________________________________________________
proc LIB_CTRL_feed_output {} {

  global mom_motion_type mom_motion_event mom_feed_cut_value mom_feed_cut_unit mom_feed_rate mom_feed_rate_per_rev
  global mom_cycle_feed_rate mom_output_unit feed_mode
  global feed lib_prev_feed lib_prev_feed_percent
  global mom_machine_mode
  global mom_feed_engage_value mom_feed_engage_unit
  global mom_feed_retract_value mom_feed_retract_unit

  set commandcheck(LIB_CTRL_feed_output_ENTRY) [llength [info commands LIB_CTRL_feed_output_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_machine_mode == "TURN" && $mom_motion_type != "FROM"} {
    MOM_do_template feedrate_mode
  }

  if {[CONF_CTRL_feed feed_linear] == 0 || ([CONF_CTRL_feed feed_linear] == 1 && $mom_machine_mode == "TURN")} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition)
    set feed "AUTO"
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {
    set tmp_motion_type [string tolower $mom_motion_type]
    if {[CONF_CTRL_feed feed_$tmp_motion_type] == "NX"} {
      if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
        MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
        MOM_set_address_format F_tool_call $mom_sys_feed_param(${feed_mode},format)
      } else {
        switch -- $feed_mode {
          IPM     -
          MMPM    -
          IPR     -
          MMPR    -
          DPM     -
          FRN     {
            MOM_set_address_format F Feed_${feed_mode}
            MOM_set_address_format F_tool_call Feed_${feed_mode}
            }
          INVERSE {MOM_set_address_format F Feed_INV}
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "P_CUT"} {
      if {(![string match "rapid" $tmp_motion_type] && ![string match "traverse" $tmp_motion_type] && ![string match "approach" $tmp_motion_type] \
      && ![string match "departure" $tmp_motion_type]) || $mom_feed_rate != $::mom_kin_rapid_feed_rate} {
      MOM_set_address_format F String
      if {![info exist lib_prev_feed] || (![EQ_is_equal $feed $mom_feed_cut_value] && $feed  != $lib_prev_feed)} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
          set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
          set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
          if {(![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]) && ![EQ_is_equal $tmp_feed_percent 1.0]} {
            MOM_output_literal "[CONF_CTRL_feed feed_generic]=[CONF_CTRL_feed feed_cut]*$tmp_feed_percent"
          set feed [CONF_CTRL_feed feed_generic]
        } elseif {[info exists lib_prev_feed_percent] && ![EQ_is_equal $lib_prev_feed_percent 1.0]} {
          set feed [CONF_CTRL_feed feed_generic]
        } else {
          set feed [CONF_CTRL_feed feed_cut]
        }
        MOM_force once F
          set lib_prev_feed_percent $tmp_feed_percent
      } else {
        set feed [CONF_CTRL_feed feed_cut]
        }
      }
      set lib_prev_feed $feed

    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "MAX"} {
      MOM_set_address_format F String
      set lib_prev_feed $feed
      set feed [CONF_CTRL_feed feed_$tmp_motion_type]
    } else {
      MOM_set_address_format F String
      set tmp_feed $feed
      set feed [CONF_CTRL_feed feed_$tmp_motion_type]
      if {$tmp_motion_type == "cut" && ![EQ_is_equal $mom_feed_rate $mom_feed_cut_value]} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {(![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]) && ![EQ_is_equal $tmp_feed_percent 1.0]} {
          MOM_output_literal "[CONF_CTRL_feed feed_generic]=[CONF_CTRL_feed feed_cut]*$tmp_feed_percent"
          set feed [CONF_CTRL_feed feed_generic]
        } elseif {[info exists lib_prev_feed_percent] && ![EQ_is_equal $lib_prev_feed_percent 1.0]} {
          set feed [CONF_CTRL_feed feed_generic]
        } else {
          set feed [CONF_CTRL_feed feed_cut]
        }
        MOM_force once F
        set lib_prev_feed_percent $tmp_feed_percent
      }
      if {$tmp_motion_type == "engage" && ![EQ_is_equal $mom_feed_rate $mom_feed_engage_value]} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_engage_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {(![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]) && ![EQ_is_equal $tmp_feed_percent 1.0]} {
          MOM_output_literal "[CONF_CTRL_feed feed_generic]=[CONF_CTRL_feed feed_engage]*$tmp_feed_percent"
          set feed [CONF_CTRL_feed feed_generic]
        } elseif {[info exists lib_prev_feed_percent] && ![EQ_is_equal $lib_prev_feed_percent 1.0]} {
          set feed [CONF_CTRL_feed feed_generic]
        } else {
          set feed [CONF_CTRL_feed feed_engage]
        }
        MOM_force once F
        set lib_prev_feed_percent $tmp_feed_percent
      }
      if {$tmp_motion_type == "retract" && ![EQ_is_equal $mom_feed_rate $mom_feed_retract_value]} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_retract_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {(![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]) && ![EQ_is_equal $tmp_feed_percent 1.0]} {
          MOM_output_literal "[CONF_CTRL_feed feed_generic]=[CONF_CTRL_feed feed_retract]*$tmp_feed_percent"
          set feed [CONF_CTRL_feed feed_generic]
        } elseif {[info exists lib_prev_feed_percent] && ![EQ_is_equal $lib_prev_feed_percent 1.0]} {
          set feed [CONF_CTRL_feed feed_generic]
        } else {
          set feed [CONF_CTRL_feed feed_retract]
        }
        MOM_force once F
        set lib_prev_feed_percent $tmp_feed_percent
      }
      set lib_prev_feed $tmp_feed
    }

  } else {
    # use only NX-Values
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Output the feed dependent on the setting
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (FQ21)
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_set_feed_parameter {} {

  global mom_feed_cut_unit mom_output_unit mom_feed_rate feed
  global mom_cycle_feed_rate mom_cycle_feed_rate_per_rev
  global mom_feed_engage_value mom_feed_cut_value mom_feed_retract_value mom_feed_cycle_value
  global mom_feed_engage_unit mom_feed_cut_unit mom_feed_retract_unit mom_feed_cycle_value
  global mom_operation_type mom_motion_type lib_motion_type_list
  global lib_prev_feed_cut_value lib_flag mom_tool_name mom_kin_is_turbo_output
  global mom_feed_rate_output_mode mom_feed_rate_per_rev
  global lib_prev_feed_engage_value lib_prev_feed_retract_value
  global lib_prev_cycle_definition_mode mom_cycle_definition_mode
  global lib_prev_feed_engage_value lib_prev_feed_retract_value

  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {

    # check if "drilling" "Thread Milling" "Cylinder Milling" are the previous operation and the current cycle output is different
    # to the previous operation
    if {($mom_operation_type == "Drilling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Thread Milling")} {
      if {![info exists lib_prev_cycle_definition_mode] || $lib_prev_cycle_definition_mode != $mom_cycle_definition_mode } {
        set check_cycle_definition_mode 1
      } else {
        set check_cycle_definition_mode 0
      }
      set lib_prev_cycle_definition_mode $mom_cycle_definition_mode
    } else {
      set check_cycle_definition_mode 0
      set lib_prev_cycle_definition_mode 1
    }

    if {[info level 1] != "MOM_start_of_path" || ($mom_tool_name == [LIB_SPF_get_pretreatment mom_tool_name -1]                 && \
      (([info exist lib_prev_feed_cut_value] && ![EQ_is_equal $mom_feed_cut_value $lib_prev_feed_cut_value])              || \
      ([info exist lib_prev_feed_engage_value] && ![EQ_is_equal $mom_feed_engage_value $lib_prev_feed_engage_value])      || \
      ([info exist lib_prev_feed_retract_value] && ![EQ_is_equal $mom_feed_retract_value $lib_prev_feed_retract_value])   || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Hole Making"                                                   || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Point to Point"                                                || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Drilling"))                                                    || \
      $check_cycle_definition_mode == 1} {

      MOM_force once F
      if {[CONF_CTRL_feed feed_engage] != "NX" && [CONF_CTRL_feed feed_engage] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_engage_value/25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_engage_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_engage_value
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_engage_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_engage_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_engage]=[LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Engage Move"]" "output_0" "1"
      }

      if {$mom_operation_type == "Hole Making" || $mom_operation_type == "Point to Point" || ($mom_operation_type == "Drilling" || $mom_operation_type == "Thread Milling" || $mom_operation_type == "Cylinder Milling" && $::mom_cycle_definition_mode == 0)} {
        set mom_feed_rate $mom_feed_cut_value
        set mom_cycle_feed_rate $mom_feed_cut_value
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_cut_value
          set mom_cycle_feed_rate_per_rev $mom_feed_cut_value
          set mom_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
          set mom_cycle_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
        set mom_motion_type "CYCLE"
        LIB_SPF_feedrate_set
        if {[CONF_CTRL_feed feed_cycle] != "NX" && [CONF_CTRL_feed feed_cycle] != "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cycle]=[LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Cycle Move"]" "output_0" "1"
        } elseif {[CONF_CTRL_feed feed_cycle] == "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cut]=[LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Cutting"]" "output_0" "1"
        }
      } else {
        set mom_kin_is_turbo_output "FALSE"
        if {[CONF_CTRL_feed feed_cut] != "NX" && [CONF_CTRL_feed feed_cut] != "P_CUT"} {
          if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
            set mom_feed_rate [expr $mom_feed_cut_value/25.4]
          } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
            set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
          } else {
            set mom_feed_rate $mom_feed_cut_value
          }
          if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
            set mom_feed_rate_per_rev $mom_feed_cut_value
          }
          set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
          set mom_motion_type "UNKNOWN"
          LIB_SPF_feedrate_set
          LIB_GE_message "[CONF_CTRL_feed feed_cut]=[LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Cutting"]" "output_0" "1"
        }
      }

      if {[CONF_CTRL_feed feed_retract] != "NX" && [CONF_CTRL_feed feed_retract] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_retract_value/25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_retract_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_retract_value
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_retract_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_retract_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_retract]=[LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Retract Move"]" "output_0" "1"
      }
      set lib_prev_feed_cut_value $mom_feed_cut_value
      set lib_prev_feed_engage_value $mom_feed_engage_value
      set lib_prev_feed_retract_value $mom_feed_retract_value
    }
  }
}
# <Internal Documentation>
#
# Set the feed parameter if nessesary
# only if property feed_linear is set to 2(parameter)
#
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (F[#21])
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_modify_inline {line {word_separator 0} {max_decimal_place 3} {iterationen 25}} {

  set check 0 ; set linebackup $line

  if {[regexp -- {=(\d*)$} $line all value]} {
    set line [string trimright $line $value]
    append line "${value}."
  }

  while {[regexp -- {(=\d* )} $line all value]} {
    incr check
    regsub -- (?q)$value $line "[string trim $value]. " line
    if {$check > $iterationen} {return $linebackup} ; # To prevent infinite loops
  }

  return $line

}
# <Internal Documentation>
#
# If numbers should be output within a list, but 0 and decimal point need to be add
# if decimal places is set there will be a formatting done with equivalent decimal places
#
# e.g.
# Before: CYCL DEF 200 Q200=2 Q201=-2.5 Q206=251 Q202=2.5 Q210=0 Q203=0 Q204=5 Q211=0
# After:  CYCL DEF 200 Q200=2. Q201=-2.5 Q206=251. Q202=2.5 Q210=0. Q203=0. Q204=5. Q211=0.
#
# <Internal Example>
# set list [LIB_CTRL_modify_inline $list]
#____________________________________________________________________________________________
proc LIB_CTRL_activate_feed_rate_modes {} {

  global mom_feed_cut_value feed_linear_leader mom_sys_feed_param feed_mode
  global mom_machine_mode

  if {[CONF_CTRL_feed feed_linear] == 1 && $mom_machine_mode == "MILL"} {
    MOM_enable_address F_param
    MOM_disable_address F
    MOM_set_address_format F String
    set feed_linear_leader "FAUTO"
    MOM_force once F_param

    # Check if all feedrate values are same as mom_feed_cut_value
    set output_warning 0
    if {$::mom_operation_type == "Point to Point"} {
      if {[info exist ::mom_feed_stepover_value]} {unset ::mom_feed_stepover_value}
      if {[info exist ::mom_feed_first_cut_value]} {unset ::mom_feed_first_cut_value}
      if {[info exist ::mom_feed_last_cut_value]} {unset ::mom_feed_last_cut_value}
    }

    foreach type $::lib_motion_type_list {
      set feed_type "mom_feed_[string tolower $type]_value"
      regsub -all "firstcut" $feed_type "first_cut" feed_type
      regsub -all "lastcut" $feed_type "last_cut" feed_type
      global $feed_type
      if {[info exist $feed_type]} {
        set feed_type_value [subst $[subst $feed_type]]
        if {![EQ_is_equal $mom_feed_cut_value $feed_type_value 0.01] && $feed_type_value > 0} {
          set output_warning 1
        }
      }
    }
    if {$output_warning} {
      LIB_SPF_add_warning "Feedrate values other than cut feedrate are ignored if FAUTO is used.."
    }

  } else {
    MOM_disable_address F_param
    MOM_enable_address F
    if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
      MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
      MOM_set_address_format F_tool_call $mom_sys_feed_param(${feed_mode},format)
    } else {
      switch -- $feed_mode {
        IPM     -
        MMPM    -
        IPR     -
        MMPR    -
        DPM     -
        FRN     {
          MOM_set_address_format F Feed_${feed_mode}
          MOM_set_address_format F_tool_call Feed_${feed_mode}
          }
        INVERSE {MOM_set_address_format F Feed_INV}
      }
    }
    set feed_linear_leader "F"
    MOM_force once F
  }
}
# <Internal Documentation>
#
# Define the feed mode dependent on the lib_parameter(feed_linear) setting
# 0      normal feedrate output
# 1      feedrate output as FAUTO
# other  feedrate output as Parameter (FQ21)
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc MOM_lib_event_cycle_32 {} {
  global lib_parameter_cycle

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_cycle_32_tolerance_defined mom_cycle_32_tolerance_rotary_defined
  if {[info exist mom_cycle_32_tolerance_defined] && $mom_cycle_32_tolerance_defined == "0"} {
    set ::mom_cycle_32_tolerance [CONF_CTRL_CYCL32 cycle32_tolerance_value]
  }
  if {[info exist mom_cycle_32_tolerance_rotary_defined] && $mom_cycle_32_tolerance_rotary_defined == "0"} {
    set ::mom_cycle_32_tolerance_rotary [CONF_CTRL_CYCL32 cycle32_tolerance_rotary]
  }
  set lib_parameter_cycle(name) "32"
  set lib_parameter_cycle(32) $::mom_cycle_32_status
  set lib_parameter_cycle(320)  $::mom_cycle_32_mode
  set lib_parameter_cycle(321)  $::mom_cycle_32_tolerance
  set lib_parameter_cycle(322)  $::mom_cycle_32_mode_optional_output
  set lib_parameter_cycle(323)  $::mom_cycle_32_tolerance_rotary
  set lib_parameter_cycle(324)  $::mom_cycle_32_use_operation

  #output cycle
  LIB_CTRL_cycle_32 1

}
# <Internal Documentation>
# Assign the variables from the cycle_ude to an array
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc  MOM_lib_event_cycle_200 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "200"
  set lib_parameter_cycle(202)  "$::mom_cycle_Q202"
  set lib_parameter_cycle(210)  "$::mom_cycle_Q210"
}
# <Internal Documentation>
# Assign the variables from the cycle_ude to an array
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc  MOM_lib_event_cycle_201 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "201"
  set lib_parameter_cycle(208)  "$::mom_cycle_Q208"
}
proc  MOM_lib_event_cycle_202 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "202"
  set lib_parameter_cycle(208)  "$::mom_cycle_Q208"
  set lib_parameter_cycle(214)  "[string range $::mom_cycle_Q214 0 1]"
  set lib_parameter_cycle(336)  "$::mom_cycle_Q336"
}
proc  MOM_lib_event_cycle_203 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "203"
  set lib_parameter_cycle(202)  "$::mom_cycle_Q202"
  set lib_parameter_cycle(210)  "$::mom_cycle_Q210"
  set lib_parameter_cycle(212)  "$::mom_cycle_Q212"
  set lib_parameter_cycle(213)  "$::mom_cycle_Q213"
  set lib_parameter_cycle(205)  "$::mom_cycle_Q205"
  set lib_parameter_cycle(208)  "$::mom_cycle_Q208"
  set lib_parameter_cycle(256)  "$::mom_cycle_Q256"
}
proc  MOM_lib_event_cycle_204 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "204"
  set lib_parameter_cycle(249)  "$::mom_cycle_Q249"
  set lib_parameter_cycle(250)  "$::mom_cycle_Q250"
  set lib_parameter_cycle(251)  "$::mom_cycle_Q251"
  set lib_parameter_cycle(252)  "$::mom_cycle_Q252"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(254)  "$::mom_cycle_Q254"
  set lib_parameter_cycle(214)  "[string range $::mom_cycle_Q214 0 1]"
  set lib_parameter_cycle(336)  "$::mom_cycle_Q336"
}
proc  MOM_lib_event_cycle_205 {} {
  global lib_parameter_cycle mom_cycle_Q208 mom_cycle_Q395

  set lib_parameter_cycle(name) "205"
  set lib_parameter_cycle(202)  "$::mom_cycle_Q202"
  set lib_parameter_cycle(212)  "$::mom_cycle_Q212"
  set lib_parameter_cycle(205)  "$::mom_cycle_Q205"
  set lib_parameter_cycle(258)  "$::mom_cycle_Q258"
  set lib_parameter_cycle(259)  "$::mom_cycle_Q259"
  set lib_parameter_cycle(257)  "$::mom_cycle_Q257"
  set lib_parameter_cycle(256)  "$::mom_cycle_Q256"
  set lib_parameter_cycle(379)  "$::mom_cycle_Q379"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  if {[info exists mom_cycle_Q208]} {
    set lib_parameter_cycle(208)  "$mom_cycle_Q208"
  }
  if {[info exists mom_cycle_Q395]} {
    set lib_parameter_cycle(395)  "$mom_cycle_Q395"
  }
}
proc  MOM_lib_event_cycle_206 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "206"
  set lib_parameter_cycle(206)  "$::mom_cycle_Q206"
  set lib_parameter_cycle(211)  "$::mom_cycle_Q211"
}
proc  MOM_lib_event_cycle_208 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "208"
  set lib_parameter_cycle(335)  "$::mom_cycle_Q335"
  set lib_parameter_cycle(334)  "$::mom_cycle_Q334"
  set lib_parameter_cycle(342)  "$::mom_cycle_Q342"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
}
proc  MOM_lib_event_cycle_209 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "209"
  set lib_parameter_cycle(257)  "$::mom_cycle_Q257"
  set lib_parameter_cycle(256)  "$::mom_cycle_Q256"
  set lib_parameter_cycle(336)  "$::mom_cycle_Q336"
  set lib_parameter_cycle(403)  "$::mom_cycle_Q403"
}
proc  MOM_lib_event_cycle_241 {} {
  global lib_parameter_cycle mom_cycle_Q435

  if {![info exists mom_cycle_Q435]} {set mom_cycle_Q435 0}

  set lib_parameter_cycle(name) "241"
  set lib_parameter_cycle(208)  "$::mom_cycle_Q208"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(379)  "$::mom_cycle_Q379"
  set lib_parameter_cycle(426)  "$::mom_cycle_Q426"
  set lib_parameter_cycle(427)  "$::mom_cycle_Q427"
  set lib_parameter_cycle(428)  "$::mom_spindle_speed"
  set lib_parameter_cycle(429)  "$::mom_cycle_Q429"
  set lib_parameter_cycle(430)  "$::mom_cycle_Q430"
  set lib_parameter_cycle(435)  "$::mom_cycle_Q435"
}
proc  MOM_lib_event_cycle_252 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "252"
  set lib_parameter_cycle(215)  "[string range $::mom_cycle_Q215 0 1]"
  set lib_parameter_cycle(223)  "$::mom_cycle_Q223"
  set lib_parameter_cycle(368)  "$::mom_cycle_Q368"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
  set lib_parameter_cycle(202)  "$::mom_cycle_Q202"
  set lib_parameter_cycle(369)  "$::mom_cycle_Q369"
  set lib_parameter_cycle(338)  "$::mom_cycle_Q338"
  set lib_parameter_cycle(370)  "$::mom_cycle_Q370"
  set lib_parameter_cycle(366)  "[string range $::mom_cycle_Q366 0 1]"
  set lib_parameter_cycle(385)  "$::mom_cycle_Q385"
}
proc  MOM_lib_event_cycle_262 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "262"
  set lib_parameter_cycle(335)  "$::mom_cycle_Q335"
  set lib_parameter_cycle(355)  "$::mom_cycle_Q355"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
}
proc  MOM_lib_event_cycle_263 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "263"
  set lib_parameter_cycle(335)  "$::mom_cycle_Q335"
  set lib_parameter_cycle(239)  "$::mom_cycle_Q239"
  set lib_parameter_cycle(356)  "$::mom_cycle_Q356"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
  set lib_parameter_cycle(357)  "$::mom_cycle_Q357"
  set lib_parameter_cycle(358)  "$::mom_cycle_Q358"
  set lib_parameter_cycle(359)  "$::mom_cycle_Q359"
  set lib_parameter_cycle(254)  "$::mom_cycle_Q254"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
}
proc  MOM_lib_event_cycle_264 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "264"
  set lib_parameter_cycle(335)  "$::mom_cycle_Q335"
  set lib_parameter_cycle(356)  "$::mom_cycle_Q356"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
  set lib_parameter_cycle(202)  "$::mom_cycle_Q202"
  set lib_parameter_cycle(258)  "$::mom_cycle_Q258"
  set lib_parameter_cycle(257)  "$::mom_cycle_Q257"
  set lib_parameter_cycle(256)  "$::mom_cycle_Q256"
  set lib_parameter_cycle(358)  "$::mom_cycle_Q358"
  set lib_parameter_cycle(359)  "$::mom_cycle_Q359"
  set lib_parameter_cycle(206)  "$::mom_cycle_Q206"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
}
proc  MOM_lib_event_cycle_265 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "265"
  set lib_parameter_cycle(335)  "$::mom_cycle_Q335"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(358)  "$::mom_cycle_Q358"
  set lib_parameter_cycle(359)  "$::mom_cycle_Q359"
  set lib_parameter_cycle(360)  "[string range $::mom_cycle_Q360 0 1]"
  set lib_parameter_cycle(254)  "$::mom_cycle_Q254"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
}
proc  MOM_lib_event_cycle_267 {} {
  global lib_parameter_cycle

  set lib_parameter_cycle(name) "267"
  set lib_parameter_cycle(335)  "$::mom_cycle_Q335"
  set lib_parameter_cycle(355)  "$::mom_cycle_Q355"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
  set lib_parameter_cycle(358)  "$::mom_cycle_Q358"
  set lib_parameter_cycle(359)  "$::mom_cycle_Q359"
  set lib_parameter_cycle(254)  "$::mom_cycle_Q254"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
}

proc LIB_CTRL_automatic_rotary_positioning_output {} {

  global mom_pos mom_out_angle_pos mom_feed_rate mom_warning_info
  global auto_rot_pos

  LIB_GE_command_buffer AUTOMATIC_ROTARY_positioning

  LIB_GE_command_buffer {LIB_GE_message "Automatic repositioning $mom_warning_info"} @MESSAGE

  LIB_GE_command_buffer {
    LIB_GE_message "retract"
                set mom_pos(0) $auto_rot_pos(retract,0)
                set mom_pos(1) $auto_rot_pos(retract,1)
                set mom_pos(2) $auto_rot_pos(retract,2)
                set mom_feed_rate $auto_rot_pos(retract,feed)
                MOM_do_template rapid_move
  } @RETRACT

  LIB_GE_command_buffer {
    #Cancel continious mode
    if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
      LIB_ROTARY_absolute_reset
    } else {
      LIB_ROTARY_simultaneous_reset
    }

    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}

  } @RETRACT_HOME

  LIB_GE_command_buffer {
    LIB_GE_message "repositionnning"
    set mom_out_angle_pos(0) $auto_rot_pos(reposition,0)
    set mom_out_angle_pos(1) $auto_rot_pos(reposition,1)
    MOM_do_template rapid_move
  } @REPOSITIONNNING

  LIB_GE_command_buffer {
    LIB_GE_message "approach"
    set mom_pos(0) $auto_rot_pos(approach,0)
    set mom_pos(1) $auto_rot_pos(approach,1)
    set mom_pos(2) $auto_rot_pos(approach,2)
    set mom_feed_rate $auto_rot_pos(approach,feed)
    MOM_do_template rapid_move
  } @APPROACH

  LIB_GE_command_buffer {
    LIB_GE_message "engage"
    set mom_pos(0) $auto_rot_pos(engage,0)
    set mom_pos(1) $auto_rot_pos(engage,1)
    set mom_pos(2) $auto_rot_pos(engage,2)
    set mom_feed_rate $auto_rot_pos(engage,feed)
    MOM_do_template linear_move
  } @ENGAGE
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Output motions for automatic rotary positioning when over travel limit
#
# AUTOMATIC_ROTARY_positioning default list:
# @RETRACT @RETRACT_HOME @REPOSITIONNNING @APPROACH @ENGAGE
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_FH_after_output_rework_outfile_ENTRY {content} {

  if {[CONF_CTRL_setting rework_emptylines]} {
    # Example to replace emty lines with e.g. "123 L"
    set loop 0
    while {$loop >= 0} {
      set loop [lsearch -regexp $content {^[0-9]+.L\s*$}]
      set content [lreplace [K $content [set list {}]] $loop $loop]
    }
  }

  if {[CONF_CTRL_setting rework_linenumbers]} {
    # Example to reorder the linenumbers
    set count $::mom_sequence_number
    set newcontend ""
    foreach e $content {
      if {[regexp -- {^[0-9]+(.*$)} $e all code]} {
        lappend newcontend "$count$code"
        incr count $::mom_sequence_increment
      } else {
        lappend newcontend $e
      }
    }
    set content $newcontend
  }

  return $content

}
# <Internal Documentation>
#
# >> It's still under development <<
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_convert_feed_unit {} {

  set commandcheck(LIB_CTRL_convert_feed_unit_ENTRY) [llength [info commands LIB_CTRL_convert_feed_unit_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_convert_feed_unit_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_convert_feed_unit_ENTRY)} {LIB_CTRL_convert_feed_unit_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global feed mom_output_unit
  if {$mom_output_unit == "IN"} {
    set feed [expr $feed*10]
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_convert_feed_unit_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_convert_feed_unit_ENTRY)} {LIB_CTRL_convert_feed_unit_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_convert_inch_unit {} {

  set commandcheck(LIB_CTRL_convert_inch_unit_ENTRY) [llength [info commands LIB_CTRL_convert_inch_unit_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_convert_inch_unit_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_convert_inch_unit_ENTRY)} {LIB_CTRL_convert_inch_unit_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_sys_feed_rate_factor mom_output_unit
  if {$mom_output_unit == "IN"} {
    set mom_sys_feed_rate_factor 10
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_convert_inch_unit_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_convert_inch_unit_ENTRY)} {LIB_CTRL_convert_inch_unit_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cut_move_LIB {} {

  set commandcheck(LIB_CTRL_cut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_LIB {} {

  set commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY) [llength [info commands LIB_CTRL_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_engage_move_LIB {} {

  set commandcheck(LIB_CTRL_engage_move_LIB_ENTRY) [llength [info commands LIB_CTRL_engage_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_retract_move_LIB {} {

  set commandcheck(LIB_CTRL_retract_move_LIB_ENTRY) [llength [info commands LIB_CTRL_retract_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_firstcut_move_LIB {} {

  set commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_firstcut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_approach_move_LIB {} {

  set commandcheck(LIB_CTRL_approach_move_LIB_ENTRY) [llength [info commands LIB_CTRL_approach_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_stepover_move_LIB {} {

  set commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY) [llength [info commands LIB_CTRL_stepover_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_departure_move_LIB {} {

  set commandcheck(LIB_CTRL_departure_move_LIB_ENTRY) [llength [info commands LIB_CTRL_departure_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_return_move_LIB {} {

  set commandcheck(LIB_CTRL_return_move_LIB_ENTRY) [llength [info commands LIB_CTRL_return_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_traversal_move_LIB {} {

  set commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY) [llength [info commands LIB_CTRL_traversal_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_AdvCallBack_feedrate {} {

  set ::feed [expr $::mom_feedrate*10]
  # Set following variable to the ::feed otherwise in the next line the orginal feedrate (::feed / 10 ) is output
  set ::mom_feed_rate $::feed
  set ::mom_feedrate $::feed

}
# <Internal Documentation>
# This function is called from LIB_SPF_feed_turbo_status_set to setup INCH output feedrate
# value in advanced turbo mode.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sidecut_move_LIB {} {

  set commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_sidecut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_from_move_LIB {} {

  set commandcheck(LIB_CTRL_from_move_LIB_ENTRY) [llength [info commands LIB_CTRL_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_default_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_default_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_move_LIB {} {

  set commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cycle_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_lift_move_LIB {} {

  set commandcheck(LIB_CTRL_lift_move_LIB_ENTRY) [llength [info commands LIB_CTRL_lift_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_undefined_move_LIB {} {

  set commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY) [llength [info commands LIB_CTRL_undefined_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_standard_path_between_rotary_motions_checking {{option default}} {

  global mom_out_angle_pos mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global prev_convert_mom_out_angle_pos mom_prev_pos mom_pos

  switch -- $option {
    "pos_to_sim"  {
      # motion POS to SIM
      # check[LIB_cycle800_DIR MOVE] to set limitation
      if {[CONF_ITNC530_PLANE seq_type] == "AUTO" || [CONF_ITNC530_PLANE seq_type] == "FIX"} {
        if {[CONF_ITNC530_PLANE seq] == "-"} {
          if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] != "5_axis_dual_head"} {
            set mom_prev_pos(3) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_4th_axis_min_limit]
            if {$mom_prev_pos(3) < -180} {set mom_prev_pos(3) -179.}
          } else {
            set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_5th_axis_min_limit]
            if {$mom_prev_pos(4) < -180} {set mom_prev_pos(4) -179.}

          }
        } else {
          if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] != "5_axis_dual_head"} {
            set mom_prev_pos(3) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_4th_axis_max_limit]
            if {$mom_prev_pos(3) > 180} {set mom_prev_pos(3) 179.}
          } else {
            set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_5th_axis_max_limit]
            if {$mom_prev_pos(4) > 180} {set mom_prev_pos(4) 179.}
          }
        }

      } elseif {[CONF_ITNC530_PLANE seq_type] == "OFF"} {
        if {[EQ_is_lt $mom_out_angle_pos(0) 0.0]} {
          if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] != "5_axis_dual_head"} {
            set mom_prev_pos(3) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_4th_axis_min_limit]
            if {$mom_prev_pos(3) < -180} {set mom_prev_pos(3) -179.}
          } else {
            set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_5th_axis_min_limit]
            if {$mom_prev_pos(4) < -180} {set mom_prev_pos(4) -179.}

          }
        } else {
          if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] != "5_axis_dual_head"} {
            set mom_prev_pos(3) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_4th_axis_max_limit]
            if {$mom_prev_pos(3) > 180} {set mom_prev_pos(3) 179.}
          } else {
            set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_5th_axis_max_limit]
            if {$mom_prev_pos(4) > 180} {set mom_prev_pos(4) 179.}
          }
        }

      }

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_prev_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_prev_pos(3) 0
      }

      MOM_reload_variable -a mom_prev_pos

    }
    "pos_to_sim_next" {
      # motion POS to SIM
      # check[LIB_cycle800_DIR MOVE] to set limitation
      if {[CONF_ITNC530_PLANE seq_type] == "AUTO" || [CONF_ITNC530_PLANE seq_type] == "FIX"} {
        if {[CONF_ITNC530_PLANE seq] == "-"} {
          set mom_pos(4) $mom_kin_5th_axis_min_limit
        } else {
          set mom_pos(4) $mom_kin_5th_axis_max_limit
        }

      } elseif {[CONF_ITNC530_PLANE seq_type] == "OFF"} {
        if {[EQ_is_lt $mom_out_angle_pos(0) 0.0]} {
          set mom_pos(4) $mom_kin_5th_axis_min_limit
        } else {
          set mom_pos(4) $mom_kin_5th_axis_max_limit
        }

      }

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_pos(3) 0
      }

      MOM_reload_variable -a mom_pos

    }
    "sim_to_pos" {
      # motion SIM to POS
      # check mom_out_angle_pos(1) setting in LIB_SPF_convert_point proc
      if {[CONF_ITNC530_PLANE seq_type] == "AUTO" || ([info exists ::lib_flag(preferred_solution)] && $::lib_flag(preferred_solution) != "OFF")} {
        if {[EQ_is_ge $mom_out_angle_pos(1) 0.0]} {
          CONF_ITNC530_PLANE set seq  "+"
        } else {
          CONF_ITNC530_PLANE set seq  "-"
        }
      }
    }
  }
}
# <Internal Documentation>
#
# Used when [CONF_CTRL_moves standard_path_between_rotary_motions] == 1 for internal tool path
# Set right rotary position when lib_flag(mode_current_status) changes
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_32 {{use_ude_settings 0}} {
  global mom_cutmthd_libref
  global lib_parameter_cycle lib_flag
  global mom_cycle_32_status
  global lib_cycle_32_1_tol lib_cycle_32_2_mode lib_cycle_32_2_ta

  if {[string match "point*" [LIB_SPF_ask_operation_type]] || [string match "probe*" [LIB_SPF_ask_operation_type]]} {
    if {[info exists lib_flag(cycl32,status)] && $lib_flag(cycl32,status) == 1} {
      LIB_GE_command_buffer CYCL32_OFF_DRILL
      LIB_GE_command_buffer {MOM_do_template CYCL_32_0} @CYCL32_0
      LIB_GE_command_buffer {
        MOM_suppress once TOL
        MOM_do_template CYCL_32_1
      } @CYCL32_1
      LIB_GE_command_buffer_output
      set lib_flag(cycl32,status) 0
    }
    return
  }
  #from UDE
  if {$use_ude_settings == 1} {
    if {$lib_parameter_cycle(32) == "OFF"} {

      LIB_GE_command_buffer CYCL32_OFF
      LIB_GE_command_buffer {MOM_do_template CYCL_32_0} @CYCL32_0
      LIB_GE_command_buffer {
        MOM_suppress once TOL
        MOM_do_template CYCL_32_1
      } @CYCL32_1
      LIB_GE_command_buffer_output

      set lib_flag(cycl32,status) 0

      return
    }
    if {$lib_parameter_cycle(324) == "ON"} {
      set lib_parameter_cycle(321) [expr $::mom_inside_outside_tolerances(0)+$::mom_inside_outside_tolerances(1)]
    }
  } else {
    #if UDE was active previously -> exit
    if {[info exists mom_cycle_32_status]} {
      unset mom_cycle_32_status
      return
    }

    #only continue if cyc32 property is set to on
    if {[CONF_CTRL_CYCL32 cycle32_mode] == 0} {return}

    if {[CONF_CTRL_CYCL32 cycle32_hsc_mode] == 0 || [CONF_CTRL_CYCL32 cycle32_hsc_mode] == 1} {
      set lib_parameter_cycle(320) [CONF_CTRL_CYCL32 cycle32_hsc_mode]
    } else {
      LIB_CONF_do_prop_custom_proc CONF_CTRL_CYCL32 cycle32_hsc_logic
    }

    if {[CONF_CTRL_CYCL32 cycle32_use_camtolerance] == 1} {
      set lib_parameter_cycle(321) [expr $::mom_inside_outside_tolerances(0)+$::mom_inside_outside_tolerances(1)]
    } else {
      set lib_parameter_cycle(321) [CONF_CTRL_CYCL32 cycle32_tolerance_value]
    }
    set lib_parameter_cycle(323) [CONF_CTRL_CYCL32 cycle32_tolerance_rotary]
    set lib_parameter_cycle(322) [CONF_CTRL_CYCL32 cycle32_optional_output]
  }

  LIB_GE_command_buffer CYCL32
  LIB_GE_command_buffer {MOM_do_template CYCL_32_0} @CYCL32_0
  LIB_GE_command_buffer {MOM_do_template CYCL_32_1} @CYCL32_1
  if {$lib_parameter_cycle(322) != 0} {
    LIB_GE_command_buffer {MOM_do_template CYCL_32_2} @CYCL32_2
  }
  LIB_GE_command_buffer_output

  set lib_flag(cycl32,status) 1
}
# <Internal Documentation>
#
# Used to output CYCLE32, either called by LIB_CTRL_before_first_motion_LIB (when tolerancing
# is defined in PostConfigurator UI) or called by MOM_lib_event_cycle_32
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_before_first_motion_LIB {} {

  set commandcheck(LIB_CTRL_before_first_motion_LIB_ENTRY) [llength [info commands LIB_CTRL_before_first_motion_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_before_first_motion_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_before_first_motion_LIB_ENTRY)} {LIB_CTRL_before_first_motion_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_cycle_32
  LIB_GE_command_buffer {
    if {$::mom_current_motion == "initial_move" || $::mom_current_motion == "first_move"} {
  LIB_CTRL_cycle_32
    }
  } @CYCLE32
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_before_first_motion_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_before_first_motion_LIB_ENTRY)} {LIB_CTRL_before_first_motion_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
# Called in LIB_SPF_first_tool_path_motion for first motion of each operation
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc DEFINE_MACROS {} {
#=============================================================
  global mom_pb_macro_arr

  set mom_pb_macro_arr(CYCL_200) \
  [list {{CYCL DEF 200} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$mom_cycle_feed_rate} 1 1 4 1 1 5 1 Q206} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$lib_parameter_cycle(210)} 1 4 3 1 1 7 4 Q210} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211}}]

  set mom_pb_macro_arr(CYCL_201) \
  [list {{CYCL DEF 201} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$feed} 1 1 4 1 1 5 1 Q206} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211} \
  {{$lib_parameter_cycle(208)} 1 4 4 1 1 8 4 Q208} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204}}]

  set mom_pb_macro_arr(CYCL_202) \
  [list {{CYCL DEF 202} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$feed} 1 1 4 1 1 5 1 Q206} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211} \
  {{$lib_parameter_cycle(208)} 1 4 4 1 1 8 4 Q208} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(214)} 0 Q214} \
  {{$lib_parameter_cycle(336)} 1 4 3 1 1 7 4 Q336}}]

  set mom_pb_macro_arr(CYCL_203) \
  [list {{CYCL DEF 203} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$feed} 1 1 4 1 1 5 1 Q206} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$lib_parameter_cycle(210)} 1 4 3 1 1 7 4 Q210} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(212)} 1 4 3 1 1 7 4 Q212} \
  {{$lib_parameter_cycle(213)} 1 0 3 0 0 3 Q213} \
  {{$lib_parameter_cycle(205)} 1 4 3 1 1 7 4 Q205} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211} \
  {{$lib_parameter_cycle(208)} 1 3 5 1 1 8 3 Q208} \
  {{$lib_parameter_cycle(256)} 1 4 3 1 1 7 4 Q256}}]

  set mom_pb_macro_arr(CYCL_204) \
  [list {{CYCL DEF 204} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$lib_parameter_cycle(249)} 1 4 4 1 1 8 4 Q249} \
  {{$lib_parameter_cycle(250)} 1 1 4 1 1 5 1 Q250} \
  {{$lib_parameter_cycle(251)} 1 4 3 1 1 7 4 Q251} \
  {{$lib_parameter_cycle(252)} 1 4 3 1 1 7 4 Q252} \
  {{$lib_parameter_cycle(253)} 1 4 4 1 1 8 4 Q253} \
  {{$lib_parameter_cycle(254)} 1 4 4 1 1 8 4 Q254} \
  {{$lib_parameter_cycle(255)} 1 4 4 1 1 8 4 Q255} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(214)} 0 Q214} \
  {{$lib_parameter_cycle(336)} 1 4 3 1 1 7 4 Q336}}]

  set mom_pb_macro_arr(CYCL_205) \
  [list {{CYCL DEF 205} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$feed} 1 1 4 1 1 5 1 Q206} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(212)} 1 4 3 1 1 7 4 Q212} \
  {{$lib_parameter_cycle(205)} 1 4 3 1 1 7 4 Q205} \
  {{$lib_parameter_cycle(258)} 1 4 3 1 1 7 4 Q258} \
  {{$lib_parameter_cycle(259)} 1 4 3 1 1 7 4 Q259} \
  {{$lib_parameter_cycle(257)} 1 4 3 1 1 7 4 Q257} \
  {{$lib_parameter_cycle(256)} 1 4 3 1 1 7 4 Q256} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211} \
  {{$lib_parameter_cycle(379)} 1 4 3 1 1 7 4 Q379} \
  {{$lib_parameter_cycle(253)} 1 4 4 1 1 8 4 Q253} \
  {{$lib_parameter_cycle(208)} 1 1 4 1 1 5 1 Q208} \
  {{$lib_parameter_cycle(395)} 0 Q395}}]

  set mom_pb_macro_arr(CYCL_206) \
  [list {{CYCL DEF 206} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 3 1 1 7 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 3 1 1 7 4 Q201} \
  {{$lib_parameter_cycle(206)} 1 3 3 1 1 6 3 Q206} \
  {{$mom_cycle_delay} 1 3 3 1 1 6 3 Q211} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 3 1 1 7 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 3 1 1 7 4 Q204}}]

  set mom_pb_macro_arr(CYCL_207) \
  [list {{CYCL DEF 207} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204}}]

  set mom_pb_macro_arr(CYCL_208) \
  [list {{CYCL DEF 208} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$mom_cycle_feed_rate} 1 1 4 1 1 5 1 Q206} \
  {{$lib_parameter_cycle(334)} 1 4 3 1 1 7 4 Q334} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(335)} 1 4 4 1 1 8 4 Q335} \
  {{$lib_parameter_cycle(342)} 1 4 4 1 1 8 4 Q342} \
  {{$lib_parameter_cycle(351)} 0 Q351}}]

  set mom_pb_macro_arr(CYCL_209) \
  [list {{CYCL DEF 209} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(257)} 1 4 3 1 1 7 4 Q257} \
  {{$lib_parameter_cycle(256)} 1 4 3 1 1 7 4 Q256} \
  {{$lib_parameter_cycle(336)} 1 4 3 1 1 7 4 Q336}}]

  set mom_pb_macro_arr(CYCL_241) \
  [list {{CYCL DEF 241} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$feed} 1 1 4 1 1 5 1 Q206} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(379)} 1 4 3 1 1 7 4 Q379} \
  {{$lib_parameter_cycle(253)} 1 4 4 1 1 8 4 Q253} \
  {{$lib_parameter_cycle(208)} 1 4 4 1 1 8 4 Q208} \
  {{$lib_parameter_cycle(426)} 1 0 3 0 0 3 Q426} \
  {{$lib_parameter_cycle(427)} 1 0 4 0 0 4 Q427} \
  {{$lib_parameter_cycle(428)} 1 0 4 0 0 4 Q428} \
  {{$lib_parameter_cycle(429)} 1 0 3 0 0 3 Q429} \
  {{$lib_parameter_cycle(430)} 1 0 3 0 0 3 Q430} \
  {{$lib_parameter_cycle(435)} 1 4 4 1 1 8 4 Q435}}]

  set mom_pb_macro_arr(CYCL_252) \
  [list {{CYCL DEF 252} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(215)} 0 Q215} \
  {{$lib_parameter_cycle(223)} 1 4 4 1 1 8 4 Q223} \
  {{$lib_parameter_cycle(368)} 1 4 3 1 1 7 4 Q368} \
  {{$lib_parameter_cycle(207)} 1 4 5 1 1 9 4 Q207} \
  {{$lib_parameter_cycle(351)} 0 Q351} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$lib_parameter_cycle(369)} 1 4 3 1 1 7 4 Q369} \
  {{$mom_cycle_feed_rate} 1 1 4 1 1 5 1 Q206} \
  {{$lib_parameter_cycle(338)} 1 4 4 1 1 8 4 Q338} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(370)} 1 4 1 1 1 5 4 Q370} \
  {{$lib_parameter_cycle(366)} 0 Q366} \
  {{$lib_parameter_cycle(385)} 1 4 5 1 1 9 4 Q385}}]

  set mom_pb_macro_arr(CYCL_262) \
  [list {{CYCL DEF 262} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(335)} 1 4 4 1 1 8 4 Q335} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(355)} 1 0 3 0 0 3 Q355} \
  {{$lib_parameter_cycle(253)} 1 4 4 1 1 8 4 Q253} \
  {{$lib_parameter_cycle(351)} 0 Q351} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(207)} 1 4 4 1 1 8 4 Q207}}]

  set mom_pb_macro_arr(CYCL_263) \
  [list {{CYCL DEF 263} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(335)} 1 4 4 1 1 8 4 Q335} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(356)} 1 4 4 1 1 8 4 Q356} \
  {{$lib_parameter_cycle(253)} 1 4 5 1 1 9 4 Q253} \
  {{$lib_parameter_cycle(351)} 0 Q351} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$lib_parameter_cycle(357)} 1 4 3 1 1 7 4 Q357} \
  {{$lib_parameter_cycle(358)} 1 4 3 1 1 7 4 Q358} \
  {{$lib_parameter_cycle(359)} 1 4 3 1 1 7 4 Q359} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(254)} 1 4 4 1 1 8 4 Q254} \
  {{$lib_parameter_cycle(207)} 1 4 4 1 1 8 4 Q207}}]

  set mom_pb_macro_arr(CYCL_264) \
  [list {{CYCL DEF 264} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(335)} 1 4 4 1 1 8 4 Q335} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(356)} 1 4 4 1 1 8 4 Q356} \
  {{$lib_parameter_cycle(253)} 1 4 5 1 1 9 4 Q253} \
  {{$lib_parameter_cycle(351)} 0 Q351} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$lib_parameter_cycle(258)} 1 4 3 1 1 7 4 Q258} \
  {{$lib_parameter_cycle(257)} 1 4 3 1 1 7 4 Q257} \
  {{$lib_parameter_cycle(256)} 1 4 3 1 1 7 4 Q256} \
  {{$lib_parameter_cycle(358)} 1 4 3 1 1 7 4 Q358} \
  {{$lib_parameter_cycle(359)} 1 4 3 1 1 7 4 Q359} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(206)} 1 4 4 1 1 8 4 Q206} \
  {{$lib_parameter_cycle(207)} 1 4 4 1 1 8 4 Q207}}]

  set mom_pb_macro_arr(CYCL_265) \
  [list {{CYCL DEF 265} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(335)} 1 4 4 1 1 8 4 Q335} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(253)} 1 4 5 1 1 9 4 Q253} \
  {{$lib_parameter_cycle(358)} 1 4 3 1 1 7 4 Q358} \
  {{$lib_parameter_cycle(359)} 1 4 3 1 1 7 4 Q359} \
  {{$lib_parameter_cycle(360)} 0 Q360} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(254)} 1 4 4 1 1 8 4 Q254} \
  {{$lib_parameter_cycle(207)} 1 4 4 1 1 8 4 Q207}}]

  set mom_pb_macro_arr(CYCL_267) \
  [list {{CYCL DEF 267} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(335)} 1 4 4 1 1 8 4 Q335} \
  {{$lib_parameter_cycle(239)} 1 2 4 1 1 6 2 Q239} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(355)} 1 0 3 0 0 3 Q355} \
  {{$lib_parameter_cycle(253)} 1 4 5 1 1 9 4 Q253} \
  {{$lib_parameter_cycle(351)} 0 Q351} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$lib_parameter_cycle(358)} 1 4 3 1 1 7 4 Q358} \
  {{$lib_parameter_cycle(359)} 1 4 3 1 1 7 4 Q359} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(254)} 1 4 4 1 1 8 4 Q254} \
  {{$lib_parameter_cycle(207)} 1 4 4 1 1 8 4 Q207}}]

  set mom_pb_macro_arr(CYCL_CALL) \
  [list {{CYCL CALL} {} {} {} 0 {}} \
  {}]

  set mom_pb_macro_arr(CYCL_NURBS) \
  [list {SPL {} { } {} 1 {}} \
  {{{$mom_nurbs_points_x} 1 4 4 1 1 8 4 X} \
  {{$mom_nurbs_points_y} 1 4 4 1 1 8 4 Y} \
  {{$mom_nurbs_points_z} 1 4 4 1 1 8 4 Z} \
  {{$mom_nurbs_co_efficient_0} 1 4 4 1 1 8 4 K3X} \
  {{$mom_nurbs_co_efficient_1} 1 4 4 1 1 8 4 K2X} \
  {{$mom_nurbs_co_efficient_2} 1 4 4 1 1 8 4 K1X} \
  {{$mom_nurbs_co_efficient_3} 1 4 4 1 1 8 4 K3Y} \
  {{$mom_nurbs_co_efficient_4} 1 4 4 1 1 8 4 K2Y} \
  {{$mom_nurbs_co_efficient_5} 1 4 4 1 1 8 4 K1Y} \
  {{$mom_nurbs_co_efficient_6} 1 4 4 1 1 8 4 K3Z} \
  {{$mom_nurbs_co_efficient_7} 1 4 4 1 1 8 4 K2Z} \
  {{$mom_nurbs_co_efficient_8} 1 4 4 1 1 8 4 K1Z}}]

}
proc LIB_CTRL_config_millturn {} {

  if {[CONF_SPF_advanced_settings chain_init] != "0"} {
    LIB_CONF_do_prop_custom_proc CONF_SPF_advanced_settings chain_init
    LIB_GE_copy_var_range lib_sav_sys_leader mom_sys_leader
  }
}
# <Internal Documentation>
# This procedure is called at each start_of_path and machine_mode events.
# It's implemented for multi chains. Content of [CONF_SPF_advanced_settings chain_init] is executed
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread_LIB {} {

  set commandcheck(MOM_lathe_thread_LIB_ENTRY) [llength [info commands MOM_lathe_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_thread_LIB {} {

  set commandcheck(MOM_start_of_thread_LIB_ENTRY) [llength [info commands MOM_start_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 1
  LIB_SPF_add_warning "Threading cuts are not supported on Heidenhain controller, only threading cycle output. Please activate cycle output in your operation!"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_lathe_thread_move_LIB {} {

  set commandcheck(MOM_lathe_thread_move_LIB_ENTRY) [llength [info commands MOM_lathe_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_thread_LIB {} {

  set commandcheck(MOM_end_of_thread_LIB_ENTRY) [llength [info commands MOM_end_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_channel_init {} {

  LIB_GE_command_buffer LIB_CTRL_channel_init
  LIB_GE_command_buffer {MOM_do_template channel_init CREATE} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_program event
#
# Specially useful for multichannels machine to reset addresses at the beginning of for each channel
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sys_leader_home {} {
  #this proc is only here for documentation purposes.
  #the real proc should be created in service layer
}
# <Internal Documentation>
# This function is called from MOM_start_of_path event
#
# Helpful to redefine mom_sys_leader variables overwritten by the original ones with the normal run
# This procedure should be redefined in service layer
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_subop_path_LIB {} {

  set commandcheck(MOM_start_of_subop_path_LIB_ENTRY) [llength [info commands MOM_start_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_inter_opr_rule_intent lib_flag

  # <17013.16 Interop path> Exit tool path and enter transition path
  if {[info exists mom_inter_opr_rule_intent] && [string match $mom_inter_opr_rule_intent "INTEROP_END"]} {
    if {$lib_flag(mode_current_status) == "pos"} {
      LIB_ROTARY_positioning_reset
    } elseif {$lib_flag(mode_current_status) == "sim"} {
      LIB_ROTARY_simultaneous_reset
    }
    set lib_flag(tool_path_motion) 0
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_subop_path.
# It can exit tool path and enter transition path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_subop_path_LIB {} {

  set commandcheck(MOM_end_of_subop_path_LIB_ENTRY) [llength [info commands MOM_end_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_transition_path_LIB {} {

  set commandcheck(MOM_start_of_transition_path_LIB_ENTRY) [llength [info commands MOM_start_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_transition_path_LIB {} {

  set commandcheck(MOM_end_of_transition_path_LIB_ENTRY) [llength [info commands MOM_end_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_transition_rapid_move_LIB {} {

  set commandcheck(MOM_transition_rapid_move_LIB_ENTRY) [llength [info commands MOM_transition_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_transition_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_LIB_ENTRY)} {MOM_transition_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_inter_opr_rule_intent
  global mom_move_axis_rtcp_mode
  global mom_move_output_x
  global mom_out_angle_pos

  # Set value of output axis
  set 4th [string tolower $::mom_kin_4th_axis_leader]
  set 5th [string tolower $::mom_kin_5th_axis_leader]
  set ::mom_transition_${4th}_axis $mom_out_angle_pos(0)
  set ::mom_transition_${5th}_axis $mom_out_angle_pos(1)

  if {$mom_move_axis_rtcp_mode == 1} {
    set ::mom_transition_x_axis $::mom_mcs_goto(0)
    set ::mom_transition_y_axis $::mom_mcs_goto(1)
    set ::mom_transition_z_axis $::mom_mcs_goto(2)
  } else {
    set ::mom_transition_x_axis $::mom_pos(0)
    set ::mom_transition_y_axis $::mom_pos(1)
    set ::mom_transition_z_axis $::mom_pos(2)
  }

  # Set output axis
  set output_status 0
  foreach axis {x y z a b c} {
    if {[set ::mom_move_output_$axis] == 0} {
      MOM_suppress Once [string toupper $axis]_AXIS
    } else {
      MOM_force Once [string toupper $axis]_AXIS
      set output_status 1
    }
  }

  # Output rapid motion
  if {$output_status == 1 } {
    LIB_GE_command_buffer TRANSITION_RAPID_MOVE
    #LIB_GE_command_buffer {LIB_CTRL_output_rtcp_mode} @SET_RTCP
    LIB_GE_command_buffer {MOM_do_template transition_rapid_move} @TRANSITION_RAPID_MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_transition_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_LIB_ENTRY)} {MOM_transition_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_transition_rapid_move.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_machine_axis_move_LIB {} {

  set commandcheck(MOM_machine_axis_move_LIB_ENTRY) [llength [info commands MOM_machine_axis_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_machine_axis_move.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_program_include {} {
  global lib_spf

  #<MAN check to avoid wrong output #1506>
  set full_circle 0
  if {[llength [info command LIB_PT_get_header_var]]} {
    if {[LIB_PT_get_header_var mom_kin_arc_output_mode] == "FULL_CIRCLE"} {
      set full_circle 1
    }
  } elseif {$::mom_kin_arc_output_mode == "FULL_CIRCLE"} {
    set full_circle 1
  }
  if { $full_circle && \
      ([CONF_CTRL_setting turbo_mode] == 1 || \
       ([info exists lib_spf(nx_version)] && $lib_spf(nx_version) < 1102 && [CONF_CTRL_setting turbo_mode] != 0))} {

    LIB_GE_error_message "Current Configuration not supported for NX < 11.0.2" "\nIn Post Configurator either set Arc Output Mode to 'QUADRANT' or deactivate Turbo Mode."
    LIB_SPF_abort_postrun

  }

}
# <Internal Documentation>
# called from MOM_start_of_program. Added to check if properties are set correctly for
# the Heidenhain controller
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_abs_move_table { } {
  global lib_parameter lib_flag mom_pos mom_prev_pos mom_sys_leader mom_sys_trailer mom_out_angle_pos

  set tmp_sys_leader_restore($lib_parameter(abs_move,axis)) $mom_sys_leader($lib_parameter(abs_move,axis))
  set tmp_sys_trailer_restore($lib_parameter(abs_move,axis)) $mom_sys_trailer($lib_parameter(abs_move,axis))

  LIB_GE_command_buffer AXIS_FOR_5TH_AXIS_MOVE
  LIB_GE_command_buffer {
    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "real"
    }

    set tmp_sys_leader_real($lib_parameter(abs_move,axis)) $mom_sys_leader($lib_parameter(abs_move,axis))
    set tmp_sys_trailer_real($lib_parameter(abs_move,axis)) $mom_sys_trailer($lib_parameter(abs_move,axis))
    VMOV 2 mom_out_angle_pos save_out_angle_pos

    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "reload"
    }
    set mom_out_angle_pos($lib_parameter(abs_move,angle_pos)) $save_out_angle_pos($lib_parameter(abs_move,angle_pos))

    set mom_sys_leader($lib_parameter(abs_move,axis)) $tmp_sys_leader_real($lib_parameter(abs_move,axis))
    if {($lib_parameter(abs_move,axis) == "fourth_axis" && $::mom_sys_4th_axis_has_limits == 0) || ($lib_parameter(abs_move,axis) == "fifth_axis" && $::mom_sys_5th_axis_has_limits == 0)} {
      MOM_do_template optimized_rot_axis_on
    }
  } @CalcAngle

  LIB_GE_command_buffer {
    MOM_enable_address $lib_parameter(abs_move,axis)
    if {[EQ_is_equal $::mom_prev_pos(0) $mom_pos(0)]} {MOM_suppress once X}
    if {[EQ_is_equal $::mom_prev_pos(1) $mom_pos(1)]} {MOM_suppress once Y}
    if {[EQ_is_equal $::mom_prev_pos(2) $mom_pos(2)]} {MOM_suppress once Z}
    MOM_do_template rapid_move
    MOM_do_template rapid_move CREATE
    MOM_disable_address $lib_parameter(abs_move,axis)
  } @AbsMoveMCS

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________

# ctrl_itnc530_base.tcl

proc LIB_start_of_program_blk_form {} {
  global mom_blk_point_1  mom_blk_point_2 lib_blk_point_1 lib_blk_point_2

  LIB_GE_command_buffer BLK_form

  LIB_GE_command_buffer {
    MOM_output_literal "BLK FORM 0.1 Z X[format %.2f $lib_blk_point_1(0)] Y[format %.2f $lib_blk_point_1(1)] Z[format %.2f $lib_blk_point_1(2)]"
    MOM_output_literal "BLK FORM 0.2 X[format %.2f $lib_blk_point_2(0)] Y[format %.2f $lib_blk_point_2(1)] Z[format %.2f $lib_blk_point_2(2)]"
  } @BLK_form_output

  LIB_GE_command_buffer_output

}

# <Documentation>
# Output the BLK Form /WORKPIECE lines
# The output is always a block for itnc530
# if a cylinder is specified in NX than the surrounded block is used
#
#____________________________________________________________________________________________

# ctrl_tnc640_base.tcl

proc LIB_SPF_set_initial_globals_LIB {} {

  uplevel #0 {
    set lib_machine_mode MILL_TURN

    CONF_CTRL_tool set check_zero_tool_number 0
    CONF_CTRL_tool set manual_change_template {tool_change_name}
    CONF_CTRL_tool set manual_preselect_template {tool_preselect_name}
    CONF_CTRL_tool set manual_preselect_last_template {tool_preselect_name}
    CONF_CTRL_tool set auto_change_template {tool_change_name}
    CONF_CTRL_tool set auto_preselect_template {tool_preselect_name}
    CONF_CTRL_tool set auto_preselect_last_template {tool_preselect_name}
    CONF_GE_debug set show_where_output_comes_from 0

    set mom_kin_machine_type           "5_axis_head_table"
    set mom_kin_4th_axis_type          "Head"
    set mom_kin_4th_axis_leader        "B"
    set mom_sys_leader(fourth_axis)    "B"
    set mom_kin_4th_axis_vector(0)     "0"
    set mom_kin_4th_axis_vector(1)     "1"
    set mom_kin_4th_axis_vector(2)     "0"
    set mom_kin_5th_axis_type          "Table"
    set mom_kin_5th_axis_leader        "C"
    set mom_sys_leader(fifth_axis)     "C"
    set mom_kin_5th_axis_vector(0)     "0"
    set mom_kin_5th_axis_vector(1)     "0"
    set mom_kin_5th_axis_vector(2)     "1"

    # chains list
    LIB_GE_CONF_add_chain turning "turning" "turning" 0

    set lib_ge_chain_selection_priority(0) mom_machine_mode
    unset lib_ge_chain_selection_priority(1)
    unset lib_ge_chain_selection_priority(2)
    unset lib_ge_chain_selection_priority(3)

    set lib_ge_chain_mapping_options(mom_machine_mode) "MILL TURN"

    set lib_ge_chain_condition(0,mom_machine_mode) "TURN"
    set lib_ge_chain_selection(0) "turning"

    LIB_GE_chain_set_global_var turning mom_sys_spindle_direction_code(CLW)  303
    LIB_GE_chain_set_global_var turning mom_sys_spindle_direction_code(CCLW) 304
    LIB_GE_chain_set_global_var turning mom_sys_spindle_direction_code(OFF)  305

  }

}
proc LIB_ROTARY_positioning_turn {} {
  global lib_parameter_cycle lib_flag
  global mom_spec_params_defined
  global mom_cycle_Q497
  global mom_cycle_Q530
  global mom_cycle_Q532
  global mom_cycle_Q533
  global mom_cycle_Q535
  global mom_cycle_Q536
  global mom_operation_type mom_use_b_axis mom_tool_holder_angle_for_cutting
  global mom_flip_a_axis RAD2DEG
  global mom_tool_axis

  if {[string match -nocase $mom_operation_type "Turn Centerline Drilling"]} {
    set swivel_ang 0
  } elseif {$mom_use_b_axis} {
    if { ![hiset mom_tool_holder_angle_for_cutting] } {set mom_tool_holder_angle_for_cutting [expr 90 / $RAD2DEG]}
    set swivel_ang [expr $mom_tool_holder_angle_for_cutting*$RAD2DEG]
  } else {
    #12-06-2019 lili - use mom_tool_axis to calculate it, in case "Reorient Tool Angle" is "NONE".
    if {![array exists mom_tool_axis]} {
      set swivel_ang 0.0
    } else {
      set swivel_ang [expr $RAD2DEG*atan2($mom_tool_axis(0),$mom_tool_axis(2))]
    }
  }

  if {[info exists mom_cycle_Q497]} {set lib_parameter_cycle(497) $mom_cycle_Q497} {set lib_parameter_cycle(497) 0}

  if {[CONF_TNC640_CYCL800 plane_output_supported] == "NONE" || \
    ([CONF_TNC640_CYCL800 plane_output_supported] == "NO_ORTHOGONAL" && [EQ_is_zero $swivel_ang] && [EQ_is_zero $mom_flip_a_axis] && [EQ_is_zero $lib_parameter_cycle(497)])} {
    return
  }

  set lib_parameter_cycle(531) $swivel_ang
  if {[info exists mom_flip_a_axis]} {
    set lib_parameter_cycle(498) $mom_flip_a_axis
  } else {
    set lib_parameter_cycle(498) 0.0
  }

  if {[info exists mom_spec_params_defined] && $mom_spec_params_defined} {
    if {[info exists mom_cycle_Q530]} {set lib_parameter_cycle(530) $mom_cycle_Q530} {set lib_parameter_cycle(530) [CONF_TNC640_CYCL800 inclined_machining_mode]}
    if {[info exists mom_cycle_Q532]} {set lib_parameter_cycle(532) $mom_cycle_Q532} {set lib_parameter_cycle(532) [CONF_TNC640_CYCL800 feed]}
    if {[info exists mom_cycle_Q533]} {set lib_parameter_cycle(533) $mom_cycle_Q533} {set lib_parameter_cycle(533) [CONF_TNC640_CYCL800 preferred_direction]}
  } else {
    set lib_parameter_cycle(530) [CONF_TNC640_CYCL800 inclined_machining_mode]
    set lib_parameter_cycle(532) [CONF_TNC640_CYCL800 feed]
    set lib_parameter_cycle(533) [CONF_TNC640_CYCL800 preferred_direction]
  }

  if {[info exists mom_cycle_Q535]} {set lib_parameter_cycle(535) $mom_cycle_Q535} {set lib_parameter_cycle(535) 0}
  if {[info exists mom_cycle_Q536]} {set lib_parameter_cycle(536) $mom_cycle_Q536} {set lib_parameter_cycle(536) 0}

  LIB_GE_command_buffer CYCL_DEF_800
  LIB_GE_command_buffer {
    LIB_SPF_call_cycle CYCL_800 "" "CYCL" ";" "~"
  } @OUTPUT
  LIB_GE_command_buffer_output

  set lib_flag(rotary_pos_turn) 1
}
# <Internal Documentation>
#
# Switch on positioning rotary mode for turning
#  (link to the controller)
#
# <Internal Example>
#
# Heidenhain: CYCL DEF 800
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset_turn {} {
  global lib_flag

  if {$lib_flag(rotary_pos_turn)} {
    LIB_GE_command_buffer CYCL_DEF_801
    LIB_GE_command_buffer {
      LIB_SPF_call_cycle CYCL_801 "" "CYCL" ";" "~"
    } @OUTPUT
    LIB_GE_command_buffer_output
    set lib_flag(rotary_pos_turn) 0
  }
}
# <Internal Documentation>
#
# Switch off positioning rotary mode for turning
#  (link to the controller)
#
# <Internal Example>
#
# Heidenhain: CYCL DEF 801
#
#____________________________________________________________________________________________
proc  MOM_lib_event_cycle_241 {} {
  global lib_parameter_cycle mom_cycle_Q435
  global mom_cycle_Q401
  global mom_cycle_Q202
  global mom_cycle_Q212
  global mom_cycle_Q205

  if {![info exists mom_cycle_Q435]} {set mom_cycle_Q435 0}

  if {![info exists mom_cycle_Q401]} {set mom_cycle_Q401 100}
  if {![info exists mom_cycle_Q202]} {set mom_cycle_Q202 9999}
  if {![info exists mom_cycle_Q212]} {set mom_cycle_Q212 0}
  if {![info exists mom_cycle_Q205]} {set mom_cycle_Q205 0}

  set lib_parameter_cycle(name) "241"
  set lib_parameter_cycle(208)  "$::mom_cycle_Q208"
  set lib_parameter_cycle(253)  "$::mom_cycle_Q253"
  set lib_parameter_cycle(379)  "$::mom_cycle_Q379"
  set lib_parameter_cycle(426)  "$::mom_cycle_Q426"
  set lib_parameter_cycle(427)  "$::mom_cycle_Q427"
  set lib_parameter_cycle(428)  "$::mom_spindle_speed"
  set lib_parameter_cycle(429)  "$::mom_cycle_Q429"
  set lib_parameter_cycle(430)  "$::mom_cycle_Q430"
  set lib_parameter_cycle(435)  "$::mom_cycle_Q435"

  set lib_parameter_cycle(401)  "$mom_cycle_Q401"
  set lib_parameter_cycle(202)  "$mom_cycle_Q202"
  set lib_parameter_cycle(212)  "$mom_cycle_Q212"
  set lib_parameter_cycle(205)  "$mom_cycle_Q205"
}
proc  MOM_lib_event_cycle_252 {} {
  global lib_parameter_cycle mom_cycle_Q439

  if {![info exists mom_cycle_Q439]} {set mom_cycle_Q439 0}

  set lib_parameter_cycle(name) "252"
  set lib_parameter_cycle(215)  "[string range $::mom_cycle_Q215 0 1]"
  set lib_parameter_cycle(223)  "$::mom_cycle_Q223"
  set lib_parameter_cycle(368)  "$::mom_cycle_Q368"
  set lib_parameter_cycle(207)  "$::mom_cycle_Q207"
  set lib_parameter_cycle(351)  "$::mom_cycle_Q351"
  set lib_parameter_cycle(202)  "$::mom_cycle_Q202"
  set lib_parameter_cycle(369)  "$::mom_cycle_Q369"
  set lib_parameter_cycle(338)  "$::mom_cycle_Q338"
  set lib_parameter_cycle(370)  "$::mom_cycle_Q370"
  set lib_parameter_cycle(366)  "[string range $::mom_cycle_Q366 0 1]"
  set lib_parameter_cycle(385)  "$::mom_cycle_Q385"

  set lib_parameter_cycle(439)  [LIB_SPF_extract_udecode $mom_cycle_Q439]
}
proc LIB_CTRL_define_macros {} {
  global mom_pb_macro_arr

  set mom_pb_macro_arr(CYCL_241) \
  [list {{CYCL DEF 241} { } { } {} 1 =} \
  {{{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$feed} 1 1 4 1 1 5 1 Q206} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3 Q211} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(379)} 1 4 3 1 1 7 4 Q379} \
  {{$lib_parameter_cycle(253)} 1 4 4 1 1 8 4 Q253} \
  {{$lib_parameter_cycle(208)} 1 4 4 1 1 8 4 Q208} \
  {{$lib_parameter_cycle(426)} 1 0 3 0 0 3 Q426} \
  {{$lib_parameter_cycle(427)} 1 0 4 0 0 4 Q427} \
  {{$lib_parameter_cycle(428)} 1 0 4 0 0 4 Q428} \
  {{$lib_parameter_cycle(429)} 1 0 3 0 0 3 Q429} \
  {{$lib_parameter_cycle(430)} 1 0 3 0 0 3 Q430} \
  {{$lib_parameter_cycle(435)} 1 4 4 1 1 8 4 Q435} \
  {{$lib_parameter_cycle(401)} 1 4 4 1 1 8 4 Q401} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$lib_parameter_cycle(212)} 1 4 4 1 1 8 4 Q212} \
  {{$lib_parameter_cycle(205)} 1 4 4 1 1 8 4 Q205}}]

  set mom_pb_macro_arr(CYCL_252) \
  [list {{CYCL DEF 252} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(215)} 0 Q215} \
  {{$lib_parameter_cycle(223)} 1 4 4 1 1 8 4 Q223} \
  {{$lib_parameter_cycle(368)} 1 4 3 1 1 7 4 Q368} \
  {{$lib_parameter_cycle(207)} 1 4 5 1 1 9 4 Q207} \
  {{$lib_parameter_cycle(351)} 0 Q351} \
  {{$mom_cycle_feed_to} 1 4 4 1 1 8 4 Q201} \
  {{$lib_parameter_cycle(202)} 1 4 4 1 1 8 4 Q202} \
  {{$lib_parameter_cycle(369)} 1 4 3 1 1 7 4 Q369} \
  {{$mom_cycle_feed_rate} 1 1 4 1 1 5 1 Q206} \
  {{$lib_parameter_cycle(338)} 1 4 4 1 1 8 4 Q338} \
  {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4 Q203} \
  {{$mom_cycle_retract_to} 1 4 4 1 1 8 4 Q204} \
  {{$lib_parameter_cycle(370)} 1 4 1 1 1 5 4 Q370} \
  {{$lib_parameter_cycle(366)} 0 Q366} \
  {{$lib_parameter_cycle(385)} 1 4 5 1 1 9 4 Q385} \
  {{$lib_parameter_cycle(439)} 0 Q439}}]

  set mom_pb_macro_arr(CYCL_800) \
  [list {{CYCL DEF 800} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(497)} 1 4 3 1 1 7 4 Q497} \
  {{$lib_parameter_cycle(498)} 1 0 3 0 0 3 Q498} \
  {{$lib_parameter_cycle(530)} 1 0 3 0 0 3 Q530} \
  {{$lib_parameter_cycle(531)} 1 4 3 1 1 7 4 Q531} \
  {{$lib_parameter_cycle(532)} 1 0 4 0 0 4 Q532} \
  {{$lib_parameter_cycle(533)} 1 0 3 0 0 3 Q533} \
  {{$lib_parameter_cycle(535)} 1 0 3 0 0 3 Q535} \
  {{$lib_parameter_cycle(536)} 1 0 3 0 0 3 Q536}}]

  set mom_pb_macro_arr(CYCL_801) \
  [list {{CYCL DEF 801} { } { } {} 1 =}]

  set mom_pb_macro_arr(CYCL_831) \
  [list {{CYCL DEF 831} { } { } {} 1 =} \
  {{{$lib_parameter_cycle(471)} 1 0 3 0 0 3 Q471} \
  {{$lib_parameter_cycle(460)} 1 0 3 0 0 3 Q460} \
  {{$lib_parameter_cycle(491)} 1 0 3 0 0 3 Q491} \
  {{$lib_parameter_cycle(472)} 1 0 3 0 0 3 Q472} \
  {{$lib_parameter_cycle(473)} 1 0 3 0 0 3 Q473} \
  {{$lib_parameter_cycle(492)} 1 0 3 0 0 3 Q492} \
  {{$lib_parameter_cycle(494)} 1 0 3 0 0 3 Q494} \
  {{$lib_parameter_cycle(474)} 1 0 3 0 0 3 Q474} \
  {{$lib_parameter_cycle(463)} 1 0 3 0 0 3 Q463} \
  {{$lib_parameter_cycle(467)} 1 0 3 0 0 3 Q467} \
  {{$lib_parameter_cycle(468)} 1 0 3 0 0 3 Q468} \
  {{$lib_parameter_cycle(470)} 1 0 3 0 0 3 Q470} \
  {{$lib_parameter_cycle(475)} 1 0 3 0 0 3 Q475} \
  {{$lib_parameter_cycle(476)} 1 0 3 0 0 3 Q476}}]

}
proc LIB_start_of_program_blk_form {} {
  global mom_blk_point_1  mom_blk_point_2 lib_blk_point_1 lib_blk_point_2
  global lib_blank_cylinder_vector lib_blank_cylinder_center lib_blank_cylinder_height lib_blank_cylinder_diameter

  LIB_GE_command_buffer BLK_form

  LIB_GE_command_buffer {

    set zero 0; set one 1
    VEC3_init one zero zero V0; VEC3_init zero one zero V1; VEC3_init zero zero one V2
    if {[info exists lib_blank_cylinder_center(0)] && ([VEC3_is_parallel lib_blank_cylinder_vector V0] || [VEC3_is_parallel lib_blank_cylinder_vector V1] || [VEC3_is_parallel lib_blank_cylinder_vector V2]) \
       && ([VEC3_is_parallel lib_blank_cylinder_center lib_blank_cylinder_vector] || [VEC3_is_zero lib_blank_cylinder_center])} {
      if {[VEC3_is_parallel lib_blank_cylinder_vector V0]} {
        MOM_output_literal "BLK FORM CYLINDER X D[format %.2f $lib_blank_cylinder_diameter] L[format %.2f $lib_blank_cylinder_height] DIST[format %.2f [expr $lib_blank_cylinder_center(0) - $lib_blank_cylinder_height/2]]"
      } elseif {[VEC3_is_parallel lib_blank_cylinder_vector V1]} {
        MOM_output_literal "BLK FORM CYLINDER Y D[format %.2f $lib_blank_cylinder_diameter] L[format %.2f $lib_blank_cylinder_height] DIST[format %.2f [expr $lib_blank_cylinder_center(1) - $lib_blank_cylinder_height/2]]"
      } else {
        MOM_output_literal "BLK FORM CYLINDER Z D[format %.2f $lib_blank_cylinder_diameter] L[format %.2f $lib_blank_cylinder_height] DIST[format %.2f [expr $lib_blank_cylinder_center(2) - $lib_blank_cylinder_height/2]]"
      }
    } else {
      MOM_output_literal "BLK FORM 0.1 Z X[format %.2f $lib_blk_point_1(0)] Y[format %.2f $lib_blk_point_1(1)] Z[format %.2f $lib_blk_point_1(2)]"
      MOM_output_literal "BLK FORM 0.2 X[format %.2f $lib_blk_point_2(0)] Y[format %.2f $lib_blk_point_2(1)] Z[format %.2f $lib_blk_point_2(2)]"
    }
  } @BLK_form_output

  LIB_GE_command_buffer_output

}

# <Documentation>
# Output the BLK Form /WORKPIECE lines
# If a cylinder is defined in NX and the cylinder axis is X,Y or Z and the center of the cylinder
# is in the middle of the coord systen than a cylinder is Output
# BLK FORM CYLINDER Z D93 L120 DIST0
#
# in all other cases a surrounded block is output
#____________________________________________________________________________________________

# oem_ootb_5ax_tnc.tcl

proc OOTB_tool_change_return_home {} {
#-------------------------------------------------------------
   MOM_do_template return_home_z
   MOM_do_template return_home_xy
   if {$::lib_sav_kin_machine_type != "3_axis_mill"} {
      if {[string match "*4_axis*" $::lib_sav_kin_machine_type]} {
         MOM_force once fourth_axis
         MOM_disable_address fifth_axis
      } else {
         MOM_force once fourth_axis fifth_axis
      }
      MOM_do_template return_home_4th5th
   }
}
proc OOTB_reset_rotary_to_zero {} {
#-------------------------------------------------------------
   LIB_SPF_reset_motions_to_zero "rot"
}
proc LIB_main_origin_call_ENTRY {position} {
#--------------------------------------------------------------
#Ouput CYCLE 7 XYZ for main CSYS output
   global lib_coord_main_X
   global lib_coord_main_Y
   global lib_coord_main_Z
   global lib_ootb_save_mom_origin
   global mom_origin
   global lib_save_mom_origin

   switch -- $position {
      "start"
      {
         if {[CONF_OOTB_CTRL_origin main_origin_with_register] == 0 && [CONF_CTRL_origin use_main] == 1 } {
      #<cam17013 new pretreatment>
        if {$::lib_flag(local_namespace_output)} {
          LIB_SPF_get_mcs_info
        } else {
            LIB_SPF_csys_3D_rotation
        }

            CONF_CTRL_origin set use_main 0
            CONF_CTRL_origin set local_origin_with_register 1
            set mom_origin(0) $lib_coord_main_X
            set mom_origin(1) $lib_coord_main_Y
            set mom_origin(2) $lib_coord_main_Z
            if {![info exist lib_ootb_save_mom_origin(0)]} {
               if {![EQ_is_zero $mom_origin(0)] || ![EQ_is_zero $mom_origin(1)] || ![EQ_is_zero $mom_origin(2)]} {

                  LIB_GE_command_buffer OOTB_OEM_MAIN_CALL_START
                  LIB_GE_command_buffer {MOM_output_literal "CYCL DEF 7.0 DATUM SHIFT"} @OOTB_CYCLE_DEF_70
                  LIB_GE_command_buffer {
                     MOM_force once X
                     MOM_do_template local_zero_xoffset} @OOTB_ZERO_XOFFSET ;# mom_origin(0)
                  LIB_GE_command_buffer {
                     MOM_force once Y
                     MOM_do_template local_zero_yoffset} @OOTB_ZERO_YOFFSET
                  LIB_GE_command_buffer {
                     MOM_force once Z
                     MOM_do_template local_zero_zoffset} @OOTB_ZERO_ZOFFSET
                  LIB_GE_command_buffer_output
                  MOM_force once X Y Z
               }
               LIB_GE_copy_var_range lib_ootb_save_mom_origin mom_origin
            } else {
                if {![VEC3_is_equal lib_ootb_save_mom_origin mom_origin]} {
                     LIB_GE_command_buffer OOTB_OEM_MAIN_CALL_START
                     LIB_GE_command_buffer {MOM_output_literal "CYCL DEF 7.0 DATUM SHIFT"} @OOTB_CYCLE_DEF_70
                     LIB_GE_command_buffer {MOM_output_literal "CYCL DEF 7.1 X+0.0"} @OOTB_CYCLE_DEF_71
                     LIB_GE_command_buffer {MOM_output_literal "CYCL DEF 7.2 Y+0.0"} @OOTB_CYCLE_DEF_72
                     LIB_GE_command_buffer {MOM_output_literal "CYCL DEF 7.3 Z+0.0"} @OOTB_CYCLE_DEF_73
                     LIB_GE_command_buffer {MOM_output_literal "CYCL DEF 7.0 DATUM SHIFT"} @OOTB_CYCLE_DEF_70_2
                     LIB_GE_command_buffer {
                         MOM_force once X
                         MOM_do_template local_zero_xoffset} @OOTB_ZERO_XOFFSET ;# mom_origin(0)
                     LIB_GE_command_buffer {
                         MOM_force once Y
                         MOM_do_template local_zero_yoffset} @OOTB_ZERO_YOFFSET ;# mom_origin(1)
                     LIB_GE_command_buffer {
                         MOM_force once Z
                         MOM_do_template local_zero_zoffset} @OOTB_ZERO_ZOFFSET ;# mom_origin(2)
                     LIB_GE_command_buffer_output
                     MOM_force once X Y Z
                     LIB_GE_copy_var_range lib_ootb_save_mom_origin mom_origin
                     set lib_save_mom_origin(0) 0
                     set lib_save_mom_origin(1) 0
                     set lib_save_mom_origin(2) 0
                  }
            }

         } elseif {[CONF_CTRL_origin use_main] == 0} {
            CONF_OOTB_CTRL_origin set main_origin_with_register 1
         }
      }
      "end"
      {
         if {[CONF_OOTB_CTRL_origin main_origin_with_register] == 0 } {
            CONF_CTRL_origin set use_main 1
         }
      }
   }
}

# template_service_itnc530.tcl

proc postcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Absolute Arc Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "999999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         ""
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "0"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "0"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "100000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0.0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "10.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}

# template_service_tnc640.tcl

proc postcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Absolute Arc Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "999999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         ""
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "0"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "0"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "100000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0.0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "10.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}

# ctrl_okuma_base.tcl

proc LIB_SPF_set_initial_globals_LIB {} {

  uplevel #0 {

    set mom_system_tolerance                      0.0000001
    set mom_sys_control_out                       "("
    set mom_sys_control_in                        ")"

    ########## SYSTEM VARIABLE DECLARATIONS ##############
    set mom_sys_rapid_code                        "0"
    set mom_sys_linear_code                       "1"
    set mom_sys_circle_code(CLW)                  "2"
    set mom_sys_circle_code(CCLW)                 "3"
    set mom_sys_delay_code(SECONDS)               "4"
    set mom_sys_delay_code(REVOLUTIONS)           "4"
    set mom_sys_cutcom_plane_code(XY)             "17"
    set mom_sys_cutcom_plane_code(ZX)             "18"
    set mom_sys_cutcom_plane_code(XZ)             "18"
    set mom_sys_cutcom_plane_code(YZ)             "19"
    set mom_sys_cutcom_plane_code(ZY)             "19"
    set mom_sys_cutcom_code(OFF)                  "40"
    set mom_sys_cutcom_code(LEFT)                 "41"
    set mom_sys_cutcom_code(RIGHT)                "42"
    set mom_sys_adjust_code(0)                    "54"
    set mom_sys_adjust_code(1)                    "55"
    set mom_sys_adjust_code(2)                    "56"
    set mom_sys_adjust_code(3)                    "57"
    set mom_sys_adjust_code(4)                    "58"
    set mom_sys_adjust_code(5)                    "59"
    set mom_sys_adjust_code_minus                 "44"
    set mom_sys_adjust_cancel_code                "53"
    set mom_sys_unit_code(IN)                     "20"
    set mom_sys_unit_code(MM)                     "21"
    set mom_sys_output_code(ABSOLUTE)             "90"
    set mom_sys_output_code(INCREMENTAL)          "91"
    set mom_sys_reset_code                        "92"
    set mom_sys_feed_rate_mode_code(FRN)          "93"
    set mom_sys_spindle_mode_code(SFM)            "96"
    set mom_sys_spindle_mode_code(RPM)            "97"
    set mom_sys_spindle_max_rpm_code              "50"
    set mom_sys_spindle_cancel_sfm_code           "97"
    set mom_sys_feed_rate_mode_code(DPM)          "94"
    set mom_sys_feed_rate_mode_code(IPM)          "94"
    set mom_sys_feed_rate_mode_code(IPR)          "95"
    set mom_sys_feed_rate_mode_code(MMPM)         "94"
    set mom_sys_feed_rate_mode_code(MMPR)         "95"
    set mom_sys_polar_mode(ON)                    "137"
    set mom_sys_polar_mode(OFF)                   "136"
    set mom_sys_program_stop_code                 "0"
    set mom_sys_optional_stop_code                "1"
    set mom_sys_end_of_program_code               "2"
    set mom_sys_start_of_subprogram               "CALL"
    set mom_sys_end_of_subprogram                 "RTS"
    set mom_sys_spindle_direction_code(CLW)       "3"
    set mom_sys_spindle_direction_code(CCLW)      "4"
    set mom_sys_spindle_direction_code(OFF)       "5"
    set mom_sys_spindle_orient_code               "19"
    set mom_sys_tool_change_code                  "6"
    set mom_sys_coolant_code(ON)                  "8"
    set mom_sys_coolant_code(FLOOD)               "8"
    set mom_sys_coolant_code(MIST)                "7"
    set mom_sys_coolant_code(THRU)                "26"
    set mom_sys_coolant_code(TAP)                 "27"
    set mom_sys_coolant_code(AIR)         "7"
    set mom_sys_coolant_code(AIRTHRU)             "26"
    set mom_sys_coolant_code(OFF)                 "9"
    set mom_sys_rewind_code                       "30"
    set mom_sys_unclamp_code_fourth               "10"
    set mom_sys_clamp_code_fourth                 "11"
    set mom_sys_unclamp_code_fifth                "50"
    set mom_sys_clamp_code_fifth                  "51"
    set mom_sys_4th_axis_has_limits               "1"
    set mom_sys_5th_axis_has_limits               "1"
    set mom_sys_sim_cycle_drill                   "0"
    set mom_sys_sim_cycle_drill_dwell             "0"
    set mom_sys_sim_cycle_drill_deep              "0"
    set mom_sys_sim_cycle_drill_break_chip        "0"
    set mom_sys_sim_cycle_tap                     "1"
    set mom_sys_sim_cycle_bore                    "0"
    set mom_sys_sim_cycle_bore_drag               "0"
    set mom_sys_sim_cycle_bore_nodrag             "0"
    set mom_sys_sim_cycle_bore_manual             "0"
    set mom_sys_sim_cycle_bore_dwell              "0"
    set mom_sys_sim_cycle_bore_manual_dwell       "0"
    set mom_sys_sim_cycle_bore_back               "0"
    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
    set mom_sys_helix_pitch_type                  "rise_revolution"
    set mom_sys_spindle_ranges                    "9"
    set mom_sys_rewind_stop_code                  "\#"
    set mom_sys_zero                              "0"
    set mom_sys_opskip_block_leader               "/"
    set mom_sys_seqnum_start                      "1"
    set mom_sys_seqnum_incr                       "1"
    set mom_sys_seqnum_freq                       "1"
    set mom_sys_seqnum_max                        "9999"
    set mom_sys_lathe_x_double                    "1"
    set mom_sys_lathe_i_double                    "1"
    set mom_sys_lathe_y_double                    "1"
    set mom_sys_lathe_j_double                    "1"
    set mom_sys_lathe_x_factor                    "1"
    set mom_sys_lathe_y_factor                    "1"
    set mom_sys_lathe_z_factor                    "1"
    set mom_sys_lathe_i_factor                    "1"
    set mom_sys_lathe_j_factor                    "1"
    set mom_sys_lathe_k_factor                    "1"
    set mom_sys_leader(N)                         "N"
    set mom_sys_leader(M)           "M"
    set mom_sys_leader(M_spindle)                 "M"
    set mom_sys_leader(G)           "G"
    set mom_sys_leader(X)                         "X"
    set mom_sys_leader(Y)                         "Y"
    set mom_sys_leader(Z)                         "Z"
    set mom_sys_leader(S)                         "S"
    set mom_sys_leader(fourth_axis)               "A"
    set mom_sys_leader(fifth_axis)                "B"
    set mom_sys_leader(sixth_axis)                "C"
    set mom_sys_trailer(M)            ""
    set mom_sys_trailer(M_spindle)                ""
    set mom_sys_trailer(G)            ""
    set mom_sys_trailer(X)                        ""
    set mom_sys_trailer(Y)                        ""
    set mom_sys_trailer(Z)                        ""
    set mom_sys_trailer(S)                        ""
    set mom_sys_trailer(fourth_axis)              ""
    set mom_sys_trailer(fifth_axis)               ""
    set mom_sys_trailer(sixth_axis)               ""
    if {[info exists pc_initial_library_release_of_post] && $pc_initial_library_release_of_post > 50306} {
      set mom_sys_contour_feed_mode(LINEAR)         "AUTO"
      set mom_sys_rapid_feed_mode(LINEAR)           "AUTO"
      set mom_sys_cycle_feed_mode                   "AUTO"
    } else {
      set mom_sys_contour_feed_mode(LINEAR)         "MMPM"
      set mom_sys_rapid_feed_mode(LINEAR)           "MMPM"
      set mom_sys_cycle_feed_mode                   "MMPM"
    }
    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
    set mom_sys_feed_param(FRN,format)            "Feed_INV"
    set mom_sys_vnc_rapid_dogleg                  "1"
    set mom_sys_prev_mach_head                    ""
    set mom_sys_curr_mach_head                    ""
    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
    set mom_sys_retract_distance                  "10"
    set mom_sys_linearization_method              "angle"
    set mom_sys_post_description                  "This is a 5-Axis Milling Machine With\n\Dual Rotary Heads."
    set mom_sys_ugpadvkins_used                   "0"
    set mom_sys_post_builder_version              "9.0.1"
    set mom_sys_linear_turbo_command              "FALSE"
    set mom_sys_rapid_turbo_command               "FALSE"
    set mom_sys_circular_turbo_command            "FALSE"
    # will be added to post core later
    set mom_sys_turbo_global_add_vars_list        "mom_feedrate_mode mom_feedrate mom_motion_type mom_current_motion mom_pos_arc_center mom_pos_arc_axis oper_mcs_matrix"
    set mom_sys_output_transition_path            "0"
    set mom_sys_post_output_subprogram_enabled    "1"

    ####### KINEMATIC VARIABLE DECLARATIONS ##############
    set mom_kin_4th_axis_ang_offset               "0.0"
    set mom_kin_4th_axis_center_offset(0)         "0.0"
    set mom_kin_4th_axis_center_offset(1)         "0.0"
    set mom_kin_4th_axis_center_offset(2)         "0.0"
    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_4th_axis_incr_switch              "OFF"
    set mom_kin_4th_axis_leader                   "A"
    set mom_kin_4th_axis_max_limit                "360"
    set mom_kin_4th_axis_min_incr                 "0.001"
    set mom_kin_4th_axis_min_limit                "0"
    set mom_kin_4th_axis_plane                    "YZ"
    set mom_kin_4th_axis_point(0)                 "0.0"
    set mom_kin_4th_axis_point(1)                 "0.0"
    set mom_kin_4th_axis_point(2)                 "0.0"
    set mom_kin_4th_axis_rotation                 "standard"
    set mom_kin_4th_axis_type                     "Head"
    set mom_kin_4th_axis_vector(0)                "1"
    set mom_kin_4th_axis_vector(1)                "0"
    set mom_kin_4th_axis_vector(2)                "0"
    set mom_kin_4th_axis_zero                     "0.0"
    set mom_kin_5th_axis_ang_offset               "0.0"
    set mom_kin_5th_axis_center_offset(0)         "0.0"
    set mom_kin_5th_axis_center_offset(1)         "0.0"
    set mom_kin_5th_axis_center_offset(2)         "0.0"
    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_5th_axis_incr_switch              "OFF"
    set mom_kin_5th_axis_leader                   "B"
    set mom_kin_5th_axis_max_limit                "360"
    set mom_kin_5th_axis_min_incr                 "0.001"
    set mom_kin_5th_axis_min_limit                "0"
    set mom_kin_5th_axis_plane                    "ZX"
    set mom_kin_5th_axis_point(0)                 "0.0"
    set mom_kin_5th_axis_point(1)                 "0.0"
    set mom_kin_5th_axis_point(2)                 "0.0"
    set mom_kin_5th_axis_rotation                 "standard"
    set mom_kin_5th_axis_type                     "Head"
    set mom_kin_5th_axis_vector(0)                "0"
    set mom_kin_5th_axis_vector(1)                "1"
    set mom_kin_5th_axis_vector(2)                "0"
    set mom_kin_5th_axis_zero                     "0.0"
    set mom_kin_arc_output_mode                   "FULL_CIRCLE"
    set mom_kin_arc_valid_plane                   "XYZ"
    set mom_kin_clamp_time                        "2.0"
    set mom_kin_cycle_plane_change_per_axis       "0"
    set mom_kin_cycle_plane_change_to_lower       "0"
    set mom_kin_dependent_head                    "NONE"
    set mom_kin_flush_time                        "2.0"
    set mom_kin_helical_arc_output_mode           "FULL_CIRCLE"
    set mom_kin_ind_to_dependent_head_x           "0"
    set mom_kin_ind_to_dependent_head_z           "0"
    set mom_kin_independent_head                  "NONE"
    set mom_kin_linearization_flag                "1"
    ###set mom_kin_linearization_tol                 "0.01"
    set mom_kin_machine_type                      "5_axis_dual_head"
    set mom_kin_machine_zero_offset(0)            "0.0"
    set mom_kin_machine_zero_offset(1)            "0.0"
    set mom_kin_machine_zero_offset(2)            "0.0"
    set mom_kin_max_dpm                           "1000000"
    set mom_kin_max_frn                           "1000"
    set mom_kin_min_dpm                           "0.0"
    set mom_kin_min_frn                           "0.01"
    set mom_kin_output_unit                       "MM"
    set mom_kin_pivot_gauge_offset                "0.0"
    set mom_kin_pivot_guage_offset                ""
    set mom_kin_post_data_unit                    "MM"
    set mom_kin_retract_distance                  "500"
    set mom_kin_rotary_axis_method                "PREVIOUS"
    set mom_kin_spindle_axis(0)                   "0.0"
    set mom_kin_spindle_axis(1)                   "0.0"
    set mom_kin_spindle_axis(2)                   "1.0"
    set mom_kin_tool_change_time                  "12.0"
    set mom_kin_x_axis_limit                      "1000"
    set mom_kin_y_axis_limit                      "1000"
    set mom_kin_z_axis_limit                      "1000"
    set mom_kin_head_spindle_axis_correction      "ON"
    set mom_kin_head_gauge_point_correction       "ON"
    set mom_kin_combine_rapid_arc_motion          "Yes"
  }
}
proc MOM_start_of_program_LIB {} {
  global lib_flag
  set commandcheck(MOM_start_of_program_LIB_ENTRY) [llength [info commands MOM_start_of_program_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_dnc_header) [llength [info commands LIB_CTRL_dnc_header]]
  set commandcheck(LIB_CTRL_nc_header) [llength [info commands LIB_CTRL_nc_header]]
  set commandcheck(LIB_CTRL_sub_header) [llength [info commands LIB_CTRL_sub_header]]
  set commandcheck(LIB_CTRL_parameter_definition) [llength [info commands LIB_CTRL_parameter_definition]]

  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_dnc_header
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_dnc_header)} {LIB_CTRL_dnc_header}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[string match "MOM_start_of_program" [info level -1]]} {
    LIB_GE_command_buffer LIB_CTRL_nc_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_nc_header)} {LIB_CTRL_nc_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Program"}} @EVENT_MESSAGE
    LIB_GE_command_buffer {LIB_SPF_program_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer LIB_CTRL_sub_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sub_header)} {LIB_CTRL_sub_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {LIB_SPF_sub_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  }

  LIB_GE_command_buffer LIB_CTRL_parameter_definition
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition)} {LIB_CTRL_parameter_definition}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  if { $lib_flag(load_pretreatment)} {
  if {[LIB_PT_get_header_var mom_sequence_mode exists]} {
    if {[LIB_PT_get_header_var mom_sequence_mode] == "OFF"} {
      MOM_set_seq_off
    } else {
      if {[CONF_CTRL_setting sequence_number] == 1} {
        MOM_set_seq_on
      } else {
        MOM_set_seq_off
      }
    }
  }
  }
  set lib_flag(plane_output_pos_type) 1

  LIB_GE_command_buffer PROGRAMSTART

  LIB_GE_command_buffer {LIB_GE_catch_do_template start_of_program "" 1} @START_OF_PROGRAM

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_path_LIB {} {

  set commandcheck(MOM_start_of_path_LIB_ENTRY) [llength [info commands MOM_start_of_path_LIB_ENTRY]]
  if {$::lib_flag(local_namespace_output) ==1 && [CONF_CTRL_setting turbo_mode] == 2} {
    LIB_SPF_turbo_status "enable" "advanced"
  }

  LIB_calc_lib_cutcom_radius

  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_update_tool_change_template
  # reset address expression
  if {[llength [info commands "MOM_set_address_expression"]]&&[info exists ::save_address_expression]} {
    if {[info exists ::save_address_expression(linear_move,X)]&&\
        [catch {MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" $::save_address_expression(linear_move,X)}]} {
          LIB_SPF_add_warning "Failed to reset address expression of 'X' in BLOCK_TEMPLATE 'linear_move'"
    }
    if {[info exists ::save_address_expression(linear_move,F)] && [catch {
      MOM_set_address_expression [CONF_CTRL_moves linear_template]   "F" $::save_address_expression(linear_move,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" $::save_address_expression(circular_move,F)
    }]} {
      LIB_SPF_add_warning "Failed to reset feed rate address expression , the feed rate address name should be 'F'"
    }
    unset ::save_address_expression
  }

  # Bug 1299 Address H is missing in operations with tool axis change but no toolchange
  if {[MOM_ask_address_value G_adjust] == $::mom_sys_adjust_cancel_code} {MOM_force once H}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_sync_LIB {} {

  set commandcheck(MOM_sync_LIB_ENTRY) [llength [info commands MOM_sync_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SYNC

  LIB_GE_command_buffer {LIB_GE_message "MOM_sync is not implemented for this controller" "output_1"} @SYNC_CALL

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_set_csys_LIB {} {

  global lib_flag

  set commandcheck(MOM_set_csys_LIB_ENTRY) [llength [info commands MOM_set_csys_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

    if {![info exist lib_flag(absolute_kin)] || $lib_flag(absolute_kin) == 0} {
      # do nothing
    } else {
      LIB_SPF_calc_4th5th_axis_points
    }

  # In new local csys mode, translate mom_pos and mom_mcs_goto from local to G54 in global namespace,
  # and get rotation matrix and origin of local coordinate system relative to G54.
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_csys_rotation_revise_output
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_calc_lib_cutcom_radius {} {

  global mom_cutter_data_output_indicator mom_cut_data_type mom_cutcom_type mom_tool_diameter
  global lib_cutcom_radius mom_kin_arc_output_mode mom_sys_cutcom_code

  if {![info exists mom_cutter_data_output_indicator]} {
    set mom_cutter_data_output_indicator 0
  }
  if {![info exists mom_cutcom_type]} {
    set mom_cutcom_type 0
  }
  if {[CONF_CTRL_tool cutcom_actual_radius] == 0} {
    # no cutcom output even it is defined
    if {$mom_cutter_data_output_indicator == 1} {
      LIB_GE_abort_message "Cutcom contact not allowed"
    } else {
      set lib_cutcom_radius 0.0
    }
  } elseif {$mom_cutcom_type > 0} {
    # cutcom defined
    if {$mom_cut_data_type == "contact contour data"} {
      set lib_cutcom_radius 0.0
    } elseif {$mom_cut_data_type == "centerline data"} {
        set lib_cutcom_radius [expr $mom_tool_diameter/2]
    } else {
      set lib_cutcom_radius 0.0
    }
    if {[CONF_CTRL_setting turbo_mode] == 2 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
      LIB_SPF_turbo_status "enable" "advanced"
    }
  } else {
    # no cutcom defined
    if {[info exists lib_cutcom_radius] && $lib_cutcom_radius > 0.0} {
      set lib_cutcom_radius 0.0
    } else {
      set lib_cutcom_radius 0.0
    }
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_tool_LIB {} {

  global lib_flag mom_operation_is_interop

  set commandcheck(MOM_first_tool_LIB_ENTRY) [llength [info commands MOM_first_tool_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set lib_flag(tool_path_motion) 0

  if {![info exists mom_operation_is_interop] && [CONF_CTRL_moves return_before_first_tool_change_pos] != ""} {
    LIB_RETURN_move CONF_CTRL_moves return_before_first_tool_change_pos
  }

  set lib_flag(first_tool_change) 1
  MOM_tool_change
  set lib_flag(first_tool_change) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag mom_next_tool_status lib_prev_tool_name

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }

  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {![info exists mom_cutcom_type]} {set mom_cutcom_type 0}
  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_from_move_LIB {} {

  global feed_mode mom_feed_rate mom_kin_rapid_feed_rate

  set commandcheck(MOM_from_move_LIB_ENTRY) [llength [info commands MOM_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_moves output_from_position] == 1 } {
    if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
      if {[EQ_is_ge $mom_feed_rate $mom_kin_rapid_feed_rate]} {
        MOM_rapid_move_LIB
      } else {
        MOM_linear_move_LIB
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_update_tool_change_template {} {

  global lib_prev_feed_cut_value mom_feed_cut_value mom_tool_name

  LIB_GE_command_buffer UPDATE_TOOL

  LIB_GE_command_buffer {
      LIB_CTRL_set_feed_parameter
      set lib_prev_feed_cut_value $mom_feed_cut_value
  } @SET_FEED_PARAM
  LIB_GE_command_buffer {
      LIB_CHECK_adjust_register
  } @SET_ADJUST_REGISTER

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_move_LIB {} {
  global mom_motion_event
  global mom_motion_type

  set commandcheck(MOM_first_move_LIB_ENTRY) [llength [info commands MOM_first_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check move

  LIB_SPF_check_decompose_first_move

  LIB_CHECK_adjust_register

  if {$mom_motion_event == "cycle_plane_change"} {
    LIB_SPF_add_warning "It is recommended to define a motion before first cycle."
  }
  catch {MOM_$mom_motion_event}
  # Handle the case user specify feed for rapid
  if {$mom_motion_type == "RAPID"} {
    LIB_SPF_last_rapid_pos
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_initial_move_LIB {} {
  global mom_programmed_feed_rate mom_motion_event
  global mom_motion_type

  set commandcheck(MOM_initial_move_LIB_ENTRY) [llength [info commands MOM_initial_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check move

  LIB_CHECK_adjust_register

  LIB_SPF_spindle_set

    if {[EQ_is_zero $mom_programmed_feed_rate]} {
      MOM_rapid_move
      set mom_motion_event "rapid_move"
    } else {
      MOM_linear_move
      set mom_motion_event "linear_move"
    # Handle the case user specify feed for rapid
    if {$mom_motion_type == "RAPID"} {
      LIB_SPF_last_rapid_pos
    }
    }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_handle_cycle_check {arg} {

  global mom_cycle_type mom_spindle_status mom_spindle_startup_status

  if {([info exists mom_cycle_type] && ([string match "Exp_Deep_Drill_Breakchip" $mom_cycle_type] || [string match "Exp_Deep_Drill" $mom_cycle_type])) ||\
  ([info exists mom_spindle_startup_status] && $mom_spindle_startup_status == "OFF")} {

    switch -- $arg {
      "move"    {
            if {$mom_spindle_status == "OFF"} {MOM_disable_address S M_spindle}
          }
      "spindle" {
            MOM_enable_address S M_spindle
          }
      default   {
            LIB_GE_abort_message "Call LIB_CTRL_handle_cycle_check without the right arguments" "Please check"
          }
    }

  }
}
# <Internal Documentation>
#
# This function controlls the spindle rotation.
# The spindle should never be activated with the first movement if a single-lip drill is used.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_turbo {} {

  if {$::lib_ge_pretreatment_runtime} {return}
    # The mom variable mom_sys_advanced_turbo_output is set in MOM_Start_of_path from core code
  if {![info exists ::mom_sys_advanced_turbo_output] || $::mom_sys_advanced_turbo_output != "TRUE"} {
    return
  }

  if {[CONF_CTRL_moves always_center_for_circle] == 1} {
    MOM_disable_address R
    MOM_enable_address I J K
  } else {
    MOM_enable_address R
    MOM_disable_address I J K
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {$::mom_kin_arc_output_mode == "FULL_CIRCLE" } {
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {[CONF_CTRL_feed feed_linear] == 2} {
    # Before NX1899, set MOM_linear_move_turbo_LIB at turbo block to output parameterized feed value
    # From NX1899, use advanced callback function to do the same thing
    if {$::lib_ge_env(major_version) < 1899} {
      set ::mom_sys_linear_turbo_command "TRUE"
      set ::mom_sys_circular_turbo_command "TRUE"
    } else {
      # In advanced turbo mode, LIB_SPF_feedrate_set is called in callback function, so disable feedrate setting in core code
      if {[llength [info commands MOM_set_turbo_feedrate_set]]} {
        MOM_set_turbo_feedrate_set OFF
      }
    }
  }

  if {$::mom_sys_rapid_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry] "MOM_rapid_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry]]
  }

  if {$::mom_sys_linear_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry] "MOM_linear_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry]]
  }

  if {$::mom_sys_circular_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment [CONF_Turbo_Templates circular_template_turbo] [CONF_Turbo_Templates circular_template_entry] "MOM_circular_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment [CONF_Turbo_Templates circular_template_turbo] [CONF_Turbo_Templates circular_template_entry]]
  }

  # The address X[$mom_pos(0)*$x_factor] will slow down turbo mode, x_factor only used in turning
  if {[llength [info commands "MOM_set_address_expression"]]} {
    if {$::x_factor == 1} {
      catch {
    set ::save_address_expression(linear_move,X) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" "\$mom_pos(0)"]
      }
    }
    if {[CONF_CTRL_feed feed_linear] != 2} {
      if {[catch {
        set ::save_address_expression(linear_move,F) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "F" "\$mom_feedrate"]
        set ::save_address_expression(circular_move,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" "\$mom_feedrate"]
      }]} {
        LIB_SPF_add_warning "Please use 'F' as feed rate address name in linear and circular block template"
      }
    }
    #when feedrate in one operation change from mmpm to mmpr we must write mom_feedrate_mode in to the advanced and set feed the mode into the G_feed Address
    set ::save_address_expression(linear_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]
    set ::save_address_expression(circular_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]

  }
}
# <Internal Documentation>
#
# This procedure is executed at MOM_initial_move MOM_first_move MOM_lock_axis.
# It is used to config turbo blocks in advanced turbo mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB {} {

  global mom_machine_mode mom_pos mom_spindle_preset_rpm mom_nxt_motion_event
  global lib_flag lib_param
  global mom_inter_opr_rule_intent

  if {[hiset lib_flag(lathe_thread_motion)] && $lib_flag(lathe_thread_motion) == 1} {
    if {$mom_nxt_motion_event == "none"} {
      # Last event MOM_end_of_thread misses
      set lib_flag(lathe_thread_motion) 0
    }
    MOM_abort_event
  }

  set commandcheck(MOM_rapid_move_LIB_ENTRY) [llength [info commands MOM_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        if {$lib_flag(decompose_first_move_turn) == 1} {
          # X then Z
          if {[hiset mom_spindle_preset_rpm] && ![EQ_is_equal $mom_spindle_preset_rpm [MOM_ask_address_value S]]} {
            MOM_disable_address S
            LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves rapid_template] FORCE "X Y Z"
            MOM_enable_address S
          } else {
            LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves rapid_template] FORCE "X Y Z"
          }
        } else {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        }
        set lib_flag(current_safety_position) 0
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
        switch -- $lib_flag(mode_current_status) {
          "std" {
            LIB_ROTARY_positioning_first_move
          }
          "pos" {
            LIB_ROTARY_positioning_first_move_pos
          }
          "sim" {
            LIB_ROTARY_positioning_first_move_sim
          }
        }
      } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized RAPID_MOVE]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer RAPID_MOVE
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer RAPID_MOVE_SINGLE
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output
  }

  LIB_SPF_last_rapid_pos

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_linear_move_turbo {} {

  set commandcheck(LIB_CTRL_linear_move_turbo_ENTRY) [llength [info commands LIB_CTRL_linear_move_turbo_ENTRY]]

  LIB_GE_command_buffer LINEAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @LINEAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_linear_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_linear_move_turbo_ENTRY)} {LIB_CTRL_linear_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_linear_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_turbo {} {

  set commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY) [llength [info commands LIB_CTRL_rapid_move_turbo_ENTRY]]

  LIB_GE_command_buffer RAPID_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @RAPID_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_rapid_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY)} {LIB_CTRL_rapid_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_rapid_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_circular_move_turbo {} {

  set commandcheck(LIB_CTRL_circular_move_turbo_ENTRY) [llength [info commands LIB_CTRL_circular_move_turbo_ENTRY]]

  LIB_GE_command_buffer CIRCULAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @CIRCULAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_circular_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_circular_move_turbo_ENTRY)} {LIB_CTRL_circular_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_circular_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_linear_move_turbo_LIB {} {

  set commandcheck(MOM_linear_move_turbo_LIB_ENTRY) [llength [info commands MOM_linear_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_linear_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_turbo_LIB {} {

  set commandcheck(MOM_rapid_move_turbo_LIB_ENTRY) [llength [info commands MOM_rapid_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_rapid_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_turbo_LIB {} {

  set commandcheck(MOM_circular_move_turbo_LIB_ENTRY) [llength [info commands MOM_circular_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  if {[CONF_CTRL_moves always_center_for_circle] != 1} {
    global mom_arc_radius
    set mom_arc_radius [expr abs($mom_arc_radius)]

    MOM_suppress once I J K

    switch -- $::tool_axis {
      0 {MOM_force once Y Z}
      1 {MOM_force once X Z}
      2 {MOM_force once X Y}
    }

    # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
    if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

      global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
      global mom_namespace_name mom_output_pos_type
      if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
        if {$mom_namespace_name == "::"} {
          set namespace ::
        } else {
          set namespace ::LOCAL_CSYS::
        }
        if {$mom_output_pos_type == "mom_pos"} {
          VMOV 3 ${namespace}mom_prev_pos prev_pos
          VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
        } else {
          VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
          VMOV 3 ${namespace}mom_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
        }
        VMOV 3 ${namespace}$mom_output_pos_type save_pos
      } else {
        set namespace ::
        set mom_output_pos_type mom_pos
        VMOV 3 mom_prev_pos prev_pos
        VMOV 3 mom_pos_arc_center pos_arc_center
        VMOV 3 mom_pos_arc_axis pos_arc_axis
        VMOV 3 mom_pos save_pos
      }
      VEC3_sub prev_pos pos_arc_center tmp_vec
      VEC3_unitize tmp_vec tmp_vec1
      VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
      VEC3_scale mom_arc_radius tmp_vec tmp_vec1
      VEC3_add pos_arc_center tmp_vec1 tmp_vec
      VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

      MOM_do_template [CONF_Turbo_Templates circular_template]

      VMOV 3 save_pos  ${namespace}$mom_output_pos_type
      MOM_suppress once I J K
      switch -- $::tool_axis {
        0 {MOM_force once Y Z}
        1 {MOM_force once X Z}
        2 {MOM_force once X Y}
      }

      VMOV 3 save_pos  mom_pos
      set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]
    }

    if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
      LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
    }

    if {[EQ_is_gt $::mom_arc_angle 180.0]} {
      set mom_arc_radius [expr -1.0*$mom_arc_radius]
    }

  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_circular_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB_MODIF_first_move_turn {} {

  return 0

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_TURNING_mode {{option default}} {

  global x_factor lib_flag

  switch -- $option {
    "start" {

      set x_factor [LIB_SPF_check_x_factor TURN]

      if {![info exist lib_flag(save_rapid_template)]} {set lib_flag(save_rapid_template) [CONF_CTRL_moves rapid_template]}
      CONF_CTRL_moves set rapid_template [CONF_CTRL_moves rapid_template_turn]

      if {![info exist lib_flag(save_linear_template)]} {set lib_flag(save_linear_template) [CONF_CTRL_moves linear_template]}
      CONF_CTRL_moves set linear_template [CONF_CTRL_moves linear_template_turn]

      if {![info exist lib_flag(save_circular_template)]} {set lib_flag(save_circular_template) [CONF_CTRL_moves circular_template]}
      CONF_CTRL_moves set circular_template [CONF_CTRL_moves circular_template_turn]
    }
    "end" {
      set x_factor [LIB_SPF_check_x_factor MILL]

      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        unset lib_flag(save_rapid_template)
      }

      if {[info exists lib_flag(save_linear_template)]} {
        CONF_CTRL_moves set linear_template $lib_flag(save_linear_template)
        unset lib_flag(save_linear_template)
      }

      if {[info exists lib_flag(save_circular_template)]} {
        CONF_CTRL_moves set circular_template $lib_flag(save_circular_template)
        unset lib_flag(save_circular_template)
      }
    }
  }
}
# <Internal Documentation>
# Controls the turning mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_start {{option default}} {

  global mom_machine_mode mom_spindle_mode mom_spindle_preset_rpm_toggle mom_spindle_preset_rpm
  global mom_spindle_maximum_rpm mom_spindle_speed mom_mcs_goto mom_spindle_status
  global PI mom_spindle_maximum_rpm_toggle lib_flag

  if {$mom_spindle_status == "OFF"} {return}

  set commandcheck(LIB_SPINDLE_start_ENTRY) [llength [info commands LIB_SPINDLE_start_ENTRY]]

  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY start_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SPINDLE
  switch -- $option {
    "preset" {
      # turning only
      LIB_GE_command_buffer {
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {[EQ_is_zero $mom_spindle_speed]} {
            LIB_GE_error_message "Spindle speed should not be = 0.0" "Please check"
          }
          if {$mom_spindle_preset_rpm_toggle == 0 || [EQ_is_zero $mom_spindle_preset_rpm]} {
            set rval [expr abs($mom_mcs_goto(0))]
            if {$rval < 0.1} {set rval 1}
            set mom_spindle_preset_rpm [expr $mom_spindle_speed * 1000 / $PI / $rval / 2]
            if {$mom_spindle_preset_rpm > [CONF_CTRL_spindle max]} {
              set mom_spindle_preset_rpm [CONF_CTRL_spindle max]
            }
            if {[info exists mom_spindle_maximum_rpm_toggle] && $mom_spindle_maximum_rpm_toggle == 1} {
              if {$mom_spindle_preset_rpm > $mom_spindle_maximum_rpm} {
                set mom_spindle_preset_rpm $mom_spindle_maximum_rpm
              }
            }
          }
          MOM_do_template spindle_rpm_preset
        } else {
          MOM_do_template spindle_rpm_preset CREATE
        }
      } @PRESET
    }
    "cycle" {
      LIB_GE_command_buffer {
        if {$mom_machine_mode == "TURN"} {set ::feed_mode "MMPR"}
        MOM_do_template spindle_rpm
      } @CYCLE
    }
    "limit" {
      LIB_GE_command_buffer {
        # turning only
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {([info exists mom_spindle_maximum_rpm_toggle] && $mom_spindle_maximum_rpm_toggle == 1) || [CONF_CTRL_spindle spindle_max_rpm_output_always]} {
            if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
              set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
            }
            MOM_do_template spindle_max_rpm
          }
        }
      } @LIMIT
    }
    "default" {
      switch -- $mom_machine_mode {
        "MILL" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm CREATE
            } else {
              # Always RPM output for milling
              if {[CONF_CTRL_spindle spindle_output_alone] == 1 || [info level 1] == "MOM_spindle_rpm"} {
                MOM_do_template spindle_rpm
              }
            }
          } @DEFAULTMILL
        }
        "TURN" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm_turn CREATE
            } elseif {$mom_spindle_mode == "RPM"} {
              if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
                MOM_force_block once spindle_rpm_turn
                MOM_do_template spindle_rpm_turn
              }

            } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {

              if {[MOM_do_template spindle_smm_turn CREATE] != ""} {
                MOM_force_block once spindle_smm_turn
                MOM_do_template spindle_smm_turn
              }

            }
          } @DEFAULTTURN
        }
      }
    }
  }
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY end_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Controls the spindle start conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_end {} {

  LIB_GE_command_buffer SPINDLE_END
  LIB_GE_command_buffer {MOM_do_template spindle_off} @SPINDLE_OFF_1
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the spindle end conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_spindle_orient {} {

  global mom_machine_mode

  LIB_GE_command_buffer SPINDLE_ORIENT

  LIB_GE_command_buffer {
    if {$mom_machine_mode == "MILL"} {MOM_do_template spindle_off}
  } @SPINDLE_OFF

  LIB_GE_command_buffer {
    MOM_force Once M_spindle RS
    MOM_do_template spindle_orient} @M19_S

  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# It used to output spindle orient code M19 S.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {
      # first tool_path motion with same tool and configuration as previous operation
      if {$lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_xlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXLU
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_ylu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYLU
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_zlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZLU
            }
        }
      } else {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_xul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXUL
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_yul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYUL
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_zul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZUL
            }
        }
      }
      unset lib_flag(current_plane_upper_than_previous)
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDXI
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_yi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDYI
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDZI
          }
      }
    }
  }

  set lib_flag(current_safety_position) 0
  LIB_GE_command_buffer {
    LIB_CTRL_clamp_axis
  } @CLAMP
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the standard case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_pos {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_POS

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_pos) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z H
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {
      # first tool_path motion with same tool and configuration as previous operation
      if {$lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_xlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXLU
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_ylu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYLU
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_zlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZLU
            }
        }
      } else {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_xul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXUL
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_yul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYUL
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_zul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZUL
            }
        }
      }
      unset lib_flag(current_plane_upper_than_previous)
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSXI
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_yi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSYI
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSZI
          }
      }
    }
  }
  set lib_flag(current_safety_position) 0
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_sim {} {

  global mom_motion_event
  global lib_flag

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_SIM

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_sim) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    LIB_GE_command_buffer {
      set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
      LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
    } @DECOMPOSE
  }
  LIB_GE_command_buffer_output
  set lib_flag(current_safety_position) 0
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning simultanous first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_check_cutcom_condition {} {

  global mom_kin_is_turbo_output mom_cutcom_adjust_register_defined mom_tool_cutcom_register mom_tool_number
  global mom_motion_event mom_path_name
  global mom_pos mom_prev_pos tool_axis
  global lib_flag

  if {([LIB_SPF_get_pretreatment mom_cutcom_status] == "LEFT" || [LIB_SPF_get_pretreatment mom_cutcom_status] == "RIGHT")\
     && $mom_kin_is_turbo_output == "TRUE" && $mom_cutcom_adjust_register_defined == 0} {
    if {$mom_tool_cutcom_register != $mom_tool_number} {
      LIB_SPF_add_warning "Tool cutcom register 'INS->$mom_tool_cutcom_register<-' is different to tool number 'INS->$mom_tool_number<-' and it's not output. With turbo mode activated, Switch it to ON in the operation"
    }
  }

  if {[info exists lib_flag(check_cutcom_start_move)] && $lib_flag(check_cutcom_start_move) == 1} {
    if {$mom_motion_event == "circular_move" && [CONF_CTRL_setting cutcom_on_with_circle_allowed] == 0} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- has to be a linear move"

    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_mag move] > 0 && [VEC3_is_parallel move tool_vector] == 1 && [CONF_CTRL_setting cutcom_on_with_tool_axis_allowed] == 0} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_start_move) 2
  } elseif {[info exists lib_flag(check_cutcom_end_move)] && $lib_flag(check_cutcom_end_move)} {
    if {$mom_motion_event == "circular_move" && [CONF_CTRL_setting cutcom_on_with_circle_allowed] == 0} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- has to be a linear move"
    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_is_parallel move tool_vector] == 1 && [CONF_CTRL_setting cutcom_on_with_tool_axis_allowed] == 0} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_end_move) 0
  }

}
# <Internal Documentation>
#
# This allows to check the first move after cutcom is switched on or off
# This is meant to do checks like first move has not to be a circular move
# The flags lib_flag(check_cutcom_start_move) and lib_flag(check_cutcom_end_move) are triggering this check
# those flags are set in MOM_cutcom_on and MOM_cutcom_off
#
# Proc has to be moved to controller level to implement controller specific checks
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_generic_cycle_LIB {} {

  set commandcheck(MOM_generic_cycle_LIB_ENTRY) [llength [info commands MOM_generic_cycle_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_error_message "Machine Cycle in turning not supported for this controller" "Please check"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is used to handle turn rough and finish cycle with generic cycle enhancement.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_linear_move_LIB {} {

  global mom_machine_mode mom_spindle_preset_rpm mom_nxt_motion_event
  global lib_flag lib_param

  if {[hiset lib_flag(lathe_thread_motion)] && $lib_flag(lathe_thread_motion) == 1} {
    if {$mom_nxt_motion_event == "none"} {
      # last event MOM_end_of_thread misses
      set lib_flag(lathe_thread_motion) 0
    }
    MOM_abort_event
  }

  set commandcheck(MOM_linear_move_LIB_ENTRY) [llength [info commands MOM_linear_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        if {$lib_flag(decompose_first_move_turn) == 1} {
          # X then Z
          if {[hiset mom_spindle_preset_rpm] && ![EQ_is_equal $mom_spindle_preset_rpm [MOM_ask_address_value S]]} {
            MOM_disable_address S
            LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves linear_template] FORCE "X Y Z"
            MOM_enable_address S
          } else {
            LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves linear_template] FORCE "X Y Z"
          }
        } else {
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
        set lib_flag(current_safety_position) 0
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
          switch -- $lib_flag(mode_current_status) {
            "std" {
              LIB_ROTARY_positioning_first_move
            }
            "pos" {
              LIB_ROTARY_positioning_first_move_pos
            }
            "sim" {
              LIB_ROTARY_positioning_first_move_sim
            }
          }
        } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer TURN
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves linear_template]} @MOVE
    LIB_GE_command_buffer_output

  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves linear_template]} @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_LIB {} {

  global lib_param

  set commandcheck(MOM_circular_move_LIB_ENTRY) [llength [info commands MOM_circular_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]} @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]} @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_helix_move_LIB {} {

  global mom_helix_turn_number
  global lib_arc_axis

  set commandcheck(MOM_helix_move_LIB_ENTRY) [llength [info commands MOM_helix_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer OUTPUT
  LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
  LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
  LIB_GE_command_buffer {LIB_HELIX_nturn $lib_arc_axis} @HELIX_NTURN
  LIB_GE_command_buffer {
    MOM_force once X Y Z
    MOM_do_template [CONF_CTRL_moves circular_template]
  } @MOVE
  LIB_GE_command_buffer_output

  unset mom_helix_turn_number

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_HELIX_nturn {axis} {

  global mom_prev_pos mom_pos mom_helix_pitch mom_arc_angle
  global mom_helix_turn_number mom_kin_machine_resolution

  set delta [expr abs($mom_pos($axis) - $mom_prev_pos($axis))]

  if {![EQ_is_equal $mom_helix_pitch 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number [expr floor([LIB_SPF_round [expr $delta / [expr abs($mom_helix_pitch)]] $mom_kin_machine_resolution])]
  } elseif {![EQ_is_equal $delta 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number 1
  } else {
    set mom_helix_turn_number 0
  }

  if {[EQ_is_le $mom_arc_angle 360.0 $mom_kin_machine_resolution]} {
    MOM_suppress once helix_turn
  }
}
# <Internal Documentation>
# Calculate number of turns
# Linked to helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_on_ENTRY {option} {

  global mom_cutcom_adjust_register mom_tool_cutcom_register mom_tool_number
  global cutcom_adjust_register

  switch -- $option {
    "start" {
      if {[CONF_CTRL_setting cutcom_output] == 1} {
        if {$mom_tool_cutcom_register == 0} {
          set cutcom_adjust_register $mom_tool_number
        } else {
          set cutcom_adjust_register $mom_tool_cutcom_register
        }
      } else {
        set cutcom_adjust_register 0
      }
      if {[hiset mom_cutcom_adjust_register]} {set cutcom_adjust_register $mom_cutcom_adjust_register}
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning and at the end of MOM_cutcom_on procedure
# depending of the argument: start or end
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_off_ENTRY {option} {

  global cutcom_adjust_register

  switch -- $option {
    "end" {
      if {[hiset cutcom_adjust_register]} {unset cutcom_adjust_register}
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning and at the end of MOM_cutcom_off procedure
# depending of the argument: start or end
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_opstop_LIB {mess} {
  global mom_opstop_text mom_opstop_text_defined

  set commandcheck(MOM_opstop_LIB_ENTRY) [llength [info commands MOM_opstop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_opstop_text_defined] && $mom_opstop_text_defined == 1} {
      LIB_GE_command_buffer MOM_opstop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "along_with_stop"} {
          MOM_do_template opstop BUFFER
        } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_opstop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_opstop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_opstop_LIB
      LIB_GE_command_buffer {
        MOM_do_template opstop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_opstop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "along_with_opstop"} {
        MOM_do_template opstop BUFFER
      } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_AFTER_MSG
  }

  LIB_GE_command_buffer MOM_opstop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_opstop_text]} {unset mom_opstop_text}
  if {[hiset mom_opstop_text_defined]} {unset mom_opstop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_stop_LIB {mess} {
  global mom_stop_text mom_stop_text_defined

  set commandcheck(MOM_stop_LIB_ENTRY) [llength [info commands MOM_stop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_stop_text_defined] && $mom_stop_text_defined == 1} {
      LIB_GE_command_buffer MOM_stop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
          MOM_do_template stop BUFFER
        } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_stop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_stop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_stop_LIB
      LIB_GE_command_buffer {
        MOM_do_template stop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_stop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
        MOM_do_template stop BUFFER
      } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_AFTER_MSG
  }
  LIB_GE_command_buffer MOM_stop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_stop_text]} {unset mom_stop_text}
  if {[hiset mom_stop_text_defined]} {unset mom_stop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_nurbs_move_LIB {} {

  set commandcheck(MOM_nurbs_move_LIB_ENTRY) [llength [info commands MOM_nurbs_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_start_LIB {} {

  set commandcheck(MOM_contour_start_LIB_ENTRY) [llength [info commands MOM_contour_start_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_end_LIB {} {

  set commandcheck(MOM_contour_end_LIB_ENTRY) [llength [info commands MOM_contour_end_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_gohome_move_LIB {} {

  global mom_motion_type

  set commandcheck(MOM_gohome_move_LIB_ENTRY) [llength [info commands MOM_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_motion_type == "GOHOME_DEFAULT"} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
  } else {
    MOM_rapid_move
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_path_LIB {} {

  global lib_flag
  global mom_next_oper_has_tool_change mom_current_oper_is_last_oper_in_program mom_next_main_mcs mom_main_mcs
  global mom_path_name mom_operation_name mom_machine_mode mom_out_angle_pos mom_kin_is_turbo_output mom_tool_axis
  global mom_flip_a_axis mom_tool_holder_angle_for_cutting
  global lib_pretreatment mom_tool_pitch mom_polar_status mom_coordinate_output_mode
  global mom_output_mcs_name lib_parameter nxt_oper_tool_axis
  global lib_prev_tool_name mom_next_tool_name mom_operation_is_interop

  set commandcheck(MOM_end_of_path_LIB_ENTRY) [llength [info commands MOM_end_of_path_LIB_ENTRY]]
  set commandcheck(LIB_unset_variables_in_end_of_path) [llength [info commands LIB_unset_variables_in_end_of_path]]

  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check "spindle" ;# to be sure S and M_spindle addresses are enable for next operation

  if {[CONF_CTRL_setting turbo_mode] == 1} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode disable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {[info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE"} {
    if {[llength [info commands MOM_set_turbo_feedrate_set]]} {MOM_set_turbo_feedrate_set ON}
  }

  if {$mom_machine_mode != "TURN" && [CONF_CTRL_moves polar_off_end_of_path] == "OFF"} {
    set mom_polar_status OFF
    set mom_coordinate_output_mode OFF
  }

  if {![info exists mom_output_mcs_name($mom_operation_name)]}      {set mom_output_mcs_name($mom_operation_name) $mom_main_mcs}
  if {![info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1])]} {set mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) $mom_next_main_mcs}

  # mom_pos(3) and mom_pos(4) are not overwritten if there is an CSYS-Rotation with Toolaxis Z and parallel to TA
  # PR10021397: compare last tool axis of current operation with first tool axis of next operation,
  # because mom_tool_axis saved in pretreatment is always from last motion event.
  if {[LIB_SPF_get_pretreatment "init_tool_axis,0" 1] == ""} {
    array set nxt_oper_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  } else {
    array set nxt_oper_tool_axis "0 [LIB_SPF_get_pretreatment "init_tool_axis,0" 1] 1 [LIB_SPF_get_pretreatment "init_tool_axis,1" 1] 2 [LIB_SPF_get_pretreatment "init_tool_axis,2" 1]"
  }
  if {([CONF_CTRL_moves reset_rotary_axis_end_of_path] == "ON" && ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] &&\
    [LIB_SPF_get_pretreatment axis_mode next] != "SIMULTANEOUS") ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

  if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES" ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) && [CONF_CTRL_moves safety_motion_when_mcs_changes] == 1)} {

    switch -- $mom_machine_mode {
      "TURN" {
        LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,TURN
        LIB_GE_command_buffer {LIB_TURNING_mode end} @TURN_END
        LIB_GE_command_buffer_output
      }
      "MILL" {
        LIB_CTRL_polar_transmit "off"
        if {$lib_flag(tool_path_motion) > 0} {
          if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,SIM
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_simultaneous_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          } else {
            #!!! if next op has different mom_out_angle_pos reset as well
            # (maybe compare current and next angle from Pretreatment)
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,POS
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $::lib_sav_kin_machine_type == "3_axis_mill" || $lib_flag(tool_axis_zm) == 1} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_positioning_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          }
        }
      }
    }

    if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
      return
    }

    LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,COMMON

    if {$::mom_oper_tool != "NONE" || ([info exist lib_prev_tool_name] && $lib_prev_tool_name != $mom_next_tool_name) } {
      LIB_GE_command_buffer {LIB_local_origin_reset} @LOCAL_ORIG_RESET
      LIB_GE_command_buffer {
        if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
          LIB_WRITE_coolant off
        }
      } @COOLANT_OFF
      LIB_GE_command_buffer {
        if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
          LIB_SPINDLE_end
        }
      } @SPINDLE_OFF
      LIB_GE_command_buffer {
        if {$mom_current_oper_is_last_oper_in_program == "YES"} {
          if {[CONF_CTRL_moves return_end_of_pgm] != ""} {
            LIB_RETURN_move CONF_CTRL_moves return_end_of_pgm
          }
        } else {
          if {[CONF_CTRL_moves return_tool_change_pos] != ""} {
            LIB_RETURN_move CONF_CTRL_moves return_tool_change_pos
          }
        }
      } @RETURN_MOVE
    }
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 0

  } else {

    switch -- $mom_machine_mode {
      "TURN" {

        set nxt_flip_a_axis [LIB_SPF_get_pretreatment mom_flip_a_axis 1]
        set nxt_tool_holder_angle_for_cutting [LIB_SPF_get_pretreatment mom_tool_holder_angle_for_cutting 1]

        if {![info exists mom_tool_holder_angle_for_cutting] || ![EQ_is_equal $nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting]} {

          LIB_GE_command_buffer TURN_HOLDER_ORIENT_CHANGE

          # check if B axis position change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {
            if {[CONF_CTRL_moves return_safety_pos] != ""} {
              LIB_RETURN_move CONF_CTRL_moves return_safety_pos
            }
          } @RETURN_MOVE
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output

        } elseif {[info exists mom_flip_a_axis] && $nxt_flip_a_axis != $mom_flip_a_axis} {

          LIB_GE_command_buffer TURN_TOOL_FLIP_CHANGE
          # check if spindle direction change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output
        }

      }
      "MILL" {
        if {$lib_flag(first_transmit_move) == 1 && ([CONF_CTRL_moves polar_off_end_of_path] == "OFF" || ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] || [LIB_SPF_get_pretreatment axis_mode next] == "SIMULTANEOUS") ||\
        ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
          LIB_CTRL_polar_transmit "off"
        }

        LIB_GE_command_buffer MILL_AXIS_CHANGE

        # If the variable does not exist in the query, an blank is returned

        LIB_GE_command_buffer {

          if {[LIB_SPF_pt_exists_not_empty "out_angle_pos_last,0" 0]} {
            set out_angle_pos(0) [LIB_SPF_get_pretreatment "out_angle_pos_last,0" 0]
            set out_angle_pos(1) [LIB_SPF_get_pretreatment "out_angle_pos_last,1" 0]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set out_angle_pos(0) $mom_out_angle_pos(0)
            set out_angle_pos(1) $mom_out_angle_pos(1)
          }

          if {[LIB_SPF_pt_exists_not_empty "mom_out_angle_pos,0" 1]} {
            set nxt_out_angle_pos(0) [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 1]
            set nxt_out_angle_pos(1) [LIB_SPF_get_pretreatment "mom_out_angle_pos,1" 1]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set nxt_out_angle_pos(0) $out_angle_pos(0)
            set nxt_out_angle_pos(1) $out_angle_pos(1)
          }

          # PR#9554274 incase operation's current status is not same as axis mode. It happened if there is only rapid motions in operation like GMC operation.
          if {([LIB_SPF_get_pretreatment axis_mode] != [LIB_SPF_get_pretreatment axis_mode 1] && ([LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || [LIB_SPF_get_pretreatment axis_mode 1] == "SIMULTANEOUS") )||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(0)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(0) $out_angle_pos(0) $::mom_kin_4th_axis_min_incr] ||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(1)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(1) $out_angle_pos(1) $::mom_kin_5th_axis_min_incr] ||\
            ($lib_flag(mode_current_status) == "sim" &&  [LIB_SPF_get_pretreatment axis_mode] == "POSITIONING")} {
            if {$mom_machine_mode == "MILL" && $lib_flag(tool_path_motion) > 0} {
              if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
                if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                  LIB_ROTARY_absolute_reset
                } else {
                  LIB_ROTARY_simultaneous_reset
                }
              } else {
                #!!! if next op has different mom_out_angle_pos reset as well
                # (maybe compare current and next angle from Pretreatment)

                if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {
                  LIB_ROTARY_absolute_reset
                } else {
                  LIB_ROTARY_positioning_reset
                }
              }
              set lib_flag(tool_path_motion) 0
              if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
            }
          }
        } @RESET

        LIB_GE_command_buffer_output

      }
    }

  }

  # unset Variables if needed
  LIB_GE_command_buffer LIB_unset_variables_in_end_of_path
  LIB_GE_command_buffer {if {$commandcheck(LIB_unset_variables_in_end_of_path)} {LIB_unset_variables_in_end_of_path}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# * store oper info (for operation list)
# * mom_next_oper_has_tool_change == "YES"
# * mom_next_oper_is_last_oper_in_program == "YES"
# * mom_next_main_mcs != mom_main_mcs
# * check rot axis change PT
# if abs
# LIB_ROTARY_absolute_reset
# if sim
# LIB_ROTARY_simultaneous_reset
# if pos
# LIB_ROTARY_positioning_reset
# * retract before set axes (if needed) PT
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_unset_variables_in_end_of_path {} {

  global initial_cycle_pos

  if {[info exists ::lib_spf(do_convert_point)]}    {unset ::lib_spf(do_convert_point)}

  set ::lib_parameter(special_cycle,name) ""
  if {[hiset initial_cycle_pos]} {unset initial_cycle_pos}

  if {$::mom_next_oper_has_tool_change == "YES" || $::mom_current_oper_is_last_oper_in_program == "YES"} {
    if {[info exists ::mom_tool_pitch]} {unset ::mom_tool_pitch}
  }
}
# <Internal Documentation>
#
#  Unset Variables in End_of_path
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_program_LIB {} {

  set commandcheck(MOM_end_of_program_LIB_ENTRY) [llength [info commands MOM_end_of_program_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer TOOL_CHANGE_EOP
  LIB_GE_command_buffer {
    MOM_suppress once S F_tool_call DL_tool_call DR_tool_call
    switch -- [join [CONF_CTRL_tool tool_change_eop]] {
      "off" {
        # nothing
      }
      "first_tool" {
        set ::mom_tool_name $::mom_next_tool_name
        set ::mom_tool_number $::mom_next_tool_number
        set ::mom_tool_adjust_register 1
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "unload_tool" {
        set ::mom_tool_number 0
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "default" {
        if {[string is integer -strict [CONF_CTRL_tool tool_change_eop]]} {
          set ::mom_tool_number [CONF_CTRL_tool tool_change_eop]
          set ::mom_tool_adjust_register 1
          LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
        }
      }
    }
  } @TOOL_CHANGE_END_OF_PROGRAM
  LIB_GE_command_buffer_output
  LIB_GE_command_buffer END_OF_PROGRAM
  LIB_GE_command_buffer {MOM_do_template end_of_program} @END_OF_PROG
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_reset {} {
  global lib_flag

  set commandcheck(LIB_ROTARY_absolute_reset_ENTRY) [llength [info commands LIB_ROTARY_absolute_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_reset {} {

  global lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_mode] == "G169"} {
      LIB_GE_command_buffer SIMULTANEOUS_RESET_G169
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @ADJUST_OFF
      LIB_GE_command_buffer_output
    }
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAFOOF
# Heidenhain: M129 / TCPM
# Fanuc: G49
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset {} {

  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_reset_ENTRY) [llength [info commands LIB_ROTARY_positioning_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    LIB_CSYS_plane_output_reset
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch off positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global tcpm_type lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_init_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_mode] == "G169" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  LIB_CTRL_unclamp_axis

  if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {return}
  if {$lib_flag(mode_current_status) != "sim"} {
    if {[CONF_CTRL_setting tcpm_mode] != "G169"} {
      LIB_SPF_add_warning "The entry 'INS->[CONF_CTRL_setting tcpm_mode]<-' for tcpm_output is not allowed, G169 will be used"
    }
    if {[CONF_CTRL_setting tcpm_mode] == "G169"} {
      set tcpm_type 1
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }

    LIB_GE_command_buffer MILL,SIMULTANEOUS

    LIB_GE_command_buffer {
      MOM_do_template tool_length_adjust CREATE
      MOM_force once H
    } @TOOL_LENGTH_ADJUST
    LIB_GE_command_buffer {
      MOM_do_template set_tcpm_on
    } @ROTARY_SIMULTANEOUS

    LIB_GE_command_buffer_output
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    set lib_flag(mode_current_status) "sim"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAORI
# Heidenhain: M128 / TCPM
# Fanuc: G169
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_init {} {
  global mom_kin_is_turbo_output mom_post_in_simulation
  global tcpm_type lib_flag

  set commandcheck(LIB_ROTARY_absolute_init_ENTRY) [llength [info commands LIB_ROTARY_absolute_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_mode] == "G169" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }
  if {[CONF_CTRL_setting tcpm_mode] != "G169"} {
    LIB_SPF_add_warning "The entry 'INS->[CONF_CTRL_setting tcpm_mode]<-' for tcpm_output is not allowed, G169 will be used"
  }
  if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {
    MOM_disable_address X_vector Y_vector Z_vector
  } else {
    if {[CONF_CTRL_setting tcpm_mode] == "G169"} {
      set tcpm_type 1
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
  }

  LIB_CTRL_polar_transmit "start"

  LIB_GE_command_buffer TOOL_LENGTH_ADJUST
  LIB_GE_command_buffer {MOM_do_template tool_length_adjust CREATE} @OUTPUT
  LIB_GE_command_buffer_output
  MOM_force once G_adjust H
  set lib_flag(mode_current_status) "std"

  LIB_GE_command_buffer UNCLAMP
  LIB_GE_command_buffer {LIB_CTRL_unclamp_axis} @UNCLAMP
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_init_ENTRY) [llength [info commands LIB_ROTARY_positioning_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

   MOM_disable_address X_vector Y_vector Z_vector

  if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {return}
  if {$lib_flag(mode_current_status) != "pos"} {
    LIB_CSYS_plane_output_init
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: AROT / CYCLE800
# Heidenhain: CYCL DEF 19 or PLANE SPATIAL
# Fanuc: G68 / G68.1 / G68.2
#____________________________________________________________________________________________
proc LIB_CTRL_KINEMATICS_set_simultanous_kin {} {

  set commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY) [llength [info commands LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_sim_kin 4th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 4th_axis_has_limit $::mom_sys_4th_axis_has_limits}
  if {[CONF_SPF_sim_kin 5th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 5th_axis_has_limit $::mom_sys_5th_axis_has_limits}
  if {![CONF_SPF_sim_kin 4th_axis_has_limit] || ![CONF_SPF_sim_kin 5th_axis_has_limit]} {
#     set optimized rotary axis on
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on shortest distance for simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: Leader "C=DC("  Trailer ")"
# Heidenhain: M126
#____________________________________________________________________________________________
proc LIB_RETURN_move {Addresses {property ""}} {

  global mom_sys_home_pos mom_prev_pos mom_prev_out_angle_pos
  global tool_axis lib_flag mom_operation_type

  set commandcheck(LIB_RETURN_move_ENTRY) [llength [info commands LIB_RETURN_move_ENTRY]]

  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[string match $mom_operation_type "Device Generic Motion"]} {
      return
  }

  if {$property != ""} {
    set object $Addresses
    set Addresses [$Addresses $property]
  } else {
    set object ""
  }

  set line_nbr -1
  set break_it 0

        foreach axes $Addresses {
          incr line_nbr

    if {[catch {foreach axis $axes {}}]} {
      set axes [list $axes]
    }

    foreach axis $axes {
            MOM_force once G_return
      switch -- $axis {
        "Z" {
                #WRITE_coolant off
                if {[CONF_CTRL_moves return_mode] == "value"} {
                  if {[hiset tool_axis] && $tool_axis == 2} {
                    LIB_GE_command_buffer TOOL_LENGTH_ADJUST_OFF
                    LIB_GE_command_buffer {MOM_do_template tool_length_adjust_off} @OUTPUT
                    LIB_GE_command_buffer_output
                  }
                              MOM_force once Z
            MOM_suppress once X Y
            LIB_GE_command_buffer AXIS_MOVE_Z
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Z
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Z
            LIB_GE_command_buffer {MOM_do_template return_home_Z} @RETURN_HOME_Z
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
                MOM_force once Z
        }
        "Y" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 1} {
              LIB_GE_command_buffer TOOL_LENGTH_ADJUST_OFF
                    LIB_GE_command_buffer {MOM_do_template tool_length_adjust_off} @OUTPUT
                    LIB_GE_command_buffer_output
                  }
            MOM_force once Y
            MOM_suppress once X Z
            LIB_GE_command_buffer AXIS_MOVE_Y
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Y
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Y
            LIB_GE_command_buffer {MOM_do_template return_home_Y} @RETURN_HOME_Y
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once Y
        }
        "X" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0} {
                    LIB_GE_command_buffer TOOL_LENGTH_ADJUST_OFF
                    LIB_GE_command_buffer {MOM_do_template tool_length_adjust_off} @OUTPUT
                    LIB_GE_command_buffer_output
            }
            MOM_force once X
            MOM_suppress once Y Z
            LIB_GE_command_buffer AXIS_MOVE_X
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_X
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_X
            LIB_GE_command_buffer {MOM_do_template return_home_X} @RETURN_HOME_X
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once X
        }
        "YX" -
        "XY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0 || [hiset tool_axis] && $tool_axis == 1} {
                    LIB_GE_command_buffer TOOL_LENGTH_ADJUST_OFF
                    LIB_GE_command_buffer {MOM_do_template tool_length_adjust_off} @OUTPUT
                    LIB_GE_command_buffer_output
            }
            MOM_force once X Y
            MOM_suppress once Z
            LIB_GE_command_buffer AXIS_MOVE_XY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_XY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_XY
            LIB_GE_command_buffer {MOM_do_template return_home_XY} @RETURN_HOME_XY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once X Y
        }
        "XZ" -
        "ZX" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0 || [hiset tool_axis] && $tool_axis == 2} {
                    LIB_GE_command_buffer TOOL_LENGTH_ADJUST_OFF
                    LIB_GE_command_buffer {MOM_do_template tool_length_adjust_off} @OUTPUT
                    LIB_GE_command_buffer_output
            }
            MOM_force once X Z
            MOM_suppress once Y
            LIB_GE_command_buffer AXIS_MOVE_ZX
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZX
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZX
            LIB_GE_command_buffer {MOM_do_template return_home_ZX} @RETURN_HOME_ZX
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once Z X
        }
        "YZ" -
        "ZY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 1 || [hiset tool_axis] && $tool_axis == 2} {
                    LIB_GE_command_buffer TOOL_LENGTH_ADJUST_OFF
                    LIB_GE_command_buffer {MOM_do_template tool_length_adjust_off} @OUTPUT
                    LIB_GE_command_buffer_output
            }
            MOM_force once Y Z
            MOM_suppress once X
            LIB_GE_command_buffer AXIS_MOVE_ZY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZY
            LIB_GE_command_buffer {MOM_do_template return_home_ZY} @RETURN_HOME_ZY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          MOM_force once Y Z
        }
        "4th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]]} {
            MOM_force once fourth_axis
            LIB_GE_command_buffer AXIS_HOME_4TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th} @RETURN_HOME_4TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            MOM_force once fourth_axis
          }
        }
        "5th" {
          if {![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fifth_axis
            LIB_GE_command_buffer AXIS_HOME_5TH
            LIB_GE_command_buffer {MOM_do_template return_home_5th} @RETURN_HOME_5TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fifth_axis
          }
        }
        "4th5th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]] || ![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fourth_axis fifth_axis
            LIB_GE_command_buffer AXIS_HOME_45TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th5th} @RETURN_HOME_45TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fourth_axis fifth_axis
          }
        }
        "" {
                #Do Nothing
        }
        "default" {
          if {[LIB_SPF_exists_block_template $axes 1] == 1} {
            MOM_do_template $axes
          } elseif {[LIB_SPF_exists_block_template $axes 1] == -1 && ![catch {set dummy [MOM_do_template $axes CREATE]}]} {
            # Thats the case when 'MOM_has_definition_element' command does not exist (older NX versions)
            #legacy
            MOM_output_literal $dummy
          } else {
            if {$object == ""} {
              #when LIB_RETURN_move is not called with a conf_object as argument
              LIB_RETURN_move_LIB_ENTRY $axes
            } else {
              if {[info proc LIB_RETURN_move_LIB_ENTRY] == "LIB_RETURN_move_LIB_ENTRY"} {
                #legacy
                LIB_RETURN_move_LIB_ENTRY $axes
              } else {
                LIB_CONF_do_prop_custom_proc $object $property "no_special_syntax" $line_nbr
                set break_it 1
                break
              }
            }
          }
        }
      }
    }
    if {$break_it} {break}
  }
  set lib_flag(current_safety_position) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Documentation>
# Writes return motions to the NC-code. Settings for home motions (CONF_CTRL_moves return_mode)
# are taken into consideration for the output format of the return motions.
#
# <Arguments>
# Addresses
# String with space separated axis names that should perform a return move.
#   Valid options:
#   X / Y / Z / XY / ZX / ZY or a template name
# property
# Reserved argument.
#
# <Returnvalue>
# None.
#
# <Example>
# name: Example using axis names
# code: LIB_RETURN_move "Z XY"
# desc: Writes return moves for Z and then XY to the NC-code in Okuma-Format.
#      Result will be:
# G0 G30 G91 Z0.
# G30 X0. Y0.
#
# <Example>
# name: Example using template names
# code: LIB_RETURN_move "custom_return_template1 custom_return_template2"
# desc: Assuming we have two custom specific block templates custom_return_template1 and custom_return_template2,
#      we can call them here by their name. It's okay to mix template names and axes names (see ex. 1)
#____________________________________________________________________________________________
proc LIB_main_origin_call {{offset_nbr ""} {create ""}} {

  global mom_fixture_offset_value
  global lib_main_zero_register lib_flag

  if {[CONF_CTRL_origin use_main] != 0} {
    if {$mom_fixture_offset_value <= 200} {
      set lib_main_zero_register [CONF_CTRL_origin use_main]
    } else {
      if {![hiset lib_flag(error_main_zero_register)]} {
        set error [LIB_SPF_add_warning "Fixture offset value should be < 200 : G[CONF_CTRL_origin use_main] H1 is used"]
        set lib_flag(error_main_zero_register) 1
      }
      set lib_main_zero_register 1
    }
    LIB_GE_command_buffer MAIN_ZERO
    LIB_GE_command_buffer {MOM_do_template main_zero $create} @OUTPUT
    LIB_GE_command_buffer_output
  }
}
# <Documentation>
# Writes the active main origin to the NC-code, provided that the property
# [CONF_CTRL_origin use_main] is set to 'On'.
#
# <Arguments>
# offset_nbr
# Reserved argument.
# create
# Reserved argument.
# <Example>
# name: Output active origin
# code: LIB_main_origin_call
# desc: Writes G54 for fixture_offset_number 1
#____________________________________________________________________________________________
proc LIB_local_origin_reset {} {

  global lib_flag

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 1 && [CONF_CTRL_setting plane_output] != "CYCLE_CSYS_ROT"} {
    # not yet implemented
    # MOM_output_literal "TRANS"
    set lib_flag(local_origin_activated) 0
  }
}
# <Internal Documentation>
# Output the main origin reset
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_pos {} {

  global mom_prev_out_angle_pos mom_out_angle_pos mom_polar_status mom_current_motion
  global lib_flag mom_operation_type

  if {[string match $mom_operation_type "Device Generic Motion"]} {
    return
  }

  if {$mom_current_motion == "initial_move"} {
    if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1} {
      set lib_flag(safety_retract_status) 1
    } else {
      set lib_flag(safety_retract_status) 0
    }
  }

  if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1 || $mom_current_motion != "initial_move"} {
  if {[info exists mom_prev_out_angle_pos] && $mom_polar_status != "ON" && [CONF_CTRL_moves standard_path_between_rotary_motions] == 0} {
    if {[CONF_CTRL_moves safety_retract_before_fourth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)]} {
      if {[EQ_is_gt [expr abs($mom_out_angle_pos(0) - $mom_prev_out_angle_pos(0))] [CONF_CTRL_moves safety_retract_before_fourth_axis_minimum_value]]} {
        set lib_flag(safety_retract_status) 1
      }
    }

    if {[CONF_CTRL_moves safety_retract_before_fifth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(1) $mom_out_angle_pos(1)]} {
      if {[EQ_is_gt [expr abs($mom_out_angle_pos(1) - $mom_prev_out_angle_pos(1))] [CONF_CTRL_moves safety_retract_before_fifth_axis_minimum_value]]} {
        set lib_flag(safety_retract_status) 1
      }
    }
  }

  if {[info exists lib_flag(safety_retract_status)] && $lib_flag(safety_retract_status) == 1} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
    set lib_flag(tool_path_motion) 1
    set lib_flag(safety_retract_status) 0
    }
  }

}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_sim {} {
  global lib_flag
  if {[CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    LIB_GE_command_buffer TCPM_PREPOS_PLANE
    LIB_GE_command_buffer {
      if {$lib_flag(local_namespace_output)} {
        LIB_SPF_local_csys_rotation "ZXZ" "euler"
      } else {
        LIB_SPF_convert_point "plane_no_reset"
        LIB_SPF_csys_3D_rotation "ZXZ" "euler"
        LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
      }
    } @CP_PLANE
    LIB_GE_command_buffer {LIB_ROTARY_positioning_init} @INIT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
    LIB_GE_command_buffer {LIB_ROTARY_positioning_first_move_pos} @MOTION
    LIB_GE_command_buffer {LIB_ROTARY_positioning_reset} @RESET
    if {$lib_flag(local_namespace_output) == 0} {
      LIB_GE_command_buffer {LIB_SPF_convert_point "reload"} @CP_RELOAD
      LIB_GE_command_buffer {
        if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
          LIB_SPF_KINEMATICS_set_absolut_output_kin
        } else {
          LIB_SPF_KINEMATICS_set_simultanous_kin
        }
      } @KIN_SIM
    } else {
      #LIB_SPF_convert_point "simultanous"
      global mom_mcs_goto mom_pos
      VMOV 3 mom_mcs_goto mom_pos
          }
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_pt_additional_variables_okuma {} {

  #PR9239197 Add mom_lock_axis to pretreatment
  LIB_SPF_pretreatment_add_var MOM_lock_axis mom_lock_axis 0
}
# <Internal Documentation>
#
# Entrypoint to define additional variables which should be stored in pretreatment
# Controller specific
#
# LIB_SPF_pretreatment_add_var in this proc to add return variables from pretreatment
#
# <Internal Example>
# Sample code as comment in proc body
#______________________________________________________________________________
proc LIB_CYCLE_dwell_set {} {

  global mom_cycle_delay_mode ;# SECONDS, REVOLUTIONS, OFF ,ON
  global mom_cycle_delay mom_cycle_delay_revs mom_spindle_rpm

  if {$mom_cycle_delay_mode == "ON"} {set mom_cycle_delay [CONF_CTRL_drill default_cycle_delay]}

  if {$mom_cycle_delay_mode == "OFF"} {
    set mom_cycle_delay 0
    return
  }

  if {$mom_cycle_delay_mode == "REVOLUTIONS"} {
    catch {set mom_cycle_delay [expr $mom_cycle_delay_revs * (60 / $mom_spindle_rpm)]}
  }

  if {$mom_cycle_delay > [CONF_CTRL_drill max_delay]} {set mom_cycle_delay [CONF_CTRL_drill max_delay]}
  if {$mom_cycle_delay < [CONF_CTRL_drill min_delay]} {set mom_cycle_delay [CONF_CTRL_drill min_delay]}
}
# <Internal Documentation>
# This procedure is executed at the cycle event.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill : output CYCLE81 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_move_LIB {} {

  set commandcheck(MOM_drill_move_LIB_ENTRY) [llength [info commands MOM_drill_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_dwell : output CYCLE82 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell_move_LIB {} {

  set commandcheck(MOM_drill_dwell_move_LIB_ENTRY) [llength [info commands MOM_drill_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_deep_LIB {} {

  global mom_cycle_step1 mom_tool_diameter mom_cycle_feed_to mom_depth_increment_distance

  LIB_CYCLE_set

  if {[hiset mom_cycle_step1]} {
    set mom_cycle_step1 [expr abs($mom_cycle_step1)]
  } else {
    set mom_cycle_step1 0
  }

  if {[info exists mom_depth_increment_distance] && ![EQ_is_equal $mom_depth_increment_distance 0.0]} {
    set mom_cycle_step1 $mom_depth_increment_distance
  }

}
# <Internal Documentation>
# MOM_drill_deep : output CYCLE83_Deep (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep_move_LIB {} {

  global mom_cycle_feed_to mom_cycle_step1 mom_tool_diameter

  if {$mom_cycle_step1 == 0} {
    if {[hiset mom_tool_diameter]} {set mom_cycle_step1 [expr $mom_tool_diameter / 2]} else {set mom_cycle_step1 2}
    LIB_SPF_add_warning "With CYCLE/DEEP, STEP1 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step1]<-'"
  }
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_drill_deep_move_LIB_ENTRY) [llength [info commands MOM_drill_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_LIB {} {

  global mom_cycle_step1 mom_cycle_step2 mom_tool_diameter mom_cycle_feed_to

  LIB_CYCLE_set

  if {[hiset mom_cycle_step1]} {
    set mom_cycle_step1 [expr abs($mom_cycle_step1)]
  } else {
    set mom_cycle_step1 0
  }

  if {[hiset mom_cycle_step2]} {
    set mom_cycle_step2 [expr abs($mom_cycle_step2)]
  } else {
    set mom_cycle_step2 0
  }
}
# <Internal Documentation>
# MOM_drill_break_chip : output CYCLE83_Break_Chip (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_mill_hole_move_LIB {} {

    set commandcheck(MOM_mill_hole_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_move_LIB_ENTRY]]

    LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_SPF_add_warning "Hole milling machine cycle is not supported on this controller"

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# This function outputs a warning as hole milling subprogram is not supported on this controller
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_mill_hole_thread_move_LIB {} {

    set commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_thread_move_LIB_ENTRY]]

    LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_SPF_add_warning "Thread milling machine cycle is not supported on this controller"

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# This function outputs a warning as thread milling subprogram is not supported on this controller
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_move_LIB {} {

  global mom_cycle_step1 mom_cycle_step2 mom_tool_diameter mom_cycle_feed_to

  if {$mom_cycle_step1 == 0} {
    if {[hiset mom_tool_diameter]} {set mom_cycle_step1 [expr $mom_tool_diameter / 2]} else {set mom_cycle_step1 2}
    LIB_SPF_add_warning "With CYCLE/BREAKCHIP, STEP1 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step1]<-'"
  }
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  if {$mom_cycle_step2 == 0} {
    set mom_cycle_step2 [expr abs($mom_cycle_feed_to)]
    LIB_SPF_add_warning "With CYCLE/BREAKCHIP, STEP2 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step2]<-'"
  }

  set commandcheck(MOM_drill_break_chip_move_LIB_ENTRY) [llength [info commands MOM_drill_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_tap
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_move_LIB {} {

  set commandcheck(MOM_tap_move_LIB_ENTRY) [llength [info commands MOM_tap_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_float_LIB {} {

  LIB_CYCLE_set

}
# <Internal Documentation>
# MOM_tap_float
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float_move_LIB {} {

  set commandcheck(MOM_tap_float_move_LIB_ENTRY) [llength [info commands MOM_tap_float_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_deep_LIB {} {
  global mom_cycle_step1

  LIB_CYCLE_set

  if {![info exists mom_cycle_step1] || [EQ_is_zero $mom_cycle_step1]} {
    LIB_SPF_add_warning "Step value of Tap Deep cycle cannot be zero!"
  }
}
# <Internal Documentation>
# MOM_tap_deep
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep_move_LIB {} {

  set commandcheck(MOM_tap_deep_move_LIB_ENTRY) [llength [info commands MOM_tap_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_break_chip_LIB {} {
  global mom_cycle_step1

  LIB_CYCLE_set

  if {![info exists mom_cycle_step1] || [EQ_is_zero $mom_cycle_step1]} {
    LIB_SPF_add_warning "Step value of Tap Break Chip cycle cannot be zero!"
  }

}
# <Internal Documentation>
# MOM_tap_break_chip
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip_move_LIB {} {

  set commandcheck(MOM_tap_break_chip_move_LIB_ENTRY) [llength [info commands MOM_tap_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore : output CYCLE85_Bore (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_move_LIB {} {

  set commandcheck(MOM_bore_move_LIB_ENTRY) [llength [info commands MOM_bore_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_dwell_LIB {} {

  LIB_CYCLE_set

}
# <Internal Documentation>
# MOM_bore_dwell : output CYCLE85_Bore_Dwell (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell_move_LIB {} {

  set commandcheck(MOM_bore_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_drag_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_drag : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag_move_LIB {} {

  set commandcheck(MOM_bore_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_no_drag_LIB {} {
  global mom_cycle_orient
  global tool_axis DEG2RAD i_shift_value j_shift_value k_shift_value

  if {![hiset mom_cycle_orient]} {set mom_cycle_orient 0.0]}
  set mom_cycle_orient [expr fmod($mom_cycle_orient,360)]
  if {[EQ_is_lt $mom_cycle_orient 0.0]} {set mom_cycle_orient [expr $mom_cycle_orient + 360.0]}

  set a [expr $mom_cycle_orient * $DEG2RAD]
  switch -- $tool_axis {
      0 {
        set j_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * cos([expr $mom_cycle_orient * $DEG2RAD])]
        set k_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * sin([expr $mom_cycle_orient * $DEG2RAD])]
        MOM_suppress once I_cycle
      }
      1 {
        set i_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * cos([expr $mom_cycle_orient * $DEG2RAD])]
        set k_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * sin([expr $mom_cycle_orient * $DEG2RAD])]
        MOM_suppress once J_cycle
      }
      2 {
        set i_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * cos([expr $mom_cycle_orient * $DEG2RAD])]
        set j_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * sin([expr $mom_cycle_orient * $DEG2RAD])]
        MOM_suppress once K_cycle
      }
  }

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_no_drag : output CYCLE76 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag_move_LIB {} {

  set commandcheck(MOM_bore_no_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_no_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_back_LIB {} {
  global mom_cycle_orient
  global tool_axis DEG2RAD i_shift_value j_shift_value k_shift_value

  if {![hiset mom_cycle_orient]} {set mom_cycle_orient 0.0]}
  set mom_cycle_orient [expr fmod($mom_cycle_orient,360)]
  if {[EQ_is_lt $mom_cycle_orient 0.0]} {set mom_cycle_orient [expr $mom_cycle_orient + 360.0]}

  set a [expr $mom_cycle_orient * $DEG2RAD]
  switch -- $tool_axis {
      0 {
        set j_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * cos([expr $mom_cycle_orient * $DEG2RAD])]
        set k_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * sin([expr $mom_cycle_orient * $DEG2RAD])]
        MOM_suppress once I_cycle
      }
      1 {
        set i_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * cos([expr $mom_cycle_orient * $DEG2RAD])]
        set k_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * sin([expr $mom_cycle_orient * $DEG2RAD])]
        MOM_suppress once J_cycle
      }
      2 {
        set i_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * cos([expr $mom_cycle_orient * $DEG2RAD])]
        set j_shift_value [expr [CONF_CTRL_drill default_cycle_shift_amount] * sin([expr $mom_cycle_orient * $DEG2RAD])]
        MOM_suppress once K_cycle
      }
  }

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_back : output CYCLE87 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back_move_LIB {} {

  set commandcheck(MOM_bore_back_move_LIB_ENTRY) [llength [info commands MOM_bore_back_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual : output CYCLE88 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_move_LIB {} {

  set commandcheck(MOM_bore_manual_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual_dwell : output CYCLE88 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________

proc MOM_bore_manual_dwell_move_LIB {} {

  set commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_text_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text_move_LIB {} {

  set commandcheck(MOM_drill_text_move_LIB_ENTRY) [llength [info commands MOM_drill_text_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_thread_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_move_LIB {} {

  set commandcheck(MOM_thread_move_LIB_ENTRY) [llength [info commands MOM_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# MOM_thread_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_off_LIB {} {

  global mom_machine_mode

  set commandcheck(MOM_cycle_off_LIB_ENTRY) [llength [info commands MOM_cycle_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer CYCLE_OFF
  LIB_GE_command_buffer {
    if {$mom_machine_mode == "TURN"} {
      MOM_do_template cycle_off CREATE
    } else {
      MOM_do_template cycle_off
    }
  } @OFF
  LIB_GE_command_buffer {MOM_do_template cycle_init CREATE} @INIT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CYCLE_set {} {

  global initial_cycle_pos mom_prev_pos

  if {![hiset initial_cycle_pos]} {VMOV 3 mom_prev_pos initial_cycle_pos}

  LIB_GE_command_buffer CYCLE_SET_start
  LIB_GE_command_buffer {
  global mom_cycle_feed_rate mom_cycle_feed_rate_mode mom_cycle_feed_rate_per_rev mom_spindle_rpm
    if {[string match *PR* [string toupper $mom_cycle_feed_rate_mode]]} {
      set mom_cycle_feed_rate [expr $mom_cycle_feed_rate_per_rev * $mom_spindle_rpm]
    }
  } @CYCLE_FEED
  LIB_GE_command_buffer_output
  LIB_CYCLE_dwell_set
}
# <Internal Documentation>
# Controls the drilling cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_set {} {
  global mom_tool_pitch mom_cycle_feed_rate_per_rev
  global mom_cycle_thread_pitch
  global mom_cycle_thread_right_handed
  global mom_spindle_direction
  global mom_spindle_rpm mom_spindle_speed
  global mom_retract_spindle
  global mom_path_name
  global feed_mode
  global feed

  if {[info exists mom_tool_pitch]} {
    set pitch $mom_tool_pitch
  } elseif {[info exists mom_cycle_thread_pitch]} {
    set pitch $mom_cycle_thread_pitch
  } else {
    if {[CONF_CTRL_drill tool_pitch_used] == 0} {
      set pitch $mom_cycle_feed_rate_per_rev
    } else {
      set pitch 0
      LIB_GE_abort_message "INS->$mom_path_name<- : No pitch defined on the tool." "Please use Tap tool."
    }
  }

  if {![info exists mom_spindle_speed] || [EQ_is_zero $mom_spindle_speed]} {
    LIB_GE_abort_message "INS->$mom_path_name<- : spindle speed is 0." "Please verify."
  }

  if {[string match "*PR" [CONF_CTRL_drill cycle_tap_feed_type]]} {
    set feed $pitch
    MOM_set_address_format F Feed_[CONF_CTRL_drill cycle_tap_feed_type]
    #<lili 05-20-2019> In this case, G95 should be outputed, reset feed_mode.
    set feed_mode [CONF_CTRL_drill cycle_tap_feed_type]
  } elseif {[string match "*PR" $feed_mode]} {
    set feed $pitch
  } else {
    set feed [expr $pitch*$mom_spindle_rpm]
  }
}
# <Internal Documentation>
# Controls the tapping cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move {} {

  global mom_cycle_feed_to mom_cycle_retract_to_pos mom_cycle_rapid_to_pos
  global mom_sys_cycle_tap_code mom_sys_cycle_tap_rigid_code mom_spindle_direction
  global mom_motion_event
  global cycle_peck_size lib_parameter cycle_factor
  global lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos lib_flag tool_axis
  global mom_namespace_name

  LIB_GE_command_buffer START_CYCLE
  LIB_GE_command_buffer {LIB_CYCLE_move_osp_type} @MOVE
  LIB_GE_command_buffer {LIB_SPINDLE_start cycle} @CYCLE
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer PREPOS_IN_CYCLE
  LIB_GE_command_buffer {
  if {$lib_flag(tool_path_motion) == 1} {
    switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z} {G_adjust X H}" "cycle_move" FORCE "G_adjust X Y Z H"}
        1 {LIB_SPF_decompose_block_template "{X Z} {G_adjust Y H}" "cycle_move" FORCE "G_adjust X Y Z H"}
        2 {LIB_SPF_decompose_block_template "{X Y} {G_adjust Z H}" "cycle_move" FORCE "G_adjust X Y Z H"}
    }
  }
  } @PREPOS_DEFAULT
  LIB_GE_command_buffer {MOM_do_template cycle_init CREATE} @INIT
  LIB_GE_command_buffer_output
  set lib_flag(tool_path_motion) 2

  switch -- $tool_axis {
    0 {set cycle_factor [LIB_SPF_check_x_factor MILL]}
    1 {set cycle_factor 1}
    2 {set cycle_factor 1}
  }

  LIB_SPF_retract_to_pos

  set cycle_peck_size [expr ($mom_cycle_feed_to*(-1.0))]     ;# single peck size most cycles

  LIB_WRITE_coolant on

  if {[info exists lib_parameter(special_cycle,name)] && $lib_parameter(special_cycle,name) != ""} {
    LIB_CYCLE_move_special_$lib_parameter(special_cycle,name)
  } else {
    switch -- $mom_motion_event {
      "drill_move"    {
              LIB_GE_command_buffer DRILL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_dwell_move"  {
              LIB_GE_command_buffer DRILL_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_deep_move"   {
              LIB_GE_command_buffer DRILL_DEEP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_deep} @OUTPUT
              LIB_GE_command_buffer_output

            }
      "drill_break_chip_move" {
              LIB_GE_command_buffer DRILL_BREAK_CHIP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_break_chip} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_move"    {
              LIB_GE_command_buffer TAP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_float_move"  {
              LIB_GE_command_buffer TAP_FLOAT_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_deep_move"   {
              LIB_GE_command_buffer TAP_DEEP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_break_chip_move"   {
              LIB_GE_command_buffer TAP_BREAK_CHIP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_move"     {
              LIB_GE_command_buffer BORE_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_dwell_move"   {
              LIB_GE_command_buffer BORE_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_drag_move"  {
              LIB_GE_command_buffer BORE_DRAG_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_drag} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_no_drag_move"   {
              LIB_GE_command_buffer BORE_NO_DRAG_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_no_drag} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_back_move"  {
              LIB_GE_command_buffer BORE_BACK_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_back} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_manual_move"  {
              LIB_GE_command_buffer BORE_MANUAL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_manual} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_manual_dwell_move" {
              LIB_GE_command_buffer BORE_MANUAL_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_manual_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_text_move"   {# nothing for the moment}
      "thread_move"     {# nothing for the moment}
    }
  }

  LIB_CTRL_cycle_retract_handling

  if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
    namespace eval $::mom_namespace_name {
      array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
      array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
    }
  } else {
    array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
    array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
  }

}
# <Internal Documentation>
# Controls the drilling move setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_retract_handling {} {
  global mom_cycle_retract_to_pos mom_cycle_rapid_to_pos tool_axis
  global mom_cycle_retract_to mom_cycle_rapid_to mom_pos
  global mom_cycle_retract_mode mom_namespace_name

  if {![EQ_is_equal $mom_cycle_retract_to $mom_cycle_rapid_to] && $mom_cycle_retract_mode == "MANUAL"} {
    if {[info exists mom_namespace_name] && [namespace exists $mom_namespace_name]} {
      # Should set mom_pos or mom_mcs_goto in specify namespace mom_namespace_name if exist
      uplevel #0 {
        namespace eval $::mom_namespace_name {
          set tmp_posz $mom_pos($tool_axis)
          set tmp_mcs_gotoz $mom_mcs_goto($tool_axis)
          set mom_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
          set mom_mcs_goto($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
          LIB_GE_command_buffer CYCLE_RETRACT
          LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
          LIB_GE_command_buffer_output
          set mom_pos($tool_axis) $tmp_posz
          set mom_mcs_goto($tool_axis) $tmp_mcs_gotoz
        }
      }
    } else {
    set tmpz $mom_pos($tool_axis)
    set mom_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
    LIB_GE_command_buffer CYCLE_RETRACT
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output
    set mom_pos($tool_axis) $tmpz
    }
    MOM_force once R_cycle
  }
}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CHECK_adjust_register {} {

  global mom_path_name mom_tool_adjust_register mom_tool_length_adjust_register mom_tool_number
  global lib_flag

  LIB_GE_command_buffer CHECK_adjust_register
  LIB_GE_command_buffer {
    if {$mom_tool_length_adjust_register == 0} {set mom_tool_adjust_register $mom_tool_number}

    if {[CONF_CTRL_tool max_h_number] != 0 && $mom_tool_length_adjust_register > [CONF_CTRL_tool max_h_number]} {
      if {![hiset lib_flag(error_adjust_register,$mom_path_name)]} {
        set error [LIB_SPF_add_warning "Adjust register $mom_tool_length_adjust_register not possible ([CONF_CTRL_tool max_h_number] max) ... Adjust register $mom_tool_number (same as tool_number) is used"]
        set lib_flag(error_adjust_register,$mom_path_name) 1
      }
      set mom_tool_adjust_register $mom_tool_number
    }
  } @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Check for adjust register
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_tool_number {} {

  global mom_tool_number mom_tool_name

  if {[CONF_CTRL_tool max_tool_number] != 0 && $mom_tool_number > [CONF_CTRL_tool max_tool_number]} {
    set error [LIB_SPF_add_warning "Maximum tool number allowed : [CONF_CTRL_tool max_tool_number]. Check tool $mom_tool_name"]
  }
}
# <Internal Documentation>
# Check the tool number
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_before_plane {} {

  if {[CONF_OKUMA_CYCLE_CSYS_ROT rotate_before] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis before plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_after_plane {} {

  if {[CONF_OKUMA_CYCLE_CSYS_ROT rotate_after] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis after plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_WRITE_coolant {{option default}} {

  global mom_coolant_mode mom_coolant_status mom_kin_is_turbo_output

  switch -- $option {
    "on"  {
      if {![hiset mom_coolant_mode] || $mom_coolant_mode == ""} {set mom_coolant_mode [CONF_CTRL_coolant coolant_status]}
      if {$mom_coolant_mode == "OFF"} {return}

      LIB_GE_command_buffer COOLNT_on
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_output_before_motion] != 0} {
          MOM_do_template coolant_on
        }
      } @COOLNT_on_std
      LIB_GE_command_buffer_output
    }
    "off" {
      LIB_GE_command_buffer COOLNT_off
      LIB_GE_command_buffer {
        if {[info exists mom_kin_is_turbo_output] && $mom_kin_is_turbo_output == "TRUE" && [MOM_ask_address_value M_coolant] != $::mom_sys_coolant_code(OFF)} {
          MOM_force once M_coolant ; #needs when turbo mode is activated (Bug#669)
        }
        MOM_do_template coolant_off
      } @COOLNT_on_std
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_auto] == 0} {
          set mom_coolant_mode "OFF"
          set mom_coolant_status "OFF"
        }
      } @COOLNT_on_std_2
      LIB_GE_command_buffer_output
    }
  }
}
# <Internal Documentation>
# This procedure is executed to output coolant on or off
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_clamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {return}

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer CLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template clamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fifth_axis] == 1} {

    LIB_GE_command_buffer CLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template clamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called before each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_unclamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}

  if {[CONF_CTRL_clamp fifth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template unclamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template unclamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called after each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_rotate_axis {} {

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer RAPID_ROTARY
  LIB_GE_command_buffer {MOM_do_template rapid_rotary} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_CTRL_clamp_axis

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_nc_header {} {

  global mom_attr_PROGRAMVIEW_PROGRAM_NUMBER
  global mom_output_file_basename lib_nc_header_number
  global lib_selected_group_name mom_dnc_program_name
  global mom_lib_program_name lib_flag

  if {$lib_flag(load_pretreatment)} {
    if {[LIB_PT_get_header_var lib_selected_group_name exists]} {
      set lib_selected_group_name [LIB_PT_get_header_var lib_selected_group_name]
    } else {
      set lib_selected_group_name [LIB_PT_get_header_var mom_oper_program]
    }
  }
  set lib_nc_header_number $mom_output_file_basename
  if {![info exists lib_selected_group_name]} {set lib_selected_group_name ""}

  switch -- [CONF_CTRL_setting header_name] {
    "mom_attr_PROGRAMVIEW_PROGRAM_NUMBER" {
      if { !$lib_flag(load_pretreatment) || ![LIB_PT_get_header_var mom_attr_PROGRAMVIEW_PROGRAM_NUMBER exists] } {
        set lib_nc_header_number "0001"
      } else {
        set lib_nc_header_number [LIB_PT_get_header_var mom_attr_PROGRAMVIEW_PROGRAM_NUMBER]
      }
    }
    "output_file_basename" {set lib_nc_header_number $mom_output_file_basename}
    "selected_group" {
      set lib_nc_header_number $lib_selected_group_name
    }
    "ude_dnc_header" {
      if {[info exists mom_dnc_program_name]} {set lib_nc_header_number $mom_dnc_program_name}
    }
    "ude" {
      if {[info exists mom_lib_program_name]} {set lib_nc_header_number $mom_lib_program_name}
    }
    "ignore" {
                  return 0
    }
                "default" {
      LIB_CONF_do_prop_custom_proc CONF_CTRL_setting header_name "short_template_syntax"
    }
  }
  # Variable lib_nc_header_number is empty that means that mom_output_file_basename is used
  # and you are not in PP
  # for this case selected_group is used -- this is not ""

  if {$lib_nc_header_number == ""} {set lib_nc_header_number $lib_selected_group_name}

  if {![LIB_SPF_is_number $lib_nc_header_number]} {
    LIB_SPF_add_warning "The entry 'INS->$lib_nc_header_number<-' for the header with argument 'INS->[CONF_CTRL_setting header_name]<-' need a number as value. 0001 will be used"
    set lib_nc_header_number 0001
  }

  if {[EQ_is_gt $lib_nc_header_number 9999]} {LIB_SPF_add_warning "Header_number 'INS->$lib_nc_header_number<-' should be < 9999: 9999 will be used"}

  LIB_GE_command_buffer PROG_NUMBER

  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_program
      } @FIRST_LINE

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_MPF
#   Heidenhain  BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O${lib_nc_header_number}
#
#____________________________________________________________________________________________
proc LIB_CTRL_sub_header {} {

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_subprogram
  } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_SPF
#   Heidenhain    BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O1234
#
#____________________________________________________________________________________________
proc LIB_CTRL_set_feed_parameter {} {

  global mom_feed_cut_unit mom_output_unit mom_feed_rate feed
  global mom_cycle_feed_rate mom_cycle_feed_rate_per_rev
  global mom_feed_engage_value mom_feed_cut_value mom_feed_retract_value mom_feed_cycle_value
  global mom_feed_engage_unit mom_feed_cut_unit mom_feed_retract_unit mom_feed_cycle_value
  global mom_operation_type mom_motion_type lib_motion_type_list
  global lib_prev_feed_cut_value lib_flag mom_tool_name mom_kin_is_turbo_output
  global mom_feed_rate_output_mode mom_feed_rate_per_rev
  global lib_prev_feed_engage_value lib_prev_feed_retract_value
  global lib_prev_cycle_definition_mode mom_cycle_definition_mode
  global lib_prev_feed_engage_value lib_prev_feed_retract_value

  set lib_flag(feed_turbo_mode_disable) 0
  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {

    foreach type $lib_motion_type_list {
      set tmp_motion_type [string tolower $type]
      if {[CONF_CTRL_feed exists feed_$tmp_motion_type]} {
        if {[CONF_CTRL_feed feed_$tmp_motion_type] != "NX"} {
          set lib_flag(feed_turbo_mode_disable) 1
          set mom_kin_is_turbo_output "FALSE"
        }
      }
    }
    if {$lib_flag(feed_turbo_mode_disable) == 1} {MOM_reload_kinematics_variable mom_kin_is_turbo_output}

    # check if "drilling" "Thread Milling" "Cylinder Milling" are the previous operation and the current cycle output is different
    # to the previous operation
    if {($mom_operation_type == "Drilling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Thread Milling")} {
      if {![info exists lib_prev_cycle_definition_mode] || $lib_prev_cycle_definition_mode != $mom_cycle_definition_mode } {
        set check_cycle_definition_mode 1
      } else {
        set check_cycle_definition_mode 0
      }
      set lib_prev_cycle_definition_mode $mom_cycle_definition_mode
    } else {
      set check_cycle_definition_mode 0
      set lib_prev_cycle_definition_mode 1
    }
    if {[info level 1] != "MOM_start_of_path" || ($mom_tool_name == [LIB_SPF_get_pretreatment mom_tool_name -1]        && \
      (([info exist lib_prev_feed_cut_value]    && ![EQ_is_equal $mom_feed_cut_value $lib_prev_feed_cut_value])          || \
      ([info exist lib_prev_feed_engage_value]  && ![EQ_is_equal $mom_feed_engage_value $lib_prev_feed_engage_value])    || \
      ([info exist lib_prev_feed_retract_value] && ![EQ_is_equal $mom_feed_retract_value $lib_prev_feed_retract_value])  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Hole Making"                                                  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Point to Point"                                               || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Drilling"))                                                   || \
      $check_cycle_definition_mode == 1} {

      MOM_force once F
      if {[CONF_CTRL_feed feed_engage] != "NX" && [CONF_CTRL_feed feed_engage] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_engage_value/25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_engage_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_engage_value
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_engage_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_engage_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_engage] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Engage Move"])" "output_0" "1"
      }

      if {$mom_operation_type == "Hole Making" || $mom_operation_type == "Point to Point" || ($mom_operation_type == "Drilling" || $mom_operation_type == "Thread Milling" || $mom_operation_type == "Cylinder Milling" && $::mom_cycle_definition_mode == 0)} {
        set mom_feed_rate $mom_feed_cut_value
        set mom_cycle_feed_rate $mom_feed_cut_value
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_cut_value
          set mom_cycle_feed_rate_per_rev $mom_feed_cut_value
          set mom_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
          set mom_cycle_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
        set mom_motion_type "CYCLE"
        LIB_SPF_feedrate_set
        if {[CONF_CTRL_feed feed_cycle] != "NX" && [CONF_CTRL_feed feed_cycle] != "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cycle] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cycle Move"])" "output_0" "1"
        } elseif {[CONF_CTRL_feed feed_cycle] == "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cycle Move"])" "output_0" "1"
        }
      } else {
        set mom_kin_is_turbo_output "FALSE"
        if {[CONF_CTRL_feed feed_cut] != "NX" && [CONF_CTRL_feed feed_cut] != "P_CUT"} {
          if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
            set mom_feed_rate [expr $mom_feed_cut_value/25.4]
          } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
            set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
          } else {
            set mom_feed_rate $mom_feed_cut_value
          }
          if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
            set mom_feed_rate_per_rev $mom_feed_cut_value
          }
          set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
          set mom_motion_type "UNKNOWN"
          LIB_SPF_feedrate_set
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cutting"])" "output_0" "1"
        }
      }

      if {[CONF_CTRL_feed feed_retract] != "NX" && [CONF_CTRL_feed feed_retract] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_retract_value/25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_retract_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_retract_value
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_retract_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_retract_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_retract] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Retract Move"])" "output_0" "1"
      }

      set lib_prev_feed_cut_value $mom_feed_cut_value
      set lib_prev_feed_engage_value $mom_feed_engage_value
      set lib_prev_feed_retract_value $mom_feed_retract_value
    }
  }
}
# <Internal Documentation>
#
# Set the feed parameter if nessesary
# only if property feed_linear is set to 2(parameter)
#
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (F[#21])
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_feed_output {} {

  global mom_motion_type mom_motion_event mom_feed_cut_value mom_feed_cut_unit mom_feed_rate mom_feed_rate_per_rev
  global mom_cycle_feed_rate mom_output_unit feed_mode
  global feed lib_prev_feed lib_prev_feed_percent
  global mom_feed_engage_value mom_feed_engage_unit
  global mom_feed_retract_value mom_feed_retract_unit

  set commandcheck(LIB_CTRL_feed_output_ENTRY) [llength [info commands LIB_CTRL_feed_output_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {
    set tmp_motion_type [string tolower $mom_motion_type]

    if {[CONF_CTRL_feed feed_$tmp_motion_type] == "NX"} {
      if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
        MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
      } else {
        switch -- $feed_mode {
          IPM     -
          MMPM    -
          IPR     -
          MMPR    -
          DPM     -
          FRN     {
            MOM_set_address_format F Feed_${feed_mode}
            }
          INVERSE {MOM_set_address_format F Feed_INV}
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "P_CUT"} {
      if {(![string match "rapid" $tmp_motion_type] && ![string match "traverse" $tmp_motion_type] && ![string match "approach" $tmp_motion_type] \
      && ![string match "departure" $tmp_motion_type]) || $mom_feed_rate != $::mom_kin_rapid_feed_rate} {
        MOM_set_address_format F String
        if {![info exist lib_prev_feed] || (![EQ_is_equal $feed $mom_feed_cut_value] && $feed  != $lib_prev_feed)} {
          if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
            set tmp_feed_rate [expr $mom_feed_rate * 25.4]
            set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
          } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
            set tmp_feed_rate [expr $mom_feed_rate / 25.4]
            set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
          } else {
            set tmp_feed_rate $mom_feed_rate
            set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
          }
          if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
            set tmp_feed_rate $tmp_feed_rate_per_rev
          }
          set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
          set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
          if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
            MOM_force once F
          }
          set feed "\[[CONF_CTRL_feed feed_cut]*$tmp_feed_percent\]"
          set lib_prev_feed_percent $tmp_feed_percent
        } else {
          set feed "\[[CONF_CTRL_feed feed_cut]\]"
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "MAX"} {
      MOM_set_address_format F String
      set feed [CONF_CTRL_feed feed_$tmp_motion_type]
    } else {
      MOM_set_address_format F String
      set tmp_feed $feed
      if {$tmp_motion_type == "cycle"} {
        set mom_cycle_feed_rate "\[[CONF_CTRL_feed feed_$tmp_motion_type]\]"
      }
      set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]\]"
      if {$tmp_motion_type == "cut" && ![EQ_is_equal $mom_feed_rate $mom_feed_cut_value]} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      if {$tmp_motion_type == "engage" && ![EQ_is_equal $mom_feed_rate $mom_feed_engage_value]} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_engage_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      if {$tmp_motion_type == "retract" && ![EQ_is_equal $mom_feed_rate $mom_feed_retract_value]} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_retract_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      set lib_prev_feed $tmp_feed
    }

  } else {
    # use only NX-Values
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Output the feed dependent on the setting
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (FQ21)
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_cut_move_LIB {} {

  set commandcheck(LIB_CTRL_cut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_LIB {} {

  set commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY) [llength [info commands LIB_CTRL_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_engage_move_LIB {} {

  set commandcheck(LIB_CTRL_engage_move_LIB_ENTRY) [llength [info commands LIB_CTRL_engage_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_retract_move_LIB {} {

  set commandcheck(LIB_CTRL_retract_move_LIB_ENTRY) [llength [info commands LIB_CTRL_retract_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_firstcut_move_LIB {} {

  set commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_firstcut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_approach_move_LIB {} {

  set commandcheck(LIB_CTRL_approach_move_LIB_ENTRY) [llength [info commands LIB_CTRL_approach_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_stepover_move_LIB {} {

  set commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY) [llength [info commands LIB_CTRL_stepover_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_departure_move_LIB {} {

  set commandcheck(LIB_CTRL_departure_move_LIB_ENTRY) [llength [info commands LIB_CTRL_departure_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_return_move_LIB {} {

  set commandcheck(LIB_CTRL_return_move_LIB_ENTRY) [llength [info commands LIB_CTRL_return_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_traversal_move_LIB {} {

  set commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY) [llength [info commands LIB_CTRL_traversal_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sidecut_move_LIB {} {

  set commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_sidecut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_from_move_LIB {} {

  set commandcheck(LIB_CTRL_from_move_LIB_ENTRY) [llength [info commands LIB_CTRL_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_default_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_default_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_move_LIB {} {

  set commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cycle_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_lift_move_LIB {} {

  set commandcheck(LIB_CTRL_lift_move_LIB_ENTRY) [llength [info commands LIB_CTRL_lift_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_undefined_move_LIB {} {

  set commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY) [llength [info commands LIB_CTRL_undefined_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_standard_path_between_rotary_motions_checking {{option default}} {

  global mom_out_angle_pos mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global prev_convert_mom_out_angle_pos mom_prev_pos mom_pos

  switch -- $option {
    "pos_to_sim"  {
      # motion POS to SIM

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_prev_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_prev_pos(3) 0
      }

      MOM_reload_variable -a mom_prev_pos

    }
    "pos_to_sim_next" {
      # motion POS to SIM

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_pos(3) 0
      }

      MOM_reload_variable -a mom_pos

    }
    "sim_to_pos" {
      # motion SIM to POS
    }
  }
}
# <Internal Documentation>
#
# Used when [CONF_CTRL_moves standard_path_between_rotary_motions] == 1 for internal tool path
# Set right rotary position when lib_flag(mode_current_status) changes
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_config_millturn {} {

  if {[CONF_SPF_advanced_settings chain_init] != "0"} {
    LIB_CONF_do_prop_custom_proc CONF_SPF_advanced_settings chain_init
  }
}
# <Internal Documentation>
# This procedure is called at each start_of_path and machine_mode events.
# It's implemented for multi chains. Content of [CONF_SPF_advanced_settings chain_init] is executed
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_polar_transmit {{mess "on"}} {
  global mom_motion_event mom_motion_type mom_prev_pos mom_pos mom_machine_mode
  global mom_sys_leader mom_sys_linear_code mom_sys_circle_code
  global polar_mode_status x_factor lib_flag

  if {$mom_machine_mode == "TURN"} {return}

  if {[CONF_CTRL_moves polar_transmit] == "ON"} {
    if {$mess == "on"} {
      if {$lib_flag(first_transmit_move) == 0} {
        set polar_mode_status "ON"
      }
    } elseif {$mess == "start" && $polar_mode_status == "ON"} {
      LIB_GE_command_buffer POLAR_MODE
      LIB_GE_command_buffer {
        set mom_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        set mom_prev_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        MOM_reload_variable -a mom_prev_pos
        MOM_reload_variable -a mom_pos

        if {[CONF_CTRL_moves prepos_before_transmit] == "5th" || [CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
          if {$lib_flag(polar_rotary_axis) == 0} {
            set lib_flag(save_clamp_fourth_axis_setting) [CONF_CTRL_clamp fourth_axis]
            if {[CONF_CTRL_clamp fourth_axis] == 1} {
              MOM_do_template unclamp_fourth_axis
              MOM_do_template fourth_axis_rotate_move
              CONF_CTRL_clamp set fourth_axis 0
            } else {
              MOM_do_template fourth_axis_rotate_move
            }
          } else {
            set lib_flag(save_clamp_fifth_axis_setting) [CONF_CTRL_clamp fifth_axis]
            if {[CONF_CTRL_clamp fifth_axis] == 1} {
              MOM_do_template unclamp_fifth_axis
              MOM_do_template fifth_axis_rotate_move
              CONF_CTRL_clamp set fifth_axis 0
            } else {
              MOM_do_template fifth_axis_rotate_move
            }
          }
          if {[CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
            LIB_SPF_decompose_block_template "{Z} {X}" prepos_transmit FORCE [join "{Z} {X}"]
          }
        } elseif {[CONF_CTRL_moves prepos_before_transmit] != ""} {
          LIB_CONF_do_prop_custom_proc CONF_CTRL_moves prepos_before_transmit "short_template_syntax"
        }

        set mom_sys_leader(Y) "C"
        set x_factor 1
        set mom_sys_linear_code 101
        if {$lib_flag(polar_tool_axis) == 0} {
          set mom_sys_circle_code(CLW) 132
          set mom_sys_circle_code(CCLW) 133
        } elseif {$lib_flag(polar_tool_axis) == 2} {
          set mom_sys_circle_code(CLW) 102
          set mom_sys_circle_code(CCLW) 103
        }
      } @OUTPUT_ROTARY_AXIS

      LIB_GE_command_buffer {
        MOM_do_template polar_mode
      } @OUTPUT
      LIB_GE_command_buffer_output

      set lib_flag(first_transmit_move) 1
      if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_enable_address Y}
    }
  }

  if {$mess == "off" && [info exists lib_flag(first_transmit_move)] && $lib_flag(first_transmit_move) == 1} {
    set polar_mode_status "OFF"

    LIB_GE_command_buffer TRAFOFF
    LIB_GE_command_buffer {
      MOM_do_template polar_mode

      set mom_sys_leader(Y) "Y"
      if {$lib_flag(polar_rotary_axis) == 0} {
        if {[info exists lib_flag(save_clamp_fourth_axis_setting)]} {CONF_CTRL_clamp set fourth_axis $lib_flag(save_clamp_fourth_axis_setting)}
      } else {
        if {[info exists lib_flag(save_clamp_fifth_axis_setting)]} {CONF_CTRL_clamp set fifth_axis $lib_flag(save_clamp_fifth_axis_setting)}
      }
      set x_factor [LIB_SPF_check_x_factor MILL]
      set mom_sys_linear_code 1
      set mom_sys_circle_code(CLW) 2
      set mom_sys_circle_code(CCLW) 3
    } @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(first_transmit_move) 0
    if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_disable_address Y}
  }
}
# <Internal Documentation>
# It's used to output polar code with axial mode when [CONF_CTRL_moves polar_transmit] property is set to 1
# This proc is called by LIB_SPF_polar_cart
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread_LIB {} {

  set commandcheck(MOM_lathe_thread_LIB_ENTRY) [llength [info commands MOM_lathe_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_thread_LIB {} {

  set commandcheck(MOM_start_of_thread_LIB_ENTRY) [llength [info commands MOM_start_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_lathe_thread_move_LIB {} {

  global mom_prev_pos mom_pos
  global thread_type

  set commandcheck(MOM_lathe_thread_move_LIB_ENTRY) [llength [info commands MOM_lathe_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[EQ_is_equal $mom_prev_pos(0) $mom_pos(0) 0.001]} {
    # face
    set thread_type 1
  } else {
    # longitudinal
    set thread_type 2
  }
  LIB_GE_command_buffer LATHE_THREAD_MOVE
  LIB_GE_command_buffer {MOM_do_template lathe_thread_move} @OUTPUT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_thread_LIB {} {

  set commandcheck(MOM_end_of_thread_LIB_ENTRY) [llength [info commands MOM_end_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_channel_init {} {

  LIB_GE_command_buffer LIB_CTRL_channel_init
  LIB_GE_command_buffer {MOM_do_template channel_init CREATE} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_program event
#
# Specially useful for multichannels machine to reset addresses at the beginning of for each channel
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sys_leader_home {} {
  #this proc is only here for documentation purposes.
  #the real proc should be created in service layer
}
# <Internal Documentation>
# This function is called from MOM_start_of_path event
#
# Helpful to redefine mom_sys_leader variables overwritten by the original ones with the normal run
# This procedure should be redefined in service layer
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_subop_path_LIB {} {

  set commandcheck(MOM_start_of_subop_path_LIB_ENTRY) [llength [info commands MOM_start_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag mom_move_type mom_tool_adjust_register cur_tool_adjust_register
  global mom_interop_has_tool_change


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_subop_path.
# It can exit tool path and enter transition path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_subop_path_LIB {} {

  set commandcheck(MOM_end_of_subop_path_LIB_ENTRY) [llength [info commands MOM_end_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_transition_path_LIB {} {

  set commandcheck(MOM_start_of_transition_path_LIB_ENTRY) [llength [info commands MOM_start_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag mom_path_name lib_pretreatment tcpm_type
  global mom_interop_has_tool_change mom_interop_has_tool_change_container
  global mom_interop_has_tool_change_position

  set lib_flag(tool_path_motion) 0
  set lib_flag(tcpm_mode) 0
  set lib_flag(tool_change) 0
  set lib_flag(is_first_rotary_point) 0

  # Consider three cases if subop list contains tool change event
  # case1: have tool change event with a given tool change point, skip the first subop rotary_point_vector_move.
  # case2: have tool change event without tool change point, regard the first subop rotary_point_vector_move as default.
  # case3: no defined tool change event, trigger a tool change mom event before subop rotary_point_vector_move.




  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_transition_path_LIB {} {

  set commandcheck(MOM_end_of_transition_path_LIB_ENTRY) [llength [info commands MOM_end_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_machine_axis_move_LIB {} {

  set commandcheck(MOM_machine_axis_move_LIB_ENTRY) [llength [info commands MOM_machine_axis_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_xaxis_status mom_yaxis_status mom_zaxis_status
  global mom_aaxis_status mom_baxis_status mom_caxis_status
  global mom_xaxis_value  mom_yaxis_value  mom_zaxis_value
  global mom_aaxis_value  mom_baxis_value  mom_caxis_value

  if {$mom_xaxis_status == 0} {
    MOM_suppress once X
  }
  if {$mom_yaxis_status == 0} {
    MOM_suppress once Y
  }
  if {$mom_zaxis_status == 0} {
    MOM_suppress once Z
  }
  if {$mom_aaxis_status == 0} {
    MOM_suppress once machine_axis_a
  }
  if {$mom_baxis_status == 0} {
    MOM_suppress once machine_axis_b
  }
  if {$mom_caxis_status == 0} {
    MOM_suppress once machine_axis_c
  }

  LIB_GE_command_buffer MACHINE_AXIS_INIT
  LIB_GE_command_buffer {
    MOM_force once G_return
    MOM_do_template machine_axis_move
    MOM_force once H_fixture_offset
  } @MACHINE_AXIS
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_machine_axis_move.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_set_tcpm_mode {{option "ON"}} {

  global lib_flag lib_kin_4th_axis_point lib_kin_5th_axis_point
  global mom_kin_4th_axis_point mom_kin_5th_axis_point

  if {$option == "ON"} {
    LIB_GE_command_buffer INTEROP_TCPM_INIT
    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_mode] == "G169"} {
        MOM_do_template tool_length_adjust CREATE
        MOM_force once H
      }
    } @TOOL_LENGTH_ADJUST
    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_mode] == "G169"} {
        MOM_do_template set_tcpm_on
      }
    } @INTEROP_ROTARY_SIMULTANEOUS
    LIB_GE_command_buffer_output

    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_mode] == "G43.5" ||\
    ([CONF_CTRL_setting tcpm_mode] == "G43.4" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    set lib_flag(tcpm_mode) 1
  } else {
    LIB_GE_command_buffer INTEROP_RESET
    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_mode] == "G169"} {
        MOM_do_template set_tcpm_off
      }
    } @INTEROP_TRAFOOF
    LIB_GE_command_buffer {
      MOM_do_template tool_length_adjust_off CREATE
    } @ADJUST_OFF
    LIB_GE_command_buffer_output

    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_mode] == "G43.5" ||\
      ([CONF_CTRL_setting tcpm_mode] == "G43.4" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos
    }

    set lib_flag(tcpm_mode) 0
  }
}
# <Internal Documentation>
# This function is used to set tcpm mode status (ON/OFF) in transition path.
#
# <Internal Example>
#____________________________________________________________________________________________

# ctrl_okuma_osp_base_l.tcl

proc LIB_CTRL_version_mom_sys {} {
  global mom_sys_seqnum_max

  switch -- [CONF_OKUMA_controller okuma_control_version] {
    "OSP-100" {
    }
    "OSP-200" {
      set mom_sys_seqnum_max 99999
    }
    "OSP-300"  {
    }
  }
}
# <Internal Documentation>
# It used to update mom_sys variables depending on [CONF_OKUMA_controller okuma_control_version] and [CONF_OKUMA_controller okuma_control_system] properties
# This proc is called by LIB_SPF_default_initial_setting "default"
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag mom_next_tool_status lib_prev_tool_name

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        MOM_do_template tool_select

      } @TOOL_SELECT_AUTO

      LIB_GE_command_buffer {
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }
  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {![info exists mom_cutcom_type]} {set mom_cutcom_type 0}
  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {

  global mom_arc_angle
  global tool_axis calrg lib_flag calrg

  switch -- $tool_axis {
    0 {MOM_force once J K; MOM_suppress once I}
    1 {MOM_force once I K; MOM_suppress once J}
    2 {MOM_force once I J; MOM_suppress once K}
  }

  if {[info level 1] == "MOM_circular_move"} {
    if {[CONF_CTRL_moves always_center_for_circle] == 1 && $lib_flag(first_transmit_move) == 0} {
      MOM_suppress once R
    } else {
      catch {unset calrg}
      if {[EQ_is_ge $mom_arc_angle 180.0]} {set calrg "CALRG"}
      MOM_suppress once I J K
      MOM_force once R
    }
  } else {
    # MOM_helix_move
    MOM_suppress once R
  }
}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_millturn_osp_type {} {

}
# <Internal Documentation>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move_osp_type {} {

  global tool_axis mom_sys_leader

  if {$tool_axis == 0} {
    set mom_sys_leader(K_cycle) "I"
  } else {
    set mom_sys_leader(K_cycle) "K"
  }
}
# <Internal Documentation>
#
# <Internal Example>
#
#____________________________________________________________________________________________

# ctrl_okuma_osp_base_m.tcl

proc LIB_CTRL_version_mom_sys {} {
  global mom_sys_seqnum_max

  switch -- [CONF_OKUMA_controller okuma_control_version] {
    "OSP-100" {
    }
    "OSP-200" {
      set mom_sys_seqnum_max 99999
    }
    "OSP-300"  {
    }
  }
}
# <Internal Documentation>
# It used to update mom_sys variables depending on [CONF_OKUMA_controller okuma_control_version] and [CONF_OKUMA_controller okuma_control_system] properties
# This proc is called by LIB_SPF_default_initial_setting "default"
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag mom_next_tool_status lib_prev_tool_name

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }

  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {![info exists mom_cutcom_type]} {set mom_cutcom_type 0}
  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {

  global lib_arc_axis calrg mom_arc_radius
  global mom_kin_helical_arc_output_mode mom_motion_event

  if {[string match $mom_kin_helical_arc_output_mode "END_POINT"] && [string match $mom_motion_event "helix_move"]} {
    # if all of I, J and K are specified, the arc will be regarded as 3-D arc.
  } else {
    switch -- $lib_arc_axis {
      0 {MOM_suppress once I}
      1 {MOM_suppress once J}
      2 {MOM_suppress once K}
    }
  }

  switch -- $lib_arc_axis {
    0 {MOM_force once Y Z J K}
    1 {MOM_force once X Z I K}
    2 {MOM_force once X Y I J}
  }

  LIB_SPF_check_arc_radius

  if {[info level -1] == "MOM_helix_move_LIB"} {
    if {[CONF_CTRL_moves always_center_for_circle] != 1 && ![EQ_is_equal [expr fmod($::mom_arc_angle,360)] 360 0.1] && ![EQ_is_equal [expr fmod($::mom_arc_angle,360)] 180 0.1]} {
      MOM_suppress once I J K
      MOM_force once X Y Z R
      if {[expr fmod($::mom_arc_angle,360)] > 180} {
        set mom_arc_radius [expr abs($mom_arc_radius) * -1]
      } else {
        set mom_arc_radius [expr abs($mom_arc_radius) * +1]
      }

    } else {
      MOM_suppress once R
      MOM_force once X Y Z
    }
  } else {
    if {[CONF_CTRL_moves always_center_for_circle] != 1} {
      set mom_arc_radius [expr abs($mom_arc_radius)]

      if {[CONF_CTRL_feed feed_linear] == 2} {
        set ::feed $::mom_feedrate
        LIB_CTRL_feed_output
      }

      MOM_suppress once I J K

# OSP-P300L (need to verified)
#if {[EQ_is_ge $mom_arc_angle 180.0]} {set calrg "CALRG"}

      # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
      if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

        global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
        global mom_namespace_name mom_output_pos_type
        if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
          if {$mom_namespace_name == "::"} {
            set namespace ::
          } else {
            set namespace ::LOCAL_CSYS::
          }
          if {$mom_output_pos_type == "mom_pos"} {
            VMOV 3 ${namespace}mom_prev_pos prev_pos
            VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
          } else {
            VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
            VMOV 3 ${namespace}mom_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
          }
          VMOV 3 ${namespace}$mom_output_pos_type save_pos
        } else {
          set namespace ::
          set mom_output_pos_type mom_pos
          VMOV 3 mom_prev_pos prev_pos
          VMOV 3 mom_pos_arc_center pos_arc_center
          VMOV 3 mom_pos_arc_axis pos_arc_axis
          VMOV 3 mom_pos save_pos
        }
        VEC3_sub prev_pos pos_arc_center tmp_vec
        VEC3_unitize tmp_vec tmp_vec1
        VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
        VEC3_scale mom_arc_radius tmp_vec tmp_vec1
        VEC3_add pos_arc_center tmp_vec1 tmp_vec
        VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

        MOM_do_template [CONF_CTRL_moves circular_template]
        MOM_suppress once I J K
        VMOV 3 save_pos  ${namespace}$mom_output_pos_type
        set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]

        switch -- $::lib_arc_axis {
          0 {
            MOM_force once Y Z
          }
          1 {
            MOM_force once X Z
          }
          2 {
            MOM_force once X Y
          }
        }
      }

      if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
        LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
      }

      if {[EQ_is_gt $::mom_arc_angle 180.0]} {
        set mom_arc_radius [expr -1.0*$mom_arc_radius]
      }
    } else {
      MOM_suppress once R
    }

  }

}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_millturn_osp_type {} {

}
# <Internal Documentation>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move_osp_type {} {

}
# <Internal Documentation>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_init {} {

  global mom_sys_csys_rot_code
  global lib_flag lib_parameter lib_sav_kin_machine_type
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3 lib_coord_ang_4

  # In new local csys mode, enter local namespace and switch output mode before plane init
  LIB_GE_command_buffer LOCAL_CSYS_INIT
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_set}} @LOCAL_POS_SET
  LIB_GE_command_buffer_output

  LIB_CTRL_unclamp_axis

  set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 1
  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_CSYS_ROT" {
      LIB_rotate_axis_before_plane
      if {[CONF_CTRL_origin use_local] == 1} {
        set lib_parameter(csys_rot,_X0) $lib_coord_ref_X; set lib_parameter(csys_rot,_Y0) $lib_coord_ref_Y; set lib_parameter(csys_rot,_Z0) $lib_coord_ref_Z
      } else {
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.
      }
      set lib_parameter(csys_rot,retract) 1
      MOM_disable_address fourth_axis fifth_axis
      MOM_force once X Y Z P_slope R_slope P_slope2
      switch -- [CONF_OKUMA_controller okuma_control_version] {
                  "OSP-100" -
                  "OSP-200" {
                      MOM_do_template set_csys_on
                      MOM_force once G_csys_rot
                      MOM_do_template set_csys_on_2
                      MOM_force once G_csys_rot
                      MOM_do_template set_csys_on_3
                      MOM_force once X Y Z
                  }
                  "OSP-300"  {
                      MOM_do_template set_csys_p300
                      MOM_force once G_csys_rot
                      MOM_do_template set_csys_on_p300
                      MOM_force once G_csys_rot
                  }
                }
    }
    default {
      if {[info command [CONF_CTRL_setting plane_output]] == [CONF_CTRL_setting plane_output]} {
        [CONF_CTRL_setting plane_output] init
      } else {
        LIB_GE_abort_message "INS->LIB_CSYS_plane_output_init<- wrong parameter" "Please check INS->lib_parameter(plane_output) = [CONF_CTRL_setting plane_output]<-"
      }
    }
  }

  LIB_rotate_axis_after_plane

  LIB_CTRL_clamp_axis

  set lib_flag(mode_current_status) "pos"
}
# <Internal Documentation>
# output the plane
#
# lib_parameter(plane_output)
#           == "CYCLE_CSYS_ROT"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_reset {} {


  global mom_sys_csys_rot_code
  global lib_flag lib_sav_kin_machine_type

  #OUT [LIB_SPF_csys_examine_local] mom_tool_axis(2)
  if {$lib_flag(mode_current_status) == "std"} {return}

  LIB_local_origin_reset

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer LOCAL_CSYS_RESET
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_reset}} @LOCAL_POS_RESET
  LIB_GE_command_buffer_output

  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_CSYS_ROT" {
      MOM_do_template tool_length_adjust_off
      switch -- [CONF_OKUMA_controller okuma_control_version] {
        "OSP-100" -
        "OSP-200" {
          MOM_do_template set_csys_off
        }
        "OSP-300" {
          MOM_do_template set_csys_off_p300
        }
      }
    }
    default {
      [CONF_CTRL_setting plane_output] reset
    }
  }
  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis
  } else {
    MOM_enable_address fourth_axis fifth_axis
  }
  set lib_flag(mode_current_status) "std"

}
# <Internal Documentation>
# reset plane
#
# lib_parameter(plane_output)
#           == "CYCLE_CSYS_ROT"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_local_origin_call {} {

  global mom_origin mom_tool_axis mom_csys_matrix mom_sys_csys_rot_code
  global lib_flag
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z

  if {[LIB_SPF_csys_examine_local] == "default" && [EQ_is_equal $mom_tool_axis(2) 1.0]} {
    set mom_origin(0) 0.0
    set mom_origin(1) 0.0
    set mom_origin(2) 0.0
  }

  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_CSYS_ROT" {
      if {$lib_flag(local_namespace_output)} {
        LIB_SPF_local_csys_rotation "ZXZ" "euler"
      } else {
      LIB_SPF_csys_3D_rotation "ZXZ" "euler"
      }
    }
  }
  set mom_origin(0) $lib_coord_ref_X
  set mom_origin(1) $lib_coord_ref_Y
  set mom_origin(2) $lib_coord_ref_Z

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 0 && [CONF_CTRL_setting plane_output] != "CYCLE_CSYS_ROT"} {
    #offset
#   MOM_force once X Y Z
#   MOM_do_template frame_trans ;# mom_origin(0)
    # not yet implemented
    MOM_force once X Y Z
    set lib_flag(local_origin_activated) 1
  }
}
# <Internal Documentation>
# Output the local origin call
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_KINEMATICS_current_setting_ENTRY {option} {
  global mom_machine_mode

  switch -- $option {
    "start" {
      if {$mom_machine_mode != "MILL"} {LIB_GE_abort_message "Operation type incompatible with this controller (OSP_xxxM" "Please verify"}
    }
    "end" {
    }
  }
}
# <Internal Documentation>
# This procedure is executed with LIB_SPF_KINEMATICS_current_setting
#
# <Internal Example>
#
#____________________________________________________________________________________________

# ctrl_okuma_osp_base_s.tcl

proc LIB_CTRL_version_mom_sys {} {
  global mom_sys_seqnum_max

  switch -- [CONF_OKUMA_controller okuma_control_version] {
    "OSP-100" {
    }
    "OSP-200" {
      set mom_sys_seqnum_max 99999
    }
    "OSP-300"  {
    }
  }
}
# <Internal Documentation>
# It used to update mom_sys variables depending on [CONF_OKUMA_controller okuma_control_version] and [CONF_OKUMA_controller okuma_control_system] properties
# This proc is called by LIB_SPF_default_initial_setting "default"
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type mom_machine_mode
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag mom_next_tool_status lib_prev_tool_name b_angle_pos

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        MOM_do_template tool_select

      } @TOOL_SELECT_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer {

        if {$mom_machine_mode == "MILL"} {
          set b_angle_pos [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 0]
        } else {
          set b_angle_pos 0.0
        }
        MOM_do_template tl_output

      } @TL_AUTO

      LIB_GE_command_buffer_output
    }
  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {![info exists mom_cutcom_type]} {set mom_cutcom_type 0}
  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {

  global mom_arc_angle
  global tool_axis calrg lib_flag calrg

  switch -- $tool_axis {
    0 {MOM_force once J K; MOM_suppress once I}
    1 {MOM_force once I K; MOM_suppress once J}
    2 {MOM_force once I J; MOM_suppress once K}
  }

  if {[info level 1] == "MOM_circular_move"} {
    if {[CONF_CTRL_moves always_center_for_circle] == 1 && $lib_flag(first_transmit_move) == 0} {
      MOM_suppress once R
    } else {
      catch {unset calrg}
      if {[EQ_is_ge $mom_arc_angle 180.0]} {set calrg "CALRG"}
      MOM_suppress once I J K
      MOM_force once R
    }
  } else {
    # MOM_helix_move
    MOM_suppress once R
  }
}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_millturn_osp_type {} {

  global mom_machine_mode mom_sys_leader

  if {$mom_machine_mode == "TURN"} {
    set mom_sys_leader(S) "S"
  } else {
    set mom_sys_leader(S) "SB="
  }

}
# <Internal Documentation>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move_osp_type {} {

  global tool_axis mom_sys_leader

  if {$tool_axis == 0} {
    set mom_sys_leader(K_cycle) "I"
  } else {
    set mom_sys_leader(K_cycle) "K"
  }
}
# <Internal Documentation>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_init {} {

  global mom_sys_csys_rot_code
  global lib_flag lib_parameter lib_sav_kin_machine_type
  global lib_coord_main_X lib_coord_main_Y lib_coord_main_Z
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3 lib_coord_ang_4 b_angle_pos DEG2RAD

  # In new local csys mode, enter local namespace and switch output mode before plane init
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_local_pos_set
  }
  LIB_CTRL_unclamp_axis

  set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 1
  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_CSYS_ROT" {
      LIB_rotate_axis_before_plane

      switch -- [CONF_CTRL_setting plane_output_rot_shift_offset] {
        "X" {
          array set X "0 1.0 1 0.0 2 0.0"
          set P(0) $lib_coord_main_X; set P(1) $lib_coord_main_Y; set P(2) $lib_coord_main_Z
          VEC3_rotate_arbitary_axis X [expr $lib_coord_ang_1 * -1 * $DEG2RAD] P P2

          set lib_parameter(csys_trans,_X0) $P2(0); set lib_parameter(csys_trans,_Y0) $P2(1); set lib_parameter(csys_trans,_Z0) $P2(2)
        }
        "Y" {
          array set Y "0 0.0 1 1.0 2 0.0"
          set P(0) $lib_coord_main_X; set P(1) $lib_coord_main_Y; set P(2) $lib_coord_main_Z
          VEC3_rotate_arbitary_axis Y [expr $lib_coord_ang_1 * -1 * $DEG2RAD] P P2

          set lib_parameter(csys_trans,_X0) $P2(0); set lib_parameter(csys_trans,_Y0) $P2(1); set lib_parameter(csys_trans,_Z0) $P2(2)
        }
        "Z" {
          array set Z "0 0.0 1 0.0 2 1.0"
          set P(0) $lib_coord_main_X; set P(1) $lib_coord_main_Y; set P(2) $lib_coord_main_Z
          VEC3_rotate_arbitary_axis Z [expr $lib_coord_ang_1 * -1 * $DEG2RAD] P P2

          set lib_parameter(csys_trans,_X0) $P2(0); set lib_parameter(csys_trans,_Y0) $P2(1); set lib_parameter(csys_trans,_Z0) $P2(2)
        }
        "default" {
          set lib_parameter(csys_trans,_X0) $lib_coord_main_X; set lib_parameter(csys_trans,_Y0) $lib_coord_main_Y; set lib_parameter(csys_trans,_Z0) $lib_coord_main_Z
        }
      }

      set lib_parameter(csys_rot,retract) 1
      MOM_do_template zero_point_shift_on

      set b_angle_pos $lib_coord_ang_2
      MOM_do_template set_csys_on
      MOM_disable_address fourth_axis

      MOM_force once X Y Z
    }
    default {
      if {[info command [CONF_CTRL_setting plane_output]] == [CONF_CTRL_setting plane_output]} {
        [CONF_CTRL_setting plane_output] init
      } else {
        LIB_GE_abort_message "INS->LIB_CSYS_plane_output_init<- wrong parameter" "Please check INS->lib_parameter(plane_output) = [CONF_CTRL_setting plane_output]<-"
      }
    }
  }

  LIB_rotate_axis_after_plane

  LIB_CTRL_clamp_axis

  set lib_flag(mode_current_status) "pos"
}
# <Internal Documentation>
# output the plane
#
# lib_parameter(plane_output)
#           == "CYCLE_CSYS_ROT"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_reset {} {

  global mom_sys_csys_rot_code
  global lib_flag lib_sav_kin_machine_type

  #OUT [LIB_SPF_csys_examine_local] mom_tool_axis(2)
  if {$lib_flag(mode_current_status) == "std"} {return}

  LIB_local_origin_reset

  LIB_CTRL_unclamp_axis

  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_CSYS_ROT" {
      MOM_do_template tool_length_adjust_off
      MOM_do_template zero_point_shift_off
      MOM_do_template set_csys_off
      if {[llength [info commands LIB_SPF_local_pos_reset]]} {LIB_SPF_local_pos_reset}
    }
    default {
      [CONF_CTRL_setting plane_output] reset
    }
  }
  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis
  } else {
    MOM_enable_address fourth_axis
  }
  set lib_flag(mode_current_status) "std"
# MOM_force once fourth_axis fifth_axis
}
# <Internal Documentation>
# reset plane
#
# lib_parameter(plane_output)
#           == "CYCLE_CSYS_ROT"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_local_origin_call {} {

  global mom_origin mom_tool_axis mom_csys_matrix mom_sys_csys_rot_code
  global lib_flag
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z

  if {[LIB_SPF_csys_examine_local] == "default" && [EQ_is_equal $mom_tool_axis(2) 1.0]} {
    set mom_origin(0) 0.0
    set mom_origin(1) 0.0
    set mom_origin(2) 0.0
  }

  switch -- [CONF_CTRL_setting plane_output] {
    "CYCLE_CSYS_ROT" {
      LIB_SPF_csys_3D_rotation "ZYX"
    }
  }
  set mom_origin(0) $lib_coord_ref_X
  set mom_origin(1) $lib_coord_ref_Y
  set mom_origin(2) $lib_coord_ref_Z

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 0 && [CONF_CTRL_setting plane_output] != "CYCLE_CSYS_ROT"} {
    #offset
#   MOM_force once X Y Z
#   MOM_do_template frame_trans ;# mom_origin(0)
    # not yet implemented
    MOM_force once X Y Z
    set lib_flag(local_origin_activated) 1
  }
}
# <Internal Documentation>
# Output the local origin call
#
# <Internal Example>
#
#____________________________________________________________________________________________

# machine_ootb_millturn_okuma_osp.tcl

proc initialize_millturn { } {
uplevel #0 {
set machine_mode "MILL_TURN"
set lib_machine_mode MILL_TURN

}

# machine_ootb_turn_okuma_osp.tcl

proc initialize_turn { } {
uplevel #0 {
set machine_mode "TURN"
set mom_kin_machine_type "2_axis_lathe"
}

# oem_ootb_okuma_osp.tcl

proc OOTB_reset_rotary_to_zero {} {
#-------------------------------------------------------------
   LIB_SPF_reset_motions_to_zero "rot"
}

# template_service_okuma_osp.tcl

proc postcon_initialize_sys_service {} {
uplevel #0 {
# ########## SYSTEM VARIABLE DECLARATIONS ##############
# set mom_sys_cir_vector "Vector - Arc Start to Center"
# set mom_sys_helix_pitch_type "rise_revolution"
# set mom_sys_zero "0"
# set mom_sys_opskip_block_leader "/"
# set mom_sys_seqnum_start "1"
# set mom_sys_seqnum_incr "1"
# set mom_sys_seqnum_freq "1"
# set mom_sys_seqnum_max "9999"
# set mom_sys_lathe_x_factor "1"
# set mom_sys_lathe_y_factor "1"
# set mom_sys_lathe_z_factor "1"
# set mom_sys_lathe_i_factor "1"
# set mom_sys_lathe_j_factor "1"
# set mom_sys_lathe_k_factor "1"
# set mom_sys_leader(N) "N"
# set mom_sys_trailer(X) ""
# set mom_sys_trailer(Y) ""
# set mom_sys_trailer(Z) ""
# set mom_sys_trailer(fourth_axis) ""
# set mom_sys_trailer(fifth_axis) ""
# set mom_sys_trailer(sixth_axis) ""
# set mom_sys_cycle_feed_mode "MMPM"
# set mom_sys_feed_param(IPM,format) "Feed_IPM"
# set mom_sys_feed_param(IPR,format) "Feed_IPR"
# set mom_sys_feed_param(FRN,format) "Feed_INV"
# set mom_sys_contour_feed_mode(ROTARY) "MMPM"
# set mom_sys_contour_feed_mode(LINEAR_ROTARY) "MMPM"
# set mom_sys_feed_param(DPM,format) "Feed_DPM"
# set mom_sys_rapid_feed_mode(ROTARY) "MMPM"
# set mom_sys_rapid_feed_mode(LINEAR_ROTARY) "MMPM"
# set mom_sys_feed_param(MMPM,format) "Feed_MMPM"
# set mom_sys_feed_param(MMPR,format) "Feed_MMPR"
# set mom_sys_linearization_method "angle"
#
# ####### KINEMATIC VARIABLE DECLARATIONS ##############
# set mom_kin_4th_axis_direction "MAGNITUDE_DETERMINES_DIRECTION"
# set mom_kin_4th_axis_incr_switch "OFF"
# set mom_kin_4th_axis_rotation "standard"
# set mom_kin_5th_axis_direction "MAGNITUDE_DETERMINES_DIRECTION"
# set mom_kin_5th_axis_incr_switch "OFF"
# set mom_kin_5th_axis_rotation "standard"
# set mom_kin_clamp_time "2.0"
# set mom_kin_cycle_plane_change_per_axis "0"
# set mom_kin_cycle_plane_change_to_lower "0"
# set mom_kin_flush_time "2.0"
# set mom_kin_linearization_flag "1"
# set mom_kin_linearization_tol "0.01"
# set mom_kin_max_dpm "1000000"
# set mom_kin_max_fpm "15000"
# set mom_kin_max_fpr "1000"
# set mom_kin_max_frn "1000"
# set mom_kin_min_dpm "0.0"
# set mom_kin_min_fpm "0.1"
# set mom_kin_min_fpr "0.1"
# set mom_kin_min_frn "0.01"
# set mom_kin_pivot_gauge_offset "0.0"
# set mom_kin_rapid_feed_rate "10000"
# set mom_kin_retract_distance "500"
# set mom_kin_rotary_axis_method "PREVIOUS"
# set mom_kin_tool_change_time "12.0"
# set mom_kin_x_axis_limit "1000"
# set mom_kin_y_axis_limit "1000"
# set mom_kin_z_axis_limit "1000"
}
proc MOM_start_of_program_include {} {

  MotionSetting set mom_sys_contour_feed_mode(LINEAR_ROTARY) "DPM"
  MotionSetting set mom_sys_contour_feed_mode(ROTARY) "DPM"

}
# <Internal Documentation>
# called from MOM_start_of_program. Added to set default value for property defined with GLOBAL_LINK_CONTAINER
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_main_origin_call {{offset_nbr ""} {create ""}} {


  global mom_fixture_offset_value
  global lib_main_zero_register lib_flag

  if {[llength [info commands LIB_main_origin_call_ENTRY]]} {LIB_main_origin_call_ENTRY "start"}

  if {$offset_nbr == ""} {
    set offset_nbr $mom_fixture_offset_value
  }

  if {[CONF_CTRL_origin use_main] == 1} {
    if {$offset_nbr == 0} {
      set lib_main_zero_register 500
    } elseif {$offset_nbr <= 6} {
      set lib_main_zero_register [expr $offset_nbr + 53]
    } elseif {$offset_nbr <= 99} {
      set lib_main_zero_register [expr $offset_nbr + 500]
    } else {
      if {![hiset lib_flag(error_main_zero_register)]} {
        set error [LIB_SPF_add_warning "Fixture offset value should be < 100: G599 is used"]
        set lib_flag(error_main_zero_register) 1
      }
      set lib_main_zero_register 599
    }
    MOM_do_template main_zero $create
  }

  if {[llength [info commands LIB_main_origin_call_ENTRY]]} {LIB_main_origin_call_ENTRY "end"}
}
# <Internal Documentation>
# Output the main origin call G54-G59 G507-G599
#
# <Internal Example>
#
#____________________________________________________________________________________________

# ctrl_s840d_base.tcl

proc MOM_high_speed_setting {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_high_speed_setting_ENTRY) [llength [info commands MOM_high_speed_setting_ENTRY]]

  LIB_GE_command_buffer MOM_high_speed_setting_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_high_speed_setting_ENTRY)} {MOM_high_speed_setting_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_high_speed_setting_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_high_speed_setting_ENTRY)} {MOM_high_speed_setting_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}

# ctrl_sinumerik_base.tcl

proc LIB_SPF_set_initial_globals_LIB {} {

  uplevel #0 {

    set mom_system_tolerance                      0.0000001
    set mom_sys_control_out                       ";"
    set mom_sys_control_in                        ""

    ########## SYSTEM VARIABLE DECLARATIONS ##############

    set mom_sys_rapid_code                        "0"
    set mom_sys_linear_code                       "1"
    set mom_sys_circle_code(CLW)                  "2"
    set mom_sys_circle_code(CCLW)                 "3"
    set mom_sys_delay_code(SECONDS)               "4"
    set mom_sys_delay_code(REVOLUTIONS)           "4"
    set mom_sys_cutcom_plane_code(XY)             "17"
    set mom_sys_cutcom_plane_code(ZX)             "18"
    set mom_sys_cutcom_plane_code(XZ)             "18"
    set mom_sys_cutcom_plane_code(YZ)             "19"
    set mom_sys_cutcom_plane_code(ZY)             "19"
    set mom_sys_lathe_thread_advance_type(1)      "33"
    set mom_sys_lathe_thread_advance_type(2)      "34"
    set mom_sys_lathe_thread_advance_type(3)      "35"
    set mom_sys_cutcom_code(OFF)                  "40"
    set mom_sys_cutcom_code(LEFT)                 "41"
    set mom_sys_cutcom_code(RIGHT)                "42"
    set mom_sys_unit_code(IN)                     "700"
    set mom_sys_unit_code(MM)                     "710"
    set mom_sys_output_code(ABSOLUTE)             "90"
    set mom_sys_output_code(INCREMENTAL)          "91"
    set mom_sys_feed_rate_mode_code(FRN)          "93"
    set mom_sys_spindle_mode_code(SMM)            "96"
    set mom_sys_spindle_mode_code(SFM)            "96"
    set mom_sys_spindle_mode_code(RPM)            "961"
    set mom_sys_return_code                       "153"
    set mom_sys_feed_rate_mode_code(DPM)          "94"
    set mom_sys_feed_rate_mode_code(IPM)          "94"
    set mom_sys_feed_rate_mode_code(IPR)          "95"
    set mom_sys_feed_rate_mode_code(MMPM)         "94"
    set mom_sys_feed_rate_mode_code(MMPR)         "95"
    set mom_sys_program_stop_code                 "0"
    set mom_sys_optional_stop_code                "1"
    set mom_sys_end_of_program_code               "2"
    set mom_sys_start_of_subprogram       "EXTCALL"
    set mom_sys_end_of_subprogram                 "17"
    set mom_sys_spindle_direction_code(CLW)       "3"
    set mom_sys_spindle_direction_code(CCLW)      "4"
    set mom_sys_spindle_direction_code(OFF)       "5"
    set mom_sys_spindle_orient_code               "19"
    set mom_sys_leader(SPOS)                      "SPOS="
    set mom_sys_trailer(SPOS)                     ""
    set mom_sys_tool_change_code                  "6"
    set mom_sys_coolant_code(ON)                  "8"
    set mom_sys_coolant_code(FLOOD)               "8"
    set mom_sys_coolant_code(MIST)                "7"
    set mom_sys_coolant_code(THRU)                "26"
    set mom_sys_coolant_code(TAP)                 "8"
    set mom_sys_coolant_code(AIR)         "7"
    set mom_sys_coolant_code(AIRTHRU)             "26"
    set mom_sys_coolant_code(OFF)                 "9"
    set mom_sys_rewind_code                       "30"
    set mom_sys_unclamp_code_fourth               "10"
    set mom_sys_clamp_code_fourth                 "11"
    set mom_sys_unclamp_code_fifth                "50"
    set mom_sys_clamp_code_fifth                  "51"
    set mom_sys_4th_axis_has_limits               "1"
    set mom_sys_5th_axis_has_limits               "1"
    set mom_sys_sim_cycle_drill                   "0"
    set mom_sys_sim_cycle_drill_dwell             "0"
    set mom_sys_sim_cycle_drill_deep              "0"
    set mom_sys_sim_cycle_drill_break_chip        "0"
    set mom_sys_sim_cycle_tap                     "0"
    set mom_sys_sim_cycle_bore                    "0"
    set mom_sys_sim_cycle_bore_drag               "0"
    set mom_sys_sim_cycle_bore_nodrag             "0"
    set mom_sys_sim_cycle_bore_manual             "0"
    set mom_sys_sim_cycle_bore_dwell              "0"
    set mom_sys_sim_cycle_bore_manual_dwell       "0"
    set mom_sys_sim_cycle_bore_back               "0"
    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
    set mom_sys_spindle_cancel_sfm_code           "97"
      set mom_sys_helix_pitch_type                  "rise_revolution"
    set mom_sys_spindle_ranges                    "0"
    set mom_sys_rewind_stop_code                  "\#"
    set mom_sys_home_pos(3)                       "0"
    set mom_sys_home_pos(4)                       "0"
    set mom_sys_home_pos(5)                       "0"
    set mom_sys_zero                              "0"
    set mom_sys_opskip_block_leader               "/"
    set mom_sys_seqnum_start                      "10"
    set mom_sys_seqnum_incr                       "10"
    set mom_sys_seqnum_freq                       "1"
    set mom_sys_seqnum_max                        "99999999"
    set mom_sys_lathe_x_double                    "1"
    set mom_sys_lathe_i_double                    "1"
    set mom_sys_lathe_y_double                    "1"
    set mom_sys_lathe_j_double                    "1"
    set mom_sys_lathe_x_factor                    "1"
    set mom_sys_lathe_y_factor                    "1"
    set mom_sys_lathe_z_factor                    "1"
    set mom_sys_lathe_i_factor                    "1"
    set mom_sys_lathe_j_factor                    "1"
    set mom_sys_lathe_k_factor                    "1"
    set mom_sys_leader(N)                         "N"
    set mom_sys_leader(M)           "M"
    set mom_sys_leader(M_spindle)                 "M"
    set mom_sys_leader(G)           "G"
    set mom_sys_leader(X)                         "X"
    set mom_sys_leader(Y)                         "Y"
    set mom_sys_leader(Z)                         "Z"
    set mom_sys_leader(fourth_axis)               "A"
    set mom_sys_leader(fifth_axis)                "B"
    set mom_sys_leader(sixth_axis)                "C"
    set mom_sys_trailer(M)            ""
    set mom_sys_trailer(M_spindle)                ""
    set mom_sys_trailer(G)            ""
    set mom_sys_trailer(X)                        ""
    set mom_sys_trailer(Y)                        ""
    set mom_sys_trailer(Z)                        ""
    set mom_sys_trailer(fourth_axis)              ""
    set mom_sys_trailer(fifth_axis)               ""
    set mom_sys_trailer(sixth_axis)               ""
    if {[info exists pc_initial_library_release_of_post] && $pc_initial_library_release_of_post > 50306} {
      set mom_sys_contour_feed_mode(LINEAR)         "AUTO"
      set mom_sys_rapid_feed_mode(LINEAR)           "AUTO"
      set mom_sys_cycle_feed_mode                   "AUTO"
    } else {
      set mom_sys_contour_feed_mode(LINEAR)         "MMPM"
      set mom_sys_rapid_feed_mode(LINEAR)           "MMPM"
      set mom_sys_cycle_feed_mode                   "MMPM"
    }
    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
    set mom_sys_feed_param(FRN,format)            "Feed_INV"
    set mom_sys_vnc_rapid_dogleg                  "1"
    set mom_sys_prev_mach_head                    ""
    set mom_sys_curr_mach_head                    ""
    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
    set mom_sys_retract_distance                  "10"
    set mom_sys_output_cycle95                    "1"
    set mom_sys_linearization_method              "angle"
    set mom_sys_post_description                  "This is a 5-Axis Milling Machine With\n\Dual Rotary Heads."
    set mom_sys_ugpadvkins_used                   "0"
    set mom_sys_post_builder_version              "9.0.1"
    set mom_sys_linear_turbo_command              "FALSE"
    set mom_sys_rapid_turbo_command               "FALSE"
    set mom_sys_circular_turbo_command            "FALSE"
    # will be added to post core later
    set mom_sys_turbo_global_add_vars_list        "mom_feedrate_mode mom_feedrate mom_motion_type mom_current_motion mom_pos_arc_center mom_pos_arc_axis oper_mcs_matrix"
    set mom_sys_output_transition_path            "0"
    set mom_sys_post_output_subprogram_enabled    "1"

    ####### KINEMATIC VARIABLE DECLARATIONS ##############
    set mom_kin_4th_axis_ang_offset               "0.0"
    set mom_kin_4th_axis_center_offset(0)         "0.0"
    set mom_kin_4th_axis_center_offset(1)         "0.0"
    set mom_kin_4th_axis_center_offset(2)         "0.0"
    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_4th_axis_incr_switch              "OFF"
    set mom_kin_4th_axis_leader                   "A"
    set mom_kin_4th_axis_max_limit                "360"
    set mom_kin_4th_axis_min_incr                 "0.001"
    set mom_kin_4th_axis_min_limit                "0"
    set mom_kin_4th_axis_plane                    "YZ"
    set mom_kin_4th_axis_point(0)                 "0.0"
    set mom_kin_4th_axis_point(1)                 "0.0"
    set mom_kin_4th_axis_point(2)                 "0.0"
    set mom_kin_4th_axis_rotation                 "standard"
    set mom_kin_4th_axis_type                     "Head"
    set mom_kin_4th_axis_vector(0)                "1"
    set mom_kin_4th_axis_vector(1)                "0"
    set mom_kin_4th_axis_vector(2)                "0"
    set mom_kin_4th_axis_zero                     "0.0"
    set mom_kin_5th_axis_ang_offset               "0.0"
    set mom_kin_5th_axis_center_offset(0)         "0.0"
    set mom_kin_5th_axis_center_offset(1)         "0.0"
    set mom_kin_5th_axis_center_offset(2)         "0.0"
    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_5th_axis_incr_switch              "OFF"
    set mom_kin_5th_axis_leader                   "B"
    set mom_kin_5th_axis_max_limit                "360"
    set mom_kin_5th_axis_min_incr                 "0.001"
    set mom_kin_5th_axis_min_limit                "0"
    set mom_kin_5th_axis_plane                    "ZX"
    set mom_kin_5th_axis_point(0)                 "0.0"
    set mom_kin_5th_axis_point(1)                 "0.0"
    set mom_kin_5th_axis_point(2)                 "0.0"
    set mom_kin_5th_axis_rotation                 "standard"
    set mom_kin_5th_axis_type                     "Head"
    set mom_kin_5th_axis_vector(0)                "0"
    set mom_kin_5th_axis_vector(1)                "1"
    set mom_kin_5th_axis_vector(2)                "0"
    set mom_kin_5th_axis_zero                     "0.0"
    set mom_kin_arc_output_mode                   "FULL_CIRCLE"
    set mom_kin_arc_valid_plane                   "XYZ"
    set mom_kin_clamp_time                        "2.0"
    set mom_kin_cycle_plane_change_per_axis       "1"
    set mom_kin_cycle_plane_change_to_lower       "1"
    set mom_kin_dependent_head                    "NONE"
    set mom_kin_flush_time                        "2.0"
    set mom_kin_helical_arc_output_mode           "END_POINT"
    set mom_kin_ind_to_dependent_head_x           "0"
    set mom_kin_ind_to_dependent_head_z           "0"
    set mom_kin_independent_head                  "NONE"
    set mom_kin_linearization_flag                "1"
    ###set mom_kin_linearization_tol                 "0.01"
    set mom_kin_machine_type                      "5_axis_dual_head"
    set mom_kin_machine_zero_offset(0)            "0.0"
    set mom_kin_machine_zero_offset(1)            "0.0"
    set mom_kin_machine_zero_offset(2)            "0.0"
    set mom_kin_max_dpm                           "1000000"
    set mom_kin_max_frn                           "1000"
    set mom_kin_min_dpm                           "0.0"
    set mom_kin_min_frn                           "0.01"
    set mom_kin_output_unit                       "MM"
    set mom_kin_pivot_gauge_offset                "0"
    set mom_kin_pivot_guage_offset                ""
    set mom_kin_post_data_unit                    "MM"
    set mom_kin_retract_distance                  "500"
    set mom_kin_rotary_axis_method                "PREVIOUS"
    set mom_kin_spindle_axis(0)                   "0.0"
    set mom_kin_spindle_axis(1)                   "0.0"
    set mom_kin_spindle_axis(2)                   "1.0"
    set mom_kin_tool_change_time                  "0.0"
    set mom_kin_x_axis_limit                      "1000"
    set mom_kin_y_axis_limit                      "1000"
    set mom_kin_z_axis_limit                      "1000"
          set mom_kin_head_spindle_axis_correction      "ON"
    set mom_kin_head_gauge_point_correction       "ON"
    set mom_kin_combine_rapid_arc_motion          "Yes"
  }
}
proc MOM_start_of_program_LIB {} {
  global lib_flag mom_kin_machine_type

  set commandcheck(MOM_start_of_program_LIB_ENTRY) [llength [info commands MOM_start_of_program_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_dnc_header) [llength [info commands LIB_CTRL_dnc_header]]
  set commandcheck(LIB_CTRL_nc_header) [llength [info commands LIB_CTRL_nc_header]]
  set commandcheck(LIB_CTRL_sub_header) [llength [info commands LIB_CTRL_sub_header]]
  set commandcheck(LIB_CTRL_parameter_definition) [llength [info commands LIB_CTRL_parameter_definition]]

  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_dnc_header
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_dnc_header)} {LIB_CTRL_dnc_header}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[string match "MOM_start_of_program" [info level -1]]} {
    LIB_GE_command_buffer LIB_CTRL_nc_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_nc_header)} {LIB_CTRL_nc_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Program"}} @EVENT_MESSAGE
    LIB_GE_command_buffer {LIB_SPF_program_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer LIB_CTRL_sub_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sub_header)} {LIB_CTRL_sub_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {LIB_SPF_sub_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  }

  LIB_GE_command_buffer LIB_CTRL_parameter_definition
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition)} {LIB_CTRL_parameter_definition}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
  if {[LIB_PT_get_header_var mom_sequence_mode exists]} {
    if {[LIB_PT_get_header_var mom_sequence_mode] == "OFF"} {
      MOM_set_seq_off
    } else {
      if {[CONF_CTRL_setting sequence_number] == 1} {
        MOM_set_seq_on
      } else {
        MOM_set_seq_off
      }
    }
    }
  }

  if {$lib_flag(local_namespace_output) == 1 && [CONF_CTRL_setting plane_output_supported] != "NONE"} {
    set lib_flag(plane_output_pos_type) 1
    if {[string match "5_axis_head_table" $mom_kin_machine_type] && [CONF_CTRL_setting plane_output] == "TRANS_ROT" && [CONF_CTRL_setting reference_direction] == 1} {
      set lib_flag(plane_output_pos_type) 0
      set lib_flag(plane_reference_direction) 1
    }
  }

  LIB_GE_command_buffer PROGRAMSTART

  LIB_GE_command_buffer {
    if {[CONF_CTRL_feed feed_linear] == 2} {
      if {[CONF_CTRL_feed feed_engage] != "NX" && [CONF_CTRL_feed feed_engage] != "P_CUT"} {
        MOM_add_to_line_buffer end " [CONF_CTRL_feed feed_engage]"
        set tmp_def 1
      }
      if {[CONF_CTRL_feed feed_cut] != "NX" && [CONF_CTRL_feed feed_cut] != "P_CUT"} {
        if {[info exists tmp_def]} {
          MOM_add_to_line_buffer end ","
        }
        MOM_add_to_line_buffer end " [CONF_CTRL_feed feed_cut]"
        set tmp_def 1
      }
      if {[CONF_CTRL_feed feed_retract] != "NX" && [CONF_CTRL_feed feed_retract] != "P_CUT"} {
        if {[info exists tmp_def]} {
          MOM_add_to_line_buffer end ","
        }
        MOM_add_to_line_buffer end " [CONF_CTRL_feed feed_retract]"
        set tmp_def 1
      }
      if {[CONF_CTRL_feed feed_cycle] != "NX" && [CONF_CTRL_feed feed_cycle] != "P_CUT"} {
        if {[info exists tmp_def]} {
          MOM_add_to_line_buffer end ","
        }
        MOM_add_to_line_buffer end " [CONF_CTRL_feed feed_cycle]"
      }
      MOM_output_literal "DEF REAL"
      unset tmp_def
    }
  } @DECLARE_FEED_PARAM
  LIB_GE_command_buffer {
    if {[CONF_CTRL_setting block_form] == 1 && [string match "MOM_start_of_program" [info level -1]]} {
      LIB_SPF_start_of_program_blank
    }
  } @BLANKGEO

  LIB_GE_command_buffer {LIB_GE_catch_do_template start_of_program "" 1} @START_OF_PROGRAM

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_path_LIB {} {

  LIB_calc_lib_cutcom_radius

  set commandcheck(MOM_start_of_path_LIB_ENTRY) [llength [info commands MOM_start_of_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_update_tool_change_template
  # reset address expression
  if {[llength [info commands "MOM_set_address_expression"]]&&[info exists ::save_address_expression]} {
    if {[info exists ::save_address_expression(linear_move,X)]&&\
        [catch {MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" $::save_address_expression(linear_move,X)}]} {
          LIB_SPF_add_warning "Failed to reset address expression of 'X' in BLOCK_TEMPLATE 'linear_move'"
    }
    if {[info exists ::save_address_expression(linear_move,F)] && [catch {
      MOM_set_address_expression [CONF_CTRL_moves linear_template]   "F" $::save_address_expression(linear_move,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" $::save_address_expression(circular_move,F)
    }]} {
      LIB_SPF_add_warning "Failed to reset feed rate address expression , the feed rate address name should be 'F'"
    }
    unset ::save_address_expression
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_sync_LIB {} {

  set commandcheck(MOM_sync_LIB_ENTRY) [llength [info commands MOM_sync_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_synchronization_mark_text

  LIB_GE_command_buffer SYNC

  LIB_GE_command_buffer {
    if {[info exists mom_synchronization_mark_text] && [string length $mom_synchronization_mark_text] > 0} {
      MOM_add_to_line_buffer end " [LIB_GE_message $mom_synchronization_mark_text "create_1"]"
      set mom_synchronization_mark_text ""
    }
  } @SYNC_MSG_ADD_BUFFER
  LIB_GE_command_buffer {MOM_do_template sync_call} @SYNC_CALL

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_set_csys_LIB {} {

  global lib_flag mom_kin_machine_type

  set commandcheck(MOM_set_csys_LIB_ENTRY) [llength [info commands MOM_set_csys_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![info exist lib_flag(absolute_kin)] || $lib_flag(absolute_kin) == 0} {
    # do nothing
  } else {
    LIB_SPF_calc_4th5th_axis_points
  }

  # In new local csys mode, translate mom_pos and mom_mcs_goto from local to G54 in global namespace,
  # and get rotation matrix and origin of local coordinate system relative to G54.
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_csys_rotation_revise_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output


}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_calc_lib_cutcom_radius {} {

  global mom_cutter_data_output_indicator mom_cut_data_type mom_cutcom_type mom_tool_diameter
  global lib_cutcom_radius mom_kin_arc_output_mode mom_sys_cutcom_code

  if {![info exists mom_cutter_data_output_indicator]} {
    set mom_cutter_data_output_indicator 0
  }
  if {![info exists mom_cutcom_type]} {
    set mom_cutcom_type 0
  }
  if {[CONF_CTRL_tool cutcom_actual_radius] == 0} {
    # no cutcom output even it is defined
    set lib_cutcom_radius 0.0
  } elseif {$mom_cutcom_type > 0} {
    # cutcom defined
    if {$mom_cut_data_type == "centerline data"} {
        set lib_cutcom_radius [expr $mom_tool_diameter/2]
    } else {
      set lib_cutcom_radius 0.0
    }
    if {[CONF_CTRL_setting turbo_mode] == 2 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
      LIB_SPF_turbo_status "enable" "advanced"
    }
  } else {
    # no cutcom defined
    set lib_cutcom_radius 0.0
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_tool_LIB {} {

  global lib_flag

  set commandcheck(MOM_first_tool_LIB_ENTRY) [llength [info commands MOM_first_tool_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set lib_flag(tool_path_motion) 0

  if {[CONF_CTRL_moves return_before_first_tool_change_pos] != ""} {
    LIB_CHECK_adjust_register
    LIB_RETURN_move CONF_CTRL_moves return_before_first_tool_change_pos
  }

  set lib_flag(first_tool_change) 1
  MOM_tool_change
  set lib_flag(first_tool_change) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {

  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag lib_prev_tool_name
  global mom_next_tool_status

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }

  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_from_move_LIB {} {

  global feed_mode mom_feed_rate mom_kin_rapid_feed_rate

  set commandcheck(MOM_from_move_LIB_ENTRY) [llength [info commands MOM_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_moves output_from_position] == 1 } {
    if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
      if {[EQ_is_ge $mom_feed_rate $mom_kin_rapid_feed_rate]} {
        MOM_rapid_move_LIB
      } else {
        MOM_linear_move_LIB
      }
    }
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_update_tool_change_template {} {

  global lib_prev_feed_cut_value mom_feed_cut_value mom_tool_name

  LIB_GE_command_buffer UPDATE_TOOL

  LIB_GE_command_buffer {
      LIB_CTRL_set_feed_parameter
      set lib_prev_feed_cut_value $mom_feed_cut_value
  } @SET_FEED_PARAM
  LIB_GE_command_buffer {
      LIB_CHECK_adjust_register
  } @SET_ADJUST_REGISTER

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_move_LIB {} {
  global mom_motion_event mom_operation_name mom_output_mcs_name
  global mom_motion_type

  set commandcheck(MOM_first_move_LIB_ENTRY) [llength [info commands MOM_first_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_generic_cycle_start_motion

  LIB_CTRL_handle_cycle_check move

  LIB_CTRL_detect_cutcom_mode

  LIB_SPF_check_decompose_first_move

  if {[info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])] && $mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])} {
    LIB_main_origin_call
  }

  LIB_CHECK_adjust_register

  if {$mom_motion_event == "cycle_plane_change"} {
    LIB_SPF_add_warning "It is recommended to define a motion before first cycle."
  }
  catch {MOM_$mom_motion_event}
  # Handle the case user specify feed for rapid
  if {$mom_motion_type == "RAPID"} {
    LIB_SPF_last_rapid_pos
  }
  LIB_SPF_calc_abs_move_parameter
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_initial_move_LIB {} {
  global lib_flag mom_programmed_feed_rate mom_motion_event
  global mom_motion_type

  set commandcheck(MOM_initial_move_LIB_ENTRY) [llength [info commands MOM_initial_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_detect_cutcom_mode
  LIB_SPF_spindle_set

  #<cam17013 new pretreatment>
  if {$lib_flag(local_namespace_output) && [CONF_CTRL_setting turbo_mode] == 3 &&\
    [CONF_CTRL_setting tcpm_output_supported] != "NONE" &&\
    [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
  }
  LIB_CTRL_handle_generic_cycle_start_motion

  LIB_CTRL_handle_cycle_check move

  LIB_CHECK_adjust_register

  if {[EQ_is_zero $mom_programmed_feed_rate]} {
    MOM_rapid_move
    set mom_motion_event "rapid_move"
  } else {
    MOM_linear_move
    set mom_motion_event "linear_move"
    # Handle the case user specify feed for rapid
    if {$mom_motion_type == "RAPID"} {
      LIB_SPF_last_rapid_pos
    }
  }
  LIB_SPF_calc_abs_move_parameter

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_handle_cycle_check {arg} {

  global mom_cycle_type mom_spindle_status mom_spindle_startup_status

  if {([info exists mom_cycle_type] && ([string match "Exp_Deep_Drill_Breakchip" $mom_cycle_type] || [string match "Exp_Deep_Drill" $mom_cycle_type])) ||\
  ([info exists mom_spindle_startup_status] && $mom_spindle_startup_status == "OFF")} {

    switch -- $arg {
      "move"    {
            if {$mom_spindle_status == "OFF"} {MOM_disable_address S M_spindle}
          }
      "spindle" {
            MOM_enable_address S M_spindle
          }
      default   {
            LIB_GE_abort_message "Call LIB_CTRL_handle_cycle_check without the right arguments" "Please check"
          }
    }

  }
}
# <Internal Documentation>
#
# This function controlls the spindle rotation.
# The spindle should never be activated with the first movement if a single-lip drill is used.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_turbo {} {

  if {$::lib_ge_pretreatment_runtime} {return}
  # The mom variable mom_sys_advanced_turbo_output is set in MOM_Start_of_path from core code
  if {![info exists ::mom_sys_advanced_turbo_output] || $::mom_sys_advanced_turbo_output != "TRUE"} {
    MOM_enable_address I J K R ;# useful when previous operation use turbo mode and addresses R or I,J,K are disable
    return
  }

  if {[CONF_CTRL_moves always_center_for_circle] == 1} {
    MOM_disable_address R
          MOM_enable_address I J K
  } else {
    MOM_enable_address R
    MOM_disable_address I J K
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {$::mom_kin_arc_output_mode == "FULL_CIRCLE" } {
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {[CONF_CTRL_feed feed_linear] == 2} {
    # Before NX1899, set MOM_linear_move_turbo_LIB at turbo block to output parameterized feed value
    # From NX1899, use advanced callback function to do the same thing
    if {$::lib_ge_env(major_version) < 1899} {
      set ::mom_sys_linear_turbo_command "TRUE"
      set ::mom_sys_circular_turbo_command "TRUE"
    } else {
      # In advanced turbo mode, LIB_SPF_feedrate_set is called in callback function, so disable feedrate setting in core code
      if {[llength [info commands MOM_set_turbo_feedrate_set]]} {
        MOM_set_turbo_feedrate_set OFF
      }
    }
  }

  if {$::mom_sys_rapid_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry] "MOM_rapid_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks RAPID [LIB_SPF_ltreatment [CONF_Turbo_Templates rapid_template_turbo] [CONF_Turbo_Templates rapid_template_entry]]
  }

  if {$::mom_sys_linear_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry] "MOM_linear_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks LINEAR [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] [CONF_Turbo_Templates linear_template_entry]]
  }

  if {$::mom_sys_circular_turbo_command == "TRUE"} {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment [CONF_Turbo_Templates circular_template_turbo] [CONF_Turbo_Templates circular_template_entry] "MOM_circular_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks CIRCULAR [LIB_SPF_ltreatment [CONF_Turbo_Templates circular_template_turbo] [CONF_Turbo_Templates circular_template_entry]]
  }

  # The address X[$mom_pos(0)*$x_factor] will slow down turbo mode, x_factor only used in turning
  if {[llength [info commands "MOM_set_address_expression"]]} {
    if {$::x_factor == 1} {
      catch {
    set ::save_address_expression(linear_move,X) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" "\$mom_pos(0)"]
      }
    }
    if {[CONF_CTRL_feed feed_linear] != 2} {
      if {[catch {
        set ::save_address_expression(linear_move,F) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "F" "\$mom_feedrate"]
        set ::save_address_expression(circular_move,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" "\$mom_feedrate"]
      }]} {
        LIB_SPF_add_warning "Please use 'F' as feed rate address name in linear and circular block template"
      }
    }
    #when feedrate in one operation change from mmpm to mmpr we must write mom_feedrate_mode in to the advanced and set feed the mode into the G_feed Address
    set ::save_address_expression(linear_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]
    set ::save_address_expression(circular_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]

  }
}
# <Internal Documentation>
#
# This procedure is executed at MOM_initial_move MOM_first_move MOM_lock_axis.
# It is used to config turbo blocks in advanced turbo mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB {} {

  global mom_machine_mode mom_pos
  global lib_flag lib_param
  global mom_output_pos_type
  global mom_inter_opr_rule_intent mom_auto_machine_pos

  set commandcheck(MOM_rapid_move_LIB_ENTRY) [llength [info commands MOM_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  #Because our default rapid feed unit is mmpm/ipm, for sinumerik customer, rapid feedrate mode should be same as cut unit
  global mom_feed_cut_unit feed_mode
  if {[info exists mom_feed_cut_unit] && $mom_machine_mode == "TURN"} {
    set feed_cut_mode [string toupper $mom_feed_cut_unit]
    if {$feed_cut_mode == "MMPR" || $feed_cut_mode == "IPR"} {
      set feed_mode $feed_cut_mode
    }
  }

  if {[info exists mom_inter_opr_rule_intent] && [string compare $mom_inter_opr_rule_intent ""]} {
    MOM_transition_move
    return
  }

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves rapid_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        }
      } @MOVE

      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {if {$::check_list(spindle,status) != 1} {LIB_SPINDLE_start}} @START_SPINDLE
      LIB_GE_command_buffer {
        switch -- $lib_flag(mode_current_status) {
          "std" {
            LIB_ROTARY_positioning_first_move
          }
          "pos" {
            LIB_ROTARY_positioning_first_move_pos
          }
          "sim" {
            LIB_ROTARY_positioning_first_move_sim
          }
        }
      } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized RAPID_MOVE]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }
    #<lili> Don't output spindle in rapid motion for turn. Otherwise spindle mode will jump between G94 and G95.
    LIB_GE_command_buffer RAPID_MOVE
    LIB_GE_command_buffer {
      if {$::check_list(spindle,status) != 1} {LIB_SPINDLE_start}
    } @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer RAPID_MOVE_SINGLE
    LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
    LIB_GE_command_buffer_output
  }

  LIB_SPF_last_rapid_pos

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_linear_move_turbo {} {

  set commandcheck(LIB_CTRL_linear_move_turbo_ENTRY) [llength [info commands LIB_CTRL_linear_move_turbo_ENTRY]]

  LIB_GE_command_buffer LINEAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @LINEAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_linear_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_linear_move_turbo_ENTRY)} {LIB_CTRL_linear_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_linear_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_turbo {} {

  set commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY) [llength [info commands LIB_CTRL_rapid_move_turbo_ENTRY]]

  LIB_GE_command_buffer RAPID_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @RAPID_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_rapid_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_turbo_ENTRY)} {LIB_CTRL_rapid_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_rapid_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_circular_move_turbo {} {

  set commandcheck(LIB_CTRL_circular_move_turbo_ENTRY) [llength [info commands LIB_CTRL_circular_move_turbo_ENTRY]]

  LIB_GE_command_buffer CIRCULAR_MOVE_TURBO
  LIB_GE_command_buffer {LIB_GE_message "Output from LIB_CTRL_circular_move_turbo" "output_1"} @CIRCULAR_MOVE_TURBO_INFO
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_circular_move_turbo_ENTRY
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_circular_move_turbo_ENTRY)} {LIB_CTRL_circular_move_turbo_ENTRY}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when LIB_CTRL_circular_move_turbo is called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_linear_move_turbo_LIB {} {

  set commandcheck(MOM_linear_move_turbo_LIB_ENTRY) [llength [info commands MOM_linear_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_linear_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_turbo_LIB {} {

  set commandcheck(MOM_rapid_move_turbo_LIB_ENTRY) [llength [info commands MOM_rapid_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_rapid_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_turbo_LIB {} {

  set commandcheck(MOM_circular_move_turbo_LIB_ENTRY) [llength [info commands MOM_circular_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  if {[CONF_CTRL_moves always_center_for_circle] != 1} {
    global mom_arc_radius
    set mom_arc_radius [expr abs($mom_arc_radius)]

    MOM_suppress once I J K
    switch -- $::tool_axis {
      0 {MOM_force once Y Z}
      1 {MOM_force once X Z}
      2 {MOM_force once X Y}
    }

    # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
    if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

      global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
      global mom_namespace_name mom_output_pos_type
      if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
        if {$mom_namespace_name == "::"} {
          set namespace ::
        } else {
          set namespace ::LOCAL_CSYS::
        }
        if {$mom_output_pos_type == "mom_pos"} {
          VMOV 3 ${namespace}mom_prev_pos prev_pos
          VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
        } else {
          VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
          VMOV 3 ${namespace}mom_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
        }
        VMOV 3 ${namespace}$mom_output_pos_type save_pos
      } else {
        set namespace ::
        set mom_output_pos_type mom_pos
        VMOV 3 mom_prev_pos prev_pos
        VMOV 3 mom_pos_arc_center pos_arc_center
        VMOV 3 mom_pos_arc_axis pos_arc_axis
        VMOV 3 mom_pos save_pos
      }
      VEC3_sub prev_pos pos_arc_center tmp_vec
      VEC3_unitize tmp_vec tmp_vec1
      VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
      VEC3_scale mom_arc_radius tmp_vec tmp_vec1
      VEC3_add pos_arc_center tmp_vec1 tmp_vec
      VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

      MOM_do_template [CONF_Turbo_Templates circular_template_turbo]

      VMOV 3 save_pos  ${namespace}$mom_output_pos_type
      MOM_suppress once I J K
      switch -- $::tool_axis {
        0 {MOM_force once Y Z}
        1 {MOM_force once X Z}
        2 {MOM_force once X Y}
      }
      set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]
    }

    if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
      LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
    }

    if {[EQ_is_gt $::mom_arc_angle 180.0]} {
      set mom_arc_radius [expr -1.0*$mom_arc_radius]
    }

  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_circular_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB_MODIF_first_move_turn {} {

  return 0

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_TURNING_mode {{option default}} {

  global x_factor lib_flag

  switch -- $option {
    "start" {
      if {[LIB_SPF_check_x_factor TURN] == 2} {
        LIB_GE_command_buffer DIA_ON
        LIB_GE_command_buffer {MOM_do_template prog_dia_on} @OUTPUT
        LIB_GE_command_buffer_output
      }
      set x_factor [LIB_SPF_check_x_factor TURN]

      if {![info exist lib_flag(save_rapid_template)]} {set lib_flag(save_rapid_template) [CONF_CTRL_moves rapid_template]}
      CONF_CTRL_moves set rapid_template [CONF_CTRL_moves rapid_template_turn]

      if {![info exist lib_flag(save_linear_template)]} {set lib_flag(save_linear_template) [CONF_CTRL_moves linear_template]}
      CONF_CTRL_moves set linear_template [CONF_CTRL_moves linear_template_turn]

      if {![info exist lib_flag(save_circular_template)]} {set lib_flag(save_circular_template) [CONF_CTRL_moves circular_template]}
      CONF_CTRL_moves set circular_template [CONF_CTRL_moves circular_template_turn]
    }
    "end" {

      if {[LIB_SPF_check_x_factor TURN] == 2 || [LIB_SPF_check_x_factor MILL] != 2} {
        LIB_GE_command_buffer DIA_OFF
        LIB_GE_command_buffer {MOM_do_template prog_dia_off} @OUTPUT
        LIB_GE_command_buffer_output
      }

      set x_factor [LIB_SPF_check_x_factor MILL]

      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        unset lib_flag(save_rapid_template)
      }

      if {[info exists lib_flag(save_linear_template)]} {
        CONF_CTRL_moves set linear_template $lib_flag(save_linear_template)
        unset lib_flag(save_linear_template)
      }

      if {[info exists lib_flag(save_circular_template)]} {
        CONF_CTRL_moves set circular_template $lib_flag(save_circular_template)
        unset lib_flag(save_circular_template)
      }
    }
  }
}
# <Internal Documentation>
# Controls the turning mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_start {{option default}} {

  global mom_machine_mode mom_spindle_mode mom_spindle_preset_rpm_toggle mom_spindle_preset_rpm
  global mom_spindle_maximum_rpm mom_spindle_speed mom_mcs_goto mom_spindle_status
  global PI mom_spindle_maximum_rpm_toggle lib_flag
  global spindle_mode mom_feed_cut_unit
  global mom_motion_event feed_mode mom_nxt_event_data mom_nxt_motion_type mom_current_motion
  global mom_sys_contour_feed_mode mom_cycle_type

  if {$mom_spindle_status == "OFF"} {return}

  set commandcheck(LIB_SPINDLE_start_ENTRY) [llength [info commands LIB_SPINDLE_start_ENTRY]]

  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY start_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_spindle masterspindle_output] == 1} {
    switch -- $mom_machine_mode {
      "MILL" {
        set ::mom_masterspindle [CONF_CTRL_spindle masterspindle_milling]
        LIB_GE_command_buffer SET_MASTERSPINDLE_MILL
        LIB_GE_command_buffer {MOM_do_template set_masterspindle} @OUTPUT
        LIB_GE_command_buffer_output
      }
      "TURN" {
        set ::mom_masterspindle [CONF_CTRL_spindle masterspindle_turning]
        LIB_GE_command_buffer SET_MASTERSPINDLE_TURN
        LIB_GE_command_buffer {MOM_do_template set_masterspindle} @OUTPUT
        LIB_GE_command_buffer_output
      }
    }
  }

  LIB_GE_command_buffer SPINDLE
  switch -- $option {
    "preset" {
      # turning only
      LIB_GE_command_buffer {
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {[EQ_is_zero $mom_spindle_speed]} {
            LIB_GE_error_message "Spindle speed should not be = 0.0" "Please check"
          }
          if {$mom_spindle_preset_rpm_toggle == 0 || [EQ_is_zero $mom_spindle_preset_rpm]} {
            set rval [expr abs($mom_mcs_goto(0))]
            if {$rval < 0.1} {set rval 1}
            set mom_spindle_preset_rpm [expr $mom_spindle_speed * 1000 / $PI / $rval / 2]
          }
          MOM_do_template spindle_rpm_preset
          #Bug1991 suppress G_spin when rpm_preset output is active
          MOM_suppress once G_spin
        } else {
          MOM_do_template spindle_rpm_preset CREATE
        }
      } @PRESET
    }
    "cycle" {
      LIB_GE_command_buffer {
        switch -- $mom_machine_mode {
          "MILL" {
            # Always RPM output for milling
            if {[CONF_CTRL_spindle spindle_output_alone] == 1} {
              MOM_do_template spindle_rpm
            }
          }
          "TURN" {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm_turn CREATE
            } elseif {$mom_spindle_mode == "RPM"} {
              if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
                if {![info exists ::mom_spindle_rpm] || [EQ_is_equal $::mom_spindle_rpm 0.0]} {
                  set ::mom_spindle_rpm $::mom_spindle_speed
                }
                MOM_force_block once spindle_rpm_turn
                MOM_do_template spindle_rpm_turn
              }
            } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
              set mom_sys_contour_feed_mode(LINEAR) "MMPR"
              set mom_sys_rapid_feed_mode(LINEAR) "MMPR"
              if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
                set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
              }
              if {[CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {
                MOM_do_template spindle_max_rpm
              }

              if {[MOM_do_template spindle_smm_turn CREATE] != ""} {
                if {[CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {MOM_do_template spindle_max_rpm CREATE}
                MOM_force_block once spindle_smm_turn
                MOM_do_template spindle_smm_turn
              }
            }
          }
        }
      } @CYCLE
    }
    "limit" {
      LIB_GE_command_buffer {
        # turning only
        if {($mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM") && [CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {
          if {([info exists mom_spindle_maximum_rpm_toggle] && $mom_spindle_maximum_rpm_toggle == 1) || [CONF_CTRL_spindle spindle_max_rpm_output_always]} {
            if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
              set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
            }
            MOM_do_template spindle_max_rpm
          }
        }
      } @LIMIT
    }
    "default" {
      switch -- $mom_machine_mode {
        "MILL" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm CREATE
            } else {
              # Always RPM output for milling
              if {[CONF_CTRL_spindle spindle_output_alone] == 1 || [info level 1] == "MOM_spindle_rpm"} {
                MOM_do_template spindle_rpm
              }
            }
            set ::check_list(spindle,status) 1
          } @DEFAULTMILL
        }
        "TURN" {
          LIB_GE_command_buffer {
            if {([info exist mom_nxt_event_data(mom_motion_type)] && ![string match "CYCLE" $mom_nxt_event_data(mom_motion_type)]) ||\
              ([info exist mom_nxt_motion_type] && ![string match "CYCLE" $mom_nxt_motion_type])} {
              if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
                MOM_do_template spindle_rpm_turn CREATE
              } elseif {$mom_spindle_mode == "RPM"} {
                if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
                  MOM_force_block once spindle_rpm_turn
                  MOM_do_template spindle_rpm_turn
                }

              } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
                set mom_sys_contour_feed_mode(LINEAR) "MMPR"
                set mom_sys_rapid_feed_mode(LINEAR) "MMPR"
                if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
                  set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
                }
                if {[CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {
                  if {([info exists mom_spindle_maximum_rpm_toggle] && $mom_spindle_maximum_rpm_toggle == 1) || [CONF_CTRL_spindle spindle_max_rpm_output_always]} {
                  MOM_do_template spindle_max_rpm
                  }
                }

                set spindle_mode $mom_spindle_mode

                if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
                    set spindle_mode "RPM"
                } else {
                  set spindle_mode "SFM"
                }

                LIB_GE_command_buffer SPINDLE_SMM
                LIB_GE_command_buffer {
                  if {($mom_current_motion == "initial_move" || $mom_current_motion == "first_move") && [MOM_do_template spindle_smm_turn CREATE] != ""} {
                    MOM_force_block once spindle_smm_turn
                    if {[CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {MOM_do_template spindle_max_rpm CREATE}
                    MOM_do_template spindle_smm_turn
                  }
                } @DEFAULTTURNSMM
                LIB_GE_command_buffer_output

              }
            }
          } @DEFAULTTURN
        }
      }
    }
  }
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY end_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Controls the spindle start conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_end {} {

  set ::check_list(spindle,status) 0

  LIB_GE_command_buffer SPINDLE_END
  LIB_GE_command_buffer {MOM_do_template spindle_off} @SPINDLE_OFF_1
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the spindle end conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_spindle_orient {} {

  global mom_machine_mode

  LIB_GE_command_buffer SPINDLE_ORIENT

  LIB_GE_command_buffer {
    if {$mom_machine_mode == "MILL"} {MOM_do_template spindle_off}
  } @SPINDLE_OFF

  LIB_GE_command_buffer {
    MOM_force Once S_pos
    MOM_do_template spindle_orient2
  } @SPOS

  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# It used to output spindle orient code SPOS.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)] && $lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXLU
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_ylu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYLU
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZLU
          }
      }
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXUL
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_yul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYUL
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZUL
          }
      }
      set lib_flag(current_safety_position) 0
    }
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {unset lib_flag(current_plane_upper_than_previous)}
  }
  LIB_GE_command_buffer {
    LIB_CTRL_clamp_axis
  } @CLAMP
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the standard case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_pos {} {

  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_POS

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_pos) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)] && $lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXLU
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_ylu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYLU
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zlu]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZLU
          }
      }
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEXUL
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_yul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEYUL
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zul]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEZUL
          }
      }
      set lib_flag(current_safety_position) 0
    }
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {unset lib_flag(current_plane_upper_than_previous)}
  }
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_sim {} {

  global mom_motion_event
  global lib_flag

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_SIM

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_sim) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    LIB_GE_command_buffer {
      set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
      LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
    } @DECOMPOSE
  }
  LIB_GE_command_buffer_output
  set lib_flag(current_safety_position) 0
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning simultanous first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_check_cutcom_condition {} {

  global lib_flag
  global mom_motion_event mom_path_name
  global mom_pos mom_prev_pos tool_axis

  if {[info exists lib_flag(check_cutcom_start_move)] && $lib_flag(check_cutcom_start_move) == 1} {
    if {$mom_motion_event == "circular_move"} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- has to be a linear move"

    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_mag move] > 0 && [VEC3_is_parallel move tool_vector] == 1} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_start_move) 2
  } elseif {[info exists lib_flag(check_cutcom_end_move)] && $lib_flag(check_cutcom_end_move)} {
    if {$mom_motion_event == "circular_move"} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- has to be a linear move"
    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_is_parallel move tool_vector] == 1} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_end_move) 0
  }

}
# <Internal Documentation>
#
# This allows to check the first move after cutcom is switched on or off
# This is meant to do checks like first move has not to be a circular move
# The flags lib_flag(check_cutcom_start_move) and lib_flag(check_cutcom_end_move) are triggering this check
# those flags are set in MOM_cutcom_on and MOM_cutcom_off
#
# Proc has to be moved to controller level to implement controller specific checks
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_handle_generic_cycle_start_motion {} {
#=============================================================

  global mom_sys_cycle95_start_motion
  global mom_sys_output_cycle95
  global mom_machine_control_motion_output

  if {[info exists mom_sys_cycle95_start_motion] && ![string compare $mom_sys_cycle95_start_motion "After Cycle"]} {

    #skip to next generic_cycle which should be cycle end
    MOM_skip_handler_to_event generic_cycle

    # Don't output first point, it is included in cycle95
    MOM_suppress once X Z
    unset mom_sys_cycle95_start_motion

  } elseif {([info exists mom_machine_control_motion_output] && $mom_machine_control_motion_output == 2) && \
        ([info exists mom_sys_output_cycle95] && $mom_sys_output_cycle95)} {

    set mom_sys_cycle95_start_motion "Before Cycle"
  }

}
# <Internal Documentation>
# This command should be only attached on initial move and first move.
#
# This command is used to handle initial_move or first_move event
# generated after generic_cycle for lathe rough cycle output.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_generic_cycle_LIB {} {
#=============================================================

  set commandcheck(MOM_generic_cycle_LIB_ENTRY) [llength [info commands MOM_generic_cycle_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_generic_cycle_status
  global mom_sys_output_contour_motion
  global mom_sys_cycle95_start_motion

  if {$mom_generic_cycle_status == 1} {

    # Init cycle95 output at generic cycle start
    LIB_CTRL_init_cycle95_output

    if {[info exist mom_sys_output_contour_motion] && $mom_sys_output_contour_motion == 1} {

      if {[info exists mom_sys_cycle95_start_motion] && ![string compare $mom_sys_cycle95_start_motion "Before Cycle"]} {

        # Skip to next generic cycle which should be cycle end
        MOM_skip_handler_to_event generic_cycle

        unset mom_sys_cycle95_start_motion

      } else {

        set mom_sys_cycle95_start_motion "After Cycle"
      }
    }

  } elseif {$mom_generic_cycle_status == 0} {

    if {[info exist mom_sys_output_contour_motion] && $mom_sys_output_contour_motion == 1} {

      # Output cycle95 statement
      LIB_CTRL_lathe_roughing
      MOM_force Once G_motion
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This event is generated for lathe rough cycle operation.
# All motion events contained inside will be replaced by CYCLE95, including non cutting motions.
#
# Following mom variable will be set in this event
#   mom_generic_cycle_status
#      1      start of cycle
#      0      end of cycle
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_init_cycle95_output {} {

#-----------------------------------------------------------------------------
# This command gathers information to determine if NX/Post should
# process contour data and produce subprogram & cycle95 instructions.
#
# The state of variable "mom_machine_control_motion_output" will indicate
# when turning processor will produce contour data whereas the variable
# "mom_sys_output_cycle95" indicates that post is equipped with the ability
# to output CYCLE95. This ability can be activated in the event below:
#
#   "Program & Tool Path"
#      -> "Program"
#          -> "Canned Cycles" -> "Turn Roughing"
#
#*****************************************************************************
# This command will only function when
#  - Turning processor has produced contour data
#  - The post is equipped with the ability to output cycle95
#
# What can be done here?
#  1. Specify labels and/or subprogram name
#  2. Validate subprogram name
#*****************************************************************************

  global mom_sys_output_contour_motion
  global mom_machine_control_motion_output
  global mom_sys_output_cycle95
  global mom_machine_cycle_subroutine_name
  global mom_operation_name

  set mom_sys_output_contour_motion 0

  #======================================================
  # When turning processor has produced contour data and
  # post is equipped with the ability to output cycle95:
  #======================================================
  if {([info exists mom_machine_control_motion_output] && $mom_machine_control_motion_output == 2) && \
    ([info exists mom_sys_output_cycle95] && $mom_sys_output_cycle95)} {

    #----------------------------------------
    # Notify NX/Post to process contour data
    #----------------------------------------
    set mom_sys_output_contour_motion 1

    #++++++++++++++++++++++++++++++++++++++++++++++++
    # Defined start & end labels and subprogram name
    # ==> User may customize these labels as needed.
    #++++++++++++++++++++++++++++++++++++++++++++++++
    global mom_sys_cycle95_subprogram_name
    global mom_sys_cycle95_subprogram_start
    global mom_sys_cycle95_subprogram_end

    # Define subprogram name when it is not specified in NX.
    if { ![info exists mom_machine_cycle_subroutine_name] } {
      set  mom_machine_cycle_subroutine_name SUB_$mom_operation_name
      set mom_sys_cycle95_subprogram_end    "[string toupper $mom_operation_name]_END"
    } elseif { ![string compare "" $mom_machine_cycle_subroutine_name] } {
      set  mom_machine_cycle_subroutine_name SUB_$mom_operation_name
      set mom_sys_cycle95_subprogram_end    "[string toupper $mom_operation_name]_END"
    } else {
      set mom_sys_cycle95_subprogram_end    "[string toupper $mom_machine_cycle_subroutine_name]_END"
    }

    set mom_sys_cycle95_subprogram_name   "[string toupper $mom_machine_cycle_subroutine_name]"
    set mom_sys_cycle95_subprogram_start  "[string toupper $mom_machine_cycle_subroutine_name]"

    # Validate subprogram name and labels
    LIB_CTRL_check_subroutine_name
  }

}
# <Internal Documentation>
# This function should be called in the event whose position can be output
# as the "ready position" (outside of stock) for the CYCLE95 call.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_check_subroutine_name {} {

  global mom_machine_cycle_subroutine_name
  global mom_operation_name
  global machine_cycle_subroutine_list
  global mom_sys_cycle95_subprogram_name
  global mom_sys_cycle95_subprogram_start
  global mom_sys_cycle95_subprogram_end

  if {[string match "LBL*" [CONF_S840D_cycle95 cycle95_output_mode]]} {

    if {[string length $mom_sys_cycle95_subprogram_start]>31} {
      LIB_SPF_add_warning "Labels name in Operation $mom_operation_name should not more than 31 characters."
      set mom_sys_cycle95_subprogram_start [string range $mom_sys_cycle95_subprogram_start 0 30]
    }

    if {[string length $mom_sys_cycle95_subprogram_end]>31} {
      LIB_SPF_add_warning "Labels name in Operation $mom_operation_name should not more than 31 characters."
      set mom_sys_cycle95_subprogram_end [string range $mom_sys_cycle95_subprogram_end 0 26]_END
    }

    if {![regexp {^[A-Za-z][A-Za-z][A-Za-z0-9_]*$} $mom_sys_cycle95_subprogram_start]} {
      LIB_SPF_add_warning "Labels name in Operation $mom_operation_name should be letters, numerals or underscore characters.\
                \n The first two characters must be letters."
    }

    if {![regexp {^[A-Za-z][A-Za-z][A-Za-z0-9_]*$} $mom_sys_cycle95_subprogram_end]} {
      LIB_SPF_add_warning "Labels name in Operation $mom_operation_name should be letters, numerals or underscore characters.\
                \n The first two characters must be letters."
    }

  } else {

    if {[string length $mom_sys_cycle95_subprogram_name]>31} {
      LIB_SPF_add_warning "Subroutine name in Operation $mom_operation_name should not more than 31 characters."
      set mom_sys_cycle95_subprogram_name [string range $mom_sys_cycle95_subprogram_name 0 30]
    }

    if {![regexp {^[A-Za-z][A-Za-z][A-Za-z0-9_]*$} $mom_sys_cycle95_subprogram_name]} {
      LIB_SPF_add_warning "Subroutine name in Operation $mom_operation_name should be letters, numerals or underscore characters.\
                \n The first two characters must be letters."
    }
  }

  if {![info exists machine_cycle_subroutine_list]} {

    set machine_cycle_subroutine_list [list $mom_machine_cycle_subroutine_name]

  } else {

    foreach subroutine $machine_cycle_subroutine_list {

      if {[string compare $subroutine $mom_machine_cycle_subroutine_name]} {

        lappend machine_cycle_subroutine_list $mom_machine_cycle_subroutine_name

      } else {

        LIB_SPF_add_warning "Subroutine name $mom_machine_cycle_subroutine_name is duplicated in Operation $mom_operation_name"
      }
    }
  }

}
# <Internal Documentation>
# This function is used to check if subroutine's name is valid.
# The first two characters must be letters.
# The others can be letters, numerals or underscore characters.
# Do not use more than 31 characters.
# No separators are to be used.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_lathe_roughing {} {

  LIB_CTRL_map_cycle95_param

  LIB_GE_command_buffer LATHE_ROUGHING
  LIB_GE_command_buffer {
    # MOM_do_template lathe_roughing doesn't need anymore, to avoid exisiting customization fail, add existing check and remove lathe_roughing from def file.
    if {[LIB_SPF_exists_block_template lathe_roughing 1]} {
      MOM_do_template lathe_roughing
    }
  } @OUTPUT
  LIB_GE_command_buffer {
    if { [CONF_S840D_controller sinumerik_control_version] == "Solutionline" } {
      LIB_SPF_call_cycle "CYCLE95,Solutionline"
    } else {
      LIB_SPF_call_cycle CYCLE95
    }
  } @CYCLEOUTPUT
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is used to output CYCLE95 statement.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_map_cycle95_param {} {

  global mom_siemens_cycle_subroutine_name
  global mom_siemens_cycle_mid
  global mom_cut_depth
  global mom_maximum
  global mom_stepover
  global mom_local_return_dwell_flag
  global mom_local_return_dwell
  global mom_local_return_dwell_unit
  global mom_local_return_status
  global mom_local_return_distance
  global mom_siemens_cycle_dam
  global mom_feed_cut_unit
  global mom_feed_cut_value
  global mom_feed_stepover_unit
  global mom_feed_stepover_value
  global mom_feedrate_profile_cut_unit
  global mom_feedrate_profile_cut
  global mom_spindle_mode
  global mom_sys_cycle95_subprogram_name
  global mom_sys_cycle95_subprogram_start
  global mom_sys_cycle95_subprogram_end

  # Subroutine name string to be referenced in CYCLE95 call
  if {[string match "SUB" [CONF_S840D_cycle95 cycle95_output_mode]]} {
    set mom_siemens_cycle_subroutine_name $mom_sys_cycle95_subprogram_name
  } else {
    set mom_siemens_cycle_subroutine_name ${mom_sys_cycle95_subprogram_start}:${mom_sys_cycle95_subprogram_end}
  }

  # MID infeed depth
  global mom_turn_cycle_cut_depth
  global mom_sys_lathe_x_double

  if {[info exists mom_turn_cycle_cut_depth]} {

    set mom_siemens_cycle_mid $mom_turn_cycle_cut_depth

  } else {

    if {[info exists mom_stepover]} {

      if {$mom_stepover == 0} {
        set mom_siemens_cycle_mid $mom_cut_depth
      } elseif {$mom_stepover == 1 || $mom_stepover == 2}  {
        set mom_siemens_cycle_mid $mom_maximum
      }

    }
  }

  if {[LIB_SPF_check_x_factor TURN] == 2} {
    set mom_siemens_cycle_mid [expr 2*$mom_siemens_cycle_mid]
  }

  # Feedrate
  global mom_operation_name
  global feed_mode

  if {[string match "SFM" $mom_spindle_mode] || [string match "SMM" $mom_spindle_mode]} {

    if {[string match "ipm" $mom_feed_cut_unit] || [string match "mmpm" $mom_feed_cut_unit]} {

      LIB_SPF_add_warning "WARNING: Cut feed rate unit $mom_feed_cut_unit doesn't match\
                spindle speed mode $mom_spindle_mode in $mom_operation_name!"
    }

  } else {

    set feed_mode [string toupper $mom_feed_cut_unit]
  }

  if {[string compare $mom_feed_cut_unit $mom_feed_stepover_unit]} {

    LIB_SPF_add_warning "WARNING: Stepover and Cut feed rate unit are different in $mom_operation_name!"
    LIB_SPF_add_warning "         In CYCLE95, FF2 will be as same as FF1!"

    set mom_feed_stepover_value $mom_feed_cut_value
  }

  if {[EQ_is_zero $mom_feed_stepover_value]} {
    set mom_feed_stepover_value $mom_feed_cut_value
  }

  if {[info exists mom_feedrate_profile_cut]} {

    if {$mom_feedrate_profile_cut_unit == 4} {

      set mom_feedrate_profile_cut [expr $mom_feed_cut_value*$mom_feedrate_profile_cut/100]

    } elseif {($mom_feedrate_profile_cut_unit == 1 && ![string match "*pm" $mom_feed_cut_unit]) || \
          ($mom_feedrate_profile_cut_unit == 2 && ![string match "*pr" $mom_feed_cut_unit])} {

      LIB_SPF_add_warning "WARNING: Profile cut and Cut feed rate unit are different in $mom_operation_name!"
      LIB_SPF_add_warning "         In CYCLE95, FF3 will be as same as FF1!"

      set mom_feedrate_profile_cut $mom_feed_cut_value

    } else {

      if {[EQ_is_zero $mom_feedrate_profile_cut]} {
        set mom_feedrate_profile_cut $mom_feed_cut_value
      }
    }
  }

  # Convert feed rate unit
  global mom_kin_output_unit mom_part_unit mom_output_unit
  if {![info exists mom_output_unit]} {set mom_output_unit $mom_kin_output_unit}

  if {![string compare $mom_output_unit $mom_part_unit]} {
    set mom_sys_unit_conversion "1.0"
  } elseif {![string compare "IN" $mom_output_unit]} {
    set mom_sys_unit_conversion [expr 1.0/25.4]
  } else {
    set mom_sys_unit_conversion 25.4
  }

  set mom_feed_cut_value [expr $mom_sys_unit_conversion*$mom_feed_cut_value]
  set mom_feed_stepover_value [expr $mom_sys_unit_conversion*$mom_feed_stepover_value]

  if {[info exists mom_feedrate_profile_cut]} {
    set mom_feedrate_profile_cut  [expr $mom_sys_unit_conversion*$mom_feedrate_profile_cut]
  }

  # DT-dwell time
  if {$mom_local_return_dwell_flag == 0} {

    set mom_local_return_dwell 0

  } else {

    if {$mom_local_return_dwell_unit == 1} {
      LIB_SPF_add_warning "WARNING: Local return dwell unit should be SECONDS in $mom_operation_name."
      LIB_SPF_add_warning "         DT value in CYCLE95 is the revolution value."
    }
  }

  # DAM
  if {[info exists mom_local_return_status] && $mom_local_return_status > 0} {
    set mom_siemens_cycle_dam $mom_local_return_distance
  } else {
    set mom_siemens_cycle_dam 0
  }

}
# <Internal Documentation>
# This function is collect the parameters for CYCLE95.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_linear_move_LIB {} {


  global lib_flag lib_param
  global mom_machine_mode
  global mom_sys_cycle95_start

  set commandcheck(MOM_linear_move_LIB_ENTRY) [llength [info commands MOM_linear_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$::mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves linear_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
        switch -- $lib_flag(mode_current_status) {
          "std" {
            LIB_ROTARY_positioning_first_move
          }
          "pos" {
            LIB_ROTARY_positioning_first_move_pos
          }
          "sim" {
            LIB_ROTARY_positioning_first_move_sim
          }
        }
      } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer TURN
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {LIB_CTRL_output_proper_address_for_3Dcutcom} @3DCUTCOM
    LIB_GE_command_buffer {
      if {![info exists mom_sys_cycle95_start] || !$mom_sys_cycle95_start} {
        MOM_do_template [CONF_CTRL_moves linear_template]
      } else {
        LIB_CTRL_output_contour_for_cycle95
      }
    } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {LIB_CTRL_output_proper_address_for_3Dcutcom} @3DCUTCOM
    LIB_GE_command_buffer {
      if {![info exists mom_sys_cycle95_start] || !$mom_sys_cycle95_start} {
        MOM_do_template [CONF_CTRL_moves linear_template]
      } else {
        LIB_CTRL_output_contour_for_cycle95
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_LIB {} {

  global lib_param

  global mom_sys_cycle95_start check_list

  set commandcheck(MOM_circular_move_LIB_ENTRY) [llength [info commands MOM_circular_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {
      if {$check_list(spindle,status) != 1} {LIB_SPINDLE_start}
    } @SPINDLE
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {
      if {![info exists mom_sys_cycle95_start] || !$mom_sys_cycle95_start} {
        MOM_do_template [CONF_CTRL_moves circular_template]
      } else {
        LIB_CTRL_output_contour_for_cycle95
      }
    } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {
      if {![info exists mom_sys_cycle95_start] || !$mom_sys_cycle95_start} {
        MOM_do_template [CONF_CTRL_moves circular_template]
      } else {
        LIB_CTRL_output_contour_for_cycle95
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen

# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_output_contour_for_cycle95 {} {

  global mom_sys_cycle95_start
  global mom_motion_event

  LIB_GE_command_buffer CYCLE95
  LIB_GE_command_buffer {
    if {[string match "LBL_END" [CONF_S840D_cycle95 cycle95_output_mode]]} {
      global cycle95_contour_file
      set o_buffer [MOM_do_template ${mom_motion_event}_cycle95 CREATE]
      lappend cycle95_contour_file $o_buffer
    } else {
      MOM_do_template ${mom_motion_event}_cycle95
    }
  } @OUTPUT
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is used to check whether cycle95 is being used to output.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_helix_move_LIB {} {

  global mom_helix_turn_number
  global lib_arc_axis

  set commandcheck(MOM_helix_move_LIB_ENTRY) [llength [info commands MOM_helix_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer OUTPUT
  LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
  LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
  LIB_GE_command_buffer {LIB_HELIX_nturn $lib_arc_axis} @HELIX_NTURN
  LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]} @MOVE
  LIB_GE_command_buffer_output

  unset mom_helix_turn_number

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_HELIX_nturn {axis} {

  global mom_prev_pos mom_pos mom_helix_pitch mom_arc_angle
  global mom_helix_turn_number mom_kin_machine_resolution

  set delta [expr abs($mom_pos($axis) - $mom_prev_pos($axis))]

  if {![EQ_is_equal $mom_helix_pitch 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number [expr floor([LIB_SPF_round [expr $delta / [expr abs($mom_helix_pitch)]] $mom_kin_machine_resolution])]
    if {[EQ_is_equal $delta [expr $mom_helix_turn_number * abs($mom_helix_pitch)] $mom_kin_machine_resolution]} {
      set mom_helix_turn_number [expr $mom_helix_turn_number - 1]
    }
  } elseif {![EQ_is_equal $delta 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number 1
  } else {
    set mom_helix_turn_number 0
  }

  if {[EQ_is_le $mom_arc_angle 360.0 $mom_kin_machine_resolution]} {
    MOM_suppress once helix_turn
  }
}
# <Internal Documentation>
# Calculate number of turns
# Linked to helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_opstop_LIB {mess} {
  global mom_opstop_text mom_opstop_text_defined

  set commandcheck(MOM_opstop_LIB_ENTRY) [llength [info commands MOM_opstop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_opstop_text_defined] && $mom_opstop_text_defined == 1} {
      LIB_GE_command_buffer MOM_opstop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "along_with_stop"} {
          MOM_do_template opstop BUFFER
        } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_opstop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_opstop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_opstop_LIB
      LIB_GE_command_buffer {
        MOM_do_template opstop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_opstop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "along_with_opstop"} {
        MOM_do_template opstop BUFFER
      } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_AFTER_MSG
  }

  LIB_GE_command_buffer MOM_opstop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_opstop_text]} {unset mom_opstop_text}
  if {[hiset mom_opstop_text_defined]} {unset mom_opstop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_stop_LIB {mess} {
  global mom_stop_text mom_stop_text_defined

  set commandcheck(MOM_stop_LIB_ENTRY) [llength [info commands MOM_stop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_stop_text_defined] && $mom_stop_text_defined == 1} {
      LIB_GE_command_buffer MOM_stop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
          MOM_do_template stop BUFFER
        } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_stop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_stop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_stop_LIB
      LIB_GE_command_buffer {
        MOM_do_template stop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_stop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
        MOM_do_template stop BUFFER
      } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_AFTER_MSG
  }
  LIB_GE_command_buffer MOM_stop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_stop_text]} {unset mom_stop_text}
  if {[hiset mom_stop_text_defined]} {unset mom_stop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_nurbs_move_LIB {} {

  set commandcheck(MOM_nurbs_move_LIB_ENTRY) [llength [info commands MOM_nurbs_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_start_LIB {} {

  set commandcheck(MOM_contour_start_LIB_ENTRY) [llength [info commands MOM_contour_start_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_cycle95_contour_start) [llength [info commands LIB_CTRL_cycle95_contour_start]]

  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_cycle95_contour_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle95_contour_start)} {LIB_CTRL_cycle95_contour_start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle95_contour_start {} {

  global mom_sys_cycle95_subprogram_name
  global mom_sys_cycle95_subprogram_start
  global mom_sys_cycle95_subprogram_end

  global mom_sys_cycle95_start
  set mom_sys_cycle95_start 1

  if {[string match "SUB" [CONF_S840D_cycle95 cycle95_output_mode]]} {

    global mom_output_file_directory
    global cycle95_subroutine_file

    MOM_close_output_file $::mom_output_file_full_name

    set cycle95_subroutine_file "${mom_output_file_directory}${mom_sys_cycle95_subprogram_name}.SPF"

    if {[file exists $cycle95_subroutine_file]} {
      MOM_remove_file $cycle95_subroutine_file
    }

    MOM_open_output_file $cycle95_subroutine_file

    global mom_sequence_number mom_sequence_increment mom_sequence_frequency mom_seqnum
    global mom_sequence_number_saved mom_sequence_increment_saved mom_sequence_frequency_saved

    # Save sequence number
    set mom_sequence_number_saved $mom_seqnum
    set mom_sequence_increment_saved $mom_sequence_increment
    set mom_sequence_frequency_saved $mom_sequence_frequency

    # Set sequence number for subprogram
    set mom_sequence_number     100
    set mom_sequence_increment  10
    set mom_sequence_frequency  1

    MOM_reset_sequence $mom_sequence_number $mom_sequence_increment $mom_sequence_frequency

  } elseif {[string match "LBL" [CONF_S840D_cycle95 cycle95_output_mode]]} {

    # Output instruction for main program to skip over the in-line subprogram
    # - All in-line labels are in upper case.
    LIB_GE_command_buffer CYCLE95
    LIB_GE_command_buffer {MOM_output_literal "GOTOF $mom_sys_cycle95_subprogram_end"} @JUMPLABEL

    # Output start label for in-line subprogram
    LIB_GE_command_buffer {MOM_output_text "${mom_sys_cycle95_subprogram_start}:"} @SUBPROGRAMSTART
    LIB_GE_command_buffer_output

  } else {

    global cycle95_contour_file

    if {![info exists cycle95_contour_file]} {
      set cycle95_contour_file [list]
    }

    lappend cycle95_contour_file "${mom_sys_cycle95_subprogram_start}:"
  }

  MOM_force Once G_motion X Z

}
# <Internal Documentation>
# This function is used to collect the information of part contour.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_contour_end_LIB {} {

  set commandcheck(MOM_contour_end_LIB_ENTRY) [llength [info commands MOM_contour_end_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_cycle95_contour_end) [llength [info commands LIB_CTRL_cycle95_contour_end]]

  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_cycle95_contour_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle95_contour_end)} {LIB_CTRL_cycle95_contour_end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle95_contour_end {} {

  global mom_sys_cycle95_start
  set mom_sys_cycle95_start 0

  if {[string match "SUB" [CONF_S840D_cycle95 cycle95_output_mode]]} {

    global mom_output_file_directory
    global cycle95_subroutine_file

    if {[info exists cycle95_subroutine_file]} {

      MOM_output_literal "M17"
      MOM_close_output_file $cycle95_subroutine_file

      # Restore sequence number
      global mom_sequence_number mom_sequence_increment mom_sequence_frequency
      global mom_sequence_number_saved mom_sequence_increment_saved mom_sequence_frequency_saved

      set mom_sequence_number $mom_sequence_number_saved
      set mom_sequence_increment $mom_sequence_increment_saved
      set mom_sequence_frequency $mom_sequence_frequency_saved
      MOM_reset_sequence $mom_sequence_number $mom_sequence_increment $mom_sequence_frequency
    }

    MOM_open_output_file $::mom_output_file_full_name

  } elseif {[string match "LBL" [CONF_S840D_cycle95 cycle95_output_mode]]} {

    global mom_sys_cycle95_subprogram_end

    # Output end label for in-line subprogram
    MOM_output_text "${mom_sys_cycle95_subprogram_end}:"

  } else {

    global cycle95_contour_file
    global mom_sys_cycle95_subprogram_end

    lappend cycle95_contour_file "${mom_sys_cycle95_subprogram_end}:"
  }

  #+++++++++++++++++++++++++++++++++++++++++
  # Tell NX/Post to end contour output mode
  #+++++++++++++++++++++++++++++++++++++++++
  global mom_sys_output_contour_motion
  set mom_sys_output_contour_motion 0

  #--------------------------
  # handle machine time
  #--------------------------
  global mom_sys_machine_time mom_machine_time mom_toolpath_time

  if {[info exists mom_sys_machine_time]} {

    set mom_machine_time [expr $mom_sys_machine_time + $mom_toolpath_time]

    MOM_reload_variable mom_machine_time
  }

}
# <Internal Documentation>
# This function is used to collect the information of part contour.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_on_LIB {} {
  global mom_kin_is_turbo_output
  global lib_cutcom_radius

  set commandcheck(MOM_cutcom_on_LIB_ENTRY) [llength [info commands MOM_cutcom_on_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cutcom_on_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_on_LIB_ENTRY)} {MOM_cutcom_on_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  if {$mom_kin_is_turbo_output && [CONF_CTRL_tool cutcom_actual_radius] == 1} {
    set mom_kin_is_turbo_output "FALSE"
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {[CONF_CTRL_tool cutcom_actual_radius] == 1 && ![EQ_is_zero $lib_cutcom_radius]} {
    MOM_output_literal "OFFN=[format "%.3f" [expr $lib_cutcom_radius * -1]]"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cutcom_on_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_on_LIB_ENTRY)} {MOM_cutcom_on_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_cutcom_off_LIB {} {
  global lib_cutcom_radius

  set commandcheck(MOM_cutcom_off_LIB_ENTRY) [llength [info commands MOM_cutcom_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cutcom_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_off_LIB_ENTRY)} {MOM_cutcom_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer CUTCOM_OFF
  LIB_GE_command_buffer {
    if {[CONF_CTRL_tool cutcom_actual_radius] == 1 && ![EQ_is_zero $lib_cutcom_radius]} {
      if {[CONF_CTRL_setting cutcom_off_alone] == 1} {
        MOM_add_to_address_buffer G_cutcom end "OFFN=0"
        MOM_do_template cutcom_off
      } else {
        MOM_output_literal "OFFN=0"
      }
    } else {
      if {[CONF_CTRL_setting cutcom_off_alone] == 1} {
        MOM_do_template cutcom_off
      }
    }
  } @OUTPUT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cutcom_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_off_LIB_ENTRY)} {MOM_cutcom_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_gohome_move_LIB {} {

  global mom_motion_type

  set commandcheck(MOM_gohome_move_LIB_ENTRY) [llength [info commands MOM_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_motion_type == "GOHOME_DEFAULT"} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
  } else {
    MOM_rapid_move
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_path_LIB {} {

  global lib_flag
  global mom_next_oper_has_tool_change mom_current_oper_is_last_oper_in_program mom_next_main_mcs mom_main_mcs
  global mom_path_name mom_operation_name mom_machine_mode mom_out_angle_pos mom_kin_is_turbo_output mom_tool_axis
  global mom_flip_a_axis mom_tool_holder_angle_for_cutting mom_siemens_cycle_amode
  global lib_pretreatment mom_tool_pitch mom_polar_status mom_coordinate_output_mode
  global mom_output_mcs_name lib_parameter nxt_oper_tool_axis
  global lib_prev_tool_name mom_next_tool_name

  set commandcheck(MOM_end_of_path_LIB_ENTRY) [llength [info commands MOM_end_of_path_LIB_ENTRY]]
  set commandcheck(LIB_unset_variables_in_end_of_path) [llength [info commands LIB_unset_variables_in_end_of_path]]

  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check "spindle" ;# to be sure S and M_spindle addresses are enable for next operation

  if {[CONF_CTRL_setting turbo_mode] == 1} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode disable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {[info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE"} {
    if {[llength [info commands MOM_set_turbo_feedrate_set]]} {MOM_set_turbo_feedrate_set ON}
  }

  if {$mom_machine_mode != "TURN" && [CONF_CTRL_moves polar_off_end_of_path] == "OFF"} {
    set mom_polar_status OFF
    set mom_coordinate_output_mode OFF
  }

  if {[info exists mom_siemens_cycle_amode]} {unset mom_siemens_cycle_amode}

  if {![info exists mom_output_mcs_name($mom_operation_name)]}      {set mom_output_mcs_name($mom_operation_name) $mom_main_mcs}
  if {![info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1])]} {set mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) $mom_next_main_mcs}

  # mom_pos(3) and mom_pos(4) are not overwritten if there is an CSYS-Rotation with Toolaxis Z and parallel to TA
  # PR10021397: compare last tool axis of current operation with first tool axis of next operation,
  # because mom_tool_axis saved in pretreatment is always from last motion event.
  if {[LIB_SPF_get_pretreatment "init_tool_axis,0" 1] == ""} {
    array set nxt_oper_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  } else {
    array set nxt_oper_tool_axis "0 [LIB_SPF_get_pretreatment "init_tool_axis,0" 1] 1 [LIB_SPF_get_pretreatment "init_tool_axis,1" 1] 2 [LIB_SPF_get_pretreatment "init_tool_axis,2" 1]"
  }
  if {([CONF_CTRL_moves reset_rotary_axis_end_of_path] == "ON" && ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] &&\
    [LIB_SPF_get_pretreatment axis_mode next] != "SIMULTANEOUS") ||\
     ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

  if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES" ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) && [CONF_CTRL_moves safety_motion_when_mcs_changes] == 1)} {

    switch -- $mom_machine_mode {
      "TURN" {
        LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,TURN
        LIB_GE_command_buffer {LIB_TURNING_mode end} @TURN_END
        LIB_GE_command_buffer {LIB_ROTARY_positioning_reset} @RESET_ROTARY
        LIB_GE_command_buffer_output
      }
      "MILL" {
        LIB_CTRL_polar_transmit "off"
        if {$lib_flag(tool_path_motion) > 0} {
          if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,SIM
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_simultaneous_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          } else {
            #!!! if next op has different mom_out_angle_pos reset as well
            # (maybe compare current and next angle from Pretreatment)
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,POS
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $::lib_sav_kin_machine_type == "3_axis_mill" || $lib_flag(tool_axis_zm) == 1} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_positioning_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          }
        }
      }
    }

    LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,COMMON

    if {$::mom_oper_tool != "NONE" || ([info exist lib_prev_tool_name] && $lib_prev_tool_name != $mom_next_tool_name) } {
    LIB_GE_command_buffer {LIB_local_origin_reset} @LOCAL_ORIG_RESET
    LIB_GE_command_buffer {
      if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
        LIB_WRITE_coolant off
      }
    } @COOLANT_OFF
    LIB_GE_command_buffer {
      if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
        LIB_SPINDLE_end
      }
    } @SPINDLE_OFF
    LIB_GE_command_buffer {
      if {$mom_current_oper_is_last_oper_in_program == "YES"} {
        if {[CONF_CTRL_moves return_end_of_pgm] != ""} {
          LIB_RETURN_move CONF_CTRL_moves return_end_of_pgm
        }
      } else {
        if {[CONF_CTRL_moves return_tool_change_pos] != ""} {
          LIB_RETURN_move CONF_CTRL_moves return_tool_change_pos
        }
      }
    } @RETURN_MOVE
    }

    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 0

  } else {

    switch -- $mom_machine_mode {
      "TURN" {

        set nxt_flip_a_axis [LIB_SPF_get_pretreatment mom_flip_a_axis 1]
        set nxt_tool_holder_angle_for_cutting [LIB_SPF_get_pretreatment mom_tool_holder_angle_for_cutting 1]

        if {![info exists mom_tool_holder_angle_for_cutting] || ![EQ_is_equal $nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting]} {

          LIB_GE_command_buffer TURN_HOLDER_ORIENT_CHANGE

          # check if B axis position change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {
            if {[CONF_CTRL_moves return_safety_pos] != ""} {
              LIB_RETURN_move CONF_CTRL_moves return_safety_pos
            }
          } @RETURN_MOVE
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output

        } elseif {[info exists mom_flip_a_axis] && $nxt_flip_a_axis != $mom_flip_a_axis} {

          LIB_GE_command_buffer TURN_TOOL_FLIP_CHANGE
          # check if spindle direction change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output
        }

      }
      "MILL" {
        if {$lib_flag(first_transmit_move) == 1 && ([CONF_CTRL_moves polar_off_end_of_path] == "OFF" || ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] || [LIB_SPF_get_pretreatment axis_mode next] == "SIMULTANEOUS") ||\
           ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
          LIB_CTRL_polar_transmit "off"
        }

        LIB_GE_command_buffer MILL_AXIS_CHANGE

        # If the variable does not exist in the query, an blank is returned

        LIB_GE_command_buffer {

          if {[LIB_SPF_pt_exists_not_empty "out_angle_pos_last,0" 0]} {
            set out_angle_pos(0) [LIB_SPF_get_pretreatment "out_angle_pos_last,0" 0]
            set out_angle_pos(1) [LIB_SPF_get_pretreatment "out_angle_pos_last,1" 0]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set out_angle_pos(0) $mom_out_angle_pos(0)
            set out_angle_pos(1) $mom_out_angle_pos(1)
          }

          if {[LIB_SPF_pt_exists_not_empty "mom_out_angle_pos,0" 1]} {
            set nxt_out_angle_pos(0) [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 1]
            set nxt_out_angle_pos(1) [LIB_SPF_get_pretreatment "mom_out_angle_pos,1" 1]
          } elseif {[llength [info command MOM_ask_next_event_data]]} {
            if {[MOM_ask_next_event_data -e first_move mom_out_angle_pos] } {
              set nxt_out_angle_pos(0) $::mom_nxt_event_data(mom_out_angle_pos,0)
              set nxt_out_angle_pos(1) $::mom_nxt_event_data(mom_out_angle_pos,1)
            } elseif {[MOM_ask_next_event_data -e msys mom_out_angle_pos] } {
              set nxt_out_angle_pos(0) $::mom_nxt_event_data(mom_out_angle_pos,0)
              set nxt_out_angle_pos(1) $::mom_nxt_event_data(mom_out_angle_pos,1)
            } else {
              set nxt_out_angle_pos(0) $out_angle_pos(0)
              set nxt_out_angle_pos(1) $out_angle_pos(1)
            }
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set nxt_out_angle_pos(0) $out_angle_pos(0)
            set nxt_out_angle_pos(1) $out_angle_pos(1)
          }

          # PR#9554274 incase operation's current status is not same as axis mode. It happened if there is only rapid motions in operation like GMC operation.
          if {([LIB_SPF_get_pretreatment axis_mode] != [LIB_SPF_get_pretreatment axis_mode 1] && ([LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || [LIB_SPF_get_pretreatment axis_mode 1] == "SIMULTANEOUS") )||\
              [LIB_SPF_is_floating $nxt_out_angle_pos(0)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(0) $out_angle_pos(0) $::mom_kin_4th_axis_min_incr] ||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(1)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(1) $out_angle_pos(1) $::mom_kin_5th_axis_min_incr] ||\
            ($lib_flag(mode_current_status) == "sim" &&  [LIB_SPF_get_pretreatment axis_mode] == "POSITIONING")} {
            if {$mom_machine_mode == "MILL" && $lib_flag(tool_path_motion) > 0} {
              if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
                if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                  LIB_ROTARY_absolute_reset
                } else {
                LIB_ROTARY_simultaneous_reset
                }
              } else {
                #!!! if next op has different mom_out_angle_pos reset as well
                # (maybe compare current and next angle from Pretreatment)

                if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {
                  LIB_ROTARY_absolute_reset
                } else {
                LIB_ROTARY_positioning_reset
                }
              }
              set lib_flag(tool_path_motion) 0
              if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
            }
          }
        } @RESET

        LIB_GE_command_buffer_output

      }
    }

  }

  # unset Variables if needed
  LIB_GE_command_buffer LIB_unset_variables_in_end_of_path
  LIB_GE_command_buffer {if {$commandcheck(LIB_unset_variables_in_end_of_path)} {LIB_unset_variables_in_end_of_path}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# * store oper info (for operation list)
# * mom_next_oper_has_tool_change == "YES"
# * mom_current_oper_is_last_oper_in_program == "YES"
# * mom_next_main_mcs != mom_main_mcs
# * check rot axis change PT
# if abs
# LIB_ROTARY_absolute_reset
# if sim
# LIB_ROTARY_simultaneous_reset
# if pos
# LIB_ROTARY_positioning_reset
# * retract before set axes (if needed) PT
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_unset_variables_in_end_of_path {} {

  global lib_flag
  global mom_siemens_cycle_dtb
  global mom_siemens_cycle_dts_mode
  global mom_siemens_cycle_dts
  global mom_siemens_cycle_o_dtd_mode
  global mom_siemens_cycle_o_dtd
  global mom_siemens_cycle_fdpr
  global mom_siemens_cycle_dam
  global mom_siemens_cycle_frf
  global mom_siemens_cycle_ffr
  global mom_siemens_cycle_rff
  global mom_siemens_cycle_sdir
  global mom_siemens_cycle_o_mdep
  global mom_cutter_data_output_indicator
  global mom_siemens_3Dcutcom_mode
  global mom_siemens_cycle_o_axn
  global mom_siemens_cycle_o_dtd
  global mom_siemens_cycle_o_dis1
  global mom_siemens_cycle_o_vrt
  global mom_siemens_cycle_o_ptab
  global mom_siemens_cycle_o_techno
  global mom_siemens_cycle_o_var1
  global mom_siemens_cycle_o_dam
  global mom_siemens_cycle_o_pitm
  global mom_siemens_cycle_o_ptab_sl
  global mom_siemens_cycle_o_ptaba
  global mom_siemens_cycle_pit
  global mom_cycle_orient
  global mom_siemens_cycle_sst1

  if {[info exists mom_siemens_cycle_dtb]}    {unset mom_siemens_cycle_dtb}
  if {[info exists mom_siemens_cycle_dts_mode]}     {unset mom_siemens_cycle_dts_mode}
  if {[info exists mom_siemens_cycle_dts]}    {unset mom_siemens_cycle_dts}
  if {[info exists mom_siemens_cycle_o_dtd_mode]}   {unset mom_siemens_cycle_o_dtd_mode}
  if {[info exists mom_siemens_cycle_o_dtd]}    {unset mom_siemens_cycle_o_dtd}
  if {[info exists mom_siemens_cycle_fdpr]}     {unset mom_siemens_cycle_fdpr}
  if {[info exists mom_siemens_cycle_dam]}    {unset mom_siemens_cycle_dam}
  if {[info exists mom_siemens_cycle_frf]}    {unset mom_siemens_cycle_frf}
  if {[info exists mom_siemens_cycle_ffr]}    {unset mom_siemens_cycle_ffr}
  if {[info exists mom_siemens_cycle_rff]}    {unset mom_siemens_cycle_rff}
  if {[info exists mom_siemens_cycle_sdir]}     {unset mom_siemens_cycle_sdir}
  if {[info exists mom_siemens_cycle_o_mdep]}     {unset mom_siemens_cycle_o_mdep}
  if {[info exists lib_flag(current_cutcom_mode)]}        {unset lib_flag(current_cutcom_mode)}
  if {[info exists mom_cutter_data_output_indicator]}     {set mom_cutter_data_output_indicator 0}
  if {[info exists mom_siemens_3Dcutcom_mode]}          {set mom_siemens_3Dcutcom_mode "OFF"}
  if {[info exists mom_siemens_cycle_o_axn]}    {unset mom_siemens_cycle_o_axn }
  if {[info exists mom_siemens_cycle_o_dis1]}     {unset mom_siemens_cycle_o_dis1}
  if {[info exists mom_siemens_cycle_o_vrt]}    {unset mom_siemens_cycle_o_vrt}
  if {[info exists mom_siemens_cycle_o_ptab]}     {unset mom_siemens_cycle_o_ptab}
  if {[info exists mom_siemens_cycle_o_techno]}     {unset mom_siemens_cycle_o_techno}
  if {[info exists mom_siemens_cycle_o_var1]}     {unset mom_siemens_cycle_o_var1}
  if {[info exists mom_siemens_cycle_o_dam]}    {unset mom_siemens_cycle_o_dam}
  if {[info exists mom_siemens_cycle_pit]}    {unset mom_siemens_cycle_pit}
  if {[info exists mom_siemens_cycle_o_pitm]}     {unset mom_siemens_cycle_o_pitm}
  if {[info exists mom_siemens_cycle_o_ptab_sl]}    {unset mom_siemens_cycle_o_ptab_sl}
  if {[info exists mom_siemens_cycle_o_ptaba]}    {unset mom_siemens_cycle_o_ptaba}
  if {[info exists mom_cycle_orient]}       {unset mom_cycle_orient}
  if {[info exists mom_siemens_cycle_sst1]}     {unset mom_siemens_cycle_sst1}
  if {[info exists ::lib_spf(do_convert_point)]}    {unset ::lib_spf(do_convert_point)}

  set ::lib_parameter(special_cycle,name) ""

  if {$::mom_next_oper_has_tool_change == "YES" || $::mom_current_oper_is_last_oper_in_program == "YES"} {
    if {[info exists ::mom_tool_pitch]} {unset ::mom_tool_pitch}
  }
}
# <Internal Documentation>
#
#  Unset Variables in End_of_path
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_program_LIB {} {

  set commandcheck(MOM_end_of_program_LIB_ENTRY) [llength [info commands MOM_end_of_program_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_output_cycle95_contour_file) [llength [info commands LIB_CTRL_output_cycle95_contour_file]]

  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer TOOL_CHANGE_EOP
  LIB_GE_command_buffer {
    MOM_force once T T_name M
    switch -- [join [CONF_CTRL_tool tool_change_eop]] {
      "off" {
        # nothing
      }
      "first_tool" {
        set ::mom_tool_name $::mom_next_tool_name
        set ::mom_tool_number $::mom_next_tool_number
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "unload_tool" {
        set ::mom_tool_number 0
        MOM_do_template tool_change
      }
      "default" {
        if {[string is integer -strict [CONF_CTRL_tool tool_change_eop]]} {
          set ::mom_tool_number [CONF_CTRL_tool tool_change_eop]
          if {[CONF_CTRL_tool auto_change_template] == "tool_change"} {
            MOM_do_template tool_change
          } else {
            MOM_do_template tool_change_number_name
          }
          MOM_do_template tool_change
        } else  {
          set ::mom_tool_name [CONF_CTRL_tool tool_change_eop]
          MOM_do_template tool_change_name
        }
      }
    }
  } @TOOL_CHANGE_END_OF_PROGRAM
  LIB_GE_command_buffer_output
  LIB_GE_command_buffer END_OF_PROGRAM
  LIB_GE_command_buffer {MOM_do_template end_of_program} @END_OF_PROG
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_CTRL_output_cycle95_contour_file
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_output_cycle95_contour_file)} {LIB_CTRL_output_cycle95_contour_file}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_output_cycle95_contour_file {} {

  global cycle95_contour_file

  if {[info exist cycle95_contour_file]} {

    MOM_output_text " "

    foreach line $cycle95_contour_file {

      MOM_output_literal $line
    }

    MOM_output_literal "M30"
  }

}
# <Internal Documentation>
# This function is used to output the contour data for cycle95.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_reset {} {

  global mom_sys_leader mom_sys_trailer
  global lib_flag lib_sav_sys_leader lib_sav_sys_trailer lib_sav_kin_machine_type

  set commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
    LIB_GE_command_buffer SIMULTANEOUS_RESET
    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_output_supported] == "ALL"} {
        MOM_do_template trafoof
      }
    } @TRAFOOF
    LIB_GE_command_buffer_output
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAFOOF
# Heidenhain: M129 / TCPM
# Fanuc: G49
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_reset {} {
  global lib_flag

  set commandcheck(LIB_ROTARY_absolute_reset_ENTRY) [llength [info commands LIB_ROTARY_absolute_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
    set lib_flag(mode_current_status) "std"
  }
  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
#  Switch off simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAFOOF
# Heidenhain: M129 / TCPM
# Fanuc: G49
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset {} {

  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_reset_ENTRY) [llength [info commands LIB_ROTARY_positioning_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    LIB_CSYS_plane_output_reset
  }
  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
# Switch off positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global lib_parameter lib_flag  mom_sys_leader mom_sys_trailer lib_sav_kin_machine_type

  set commandcheck(LIB_ROTARY_simultaneous_init_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_output] != "vector" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  LIB_CTRL_unclamp_axis

  if {$lib_flag(mode_current_status) != "sim"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_force once X_vector Y_vector Z_vector
      MOM_enable_address X_vector Y_vector Z_vector
      MOM_disable_address fourth_axis fifth_axis
    } else {
      MOM_force once fourth_axis fifth_axis
      MOM_enable_address fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }

    LIB_GE_command_buffer MILL,SIMULTANEOUS

    LIB_GE_command_buffer {
      if {[CONF_CTRL_setting tcpm_mode] == "TRAORI"} {
        #MOM_output_literal "TRAORI"
        MOM_do_template traori

        # to have the tool lenght correction on the MachineTool always in the good direction
        # otherwise it might be wrong if the toolpath starts with toolaxis X or Y
        set ::mom_cutcom_plane XY
      } else {
        LIB_CONF_do_prop_custom_proc CONF_CTRL_setting tcpm_mode "short_template_syntax"
      }
    } @ROTARY_SIMULTANEOUS

    LIB_GE_command_buffer_output
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    set lib_flag(mode_current_status) "sim"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
# Switch on simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAORI
# Heidenhain: M128 / TCPM
# Fanuc: G43.4
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_init {} {
  global mom_kin_is_turbo_output mom_post_in_simulation
  global lib_parameter lib_flag

  set commandcheck(LIB_ROTARY_absolute_init_ENTRY) [llength [info commands LIB_ROTARY_absolute_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting absolute_output] != "vector" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }
  if {[CONF_CTRL_setting absolute_output] == "vector"} {
    MOM_force once X_vector Y_vector Z_vector
    MOM_enable_address X_vector Y_vector Z_vector
    MOM_disable_address fourth_axis fifth_axis
  } else {
    MOM_force once fourth_axis fifth_axis
    MOM_enable_address fourth_axis fifth_axis
    MOM_disable_address X_vector Y_vector Z_vector
  }

  LIB_CTRL_polar_transmit "start"

  set lib_flag(mode_current_status) "std"

  LIB_GE_command_buffer UNCLAMP
  LIB_GE_command_buffer {LIB_CTRL_unclamp_axis} @UNCLAMP
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on absolute output rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global lib_sav_kin_machine_type lib_flag

  set commandcheck(LIB_ROTARY_positioning_init_ENTRY) [llength [info commands LIB_ROTARY_positioning_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  MOM_disable_address X_vector Y_vector Z_vector
  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_disable_address fifth_axis
  }

  if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {return}
  if {$lib_flag(mode_current_status) != "pos"} {
      LIB_CSYS_plane_output_init
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: AROT / CYCLE800
# Heidenhain: CYCL DEF 19 or PLANE SPATIAL
# Fanuc: G68.2
#____________________________________________________________________________________________
proc LIB_CTRL_detect_cutcom_mode {} {

  global mom_operation_type
  global mom_cutter_data_output_indicator
  global mom_drive_method
  global mom_automatic_wall_selection
  global mom_kin_machine_type
  global mom_siemens_3Dcutcom_mode
  global mom_tool_taper_angle
  global mom_tool_axis_type
  global mom_tool_path_type

  set commandcheck(LIB_CTRL_detect_cutcom_mode_ENTRY) [llength [info commands LIB_CTRL_detect_cutcom_mode_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_detect_cutcom_mode_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_detect_cutcom_mode_ENTRY)} {LIB_CTRL_detect_cutcom_mode_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting 3d_cutcom_output] == 0} {
    return
  }

  if {![info exists mom_tool_path_type]} {
    set mom_tool_path_type "undefined"
  }

  # mom_cutter_data_output_indicator defines the current output mode.
  # 0 - the output is tool end. Both 2D contact contour and 3D cutter compensation modes are inactive
  # 1 - the output is 2D contact contour
  # 2 - the output is 3D cutter compensation mode
  if { ![info exists mom_siemens_3Dcutcom_mode] || [string match "OFF" $mom_siemens_3Dcutcom_mode] } {
    if { [info exists mom_cutter_data_output_indicator] && $mom_cutter_data_output_indicator == 2 } {

      # 3axis machine
      if { [string match "3_axis_mill" $mom_kin_machine_type] } {
        set mom_siemens_3Dcutcom_mode "3DFF"

        # 5axis machine
      } else {
        if { ![info exists mom_tool_taper_angle] } {
          set mom_tool_taper_angle 0.0
        }

        # check tool taper angle, CUT3DC cannot work with taper tool
        if { [EQ_is_zero $mom_tool_taper_angle] && [info exists mom_drive_method] && $mom_drive_method == 120 && \
        [info exists mom_automatic_wall_selection] && [string match "No" $mom_automatic_wall_selection] } {
          set mom_siemens_3Dcutcom_mode "3DC"
        } elseif { $mom_tool_axis_type < 2 || (![string match "Variable-axis *" $mom_operation_type]) && \
          ![string match "Sequential Mill Main Operation" $mom_operation_type] && \
        [string match "fixed_axis" $mom_tool_path_type]} { ;#3 axis or 3+2 axis milling
          set mom_siemens_3Dcutcom_mode "3DFF"
        } else {
          set mom_siemens_3Dcutcom_mode "3DF"
        }
      }
    } elseif { [info exists mom_cutter_data_output_indicator] && $mom_cutter_data_output_indicator == 1 } {
      if {$::lib_flag(mode_current_status) == "sim"} {
        set mom_siemens_3Dcutcom_mode "3DC_3axis"

        #Cutcom 2&1/2
      } else {
        set mom_siemens_3Dcutcom_mode "2DF"
      }
    }

    # Current cutcom mode will be output
    LIB_CTRL_output_current_cutcom_mode
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_detect_cutcom_mode_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_detect_cutcom_mode_ENTRY)} {LIB_CTRL_detect_cutcom_mode_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This command is used to detect and output cutcom mode.
# This command should be called in MOM_first_move_LIB and MOM_initial_move_LIB.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_current_cutcom_mode {} {

  global mom_siemens_3Dcutcom_mode

  set commandcheck(LIB_CTRL_output_current_cutcom_mode_ENTRY) [llength [info commands LIB_CTRL_output_current_cutcom_mode_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_output_current_cutcom_mode_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_output_current_cutcom_mode_ENTRY)} {LIB_CTRL_output_current_cutcom_mode_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {(![info exists ::lib_flag(current_cutcom_mode)] || $::lib_flag(current_cutcom_mode) != 1) && \
  [info exists mom_siemens_3Dcutcom_mode]} {

    switch -- $mom_siemens_3Dcutcom_mode {
      "OFF" {
        # nothing
      }
      "3DC_3axis" {
        LIB_GE_command_buffer CURRENT_3DC_3axis_CUTCOM_MODE
        LIB_GE_command_buffer {MOM_output_literal "CUT3DC" ; set ::lib_flag(current_cutcom_mode) 1 } @3DC_3axis_CUTCOM_MODE
        LIB_GE_command_buffer_output
      }
      "3DC"  -
      "3DF"  -
      "3DFF" -
      "2DF" {
        LIB_GE_command_buffer CURRENT_CUTCOM_MODE
        LIB_GE_command_buffer {MOM_output_literal "CUT$mom_siemens_3Dcutcom_mode" ; set ::lib_flag(current_cutcom_mode) 1 } @CURRENT_CUTCOM_MODE
        LIB_GE_command_buffer_output
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_output_current_cutcom_mode_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_output_current_cutcom_mode_ENTRY)} {LIB_CTRL_output_current_cutcom_mode_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This command is used to output current cutcom mode.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_proper_address_for_3Dcutcom {} {

  global mom_contact_status
  global mom_siemens_3Dcutcom_mode
  global mom_cutter_data_output_indicator

  set commandcheck(LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY) [llength [info commands LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY)} {LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting 3d_cutcom_output] == 0} {
    MOM_disable_address A5 B5 C5
    return
  }

  if {[info exists mom_cutter_data_output_indicator] && $mom_cutter_data_output_indicator == 2} {
    MOM_enable_address A5 B5 C5
  } else {
    MOM_disable_address A5 B5 C5
  }

  if { [info exists mom_siemens_3Dcutcom_mode] } {
    if { [string match "3DF" $mom_siemens_3Dcutcom_mode] || [string match "3DFF" $mom_siemens_3Dcutcom_mode] } {
      if { [info exists mom_contact_status] && [string match "ON" $mom_contact_status] } {
        MOM_force Once A5 B5 C5
      } else {
        MOM_suppress Once A5 B5 C5
      }
    } else {
      MOM_suppress Once A5 B5 C5
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY)} {LIB_CTRL_output_proper_address_for_3Dcutcom_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This command is used to output proper address for 3Dcutcome mode.
#
# This command should be called in MOM_linear_move_LIB.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_calculate_cutcom {} {


  global mom_siemens_3Dcutcom_mode
  global mom_cutcom_mode mom_cutcom_status
  global mom_pos mom_mcs_goto mom_prev_mcs_goto
  global mom_contact_point mom_contact_normal
  global mom_tool_axis
  global mom_contact_status
  global mcs_contact_normal
  global mom_cutter_data_output_indicator
  global mom_tool_taper_angle
  global mom_drive_method
  global mom_motion_type
  global mom_sys_abort_next_event

  set commandcheck(LIB_CTRL_calculate_cutcom_ENTRY) [llength [info commands LIB_CTRL_calculate_cutcom_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_calculate_cutcom_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_calculate_cutcom_ENTRY)} {LIB_CTRL_calculate_cutcom_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting 3d_cutcom_output] == 0} {
    return
  }

  if { ![info exists mom_siemens_3Dcutcom_mode] || $mom_siemens_3Dcutcom_mode == "OFF" } {
    if { ![info exists mom_cutter_data_output_indicator] || $mom_cutter_data_output_indicator == 0 } {
      if { [info exists mom_cutcom_status] && ($mom_cutcom_status == "LEFT" || $mom_cutcom_status == "RIGHT") } {
        if { ![info exists mom_tool_taper_angle] } {
          set mom_tool_taper_angle 0.0
        }

        if {$::lib_flag(mode_current_status) == "sim" && [EQ_is_zero $mom_tool_taper_angle]} {
          set mom_siemens_3Dcutcom_mode "3DC_3axis"
        } else {
          # Cutcom 2&1/2
          set mom_siemens_3Dcutcom_mode "2DF"
        }
      }
    }
  }

  if { ![info exists mom_contact_status] } {
    return
  }

  if { [info exists mom_siemens_3Dcutcom_mode] && [string match "3D*" $mom_siemens_3Dcutcom_mode] } {

    if { $mom_siemens_3Dcutcom_mode == "3DC_3axis" } {
      return
    }

    if { [string match "3DF*" $mom_siemens_3Dcutcom_mode] } {
      set dot [VEC3_dot mom_tool_axis mom_contact_normal]
      if { [EQ_is_zero $dot] } {
        if { [info exists mom_drive_method] && $mom_drive_method == 120 } {
          if {$::lib_flag(mode_current_status) == "sim"} {
            set mom_siemens_3Dcutcom_mode "3DC"
          } else {
            set mom_siemens_3Dcutcom_mode "2DF"
          }
        }
      }
    }

    if { $mom_contact_status == "ON" } {
      set mom_cutcom_status "ON"
      set mom_cutcom_mode "LEFT"
      LIB_SPF_mcs_vector mom_contact_normal mcs_contact_normal ; # get contact normal vector reference mcs

      if { $mom_siemens_3Dcutcom_mode == "3DC" } {
        VMOV 3 mom_mcs_goto end_point
        VMOV 3 mom_prev_mcs_goto start_point
        VEC3_sub end_point start_point vec_move ;# get move vector
        VEC3_cross vec_move mcs_contact_normal vec_dir; # crossed product of move and contact normal vector
        set vec_axis [VEC3_dot vec_dir mom_tool_axis];# project to tool axis vector

        if { $vec_axis < 0 } {
          set mom_cutcom_mode "RIGHT"
        }
      }

      if {$mom_cutcom_status != "UNDEFINED"} {
        if {$mom_cutcom_status != "OFF"} {set mom_cutcom_status ON}
        if {$mom_cutcom_status == "ON"} {
          if {$mom_cutcom_mode != ""} {set mom_cutcom_status $mom_cutcom_mode}
        }
      }

    } else {
      # handle no contact point scenario after filter
      if { $mom_motion_type == "CUT" } {
        set mom_sys_abort_next_event 1
        LIB_SPF_add_warning "No contact point generated!"
        MOM_abort_event
      } else {
        set mom_cutcom_status "OFF"
      }
    }
  }

  # Current cutcom mode will be output
  LIB_CTRL_output_current_cutcom_mode

  # Contact points will be output
  if { [info exists mom_contact_status] && $mom_contact_status == "ON" } {
    if { [info exists mom_contact_point] } {
      VMOV 3 mom_contact_point mom_pos
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_calculate_cutcom_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_calculate_cutcom_ENTRY)} {LIB_CTRL_calculate_cutcom_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This command is used to calculate cutcom mode LEFT/RIGHT for CUT3DC and output contact point.
# For surface 3D cutcom, output default G41 as active motion.
#
# This command should be added in MOM_before_motion.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_KINEMATICS_set_simultanous_kin {} {

  global mom_sys_leader mom_sys_trailer lib_sav_kin_machine_type lib_spf
  global mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit lib_flag
  global mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_4th_axis_output_limit_min mom_4th_axis_output_limit_max mom_5th_axis_output_limit_min mom_5th_axis_output_limit_max

  set commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY) [llength [info commands LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_sim_kin 4th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 4th_axis_has_limit $::mom_sys_4th_axis_has_limits}
  if {[CONF_SPF_sim_kin 5th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 5th_axis_has_limit $::mom_sys_5th_axis_has_limits}

  if {$lib_flag(local_namespace_output)} {
    if {![CONF_SPF_sim_kin 4th_axis_has_limit] && ![info exists lib_spf(do_convert_point)]} {
      set mom_sys_leader(fourth_axis) "[lindex [split "$mom_sys_leader(fourth_axis)" "="] 0]=DC("
      set mom_sys_trailer(fourth_axis) ")"
      if {[llength [info commands "MOM_limit_output_angle"]]} {
        MOM_limit_output_angle ON 4 [expr 360.0-$::mom_kin_4th_axis_min_incr] 0.0
      # set mom_kin_4th_axis_min_limit $mom_4th_axis_output_limit_min
      # set mom_kin_4th_axis_max_limit $mom_4th_axis_output_limit_max
      } else {
        set mom_kin_4th_axis_min_limit 0.0
        set mom_kin_4th_axis_max_limit 359.9999
      }
    }
    if {![CONF_SPF_sim_kin 5th_axis_has_limit] && ![info exists lib_spf(do_convert_point)]} {
      set mom_sys_leader(fifth_axis) "[lindex [split "$mom_sys_leader(fifth_axis)" "="] 0]=DC("
      set mom_sys_trailer(fifth_axis) ")"
      if {[llength [info commands "MOM_limit_output_angle"]]} {
        MOM_limit_output_angle ON 5 [expr 360.0-$::mom_kin_5th_axis_min_incr] 0.0
      # set mom_kin_5th_axis_min_limit $mom_4th_axis_output_limit_min
      # set mom_kin_5th_axis_max_limit $mom_4th_axis_output_limit_max
      } else {
        set mom_kin_5th_axis_min_limit 0.0
        set mom_kin_5th_axis_max_limit 359.9999
      }
    }
  } else {
  if {![CONF_SPF_sim_kin 4th_axis_has_limit]} {
    if {$lib_sav_kin_machine_type != "5_axis_dual_head" && ([CONF_SPF_sim_kin 4th_axis] == "real" && [CONF_SPF_sim_kin 5th_axis] == "real")} {
      set mom_sys_leader(fifth_axis) "[lindex [split "$mom_sys_leader(fifth_axis)" "="] 0]=DC("
      set mom_sys_trailer(fifth_axis) ")"
      if {[llength [info commands "MOM_limit_output_angle"]]} {
        MOM_limit_output_angle ON 5 [expr 360.0-$::mom_kin_5th_axis_min_incr] 0.0
      # set mom_kin_5th_axis_min_limit $mom_5th_axis_output_limit_min
      # set mom_kin_5th_axis_max_limit $mom_5th_axis_output_limit_max
      } else {
        set mom_kin_5th_axis_min_limit 0.0
        set mom_kin_5th_axis_max_limit 359.9999
      }
    } else {
      set mom_sys_leader(fourth_axis) "[lindex [split "$mom_sys_leader(fourth_axis)" "="] 0]=DC("
      set mom_sys_trailer(fourth_axis) ")"
      if {[llength [info commands "MOM_limit_output_angle"]]} {
        MOM_limit_output_angle ON 4 [expr 360.0-$::mom_kin_4th_axis_min_incr] 0.0
      # set mom_kin_4th_axis_min_limit $mom_4th_axis_output_limit_min
      # set mom_kin_4th_axis_max_limit $mom_4th_axis_output_limit_max
      } else {
        set mom_kin_4th_axis_min_limit 0.0
        set mom_kin_4th_axis_max_limit 359.9999
      }
    }
  }

  if {![CONF_SPF_sim_kin 5th_axis_has_limit]} {
    if {$lib_sav_kin_machine_type != "5_axis_dual_head" && ([CONF_SPF_sim_kin 4th_axis] == "real" && [CONF_SPF_sim_kin 5th_axis] == "real")} {
      set mom_sys_leader(fourth_axis) "[lindex [split "$mom_sys_leader(fourth_axis)" "="] 0]=DC("
      set mom_sys_trailer(fourth_axis) ")"
      if {[llength [info commands "MOM_limit_output_angle"]]} {
        MOM_limit_output_angle ON 4 [expr 360.0-$::mom_kin_4th_axis_min_incr] 0.0
        #set mom_kin_4th_axis_min_limit $mom_4th_axis_output_limit_min
        #set mom_kin_4th_axis_max_limit $mom_4th_axis_output_limit_max
      } else {
        set mom_kin_4th_axis_min_limit 0.0
        set mom_kin_4th_axis_max_limit 359.9999
      }
    } else {
      set mom_sys_leader(fifth_axis) "[lindex [split "$mom_sys_leader(fifth_axis)" "="] 0]=DC("
      set mom_sys_trailer(fifth_axis) ")"
      if {[llength [info commands "MOM_limit_output_angle"]]} {
        MOM_limit_output_angle ON 5 [expr 360.0-$::mom_kin_5th_axis_min_incr] 0.0
        #set mom_kin_5th_axis_min_limit $mom_5th_axis_output_limit_min
        #set mom_kin_5th_axis_max_limit $mom_5th_axis_output_limit_max
      } else {
        set mom_kin_5th_axis_min_limit 0.0
        set mom_kin_5th_axis_max_limit 359.9999
      }
    }
  }
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
# Switch on shortest distance for simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: Leader "C=DC("  Trailer ")"
# Heidenhain: M126
#____________________________________________________________________________________________
proc LIB_RETURN_move {Addresses {property ""}} {
  global mom_sys_home_pos mom_prev_pos mom_prev_out_angle_pos
  global lib_flag mom_operation_type

  set commandcheck(LIB_RETURN_move_ENTRY) [llength [info commands LIB_RETURN_move_ENTRY]]

  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[string match $mom_operation_type "Device Generic Motion"]} {
       return
  }

  if {$property != ""} {
    set object $Addresses
    set Addresses [$Addresses $property]
  } else {
    set object ""
  }

  set line_nbr -1
  set break_it 0
        foreach axes $Addresses {
    incr line_nbr

    if {[catch {foreach axis $axes {}}]} {
      set axes [list $axes]
    }

    foreach axis $axes {

      switch -- $axis {
        "Z" {
                #WRITE_coolant off
                if {[CONF_CTRL_moves return_mode] == "value"} {
                              MOM_force once Z
            MOM_suppress once X Y
            LIB_GE_command_buffer AXIS_MOVE_Z
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Z
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Z
            LIB_GE_command_buffer {MOM_do_template return_home_Z} @RETURN_HOME_Z
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
                MOM_force once Z
        }
        "Y" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once Y
            MOM_suppress once X Z
            LIB_GE_command_buffer AXIS_MOVE_Y
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Y
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Y
            LIB_GE_command_buffer {MOM_do_template return_home_Y} @RETURN_HOME_Y
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once Y
        }
        "X" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once X
            MOM_suppress once Y Z
            LIB_GE_command_buffer AXIS_MOVE_X
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_X
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_X
            LIB_GE_command_buffer {MOM_do_template return_home_X} @RETURN_HOME_X
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once X
        }
        "YX" -
        "XY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once X Y
            MOM_suppress once Z
            LIB_GE_command_buffer AXIS_MOVE_XY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_XY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_XY
            LIB_GE_command_buffer {MOM_do_template return_home_XY} @RETURN_HOME_XY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once X Y
        }
        "XZ" -
        "ZX" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once X Z
            MOM_suppress once Y
            LIB_GE_command_buffer AXIS_MOVE_ZX
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZX
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZX
            LIB_GE_command_buffer {MOM_do_template return_home_ZX} @RETURN_HOME_ZX
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once Z X
        }
        "YZ" -
        "ZY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            MOM_force once Y Z
            MOM_suppress once X
            LIB_GE_command_buffer AXIS_MOVE_ZY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZY
            LIB_GE_command_buffer {MOM_do_template return_home_ZY} @RETURN_HOME_ZY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          MOM_force once Y Z
        }
        "4th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]]} {
            if {[CONF_CTRL_moves return_mode] == "value"} {
              MOM_force once fourth_axis
              LIB_GE_command_buffer AXIS_MOVE_4TH
              LIB_GE_command_buffer {MOM_do_template return_move_4th} @RETURN_MOVE_4TH
              LIB_GE_command_buffer_output
            } else {
              LIB_GE_command_buffer AXIS_HOME_4TH
              LIB_GE_command_buffer {MOM_do_template return_home_4th} @RETURN_HOME_4TH
              LIB_GE_command_buffer_output
            }
            set mom_prev_out_angle_pos(0) 0.0
            MOM_force once fourth_axis
          }
        }
        "5th" {
          if {![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            if {[CONF_CTRL_moves return_mode] == "value"} {
              MOM_force once fifth_axis
              LIB_GE_command_buffer AXIS_MOVE_5TH
              LIB_GE_command_buffer {MOM_do_template return_move_5th} @RETURN_MOVE_5TH
              LIB_GE_command_buffer_output
            } else {
              LIB_GE_command_buffer AXIS_HOME_5TH
              LIB_GE_command_buffer {MOM_do_template return_home_5th} @RETURN_HOME_5TH
              LIB_GE_command_buffer_output
            }
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fifth_axis
          }
        }
        "4th5th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]] || ![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            if {[CONF_CTRL_moves return_mode] == "value"} {
              MOM_force once fourth_axis fifth_axis
              LIB_GE_command_buffer AXIS_MOVE_45TH
              LIB_GE_command_buffer {MOM_do_template return_move_4th5th} @RETURN_MOVE_45TH
              LIB_GE_command_buffer_output
            } else {
              LIB_GE_command_buffer AXIS_HOME_45TH
              LIB_GE_command_buffer {MOM_do_template return_home_4th5th} @RETURN_HOME_45TH
              LIB_GE_command_buffer_output
            }
            set mom_prev_out_angle_pos(0) 0.0
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fourth_axis fifth_axis
          }
        }
        "" {
                #Do Nothing
        }
        "default" {
          if {[LIB_SPF_exists_block_template $axes 1] == 1} {
            MOM_do_template $axes
          } elseif {[LIB_SPF_exists_block_template $axes 1] == -1 && ![catch {set dummy [MOM_do_template $axes CREATE]}]} {
            # Thats the case when 'MOM_has_definition_element' command does not exist (older NX versions)
            #legacy
            MOM_output_literal $dummy
          } else {
            if {$object == ""} {
              #when LIB_RETURN_move is not called with a conf_object as argument
              LIB_RETURN_move_LIB_ENTRY $axes
            } else {
              if {[info proc LIB_RETURN_move_LIB_ENTRY] == "LIB_RETURN_move_LIB_ENTRY"} {
                #legacy
                LIB_RETURN_move_LIB_ENTRY $axes
              } else {
                LIB_CONF_do_prop_custom_proc $object $property "no_special_syntax" $line_nbr
                set break_it 1
                break
              }
            }
          }
        }
      }
    }
    if {$break_it} {break}
  }
  set lib_flag(current_safety_position) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Documentation>
# Writes return motions to the NC-code. Settings for home motions (CONF_CTRL_moves return_mode)
# are taken into consideration for the output format of the return motions.
#
# <Arguments>
# Addresses
# String with space separated axis names that should perform a return move.
#   Valid options:
#   X / Y / Z / XY / ZX / ZY or a template name
# property
# Reserved argument.
#
# <Returnvalue>
# None.
#
# <Example>
# name: Example using axis names
# code: LIB_RETURN_move "Z XY"
# desc: Writes return moves for Z and then XY to the NC-code in Sinumerik-Format.
#      Result will be:
# G153 Z99999.9 D0
# G153 X99999.9 Y99999.9
# <Example>
# name: Example using template names
# code: LIB_RETURN_move "custom_return_template1 custom_return_template2"
# desc: Assuming we have two custom specific block templates custom_return_template1 and custom_return_template2,
#      we can call them here by their name. It's okay to mix template names and axes names (see ex. 1)
#____________________________________________________________________________________________
proc MOM_machine_mode_LIB_ENTRY {{option default}} {

  switch -- $option {
    "start" {
      # nothing
      if {$::mom_machine_mode == "MILL"} {
        LIB_GE_command_buffer LIB_mill_machine_mode
        LIB_GE_command_buffer {MOM_do_template mill_machine_mode_init} @MILL_MACHINE_MODE_INIT
        LIB_GE_command_buffer_output
      }
    }
    "end" {
      # nothing
    }
  }
}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_main_origin_call {{offset_nbr ""} {create ""}} {

  global mom_fixture_offset_value
  global lib_main_zero_register lib_flag

  set commandcheck(LIB_main_origin_call_ENTRY) [llength [info commands LIB_main_origin_call_ENTRY]]

  LIB_GE_command_buffer LIB_main_origin_call_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_main_origin_call_ENTRY)} {LIB_main_origin_call_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$offset_nbr == ""} {
    set offset_nbr $mom_fixture_offset_value
  }

  if {[CONF_CTRL_origin use_main] == 1} {
    if {$offset_nbr == 0} {
      set lib_main_zero_register 500
    } elseif {$offset_nbr <= 4} {
      set lib_main_zero_register [expr $offset_nbr + 53]
    } elseif {$offset_nbr <= 99} {
      set lib_main_zero_register [expr $offset_nbr + 500]
    } else {
      if {![hiset lib_flag(error_main_zero_register)]} {
        set error [LIB_SPF_add_warning "Fixture offset value should be < 100: G599 is used"]
        set lib_flag(error_main_zero_register) 1
      }
      set lib_main_zero_register 599
    }
    LIB_GE_command_buffer MAIN_ZERO
    LIB_GE_command_buffer {MOM_do_template main_zero $create} @OUTPUT
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_main_origin_call_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_main_origin_call_ENTRY)} {LIB_main_origin_call_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Documentation>
# Writes the active main origin to the NC-code, provided that the property
# [CONF_CTRL_origin use_main] is set to 'On'.
#
# <Arguments>
# offset_nbr
# Reserved argument.
# create
# Reserved argument.
# <Example>
# name: Output active origin
# code: LIB_main_origin_call
# desc: Writes G54 for fixture_offset_number 1
#____________________________________________________________________________________________
proc LIB_local_origin_call {} {


  global mom_origin mom_tool_axis mom_csys_matrix
  global lib_flag
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z

  if {[LIB_SPF_csys_examine_local] == "default" && [EQ_is_equal $mom_tool_axis(2) 1.0]} {

    set mom_origin(0) 0.0
    set mom_origin(1) 0.0
    set mom_origin(2) 0.0

    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_local_csys_rotation
    } else {
      LIB_SPF_csys_3D_rotation
    }
    set mom_origin(0) $lib_coord_ref_X
    set mom_origin(1) $lib_coord_ref_Y
    set mom_origin(2) $lib_coord_ref_Z
  } else {
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_local_csys_rotation
    } else {
      LIB_SPF_csys_3D_rotation
    }
    set mom_origin(0) $lib_coord_ref_X
    set mom_origin(1) $lib_coord_ref_Y
    set mom_origin(2) $lib_coord_ref_Z
  }
  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 0 && [CONF_CTRL_setting plane_output] == "TRANS_ROT"} {
    #offset
    MOM_force once X Y Z
    set buffer_name FRAME_TRANS

    if {[LIB_GE_commandbuffer_is_customized MOM_coolant_off]} {
      #This is just for legacy support of the old missleading name
      set buffer_name MOM_coolant_off
    }
    LIB_GE_command_buffer $buffer_name
    LIB_GE_command_buffer {MOM_do_template frame_trans} @OUTPUT ;# mom_origin(0)
    LIB_GE_command_buffer_output
    MOM_force once X Y Z
    set lib_flag(local_origin_activated) 1
  }
}
# <Internal Documentation>
# Output the local origin call (CYCL DEF 7)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_local_origin_reset {} {

  global lib_flag

  if {[CONF_CTRL_origin use_local] == 1 && $lib_flag(local_origin_activated) == 1 && [CONF_CTRL_setting plane_output] == "TRANS_ROT"} {
    MOM_output_literal "TRANS"
    set lib_flag(local_origin_activated) 0
  }
}
# <Internal Documentation>
# Output the main origin reset (CYCL DEF 7)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_KINEMATICS_set_plane_output_kin_auto {} {

  global lib_parameter

  if {0} {
    CONF_SPF_csys_3d_rot set rot_mode Euler
    if {[LIB_SPF_get_pretreatment axis_mode] == "POSITIONING" && [CONF_CTRL_moves standard_path_between_rotary_motions] == 1} {
      return
    }
  }

  if {[CONF_S840D_cycle800 auto_set_kin] == 1 && [CONF_CTRL_setting plane_output] == "CYCLE800"} {
    if {[LIB_CTRL_custom_cycle800_auto_set_kin [CONF_S840D_cycle800 _MODE]] == 0} {
      switch -- [CONF_S840D_cycle800 _MODE] {
        27 {
          CONF_SPF_plane_kin set 4th_axis "X"
          CONF_SPF_plane_kin set 4th_leader "A"
          CONF_SPF_plane_kin set 4th_axis_min_limit 0
          CONF_SPF_plane_kin set 4th_axis_max_limit 359.999
          CONF_SPF_plane_kin set 5th_axis "Y"
          CONF_SPF_plane_kin set 5th_leader "B"
          CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
          CONF_SPF_csys_3d_rot set rot_order ZYX
          CONF_SPF_csys_3d_rot set rot_mode "Euler"
        }
        30 {
          CONF_SPF_plane_kin set 4th_axis "X"
          CONF_SPF_plane_kin set 4th_leader "A"
          CONF_SPF_plane_kin set 4th_axis_min_limit 0
          CONF_SPF_plane_kin set 4th_axis_max_limit 359.999
          CONF_SPF_plane_kin set 5th_axis "Y"
          CONF_SPF_plane_kin set 5th_leader "B"
          CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
          CONF_SPF_csys_3d_rot set rot_order YZX
          CONF_SPF_csys_3d_rot set rot_mode "Euler"
        }
        39 {
          CONF_SPF_plane_kin set 4th_axis "Y"
          CONF_SPF_plane_kin set 4th_leader "B"
          CONF_SPF_plane_kin set 4th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 4th_axis_max_limit 359.999
          CONF_SPF_plane_kin set 5th_axis "X"
          CONF_SPF_plane_kin set 5th_leader "A"
          CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
          CONF_SPF_csys_3d_rot set rot_order ZXY
          CONF_SPF_csys_3d_rot set rot_mode "Euler"
        }
        45 {
          CONF_SPF_plane_kin set 4th_axis "Y"
          CONF_SPF_plane_kin set 4th_leader "B"
          CONF_SPF_plane_kin set 4th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 4th_axis_max_limit 359.999
          CONF_SPF_plane_kin set 5th_axis "X"
          CONF_SPF_plane_kin set 5th_leader "A"
          CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
          CONF_SPF_csys_3d_rot set rot_order XZY
          CONF_SPF_csys_3d_rot set rot_mode "Euler"
        }
        54 {
          CONF_SPF_plane_kin set 4th_axis "X"
          CONF_SPF_plane_kin set 4th_leader "A"
          CONF_SPF_plane_kin set 4th_axis_min_limit 0
          CONF_SPF_plane_kin set 4th_axis_max_limit 359.999
          CONF_SPF_plane_kin set 5th_axis "Y"
          CONF_SPF_plane_kin set 5th_leader "B"
          CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
          CONF_SPF_csys_3d_rot set rot_order YXZ
          CONF_SPF_csys_3d_rot set rot_mode "Euler"
        }
        57 {
          CONF_SPF_plane_kin set 4th_axis "Y"
          CONF_SPF_plane_kin set 4th_leader "B"
          CONF_SPF_plane_kin set 4th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 4th_axis_max_limit 359.999
          CONF_SPF_plane_kin set 5th_axis "X"
          CONF_SPF_plane_kin set 5th_leader "A"
          CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
          CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
          CONF_SPF_csys_3d_rot set rot_order XYZ
          CONF_SPF_csys_3d_rot set rot_mode "Euler"
        }
        default {
          LIB_GE_abort_message "The parameter for 'lib_parameter(cycle800,_MODE)' isn't included in the code" "Please check"
        }
      }
    }
  }
}
# <Internal Documentation>
# Controls the kinematics plane output conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_custom_cycle800_auto_set_kin {mode} {

  return 0
}
# <Documentation>
# This procedure sets the kinematics used for the CYCLE800 based on the value of the
# _MODE configuration object setting in the UI. The procedure is called from
# LIB_SPF_KINEMATICS_set_plane_output_kin_ENTRY and gets CONF_S840D_cycle800 _MODE as an argument.
#
# <Arguments>
# mode
# The value of the _MODE parameter of the CYCLE800.
# <Returnvalue>
# 0 - The mode parameter is not defined.
# 1 - The mode parameter is defined and kinematics are set for the CYCLE800.
#
# <Example>
# name: Example 1
# code: if {$mode == 54} {
#   CONF_SPF_plane_kin set 4th_axis "X"
#   CONF_SPF_plane_kin set 4th_leader "A"
#   CONF_SPF_plane_kin set 4th_axis_min_limit 0
#   set lib_parameter(inclined_plane_4th_axis_max_limit) 180.
#   CONF_SPF_plane_kin set 5th_axis "Y"
#   CONF_SPF_plane_kin set 5th_leader "B"
#   CONF_SPF_plane_kin set 5th_axis_min_limit 0.0
#   CONF_SPF_plane_kin set 5th_axis_max_limit 359.999
#
#   return 1
# }
# desc: This is an example for implementation of a specific kinematic setting for mode 54 in the CYCLE800.
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_init {} {

  global lib_flag lib_parameter
  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global mom_motion_output_type

  set commandcheck(LIB_SAFETY_approach_first_move) [llength [info commands LIB_SAFETY_approach_first_move]]

  # In new local csys mode, enter local namespace and switch output mode before plane init
  LIB_GE_command_buffer LOCAL_CSYS_INIT
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_set}} @LOCAL_POS_SET
  LIB_GE_command_buffer_output

  # Use LIB_rotate_axis_before_plane instead of LIB_SAFETY_approach_first_move
  # so we have the same structure in all controllers
  LIB_GE_command_buffer LIB_SAFETY_approach_first_move
  LIB_GE_command_buffer {if {$commandcheck(LIB_SAFETY_approach_first_move)} {LIB_SAFETY_approach_first_move}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CTRL_unclamp_axis

  LIB_rotate_axis_before_plane

  set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 1
  switch -- [CONF_CTRL_setting plane_output] {
    "TRANS_ROT"  {

      if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point real
      }

      LIB_GE_command_buffer TRANS_ROT
      LIB_GE_command_buffer {
        if {[CONF_S840D_cycle800 _DIR] != 0} {
          set ::lib_parameter(cycle800,_DIR) [CONF_S840D_cycle800 _DIR]
        } else {
          set ::lib_parameter(cycle800,_DIR) 0
        }
      } @SET_DIR
      LIB_GE_command_buffer {LIB_CTRL_rotate_axis} @RAPID_ROTARY
      LIB_GE_command_buffer {MOM_do_template frame_arot_z} @FRAME_AROT_Z
      LIB_GE_command_buffer {MOM_do_template frame_arot_y} @FRAME_AROT_Y
      LIB_GE_command_buffer {MOM_do_template frame_arot_x} @FRAME_AROT_X
      LIB_GE_command_buffer {MOM_do_template traori} @TRAORI
      LIB_GE_command_buffer_output

      if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point reload
      }

      MOM_disable_address fourth_axis fifth_axis
    }
    "CYCLE800" {
      LIB_GE_command_buffer BEFORE_CYCLE800_DEFINITION
      LIB_GE_command_buffer {} @DEFAULT_ENTRY
      LIB_GE_command_buffer_output

      ##CYCLE800(_FR, _TC, _ST, _MODE, _X0, _Y0, _Z0, _A, _B, _C, _X1, _Y1, _Z1, _DIR, _FR _I)

                # Output D1 in front of CYCLE800(4, ...) or CYCLE800(5, ...)
              if {[CONF_S840D_cycle800 _FR] == 4 || [CONF_S840D_cycle800 _FR] == 5} {
                    LIB_GE_command_buffer TOOL_LENGTH_ADJUST
                    LIB_GE_command_buffer {
                        MOM_do_template tool_length_adjust
                    } @OUTPUT
                    LIB_GE_command_buffer_output
                }

      if {[CONF_CTRL_origin use_local] == 1} {
        set lib_parameter(cycle800,_X0) [LIB_SPF_eliminate_zero $lib_coord_ref_X]
        set lib_parameter(cycle800,_Y0) [LIB_SPF_eliminate_zero $lib_coord_ref_Y]
        set lib_parameter(cycle800,_Z0) [LIB_SPF_eliminate_zero $lib_coord_ref_Z]
      } else {
        set lib_parameter(cycle800,_X0) 0
        set lib_parameter(cycle800,_Y0) 0
        set lib_parameter(cycle800,_Z0) 0
      }

      #set snapshot [LIB_GE_snapshot CREATE "mom_pos mom_out_angle_pos mom_tool_axis(1) "]

      if {[LIB_CTRL_custom_cycle800_plane_output_kin [CONF_S840D_cycle800 _MODE]] == 0} {
        switch -- [CONF_S840D_cycle800 _MODE] {
          27 {
            set lib_parameter(cycle800,_A) $lib_coord_ang_C
            set lib_parameter(cycle800,_B) $lib_coord_ang_B
            set lib_parameter(cycle800,_C) $lib_coord_ang_A
          }
          30 {
            set lib_parameter(cycle800,_A) $lib_coord_ang_B
            set lib_parameter(cycle800,_B) $lib_coord_ang_C
            set lib_parameter(cycle800,_C) $lib_coord_ang_A
          }
          39 {
            set lib_parameter(cycle800,_A) $lib_coord_ang_C
            set lib_parameter(cycle800,_B) $lib_coord_ang_A
            set lib_parameter(cycle800,_C) $lib_coord_ang_B
          }
          45 {
            set lib_parameter(cycle800,_A) $lib_coord_ang_A
            set lib_parameter(cycle800,_B) $lib_coord_ang_C
            set lib_parameter(cycle800,_C) $lib_coord_ang_B
          }
          54 {
            set lib_parameter(cycle800,_A) $lib_coord_ang_B
            set lib_parameter(cycle800,_B) $lib_coord_ang_A
            set lib_parameter(cycle800,_C) $lib_coord_ang_C
          }
          57 {
            set lib_parameter(cycle800,_A) $lib_coord_ang_A
            set lib_parameter(cycle800,_B) $lib_coord_ang_B
            set lib_parameter(cycle800,_C) $lib_coord_ang_C
          }
          default {

          }
        }
      }

      set lib_parameter(cycle800,_A) [LIB_SPF_eliminate_zero $lib_parameter(cycle800,_A)]
      set lib_parameter(cycle800,_B) [LIB_SPF_eliminate_zero $lib_parameter(cycle800,_B)]
      set lib_parameter(cycle800,_C) [LIB_SPF_eliminate_zero $lib_parameter(cycle800,_C)]

      set lib_parameter(cycle800,_X1) 0
      set lib_parameter(cycle800,_Y1) 0
      set lib_parameter(cycle800,_Z1) 0

      # If arc perpendicular/parallel to tool axis, output G_plane in cycle800
      if {[info exists mom_motion_output_type] && $mom_motion_output_type == 1} {
        MOM_enable_address G_plane
      } else {
        MOM_disable_address G_plane
      }

      if {[CONF_S840D_cycle800 plane_output_motion_with_init] == "MOVE"} {
        set lib_parameter(cycle800,_DIR) [LIB_cycle800_DIR MOVE]
        MOM_disable_address fourth_axis fifth_axis
      } else {
        set tmp_cycle_800_st [CONF_S840D_cycle800 _ST]
        set lib_parameter(cycle800,_DIR) [LIB_cycle800_DIR NO_MOVE]

        if {[info exists lib_parameter(cycle800,_ST)]} {CONF_S840D_cycle800 set _ST $lib_parameter(cycle800,_ST)}

        if {[CONF_S840D_cycle800 rotate_before] == 1} {
          LIB_GE_command_buffer RAPID_ROTARY
          LIB_GE_command_buffer {LIB_CTRL_rotate_axis} @RAPID_ROTARY
          LIB_GE_command_buffer_output
        }

        MOM_disable_address fourth_axis fifth_axis
      }

      if {[CONF_CTRL_moves standard_path_between_rotary_motions] == 1} {
        # _FR should be set to zero except for the first time in the tool path
        if {$lib_flag(first_plane_output) == 0} {
          set lib_parameter(cycle800,_FR) [CONF_S840D_cycle800 _FR]
        } else {
          set lib_parameter(cycle800,_FR) 0
        }
        incr lib_flag(first_plane_output)
        set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) $lib_parameter(cycle800,_DIR)
      } else {
        set lib_parameter(cycle800,_FR) [CONF_S840D_cycle800 _FR]
      }

      if {[info exist lib_flag(preset_save_pos)] && $lib_flag(preset_save_pos) == 0} {
        set lib_parameter(cycle800,_FR) 0
        unset lib_flag(preset_save_pos)
      }

      set lib_parameter(cycle800,_FR_I) 0
      LIB_GE_command_buffer CYCLE800
      LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE800} @CYCLE800
      LIB_GE_command_buffer_output
      MOM_force once X Y Z
      if {[info exists tmp_cycle_800_st]} {CONF_S840D_cycle800 set _ST $tmp_cycle_800_st}
      unset -nocomplain lib_parameter(cycle800,_ST)
    }
    default {
      if {[info command [CONF_CTRL_setting plane_output]] == [CONF_CTRL_setting plane_output]} {
        [CONF_CTRL_setting plane_output] init
      } else {
        LIB_GE_abort_message "INS->LIB_CSYS_plane_output_init<- wrong parameter" "Please check INS->lib_parameter(plane_output) = [CONF_CTRL_setting plane_output]<-"
      }
    }
  }

  LIB_rotate_axis_after_plane

  LIB_CTRL_clamp_axis

  set lib_flag(mode_current_status) "pos"
}
# <Internal Documentation>
# output the plane
#
# lib_parameter(plane_output)
#           == "TRANS_ROT"
#           == "CYCLE800"
#
# lib_parameter(plane_output_motion_with_init)
#           == "MOVE"
#           == "STAY"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_custom_cycle800_plane_output_kin {mode} {

  return 0
}
# <Documentation>
# This procedure sets the variables for the angular output that is used for CYCLE800
# based on a specific _MODE configuration object setting in the UI.
#
# The procedure is called from LIB_CSYS_plane_output_init and gets
# CONF_S840D_cycle800 _MODE as an argument.
# <Arguments>
# mode
# The value of the _MODE parameter of the CYCLE800.
# <Returnvalue>
# 0 - The mode parameter is not defined.
# 1 - The mode parameter is defined and the angle output variables are set for the CYCLE800.
#
# <Example>
# name: Example 1
# code: if {$mode == 54} {
#
#   set lib_parameter(cycle800,_A) $lib_coord_ang_B
#   set lib_parameter(cycle800,_B) $lib_coord_ang_A
#   set lib_parameter(cycle800,_C) $lib_coord_ang_C
#
#   return 1
# }
# desc: This is an example for implementation of a specific kinematic setting for mode 54 in the CYCLE800.
#____________________________________________________________________________________________
proc LIB_cycle800_DIR {mode} {


  global mom_rotary_direction_4th mom_machine_mode
  global mom_lib_cycle800_dir mom_out_angle_pos
  global mom_rotary_direction_4th
  global lib_flag
  global lib_parameter

  if {$mode == "MOVE"} {
    if {$mom_machine_mode == "TURN"} {
      return -1
    } elseif {![info exists mom_lib_cycle800_dir] || [string match -nocase "Auto" $mom_lib_cycle800_dir]} {
      if {![string compare "5_axis_dual_head" $::mom_kin_machine_type]} {
        set axis 1
      } else {
        set axis 0
      }
      if {$mom_out_angle_pos($axis)<0} {
        return -1
      } else {
        return 1
      }
    } else {
      if {[info exists lib_flag(preferred_solution)] && $lib_flag(preferred_solution) != "OFF"} {
        LIB_SPF_add_warning "Set Preferred Solution is using, CYCLE800 _DIR set to auto"
        if {$mom_out_angle_pos(0)<0} {
          return -1
        } else {
          return 1
        }
      } else {
        return $mom_lib_cycle800_dir
      }
    }
  } elseif {$mode == "NO_MOVE"} {
    if {![info exists mom_lib_cycle800_dir] || [string match -nocase "Auto" $mom_lib_cycle800_dir]} {
      if {$mom_out_angle_pos(0)<0} {
        set lib_parameter(cycle800,_ST) 110000
      } else {
        set lib_parameter(cycle800,_ST) 220000
      }
    } else {
      if {[info exists lib_flag(preferred_solution)] && $lib_flag(preferred_solution) != "OFF"} {
        LIB_SPF_add_warning "Set Preferred Solution is using, CYCLE800 _DIR set to auto"
        if {$mom_out_angle_pos(0)<0} {
          set lib_parameter(cycle800,_ST) 110000
        } else {
          set lib_parameter(cycle800,_ST) 220000
        }
      } else {
        if {$mom_lib_cycle800_dir == "-1"} {
          set lib_parameter(cycle800,_ST) 110000
        } else {
          set lib_parameter(cycle800,_ST) 220000
        }
      }
    }
    set lib_parameter(cycle800,_ST) [expr $lib_parameter(cycle800,_ST) + [CONF_S840D_cycle800 _ST]]

    return 0
  }

}
# <Internal Documentation>
# Controls for CYCLE800 the direction
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_reset {} {

  global lib_flag lib_sav_kin_machine_type

  if {$lib_flag(mode_current_status) == "std"} {return}

  LIB_local_origin_reset

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer LOCAL_CSYS_RESET
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_reset}} @LOCAL_POS_RESET
  LIB_GE_command_buffer_output
  switch -- [CONF_CTRL_setting plane_output] {
    "TRANS_ROT"  {
      LIB_GE_command_buffer TRANS_ROT_reset
      LIB_GE_command_buffer {MOM_do_template trafoof} @RESET_TRAFOOF
      LIB_GE_command_buffer {MOM_output_literal "ROT"} @RESET_ROT
      LIB_GE_command_buffer_output
    }
    "CYCLE800" {
      MOM_enable_address G_plane
      if {[CONF_S840D_cycle800 plane_output_motion_with_reset] == "STAY"} {
        LIB_GE_command_buffer CYCLE800_reset
        LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE800_reset} @RESET
        LIB_GE_command_buffer_output
      } else {
        LIB_GE_command_buffer CYCLE800_reset_turn
        LIB_GE_command_buffer {if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}} @RETRACT
        LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE800_reset_turn} @RESET
        LIB_GE_command_buffer_output
      }
    }
    default {
      [CONF_CTRL_setting plane_output] reset
    }
  }
  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis
  } else {
    MOM_enable_address fourth_axis fifth_axis
  }
  set lib_flag(mode_current_status) "std"

}
# <Internal Documentation>
# reset plane
#
# lib_parameter(plane_output)
#           == "TRANS_ROT"
#           == "CYCLE800"
#
# lib_parameter(plane_output_motion_with_reset)
#           == "MOVE"
#           == "STAY"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_pos {} {

  global mom_prev_out_angle_pos mom_out_angle_pos mom_polar_status mom_current_motion
  global lib_flag mom_rotary_direction_4th mom_lib_cycle800_dir mom_operation_type

  # To get the smaller value of rotary axis 1 or 2 for CYCLE800.
  if {[CONF_S840D_cycle800 _DIR] != 0} {
    set mom_rotary_direction_4th [CONF_S840D_cycle800 _DIR]
    set mom_lib_cycle800_dir [CONF_S840D_cycle800 _DIR]
  }

  if {[string match $mom_operation_type "Device Generic Motion"]} {
    return
  }

  if {$mom_current_motion == "initial_move"} {
    if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1} {
      set lib_flag(safety_retract_status) 1
    } else {
      set lib_flag(safety_retract_status) 0
    }
  }

  if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1 || $mom_current_motion != "initial_move"} {
    if {[info exists mom_prev_out_angle_pos] && $mom_polar_status != "ON" && [CONF_CTRL_moves standard_path_between_rotary_motions] == 0} {
      if {[CONF_CTRL_moves safety_retract_before_fourth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)]} {
        if {[EQ_is_gt [expr abs($mom_out_angle_pos(0) - $mom_prev_out_angle_pos(0))] [CONF_CTRL_moves safety_retract_before_fourth_axis_minimum_value]]} {
          set lib_flag(safety_retract_status) 1
        }
      }

      if {[CONF_CTRL_moves safety_retract_before_fifth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(1) $mom_out_angle_pos(1)]} {
        if {[EQ_is_gt [expr abs($mom_out_angle_pos(1) - $mom_prev_out_angle_pos(1))] [CONF_CTRL_moves safety_retract_before_fifth_axis_minimum_value]]} {
          set lib_flag(safety_retract_status) 1
        }
      }
    }

    if {[info exists lib_flag(safety_retract_status)] && $lib_flag(safety_retract_status) == 1} {
      if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
      set lib_flag(tool_path_motion) 1
      set lib_flag(safety_retract_status) 0
    }
  }

  LIB_CTRL_prepos_before_plane

}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_prepos_before_plane {} {

  if {[CONF_SPF_plane_kin plane_prepos] == 1} {
    global lib_flag mom_pos oper_mcs_matrix mom_origin
    set tmp_motion_init [CONF_S840D_cycle800 plane_output_motion_with_init]
    set tmp_motion_reset [CONF_S840D_cycle800 plane_output_motion_with_reset]
    if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_dual_head" || \
      [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_head_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HH
      LIB_GE_command_buffer {
        CONF_S840D_cycle800 set plane_output_motion_with_init "MOVE"
        if {[CONF_CTRL_setting plane_output] == "CYCLE800"} {
          LIB_ROTARY_positioning_init
        } elseif {[CONF_CTRL_setting plane_output] == "TRANS_ROT"} {
          MOM_suppress once rot_x rot_y rot_z transf
          LIB_ROTARY_positioning_init
          MOM_suppress once transf
        }
      } @INIT_PLANE
      LIB_GE_command_buffer {
        CONF_S840D_cycle800 set plane_output_motion_with_reset "STAY"
        set tmp_local_origin_activated $lib_flag(local_origin_activated)
        set lib_flag(local_origin_activated) 0
        LIB_ROTARY_positioning_reset
        set lib_flag(local_origin_activated) $tmp_local_origin_activated
      } @RESET_PLANE
      LIB_GE_command_buffer {LIB_ROTARY_simultaneous_init} @INIT_SIM
      LIB_GE_command_buffer {
        LIB_SPF_convert_point "simultaneous"
        VMOV 3 mom_pos tmp_pos
        MTX3_transpose oper_mcs_matrix tmp_matrix
        MTX3_vec_multiply tmp_pos tmp_matrix mom_pos
        if {[CONF_CTRL_setting plane_output] == "CYCLE800"} {
          VEC3_add mom_origin mom_pos mom_pos
        }
      } @CP_SIM
      LIB_GE_command_buffer {
        set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
        LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $::mom_motion_event] FORCE "[join $decompose] fourth_axis fifth_axis"
      } @MOTION
      LIB_GE_command_buffer {LIB_SPF_convert_point "reload"} @CP_RELOAD
      LIB_GE_command_buffer {
        LIB_ROTARY_simultaneous_reset
      } @RESET_SIM
      LIB_GE_command_buffer_output
      set ::lib_flag(preset_save_pos) 0

    } elseif {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_head_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HT

      LIB_GE_command_buffer_output
    } else {
      # do nothing
    }
    CONF_S840D_cycle800 set plane_output_motion_with_init $tmp_motion_init
    CONF_S840D_cycle800 set plane_output_motion_with_reset $tmp_motion_reset
  }
}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion_pos
# Preposition tool axis when property plane_prepos is set
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_sim {} {
  global lib_parameter lib_flag mom_origin

  if {[CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    set tmp_motion_init [CONF_S840D_cycle800 plane_output_motion_with_init]
    set tmp_motion_reset [CONF_S840D_cycle800 plane_output_motion_with_reset]
    set tmp_rotate_before [CONF_S840D_cycle800 rotate_before]
    set tmp_rotate_after [CONF_S840D_cycle800 rotate_after]
    set tmp_int_dir [CONF_S840D_cycle800 _ST]
    if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] == "5_axis_dual_table"} {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE
      LIB_GE_command_buffer {
        MOM_force once fourth_axis fifth_axis
        LIB_CTRL_rotate_axis
        CONF_S840D_cycle800 set rotate_before 0
      } @PRE_ROTARY
      LIB_GE_command_buffer {
        # PR#9759547 use lower rotary axis value for _ST "10000"
        set alt_out_angle_pos(1) [LIB_SPF_rotset $::mom_alt_pos(4) $::mom_prev_out_angle_pos(1) $::mom_kin_5th_axis_direction\
          $::mom_kin_5th_axis_leader mom_sys_leader(fifth_axis)\
          $::mom_kin_5th_axis_min_limit $::mom_kin_5th_axis_max_limit 1]
        if {[EQ_is_gt $::mom_out_angle_pos(1) $alt_out_angle_pos(1)]} {
          CONF_S840D_cycle800 set _ST "20000"
        } else {
          CONF_S840D_cycle800 set _ST "10000"
        }

        if {$lib_flag(local_namespace_output)} {
          LIB_SPF_local_csys_rotation
        } else {
          LIB_SPF_convert_point "plane_no_reset"
          LIB_SPF_csys_3D_rotation
          LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
        }
      } @CP_PLANE
      LIB_GE_command_buffer {
        CONF_S840D_cycle800 set plane_output_motion_with_init "UNUSED"
        CONF_S840D_cycle800 set rotate_after "0"
        LIB_ROTARY_positioning_init
      } @INIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {LIB_ROTARY_positioning_first_move_pos} @MOTION
      LIB_GE_command_buffer {
        CONF_S840D_cycle800 set plane_output_motion_with_reset "STAY"
        set tmp_local_origin_activated $lib_flag(local_origin_activated)
        set lib_flag(local_origin_activated) 0
        LIB_ROTARY_positioning_reset
        set lib_flag(local_origin_activated) $tmp_local_origin_activated
        if {![VEC3_is_zero mom_origin] && [CONF_CTRL_setting plane_output] == "CYCLE800"} {
          MOM_do_template frame_trans
          set lib_flag(local_origin_activated) 1
        }
      } @RESET
      LIB_GE_command_buffer {
        if {$lib_flag(local_namespace_output) == 0} {
          LIB_SPF_convert_point "reload"
        } else {
          VMOV 3 ::mom_mcs_goto ::mom_pos
        }
      } @CP_RELOAD
      LIB_GE_command_buffer {
        if {$lib_flag(local_namespace_output) == 0} {
          if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
            LIB_SPF_KINEMATICS_set_absolut_output_kin
          } else {
            LIB_SPF_KINEMATICS_set_simultanous_kin
          }
        }
      } @KIN_SIM
      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TCPM_PREPOS_PLANE_HH
      LIB_GE_command_buffer {
        MOM_force once fourth_axis fifth_axis
        MOM_do_template rapid_rotary
      } @PRE_ROTARY
      LIB_GE_command_buffer {LIB_ROTARY_simultaneous_init} @INIT
      LIB_GE_command_buffer_output

    }
    CONF_S840D_cycle800 set plane_output_motion_with_init $tmp_motion_init
    CONF_S840D_cycle800 set plane_output_motion_with_reset $tmp_motion_reset
    CONF_S840D_cycle800 set rotate_before $tmp_rotate_before
    CONF_S840D_cycle800 set rotate_after $tmp_rotate_after
    CONF_S840D_cycle800 set _ST $tmp_int_dir
  }
}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_dwell_set {} {

  global mom_cycle_delay_mode ;# SECONDS, REVOLUTIONS, OFF ,ON
  global mom_cycle_delay mom_cycle_delay_revs mom_spindle_rpm

  if {$mom_cycle_delay_mode == "ON"} {set mom_cycle_delay [CONF_CTRL_drill default_cycle_delay]}

  if {$mom_cycle_delay_mode == "OFF"} {
    set mom_cycle_delay 0
    return
  }

  if {$mom_cycle_delay_mode == "REVOLUTIONS"} {
    catch {set mom_cycle_delay [expr $mom_cycle_delay_revs * (60 / $mom_spindle_rpm)]}
  }

  if {$mom_cycle_delay > [CONF_CTRL_drill max_delay]} {set mom_cycle_delay [CONF_CTRL_drill max_delay]}
  if {$mom_cycle_delay < [CONF_CTRL_drill min_delay]} {set mom_cycle_delay [CONF_CTRL_drill min_delay]}
}
# <Internal Documentation>
# This procedure is executed at the cycle event.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_cleanup_inline {line} {

  regsub -all -- {, } $line "," line
  return $line

}

# <Internal Documentation>
#
# Adjusted blank in the cycle output
#
# e.g.
# Before: MCALL CYCLE81(5,0,2,-28.0043, ,0,1,0)
# After:  MCALL CYCLE81(5,0,2,-28.0043,,0,1,0)
#
# <Internal Example>
# set list [LIB_CTRL_cleanup_inline $list]
#____________________________________________________________________________________________
proc MOM_drill_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill : output CYCLE81 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_move_LIB {} {

  set commandcheck(MOM_drill_move_LIB_ENTRY) [llength [info commands MOM_drill_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_dwell : output CYCLE82 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell_move_LIB {} {

  set commandcheck(MOM_drill_dwell_move_LIB_ENTRY) [llength [info commands MOM_drill_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_deep_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_deep : output CYCLE83_Deep (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep_move_LIB {} {

  set commandcheck(MOM_drill_deep_move_LIB_ENTRY) [llength [info commands MOM_drill_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_break_chip : output CYCLE83_Break_Chip (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_break_chip_move_LIB {} {

  set commandcheck(MOM_drill_break_chip_move_LIB_ENTRY) [llength [info commands MOM_drill_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_mill_hole_move_LIB {} {

  set commandcheck(MOM_mill_hole_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_parameter
  if {![string equal $::mom_cycle_feed_rate_mode "MMPM"]&&![string equal $::mom_cycle_feed_rate_mode "IPM"]} {
    LIB_GE_error_message "Unspported mom_cycle_feed_rate_mode in Operation 'INS->$::mom_path_name<-'" "It should be MMPM or IPM"
  }
  if {![string equal $::mom_feed_engage_unit "mmpm"]&&![string equal $::mom_feed_engage_unit "ipm"]} {
    LIB_GE_error_message "Unspported mom_feed_engage_unit in Operation 'INS->$::mom_path_name<-'" "It should be mmpm or ipm"
  }
  if {$::mom_cycle_spindle_axis==0} {
    set lib_parameter(pocket4,_RTP) $::mom_cycle_rapid_to_pos(0)
    set lib_parameter(pocket4,_RFP) $::mom_pos(0)
    set lib_parameter(pocket4,_DP) [expr $::mom_pos(0) + $::mom_cycle_feed_to]
    set lib_parameter(pocket4,_PA) $::mom_pos(1)
    set lib_parameter(pocket4,_PO) $::mom_pos(2)
  }
  if {$::mom_cycle_spindle_axis==1} {
    set lib_parameter(pocket4,_RTP) $::mom_cycle_rapid_to_pos(1)
    set lib_parameter(pocket4,_RFP) $::mom_pos(1)
    set lib_parameter(pocket4,_DP) [expr $::mom_pos(1) + $::mom_cycle_feed_to]
    set lib_parameter(pocket4,_PA) $::mom_pos(0)
    set lib_parameter(pocket4,_PO) $::mom_pos(2)
  }
  if {$::mom_cycle_spindle_axis==2} {
    set lib_parameter(pocket4,_RTP) $::mom_cycle_rapid_to_pos(2)
    set lib_parameter(pocket4,_RFP) $::mom_pos(2)
    set lib_parameter(pocket4,_DP) [expr $::mom_pos(2) + $::mom_cycle_feed_to]
    set lib_parameter(pocket4,_PA) $::mom_pos(0)
    set lib_parameter(pocket4,_PO) $::mom_pos(1)
  }
  set lib_parameter(pocket4,_SDIS) $::mom_cycle_clearance_plane
  set lib_parameter(pocket4,_PRAD) [expr $::mom_cycle_feature_diameter/2.0]
  set lib_parameter(pocket4,_FAL) 0
  set lib_parameter(pocket4,_FALD) 0
  set lib_parameter(pocket4,_FFP1) $::mom_cycle_feed_rate
  set lib_parameter(pocket4,_FFD) $::mom_feed_engage_value
  if {$::mom_cut_direction_type==1} {
    #Climb
    set lib_parameter(pocket4,_CDIR) 2
  }
  if {$::mom_cut_direction_type==2} {
    #Conventional
    set lib_parameter(pocket4,_CDIR) 3
  }
  if {$::mom_region_cut_method == 11} {
    #Helical
    set lib_parameter(pocket4,_VARI) 1021
    if {[info exists ::mom_vertical_pitch_value_source] && $::mom_vertical_pitch_value_source == 4} {
      if {[info exists ::mom_axial_stepover_distance_source] && $::mom_axial_stepover_distance_source == 4} {
        if {$::mom_vertical_pitch_value > $::mom_axial_stepover_distance} {
          set lib_parameter(pocket4,_DP1) [expr $::mom_tool_diameter*$::mom_axial_stepover_distance/100.0]
        } else {
          set lib_parameter(pocket4,_DP1) [expr $::mom_tool_diameter*$::mom_vertical_pitch_value/100.0]
        }
      } else {
        if {[expr $::mom_tool_diameter*$::mom_vertical_pitch_value/100.0] > $::mom_axial_stepover_distance} {
          set lib_parameter(pocket4,_DP1) $::mom_axial_stepover_distance
        } else {
          set lib_parameter(pocket4,_DP1) [expr $::mom_tool_diameter*$::mom_vertical_pitch_value/100.0]
        }
      }
    } else {
      if {[info exists ::mom_axial_stepover_distance_source] && $::mom_axial_stepover_distance_source == 4} {
        if {$::mom_vertical_pitch_value > [expr $::mom_tool_diameter*$::mom_axial_stepover_distance/100.0]} {
          set lib_parameter(pocket4,_DP1) [expr $::mom_tool_diameter*$::mom_axial_stepover_distance/100.0]
        } else {
          set lib_parameter(pocket4,_DP1) $::mom_vertical_pitch_value
        }
      } else {
        if {$::mom_vertical_pitch_value > $::mom_axial_stepover_distance} {
          set lib_parameter(pocket4,_DP1) $::mom_axial_stepover_distance
        } else {
          set lib_parameter(pocket4,_DP1) $::mom_vertical_pitch_value
        }
      }
    }
  } else {
    if {$::mom_region_cut_method == 16} {
      #Circular
      if {[string equal $::mom_feed_engage_nominal_unit "Rapid"]} {
        set lib_parameter(pocket4,_VARI) 0001
      } else {
        set lib_parameter(pocket4,_VARI) 0011
      }
      if {[info exists ::mom_axial_stepover_distance_source] && $::mom_axial_stepover_distance_source == 4} {
        set lib_parameter(pocket4,_DP1) [expr $::mom_tool_diameter*$::mom_axial_stepover_distance/100.0]
      } else {
        set lib_parameter(pocket4,_DP1) $::mom_axial_stepover_distance
      }
    } else {
      LIB_GE_abort_message "$::mom_operation_name: Only Circular and Helical Cut Pattern Supported for POCKET4"
    }
  }
  set lib_parameter(pocket4,_MID) $lib_parameter(pocket4,_DP1)
  if {[info exists ::mom_pocket4_maximum_infeed_width]} {
    set lib_parameter(pocket4,_MIDA) $::mom_pocket4_maximum_infeed_width
  } else {
    set lib_parameter(pocket4,_MIDA) 0
  }
  set lib_parameter(pocket4,_AP1) [expr $::mom_cycle_feature_start_diameter/2.0]
  if {$::mom_cycle_feature_start_diameter > 0} {
    set lib_parameter(pocket4,_AD) [expr - $::mom_cycle_feed_to]
  } else {
    set lib_parameter(pocket4,_AD) 0
  }
  if {[info exists ::mom_pocket4_helical_path_radius]} {
    set lib_parameter(pocket4,_RAD1) $::mom_pocket4_helical_path_radius
  } else {
    set lib_parameter(pocket4,_RAD1) 2
  }
  LIB_GE_command_buffer MILL_HOLE_MOVE
  LIB_GE_command_buffer {LIB_SPF_call_cycle "POCKET4"} @Output
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# MOM_mill_hole_move : Output POCKET4
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_mill_hole_thread_move_LIB {} {

  set commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_parameter
  if {![string equal $::mom_cycle_feed_rate_mode "MMPM"]&&![string equal $::mom_cycle_feed_rate_mode "IPM"]} {
    LIB_GE_error_message "Unspported mom_cycle_feed_rate_mode in Operation 'INS->$::mom_path_name<-'" "It should be MMPM or IPM"
  }
  if {![string equal $::mom_feed_engage_unit "mmpm"]&&![string equal $::mom_feed_engage_unit "ipm"]} {
    LIB_GE_error_message "Unspported mom_feed_engage_unit in Operation 'INS->$::mom_path_name<-'" "It should be mmpm or ipm"
  }
  if {$::mom_cycle_spindle_axis==0} {
    set lib_parameter(cycle90,_RTP) $::mom_cycle_rapid_to_pos(0)
    set lib_parameter(cycle90,_RFP) $::mom_pos(0)
    set lib_parameter(cycle90,_DP) [expr $::mom_pos(0) + $::mom_cycle_feed_to]
    set lib_parameter(cycle90,_CPA) $::mom_cycle_rapid_to_pos(1)
    set lib_parameter(cycle90,_CPO) $::mom_cycle_rapid_to_pos(2)
  }
  if {$::mom_cycle_spindle_axis==1} {
    set lib_parameter(cycle90,_RTP) $::mom_cycle_rapid_to_pos(1)
    set lib_parameter(cycle90,_RFP) $::mom_pos(1)
    set lib_parameter(cycle90,_DP) [expr $::mom_pos(1) + $::mom_cycle_feed_to]
    set lib_parameter(cycle90,_CPA) $::mom_cycle_rapid_to_pos(0)
    set lib_parameter(cycle90,_CPO) $::mom_cycle_rapid_to_pos(2)
  }
  if {$::mom_cycle_spindle_axis==2} {
    set lib_parameter(cycle90,_RTP) $::mom_cycle_rapid_to_pos(2)
    set lib_parameter(cycle90,_RFP) $::mom_pos(2)
    set lib_parameter(cycle90,_DP) [expr $::mom_pos(2) + $::mom_cycle_feed_to]
    set lib_parameter(cycle90,_CPA) $::mom_cycle_rapid_to_pos(0)
    set lib_parameter(cycle90,_CPO) $::mom_cycle_rapid_to_pos(1)
  }
  set lib_parameter(cycle90,_SDIS) $::mom_cycle_clearance_plane

  if {$::mom_cut_direction_type==1} {
    #Climb
    set lib_parameter(cycle90,_CDIR) 2
  }
  if {$::mom_cut_direction_type==2} {
    #Conventional
    set lib_parameter(cycle90,_CDIR) 3
  }

  if {$::mom_cycle_feed_to < 0 } {
      set lib_parameter(cycle90,_DPR) [expr $::mom_cycle_feed_to*-1]
  } else {
      set lib_parameter(cycle90,_DPR) $::mom_cycle_feed_to
  }

  if {$::mom_cycle_thread_major_diameter > $::mom_cycle_feature_diameter} {
    set lib_parameter(cycle90,_DIATH) $::mom_cycle_thread_major_diameter
    set lib_parameter(cycle90,_KDIAM) $::mom_cycle_feature_diameter
  } else {
    set lib_parameter(cycle90,_DIATH) $::mom_cycle_feature_diameter
    set lib_parameter(cycle90,_KDIAM) $::mom_cycle_thread_minor_diameter
  }
  set lib_parameter(cycle90,_PIT) $::mom_cycle_thread_pitch
  set lib_parameter(cycle90,_FFR) $::mom_cycle_feed_rate

  if {$::mom_cycle_feature_internal} {
    set lib_parameter(cycle90,_TYPTH) 0
  } else {
    set lib_parameter(cycle90,_TYPTH) 1
  }
  LIB_GE_command_buffer MILL_HOLE_THREAD_MOVE
  LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE90"} @Output
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# MOM_mill_hole_move : Output CYCLE90
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_LIB {} {
  global mom_spindle_direction
  global mom_cycle_feed_rate_per_rev
  global mom_siemens_cycle_pit mom_siemens_cycle_mpit
  global mom_siemens_cycle_o_var1

  set mom_siemens_cycle_mpit ""

  if {0} {
    if {$mom_spindle_direction == "CLW"} {
      set mom_siemens_cycle_pit $mom_cycle_feed_rate_per_rev
    } else {
      set mom_siemens_cycle_pit [expr $mom_cycle_feed_rate_per_rev * -1]
    }
  }

  set mom_siemens_cycle_o_var1 0

  LIB_CYCLE_set
  LIB_CYCLE_tap_set
}
# <Internal Documentation>
# MOM_tap : output CYCLE84 (default)
#   output CYCLE840 (option)
# (see lib_parameter(cycle_tap) parameter)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_move_LIB {} {

  set commandcheck(MOM_tap_move_LIB_ENTRY) [llength [info commands MOM_tap_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_float_LIB {} {
  global mom_spindle_direction
  global mom_cycle_feed_rate_per_rev
  global mom_siemens_cycle_pit mom_siemens_cycle_mpit
  global mom_siemens_cycle_enc
  global mom_siemens_cycle_sdr
  global mom_spindle_direction

  set mom_siemens_cycle_mpit ""
  if {[info exists mom_siemens_cycle_enc]} {
    switch $mom_siemens_cycle_enc {
      "Use Encoder-Dwell Off" {set mom_siemens_cycle_enc 0; set mom_siemens_cycle_sdr 0}
      "Use Encoder-Dwell On"  {set mom_siemens_cycle_enc 20; set mom_siemens_cycle_sdr 0}
      "No Encoder-Feed Rate before Cycle" {
        set mom_siemens_cycle_enc 1
        if {$mom_spindle_direction == "CCLW"} {
          set mom_siemens_cycle_sdr 3
        } else {
          set mom_siemens_cycle_sdr 4
        }
      }
      "No Encoder-Feed Rate in Cycle"     {
        set mom_siemens_cycle_enc 11
        if {$mom_spindle_direction == "CCLW"} {
          set mom_siemens_cycle_sdr 3
        } else {
          set mom_siemens_cycle_sdr 4
        }
      }
      default  {}
    }
  }

  LIB_CYCLE_set
  LIB_CYCLE_tap_set
}
# <Internal Documentation>
# MOM_tap_float : output CYCLE840 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float_move_LIB {} {

  set commandcheck(MOM_tap_float_move_LIB_ENTRY) [llength [info commands MOM_tap_float_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_deep_LIB {} {
  global mom_spindle_direction
  global mom_cycle_feed_rate_per_rev
  global mom_siemens_cycle_pit mom_siemens_cycle_mpit
  global mom_siemens_cycle_o_var1
  global mom_siemens_cycle_o_dam mom_cycle_step1
  global mom_siemens_cycle_poss mom_cycle_orient
  global mom_siemens_cycle_o_vrt

  set mom_siemens_cycle_mpit ""

  set mom_siemens_cycle_o_var1 2

  if {[info exists mom_cycle_step1] && ![EQ_is_zero $mom_cycle_step1]} {
    set mom_siemens_cycle_o_dam $mom_cycle_step1
  } else {
    LIB_SPF_add_warning "Step value of Tap Deep cycle cannot be zero!"
  }

  if {[info exists mom_cycle_orient]} {
    set mom_siemens_cycle_poss $mom_cycle_orient
  } else {
    set mom_siemens_cycle_poss 0
  }

  LIB_CYCLE_set
  LIB_CYCLE_tap_set
}
# <Internal Documentation>
# MOM_tap_deep : output CYCLE84 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep_move_LIB {} {

  set commandcheck(MOM_tap_deep_move_LIB_ENTRY) [llength [info commands MOM_tap_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_break_chip_LIB {} {
  global mom_spindle_direction
  global mom_cycle_feed_rate_per_rev
  global mom_siemens_cycle_pit mom_siemens_cycle_mpit
  global mom_siemens_cycle_o_var1
  global mom_siemens_cycle_o_dam mom_cycle_step1
  global mom_siemens_cycle_poss mom_cycle_orient
  global mom_siemens_cycle_o_vrt mom_cycle_step_clearance

  set mom_siemens_cycle_mpit ""

  set mom_siemens_cycle_o_var1 1

  if {[info exists mom_cycle_step1] && ![EQ_is_zero $mom_cycle_step1]} {
    set mom_siemens_cycle_o_dam $mom_cycle_step1
  } else {
    LIB_SPF_add_warning "Step value of Tap Break Chip cycle cannot be zero!"
  }

  if {[info exists mom_cycle_orient]} {
    set mom_siemens_cycle_poss $mom_cycle_orient
  } else {
    set mom_siemens_cycle_poss 0
  }

  if {[info exists mom_cycle_step_clearance]} {
    set mom_siemens_cycle_o_vrt $mom_cycle_step_clearance
  }

  LIB_CYCLE_set
  LIB_CYCLE_tap_set
}
# <Internal Documentation>
# MOM_tap_break_chip : output CYCLE84 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip_move_LIB {} {

  set commandcheck(MOM_tap_break_chip_move_LIB_ENTRY) [llength [info commands MOM_tap_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore : output CYCLE85_Bore (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_move_LIB {} {

  set commandcheck(MOM_bore_move_LIB_ENTRY) [llength [info commands MOM_bore_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_dwell : output CYCLE85_Bore_Dwell (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell_move_LIB {} {

  set commandcheck(MOM_bore_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_drag_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_drag : output CYCLE89 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag_move_LIB {} {

  set commandcheck(MOM_bore_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_no_drag_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_no_drag : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag_move_LIB {} {

  set commandcheck(MOM_bore_no_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_no_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_back_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_back : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back_move_LIB {} {

  set commandcheck(MOM_bore_back_move_LIB_ENTRY) [llength [info commands MOM_bore_back_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![LIB_GE_commandbuffer_is_customized BORE_BACK_MOVE] && ![LIB_GE_commandbuffer_is_customized CLEARANCE_MOVE] && ![LIB_GE_commandbuffer_is_customized OPERATION]} {

    LIB_CYCLE_move

  } else {

    global mom_cycle_feed_to mom_cycle_retract_to_pos mom_cycle_rapid_to_pos
    global lib_parameter lib_flag tool_axis mom_cycle_option mom_motion_event
    global mom_pos mom_prev_pos mom_cycle_clearance_plane_change mom_delay_value mom_cycle_delay
    global cycle_peck_size cycle_axis_address tool_axis_direction
    global lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos

    LIB_GE_command_buffer BORE_BACK_MOVE
    LIB_GE_command_buffer {
      LIB_SPINDLE_start cycle
    } @SPINDLE_START
    LIB_GE_command_buffer {
      if {$lib_flag(tool_path_motion) == 1} {
        switch -- $tool_axis {
          0 {LIB_SPF_decompose_block_template "{Y Z}" "cycle_move" FORCE "Y Z"}

          1 {LIB_SPF_decompose_block_template "{X Z}" "cycle_move" FORCE "X Z"}

          2 {LIB_SPF_decompose_block_template "{X Y}" "cycle_move" FORCE "X Y"}
        }
      }
    } @CYCLE_MOVE
    LIB_GE_command_buffer_output
    set lib_flag(tool_path_motion) 2

    # --> mom_cycle_tool_axis_change and mom_cycle_clearance_plane_change is added
    # to detect the tool axis change and clearance plane change in cycles. They are only available in NX754 and later version.
    # mom_cycle_tool_axis_change = 1 means tool axis is changed.
    # mom_cycle_tool_axis_change = 0 menas no tool axis change.
    # mom_cycle_clearance_plane_change = 0 means no clearance plane change.
    # mom_cycle_clearance_plane_change = 1 means clearance plane change from lower to higher.
    # mom_cycle_clearance_plane_change = -1 means clearance plane change from higher to lower.
    # mom_cycle_clearance_plane_change is only defined if mom_kin_cycle_plane_change_per_axis is set to 1
    # if mom_kin_cycle_plane_change_per_axis is not set to 1 mom_cycle_clearance_plane_change is defined here
    # after this proc mom_cycle_clearance_plane_change is unset
    if {![info exist mom_cycle_clearance_plane_change]} {
      if {[EQ_is_gt $mom_prev_pos($tool_axis) $mom_pos($tool_axis)]} {
        set mom_cycle_clearance_plane_change -1
      } elseif {[EQ_is_lt $mom_prev_pos($tool_axis) $mom_pos($tool_axis)]} {
        set mom_cycle_clearance_plane_change 1
      } else {
        set mom_cycle_clearance_plane_change 0
      }
    }
    if {$lib_flag(output_cycle_call) == 1 || $mom_cycle_clearance_plane_change != 0 || ![info exists lib_flag(cycle_mcall_active)] || $lib_flag(cycle_mcall_active) == 0} {
      LIB_GE_command_buffer CLEARANCE_MOVE
      LIB_GE_command_buffer {
        LIB_SPF_retract_to_pos
      } @RETRACT_TO_POS
      LIB_GE_command_buffer {
        set cycle_peck_size [expr ($mom_cycle_feed_to*(-1.0))]     ;# single peck size most cycles
        LIB_init_cycle_parameters
      } @CYCLE_PARAMETERS
      LIB_GE_command_buffer {
        # move to XY position
        switch -- $tool_axis {
          0 {LIB_SPF_decompose_block_template "{Y Z}" "cycle_move" FORCE "X"}

          1 {LIB_SPF_decompose_block_template "{X Z}" "cycle_move" FORCE "Y"}

          2 {LIB_SPF_decompose_block_template "{X Y}" "cycle_move" FORCE "Z"}
        }
      } @CYCLE_MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer OPERATION
    LIB_GE_command_buffer {
      # Orient spindle
      global mom_sys_spindle_orient_value mom_cycle_orient
      if {[info exists mom_cycle_orient] && [string trim $mom_cycle_orient] != ""} {
        set mom_sys_spindle_orient_value $mom_cycle_orient
      } else {
        set mom_sys_spindle_orient_value 0
      }
      MOM_force Once S_pos
      MOM_do_template spindle_orient2
    } @SPINDLE_ORIENT_1
    LIB_GE_command_buffer {
      # Offset X Y Z
      MOM_force Once X Y Z
      MOM_do_template bore_back_offset
    } @OFFSET
    LIB_GE_command_buffer {
      MOM_do_template absolute_mode BUFFER
      # Move to bottom
      switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{X}" "cycle_move" FORCE "Y Z"}

        1 {LIB_SPF_decompose_block_template "{Y}" "cycle_move" FORCE "X Z"}

        2 {LIB_SPF_decompose_block_template "{Z}" "cycle_move" FORCE "X Y"}
      }
    } @MOVE_TO_BOTTOM
    LIB_GE_command_buffer {
      # Move to XY position
      switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z}" "cycle_move" FORCE "X"}

        1 {LIB_SPF_decompose_block_template "{X Z}" "cycle_move" FORCE "Y"}

        2 {LIB_SPF_decompose_block_template "{X Y}" "cycle_move" FORCE "Z"}
      }
    } @MOVE_TO_XY_POS
    LIB_GE_command_buffer {
      # Spindle start
      # Bore back
      switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{X M_spindle}" "cycle_feed_to" FORCE "Y Z"}

        1 {LIB_SPF_decompose_block_template "{Y M_spindle}" "cycle_feed_to" FORCE "X Z"}

        2 {LIB_SPF_decompose_block_template "{Z M_spindle}" "cycle_feed_to" FORCE "X Y"}
      }
    } @CYCLE_FEED_TO
    LIB_GE_command_buffer {
      if {[info exists ::mom_cycle_delay]} {
        # DWEll
        set mom_delay_value $mom_cycle_delay
        MOM_do_template delay
      }
    } @DELAY
    LIB_GE_command_buffer {
      # Orient spindle
      MOM_force Once S_pos
      MOM_do_template spindle_orient2
    } @SPINDLE_ORIENT_2
    LIB_GE_command_buffer {
      # Offset X Y Z
      MOM_do_template bore_back_offset
    } @BORE_BACK_OFFSET
    LIB_GE_command_buffer {
      # Move back to retract plane and origianl point
      MOM_do_template absolute_mode BUFFER
    } @BACK_TO_RETRACT_PLANE
    LIB_GE_command_buffer {
      switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z} X" "cycle_retract" FORCE "X Y Z"}

        1 {LIB_SPF_decompose_block_template "{X Z} Y" "cycle_retract" FORCE "X Y Z"}

        2 {LIB_SPF_decompose_block_template "{X Y} Z" "cycle_retract" FORCE "X Y Z"}
      }
    } @CYCLE_RETRACT
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual : output CYCLE87 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_move_LIB {} {

  set commandcheck(MOM_bore_manual_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual_dwell : output CYCLE88 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_move_LIB {} {

  set commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_text_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text_move_LIB {} {

  set commandcheck(MOM_drill_text_move_LIB_ENTRY) [llength [info commands MOM_drill_text_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_thread_LIB {} {

  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_move_LIB {} {

  set commandcheck(MOM_thread_move_LIB_ENTRY) [llength [info commands MOM_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# MOM_thread_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_off_LIB {} {

  global lib_flag

  set commandcheck(MOM_cycle_off_LIB_ENTRY) [llength [info commands MOM_cycle_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[info exists lib_flag(cycle_mcall_active)] && $lib_flag(cycle_mcall_active) == 1} {
    LIB_SPF_call_cycle MCALL
    set lib_flag(cycle_mcall_active) 0
  }

  LIB_GE_command_buffer CYCLE_OFF
  LIB_GE_command_buffer {MOM_do_template cycle_init CREATE} @OUTPUT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CYCLE_set {} {
  global mom_cycle_delay mom_siemens_cycle_dtb
  global lib_flag

  LIB_GE_command_buffer CYCLE_SET_start
  LIB_GE_command_buffer {
  global mom_cycle_feed_rate mom_cycle_feed_rate_mode mom_cycle_feed_rate_per_rev mom_spindle_rpm
    if {[string match *PR* [string toupper $mom_cycle_feed_rate_mode]]} {
      set mom_cycle_feed_rate [expr $mom_cycle_feed_rate_per_rev * $mom_spindle_rpm]
    }
  } @CYCLE_FEED
  LIB_GE_command_buffer_output

  LIB_CYCLE_dwell_set
  if {![hiset mom_siemens_cycle_dtb]} {set mom_siemens_cycle_dtb $mom_cycle_delay}
  set lib_flag(output_cycle_call) 1
}
# <Internal Documentation>
# Controls the drilling cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_set {} {

  global mom_tool_pitch mom_path_name mom_retract_spindle
  global mom_cycle_thread_pitch mom_siemens_cycle_sdac
  global mom_siemens_cycle_pit mom_cycle_feed_rate_per_rev
  global mom_cycle_thread_right_handed mom_spindle_speed
  global mom_spindle_direction mom_siemens_cycle_o_ptab
  global mom_spindle_rpm mom_siemens_cycle_sst mom_siemens_cycle_sst1
  global mom_cycle_option mom_siemens_cycle_amode

  if {[info exists mom_tool_pitch]} {
    set mom_siemens_cycle_pit $mom_tool_pitch
  } elseif {[info exists mom_cycle_thread_pitch]} {
    set mom_siemens_cycle_pit $mom_cycle_thread_pitch
  } else {
    if {[CONF_CTRL_drill tool_pitch_used] == 0} {
      set mom_siemens_cycle_pit $mom_cycle_feed_rate_per_rev
    } else {
      LIB_GE_abort_message "INS->$mom_path_name<- : No pitch defined on the tool." "Please use Tap tool."
    }
  }
  if {[info exists mom_cycle_thread_right_handed]} {
    if {$mom_cycle_thread_right_handed == "FALSE"} {
      set mom_siemens_cycle_pit [expr -1*$mom_siemens_cycle_pit]
    }
  } elseif {($::mom_operation_type == "Turn Centerline Drilling" && $mom_spindle_direction == "CLW") ||  ($::mom_operation_type != "Turn Centerline Drilling" && $mom_spindle_direction == "CCLW")} {
    set mom_siemens_cycle_pit [expr -1*$mom_siemens_cycle_pit]
  }

  if {[info exists mom_spindle_speed] && ![EQ_is_zero $mom_spindle_speed]} {
    set mom_siemens_cycle_sst $mom_spindle_rpm
  } else {
    LIB_GE_abort_message "INS->$mom_path_name<- : spindle speed is 0." "Please verify."
  }

  if {![info exists mom_siemens_cycle_sst1]} {
    if {![info exists mom_retract_spindle] || $mom_retract_spindle == 0} {
      set mom_siemens_cycle_sst1 $mom_spindle_rpm
    } else {
      set mom_siemens_cycle_sst1 [expr 0.01*$mom_retract_spindle*$mom_spindle_speed]
    }
  }

  if {![info exists mom_siemens_cycle_sdac]} {
    set mom_siemens_cycle_sdac 3
  } else {
    switch $mom_siemens_cycle_sdac {
      CLW     {set mom_siemens_cycle_sdac 3}
      CCLW    {set mom_siemens_cycle_sdac 4}
      Off     {set mom_siemens_cycle_sdac 5}
      default {}
    }
  }

  if {[CONF_S840D_controller sinumerik_version_sl] >= "45"} {
    if {![info exists mom_siemens_cycle_o_ptab]} {set mom_siemens_cycle_o_ptab "Post Defined"}
    switch -- [string tolower $mom_siemens_cycle_o_ptab] {
      "post defined"          {
        if {$::mom_output_unit == "IN"} {
          set mom_siemens_cycle_o_ptab 3
        } else {
          set mom_siemens_cycle_o_ptab 1
        }
      }
      "millimeter"            {
        set mom_siemens_cycle_o_ptab 1
      }
      "groove per inch"       {
        set mom_siemens_cycle_o_ptab 2
      }
      "inch per revolution"   {
        set mom_siemens_cycle_o_ptab 3
      }
      "module(solution line)" {
        set mom_siemens_cycle_o_ptab 4
      }
    }

    if {![info exists mom_cycle_option]} {set mom_cycle_option ""}
    if {(![string compare "MOM_tap_LIB" [info level -1] ] && \
      (([CONF_CTRL_drill cycle_tap] == 84 && $mom_cycle_option != "OPTION") || \
      ([CONF_CTRL_drill cycle_tap] == 840 && $mom_cycle_option == "OPTION"))) \
      || ![string compare "MOM_tap_deep_LIB" [info level -1] ] \
    || ![string compare "MOM_tap_break_chip_LIB" [info level -1] ]} {
      if {![info exists mom_cycle_thread_right_handed]} {
        if {$mom_spindle_direction=="CLW"} {set mom_siemens_cycle_amode 1000} {set mom_siemens_cycle_amode 2000}
      } else {
        set mom_siemens_cycle_amode [expr $mom_cycle_thread_right_handed?1000:2000]
      }
    }
  }
}
# <Internal Documentation>
# Controls the tapping cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move {} {

  global mom_cycle_feed_to mom_cycle_retract_to_pos mom_cycle_rapid_to_pos mom_cycle_option mom_motion_event
  global mom_pos mom_prev_pos mom_cycle_clearance_plane_change
  global cycle_peck_size cycle_axis_address tool_axis_direction
  global lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos lib_parameter lib_flag tool_axis
  global mom_cycle_feed_to_pos mom_siemens_cycle_amode mom_siemens_cycle_liftoff
  global mom_cycle_spindle_axis mom_cycle_hole_dia mom_siemens_cycle_gmode mom_siemens_cycle_dmode
  global mom_namespace_name mom_cycle_rapid_to mom_cycle_clearance_plane

  LIB_GE_command_buffer START_CYCLE
  LIB_GE_command_buffer {LIB_SPINDLE_start cycle} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer PREPOS_IN_CYCLE
  LIB_GE_command_buffer {
    if {$lib_flag(tool_path_motion) == 1} {
      switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z}" "cycle_move" FORCE "Y Z"}

        1 {LIB_SPF_decompose_block_template "{X Z}" "cycle_move" FORCE "X Z"}

        2 {LIB_SPF_decompose_block_template "{X Y}" "cycle_move" FORCE "X Y"}
      }
    }
  } @PREPOS_DEFAULT
  LIB_GE_command_buffer_output

  global mom_cutcom_plane
  switch -- $tool_axis {
          0 {set mom_cutcom_plane "YZ"}
          1 {set mom_cutcom_plane "ZX"}
          2 {set mom_cutcom_plane "XY"}
      }
  LIB_GE_command_buffer CYCLE_FEED
  LIB_GE_command_buffer {
    if {$mom_motion_event == "thread_move"} {
      MOM_suppress once F
    }
    MOM_do_template cycle_feed_mode
  } @OUTPUT
  LIB_GE_command_buffer_output

  set lib_flag(tool_path_motion) 2

  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_recalculate_cycle_pos
  }

  # --> mom_cycle_tool_axis_change and mom_cycle_clearance_plane_change is added
  # to detect the tool axis change and clearance plane change in cycles. They are only available in NX754 and later version.
  # mom_cycle_tool_axis_change = 1 means tool axis is changed.
  # mom_cycle_tool_axis_change = 0 menas no tool axis change.
  # mom_cycle_clearance_plane_change = 0 means no clearance plane change.
  # mom_cycle_clearance_plane_change = 1 means clearance plane change from lower to higher.
  # mom_cycle_clearance_plane_change = -1 means clearance plane change from higher to lower.
  # mom_cycle_clearance_plane_change is only defined if mom_kin_cycle_plane_change_per_axis is set to 1
  # if mom_kin_cycle_plane_change_per_axis is not set to 1 mom_cycle_clearance_plane_change is defined here
  # after this proc mom_cycle_clearance_plane_change is unset
  if {![info exist mom_cycle_clearance_plane_change]} {
    if {[EQ_is_gt $mom_prev_pos($tool_axis) $mom_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
      set mom_cycle_clearance_plane_change -1
    } elseif {[EQ_is_lt $mom_prev_pos($tool_axis) $mom_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
      set mom_cycle_clearance_plane_change 1
    } else {
      set mom_cycle_clearance_plane_change 0
    }
  }
  if {$lib_flag(output_cycle_call) == 1 || $mom_cycle_clearance_plane_change != 0 || ![info exists lib_flag(cycle_mcall_active)] || $lib_flag(cycle_mcall_active) == 0} {

    LIB_SPF_retract_to_pos

    set cycle_peck_size [expr ($mom_cycle_feed_to*(-1.0))]     ;# single peck size most cycles
    set force_plane_axes 1 ;#always force the output of first drilling position
    LIB_init_cycle_parameters

    if {[info exists lib_parameter(special_cycle,name)] && $lib_parameter(special_cycle,name) != ""} {
      LIB_CYCLE_move_special_$lib_parameter(special_cycle,name)
    } else {
      if {![info exists mom_cycle_option]} {set mom_cycle_option ""}
      set control ""
      if {[CONF_S840D_controller sinumerik_control_version] == "Solutionline"} {
        append control ",[CONF_S840D_controller sinumerik_control_version]"

        switch $mom_motion_event {
          drill_move {
            if {![info exists mom_siemens_cycle_gmode]} {set mom_siemens_cycle_gmode 0}
            if {[string match $mom_siemens_cycle_gmode "Depth"]} {set mom_siemens_cycle_gmode 0}
            if {[string match $mom_siemens_cycle_gmode "Diameter"]} {set mom_siemens_cycle_gmode 1}
            if {$mom_siemens_cycle_gmode ==1 && [info exists mom_cycle_hole_dia] } {
              set mom_cycle_feed_to_pos($mom_cycle_spindle_axis) $mom_cycle_hole_dia
            }
            set mom_siemens_cycle_dmode [expr 3-$mom_cycle_spindle_axis]
            set mom_siemens_cycle_amode 0
          }
          drill_dwell_move {
            set mom_siemens_cycle_gmode 0
            set mom_siemens_cycle_dmode [expr 3-$mom_cycle_spindle_axis]
            set mom_siemens_cycle_amode 0

          }
          drill_deep_move -
          drill_break_chip_move {
            set mom_siemens_cycle_gmode 0
            set mom_siemens_cycle_dmode [expr 3-$mom_cycle_spindle_axis]
            set mom_siemens_cycle_amode 0
          }
          bore_move -
          bore_dwell_move {
            set mom_siemens_cycle_plane [expr 3-$mom_cycle_spindle_axis]
            set mom_siemens_cycle_amode 0
          }
          bore_no_drag_move {
            set mom_siemens_cycle_gmode 0
            set mom_siemens_cycle_dmode [expr 3-$mom_cycle_spindle_axis]
            set mom_siemens_cycle_amode 0
          }
          bore_back_move {
            set mom_siemens_cycle_gmode 0
            if {[info exists mom_siemens_cycle_liftoff] && [string match $mom_siemens_cycle_liftoff "No"]} {
              set mom_siemens_cycle_gmode 1
            }
            set mom_siemens_cycle_dmode [expr 3-$mom_cycle_spindle_axis]
            set mom_siemens_cycle_amode 0
          }
          tap_move -
          tap_float_move -
          tap_deep_move -
          tap_break_chip_move  {
            if {![info exist mom_siemens_cycle_gmode]} {
              set mom_siemens_cycle_gmode 0
            }
            set mom_siemens_cycle_dmode [expr 3-$mom_cycle_spindle_axis]
            if {![info exist mom_siemens_cycle_amode]} {
              set mom_siemens_cycle_amode 0
            }
          }
          default {}
        }

      }

      if {[CONF_CTRL_drill drilling_cycles_output] == "Incremental"} {
        append control ",[CONF_CTRL_drill drilling_cycles_output]"
      }

      # PR9528010: The safety distance (SDIS) in Cycle must be positive.
      # If rapid_to is negetive, replace it by clearance_plane before output.
      LIB_GE_command_buffer CYCLE_RAPIDTO
      LIB_GE_command_buffer {
        if {$mom_cycle_rapid_to < 0} {
          set mom_cycle_rapid_to $mom_cycle_clearance_plane
        }
      } @RAPIDTO_ADJUST
      LIB_GE_command_buffer_output

      set lib_flag(cycle_mcall_active) 1

      switch $mom_motion_event {
        "drill_move"     {
                LIB_GE_command_buffer DRILL_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE81$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "drill_dwell_move"   {
                LIB_GE_command_buffer DRILL_DWELL_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE82$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "drill_deep_move"    {
                LIB_GE_command_buffer DRILL_DEEP_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE83_Deep$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "drill_break_chip_move"  {
                LIB_GE_command_buffer DRILL_BREAK_CHIP_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE83_Break_Chip$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "tap_move"     {
                LIB_GE_command_buffer TAP_MOVE
                LIB_GE_command_buffer {
                  if {([CONF_CTRL_drill cycle_tap] == 84 && $mom_cycle_option != "OPTION")} {
                    LIB_SPF_call_cycle "CYCLE84$control" MCALL
                  } elseif {([CONF_CTRL_drill cycle_tap] == 84 && $mom_cycle_option == "OPTION")} {
                    LIB_SPF_call_cycle "CYCLE840$control" MCALL
                    LIB_SPF_add_warning "Cycle Tap is set in PC-Interface to CYCLE84. With option set to ON it will be switched to CYCLE840"
                  } elseif {([CONF_CTRL_drill cycle_tap] == 840 && $mom_cycle_option != "OPTION")} {
                    LIB_SPF_call_cycle "CYCLE840$control" MCALL
                  } elseif {([CONF_CTRL_drill cycle_tap] == 840 && $mom_cycle_option == "OPTION")} {
                    LIB_SPF_add_warning "Cycle Tap is set in PC-Interface to CYCLE840. With option set to ON it will be switched to CYCLE84"
                    LIB_SPF_call_cycle "CYCLE84$control" MCALL
                  }
                  MOM_do_template cycle_feed_mode CREATE
                  MOM_force once F
                } @OUTPUT
                LIB_GE_command_buffer_output
               }
        "tap_float_move"   {
                LIB_GE_command_buffer TAP_FLOAT_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE840$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "tap_deep_move"    {
                LIB_GE_command_buffer TAP_DEEP_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE84$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "tap_break_chip_move"    {
                LIB_GE_command_buffer TAP_BREAK_CHIP_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE84$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_move"      {
                LIB_GE_command_buffer BORE_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE85_Bore$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_dwell_move"    {
                LIB_GE_command_buffer BORE_DWELL_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE85_Bore_Dwell$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_drag_move"   {
                LIB_GE_command_buffer BORE_DRAG_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE89$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_no_drag_move"    {
                LIB_GE_command_buffer BORE_NO_DRAG_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE86$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_back_move"   {
                LIB_GE_command_buffer BORE_BACK_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE86$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_manual_move"   {
                LIB_GE_command_buffer BORE_MANUAL_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE87$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "bore_manual_dwell_move" {
                LIB_GE_command_buffer BORE_MANUAL_DWELL_MOVE
                LIB_GE_command_buffer {LIB_SPF_call_cycle "CYCLE88$control" MCALL} @OUTPUT
                LIB_GE_command_buffer_output
               }
        "drill_text_move"    {
                # nothing for the moment
               }
        "thread_move"      {
                LIB_GE_command_buffer THREAD_MOVE
                LIB_GE_command_buffer {
                  LIB_CTRL_map_cycle97_param
                  LIB_SPF_call_cycle CYCLE97
                  set lib_flag(cycle_mcall_active) 0
                } @OUTPUT
                LIB_GE_command_buffer_output
               }
      }
      set lib_flag(output_cycle_call) 0
    }
  }

  LIB_GE_command_buffer COOLANT
  LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
  LIB_GE_command_buffer_output

  unset mom_cycle_clearance_plane_change
  if {[info exists lib_flag(cycle_mcall_active)] && $lib_flag(cycle_mcall_active) == 1} {
    LIB_GE_command_buffer CYCLE_MOVE
    LIB_GE_command_buffer {

      if {[info exists force_plane_axes] || [CONF_CTRL_drill force_workingplane_coordinates]} {
        MOM_force once X Y Z
        catch {unset force_plane_axes}
      }
      MOM_suppress once $cycle_axis_address
      MOM_do_template cycle_move
    } @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
    namespace eval $::mom_namespace_name {
      array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
      array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
    }
  } else {
    array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
    array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
  }

}
# <Internal Documentation>
# Controls the drilling move setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_map_cycle97_param {} {

  global mom_turn_cycle97_machining_type mom_siemens_cycle_pit RAD2DEG
  global mom_turn_cycle_total_depth mom_turn_thread_pitch_lead mom_siemens_cycle_nrc
  global mom_lathe_thread_crest_line_start mom_lathe_thread_crest_line_end
  global mom_lathe_thread_root_line_start  mom_lathe_thread_root_line_end
  global mom_lathe_thread_clearance_start mom_lathe_thread_clearance_end
  global mom_lathe_spindle_axis mom_number_of_starts mom_total_depth_finish_passes_increment
  global mom_siemens_cycle_spl mom_siemens_cycle_fpl mom_siemens_cycle_dm1 mom_total_depth_constant_increment
  global mom_siemens_cycle_dm2 mom_siemens_cycle_fal mom_total_depth_finish_passes_number_of_passes
  global mom_total_depth_constant_increment_source mom_total_depth_increment_type
  global mom_tool_insert_length mom_siemens_cycle_iang mom_thread_infeed_vector mom_thread_infeed_angle
  global mom_area_start_point_offset mom_area_end_point_offset mom_tool_orientation
  global mom_siemens_cycle_app mom_siemens_cycle_rop PI mom_thread_engage_type
  global mom_total_depth_variable_number_of_passes

  if {[llength [info commands MOM_load_lathe_thread_cycle_params]] && [MOM_load_lathe_thread_cycle_params]} {
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_pit -PIT pitch value
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    set mom_siemens_cycle_pit [expr $mom_turn_thread_pitch_lead/$mom_number_of_starts]

    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_spl -SPL thread start point longitudinal
    # mom_siemens_cycle_fpl -FPL thread end point longitudinal
    # mom_siemens_cycle_dm1 -DM1 thread start point diameter
    # mom_siemens_cycle_dm2 -DM2 thread end point diameter
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    if {[string match $mom_lathe_spindle_axis "MCSX"]} {
      set mom_siemens_cycle_spl $mom_lathe_thread_crest_line_start(0)
      set mom_siemens_cycle_fpl $mom_lathe_thread_crest_line_end(0)
      set mom_siemens_cycle_dm1 [expr 2*$mom_lathe_thread_crest_line_start(1)]
      set mom_siemens_cycle_dm2 [expr 2*$mom_lathe_thread_crest_line_end(1)]
    } elseif {[string match $mom_lathe_spindle_axis "MCSZ"]} {
      set mom_siemens_cycle_spl $mom_lathe_thread_crest_line_start(2)
      set mom_siemens_cycle_fpl $mom_lathe_thread_crest_line_end(2)
      set mom_siemens_cycle_dm1 [expr 2*$mom_lathe_thread_crest_line_start(0)]
      set mom_siemens_cycle_dm2 [expr 2*$mom_lathe_thread_crest_line_end(0)]
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_app -APP run-in path
    # mom_siemens_cycle_rop -ROP run-out path
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    if {[info exists mom_area_start_point_offset]} {
      set mom_siemens_cycle_app [expr abs($mom_area_start_point_offset)]
    } else {
      set mom_siemens_cycle_app 0.0
    }

    if {[info exists mom_area_end_point_offset]} {
      set mom_siemens_cycle_rop [expr abs($mom_area_end_point_offset)]
    } else {
      set mom_siemens_cycle_rop 0.0
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_fal -FAL finish allowance
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    set mom_siemens_cycle_fal 0
    for {set i 0} {$i<100} {incr i} {
      set mom_siemens_cycle_fal [expr $mom_siemens_cycle_fal + $mom_total_depth_finish_passes_increment($i)*$mom_total_depth_finish_passes_number_of_passes($i)]
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_iang -IANG infeed angle
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    set mom_siemens_cycle_iang 0
    if {[info exists mom_thread_engage_type]} {
      if {$mom_thread_engage_type == 0} {
        # Automatic
        set mom_siemens_cycle_iang 0
      } else {
        if {[info exists mom_thread_infeed_vector]} {
          set mom_siemens_cycle_iang [expr $RAD2DEG*atan2($mom_thread_infeed_vector(1), $mom_thread_infeed_vector(0))]
        } elseif {[info exists mom_thread_infeed_angle]} {
          set mom_siemens_cycle_iang $mom_thread_infeed_angle
        }
      }
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_nrc -NRC roughing cuts number
    #++++++++++++++++++++++++++++++++++++++++++++++++++++
    if {$mom_total_depth_increment_type == 0} {
      if {[info exists mom_total_depth_constant_increment_source]} {
        set constant_depth [expr $mom_tool_insert_length*$mom_total_depth_constant_increment/100]
        global mom_output_unit mom_part_unit
        if {[string compare $mom_output_unit $mom_part_unit]} {
          if {[string compare $mom_part_unit "MM"]} {
            set constant_depth [expr $constant_depth/25.4]
          } else {
            set constant_depth [expr $constant_depth*25.4]
          }
        }
      } else {
        set constant_depth $mom_total_depth_constant_increment
      }
      set mom_siemens_cycle_nrc [expr ceil(($mom_turn_cycle_total_depth- $mom_siemens_cycle_fal)/$constant_depth)]
    } elseif {$mom_total_depth_increment_type == 1} {
      if {[info exists mom_total_depth_variable_number_of_passes(0)]} {
        set mom_siemens_cycle_nrc $mom_total_depth_variable_number_of_passes(0)
      } else {
        set mom_siemens_cycle_nrc 0
      }
    } else {
      # In constant cutting cross-section mode, the cycle will calculate individual infeed depth automatically
      LIB_SPF_add_warning "Thread CYCLE97 should be constant/individual cut depth!"
    }


    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # mom_siemens_cycle_vari -VARI the machining type for thread
    # 1 - cutting depth constant / outside Thread
    # 2 - cutting depth constant / inside Thread
    # 3 - cutting depth deggresive / outside Thread
    # 4 - cutting depth deggresive / inside Thread
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if {![info exists mom_turn_cycle97_machining_type]} {
      if {[regexp -nocase "_OD" $::mom_template_subtype]} {
        if {$mom_total_depth_increment_type == 1} {
          set mom_turn_cycle97_machining_type 3
        } else {
          set mom_turn_cycle97_machining_type 1
        }
      } else {
        if {$mom_total_depth_increment_type == 1} {
          set mom_turn_cycle97_machining_type 4
        } else {
          set mom_turn_cycle97_machining_type 2
        }
      }
    } else {
      if {$mom_turn_cycle97_machining_type == 1} {
        if {$mom_total_depth_increment_type == 1} {
          set mom_turn_cycle97_machining_type 3
        } else {
          set mom_turn_cycle97_machining_type 1
        }
      } else {
        if {$mom_total_depth_increment_type == 1} {
          set mom_turn_cycle97_machining_type 4
        } else {
          set mom_turn_cycle97_machining_type 2
        }
      }
    }

    # Skip to MOM_cycle_off
    if {[llength [info commands MOM_skip_handler_to_event]]} {
      MOM_skip_handler_to_event cycle_off
      global thread_cycle_flag
      set thread_cycle_flag 1
    }
  }
}
# <Internal Documentation>
# This command is used to map cycle97 parameters.
# Under machine control cycle output condition, MOM_load_lathe_thread_cycle_params will return 1
# if it is executed properly. It will load cycle97 thread related MOM variables
# mom_lathe_thread_crest_line_start mom_lathe_thread_root_line_start
# mom_lathe_thread_crest_line_end mom_lathe_thread_clearance_start
# mom_lathe_thread_root_line_end  mom_lathe_thread_clearance_end
# MOM_skip_handler_to_event cycle_off is used to skip events between current event to MOM_cycle_off.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_adjust_register {} {

  global mom_path_name mom_tool_adjust_register mom_tool_length_adjust_register mom_tool_number
  global lib_flag

  LIB_GE_command_buffer CHECK_adjust_register
  LIB_GE_command_buffer {
    if {$mom_tool_length_adjust_register == 0} {
      set mom_tool_adjust_register 1
    } else {
      set mom_tool_adjust_register $mom_tool_length_adjust_register
    }

    if {$mom_tool_adjust_register > [CONF_CTRL_tool max_d_number]} {
      if {![hiset lib_flag(error_adjust_register,$mom_path_name)]} {
        set error [LIB_SPF_add_warning "Adjust register INS->$mom_tool_length_adjust_register<- not possible... Adjust register 1 is used"]
        set lib_flag(error_adjust_register,$mom_path_name) 1
      }
      set mom_tool_adjust_register 1
    }
  } @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Check for adjust register
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_tool_number {} {

  global mom_tool_number mom_tool_name

  if {[CONF_CTRL_tool max_tool_number] != 0 && $mom_tool_number > [CONF_CTRL_tool max_tool_number]} {
    set error [LIB_SPF_add_warning "Maximum tool number allowed INS->[CONF_CTRL_tool max_tool_number]<- : Check tool \"INS->$mom_tool_name<-\", current value \"INS->$mom_tool_number<-\""]
  }
}
# <Internal Documentation>
# Check the tool number
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_before_plane {} {

  if {[CONF_S840D_cycle800 rotate_before] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis before plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_after_plane {} {

  global lib_sav_kin_4th_axis_leader lib_sav_kin_5th_axis_leader

  if {[CONF_S840D_cycle800 rotate_after] == "1" || ([CONF_S840D_cycle800 plane_output_motion_with_init] == "STAY" && [CONF_S840D_cycle800 rotate_before] == 0)} {

    LIB_CTRL_unclamp_axis

    if {[string match "5_AXIS*" [string toupper [LIB_PT_get_header_var mom_kin_machine_type]]] } {
      LIB_GE_command_buffer 5AXIS
      LIB_GE_command_buffer {MOM_output_literal "G0 ${lib_sav_kin_4th_axis_leader}=\$TC_CARR13\[\$P_TC\] ${lib_sav_kin_5th_axis_leader}=\$TC_CARR14\[\$P_TC\]"} @OUTPUT
      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer 4AXIS
      LIB_GE_command_buffer {MOM_output_literal "G0 ${lib_sav_kin_4th_axis_leader}=\$TC_CARR13\[\$P_TC\]"} @OUTPUT
      LIB_GE_command_buffer_output
    }
    LIB_GE_command_buffer RAPID
    LIB_GE_command_buffer {MOM_do_template rapid_rotary CREATE} @OUTPUT
    LIB_GE_command_buffer_output

    LIB_GE_command_buffer CLAMP
    LIB_GE_command_buffer {LIB_CTRL_clamp_axis} @OUTPUT
    LIB_GE_command_buffer_output
  }
}
# <Internal Documentation>
# Check to rotate the axis after plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_init_cycle_parameters {} {
  global mom_cycle_step1 mom_cycle_step2 mom_cycle_step3
  global mom_spindle_direction
  global mom_cycle_feed_rate mom_feed_retract_value
  global mom_siemens_cycle_dts_mode
  global mom_siemens_cycle_dts
  global mom_siemens_cycle_o_dtd_mode
  global mom_siemens_cycle_o_dtd
  global mom_siemens_cycle_fdpr
  global mom_siemens_cycle_dam
  global mom_siemens_cycle_frf
  global mom_siemens_cycle_ffr
  global mom_siemens_cycle_rff
  global mom_siemens_cycle_sdir
  global mom_siemens_cycle_o_mdep

  if {[string match "DEF" [CONF_SPF_cycle regulation]]} {

    global mom_siemens_cycle_o_axn
    global mom_siemens_cycle_o_dtd
    global mom_siemens_cycle_o_dis1
    global mom_siemens_cycle_o_vrt
    global mom_siemens_cycle_o_ptab
    global mom_siemens_cycle_o_techno
    global mom_siemens_cycle_o_var1
    global mom_siemens_cycle_o_dam
    global mom_siemens_cycle_o_pitm
    global mom_siemens_cycle_o_ptab_sl
    global mom_siemens_cycle_o_ptaba
    global mom_cycle_orient

    if {![info exists mom_siemens_cycle_o_axn]}   {set mom_siemens_cycle_o_axn   ""}
    if {![info exists mom_siemens_cycle_o_dis1]}  {set mom_siemens_cycle_o_dis1    ""}
    if {![info exists mom_siemens_cycle_o_vrt]}   {set mom_siemens_cycle_o_vrt   ""}
    if {![info exists mom_siemens_cycle_o_ptab]}  {set mom_siemens_cycle_o_ptab    ""}
    if {![info exists mom_siemens_cycle_o_techno]}  {set mom_siemens_cycle_o_techno  ""}
    if {![info exists mom_siemens_cycle_o_var1]}  {set mom_siemens_cycle_o_var1    ""}
    if {![info exists mom_siemens_cycle_o_dam]}   {set mom_siemens_cycle_o_dam   ""}
    if {![info exists mom_siemens_cycle_o_pit]}   {set mom_siemens_cycle_o_pit   ""}
    if {![info exists mom_siemens_cycle_o_pitm]}  {set mom_siemens_cycle_o_pitm    ""}
    if {![info exists mom_siemens_cycle_o_ptab_sl]} {set mom_siemens_cycle_o_ptab_sl ""}
    if {![info exists mom_siemens_cycle_o_ptaba]}   {set mom_siemens_cycle_o_ptaba   ""}
    if {![info exists mom_cycle_orient]}    {set mom_cycle_orient      ""}

  }

  #mom_siemens_cycle_dts
  if {[info exists mom_siemens_cycle_dts_mode]} {
    set mom_siemens_cycle_dts_mode [LIB_GE_string_toupper $mom_siemens_cycle_dts_mode]
    if {[info exists mom_siemens_cycle_dts] && [string match "SECONDS" $mom_siemens_cycle_dts_mode]} {
      set mom_siemens_cycle_dts [expr abs($mom_siemens_cycle_dts)]
    } elseif {[info exists mom_siemens_cycle_dts] && [string match "REVOLUTIONS" $mom_siemens_cycle_dts_mode]} {
      set mom_siemens_cycle_dts [expr -1*abs($mom_siemens_cycle_dts)]
    } elseif {[string match "OFF" $mom_siemens_cycle_dts_mode]} {
      catch {unset mom_siemens_cycle_dts}
      if {[string match "DEF" [CONF_SPF_cycle regulation]]} {set mom_siemens_cycle_dts ""}
    }
  } else {
    set mom_siemens_cycle_dts ""
  }

  #mom_siemens_cycle_o_dtd
  if {[info exists mom_siemens_cycle_o_dtd_mode]} {
    set mom_siemens_cycle_o_dtd_mode [LIB_GE_string_toupper $mom_siemens_cycle_o_dtd_mode]
    if {[info exists mom_siemens_cycle_o_dtd] && [string match "SECONDS" $mom_siemens_cycle_o_dtd_mode]} {
      set mom_siemens_cycle_o_dtd [expr abs($mom_siemens_cycle_o_dtd)]
    } elseif {[info exists mom_siemens_cycle_o_dtd] && [string match "REVOLUTIONS" $mom_siemens_cycle_o_dtd_mode]} {
      set mom_siemens_cycle_o_dtd [expr -1*abs($mom_siemens_cycle_o_dtd)]
    } elseif {[string match "ON" $mom_siemens_cycle_o_dtd_mode]} {
      set mom_siemens_cycle_o_dtd 0
    } elseif {[string match "OFF" $mom_siemens_cycle_o_dtd_mode]} {
      catch {unset mom_siemens_cycle_o_dtd}
      if {[string match "DEF" [CONF_SPF_cycle regulation]]} {set mom_siemens_cycle_o_dtd ""}
    }
  } else {
    set mom_siemens_cycle_o_dtd ""
  }

  #mom_siemens_cycle_fdpr
  if [info exists mom_cycle_step1] {
    set mom_siemens_cycle_fdpr $mom_cycle_step1
  }

  #mom_siemens_cycle_dam
  if {[info exists mom_cycle_step2]} {
    set mom_siemens_cycle_dam $mom_cycle_step2
  }

  #mom_siemens_cycle_o_mdep
  if {[info exists mom_cycle_step3]} {
    set mom_siemens_cycle_o_mdep $mom_cycle_step3
  }
  set mom_siemens_cycle_ffr $mom_cycle_feed_rate

  #mom_siemens_cycle_rff
  if {![info exists mom_siemens_cycle_rff] || ([LIB_SPF_is_number $mom_siemens_cycle_rff] && [EQ_is_zero $mom_siemens_cycle_rff]) } {
    if {[info exists mom_feed_retract_value] && ![EQ_is_zero $mom_feed_retract_value]} {
      set mom_siemens_cycle_rff $mom_feed_retract_value
    } else {
      set mom_siemens_cycle_rff $mom_cycle_feed_rate
    }
  }

  #mom_siemens_cycle_frf
  if {![info exists mom_siemens_cycle_frf]} {
    set mom_siemens_cycle_frf 1
  }

  #mom_siemens_cycle_sdir
  set mom_siemens_cycle_sdir 3
  if {[info exists mom_spindle_direction]} {
    switch -- $mom_spindle_direction {
      "CLW"  {set mom_siemens_cycle_sdir 3}
      "CCLW" {set mom_siemens_cycle_sdir 4}
    }
  }
}
# <Internal Documentation>
# This procedure is used to set cycle parameters
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_WRITE_coolant {{option default}} {

  global mom_coolant_mode mom_coolant_status mom_kin_is_turbo_output

  switch -- $option {
    "on"  {
      if {![hiset mom_coolant_mode] || $mom_coolant_mode == ""} {set mom_coolant_mode [CONF_CTRL_coolant coolant_status]}
      if {$mom_coolant_mode == "OFF"} {return}

      LIB_GE_command_buffer COOLNT_on
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_output_before_motion] != 0} {
          MOM_do_template coolant_on
        }
      } @COOLNT_on_std
      LIB_GE_command_buffer_output
    }
    "off" {
      LIB_GE_command_buffer COOLNT_off
      LIB_GE_command_buffer {
        if {[info exists mom_kin_is_turbo_output] && $mom_kin_is_turbo_output == "TRUE" && [MOM_ask_address_value M_coolant] != $::mom_sys_coolant_code(OFF)} {
          MOM_force once M_coolant ; #needs when turbo mode is activated (Bug#669)
        }
        MOM_do_template coolant_off
      } @COOLNT_on_std
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_auto] == 0} {
          set mom_coolant_mode "OFF"
          set mom_coolant_status "OFF"
        }
      } @COOLNT_on_std_2
      LIB_GE_command_buffer_output
    }
  }
}
# <Internal Documentation>
# This procedure is executed to output coolant on or off
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {

  global lib_arc_axis mom_arc_radius

  # PR8421657 Only suppress address for non-turning mode
  if { $::mom_machine_mode != "TURN" } {
    switch -- $lib_arc_axis {
      0 {MOM_suppress once I}
      1 {MOM_suppress once J}
      2 {MOM_suppress once K}
    }
  }

  switch -- $lib_arc_axis {
    0 {MOM_force once Y Z J K}
    1 {MOM_force once X Z I K}
    2 {MOM_force once X Y I J}
  }

  LIB_SPF_check_arc_radius
  if {[info level -1] == "MOM_helix_move_LIB"} {
    if {[CONF_CTRL_moves always_center_for_circle] != 1 && [EQ_is_le $::mom_arc_angle 360.0] && ![EQ_is_equal [expr fmod($::mom_arc_angle,360)] 360 0.1] && ![EQ_is_equal [expr fmod($::mom_arc_angle,360)] 180 0.1]} {
      MOM_suppress once I J K
      MOM_force once X Y Z R
      if {[expr fmod($::mom_arc_angle,360)] > 180} {
        set mom_arc_radius [expr abs($mom_arc_radius) * -1]
      } else {
        set mom_arc_radius [expr abs($mom_arc_radius) * +1]
      }

    } else {
      MOM_suppress once R
      MOM_force once X Y Z
    }
  } else {

    if {[CONF_CTRL_moves always_center_for_circle] != 1} {
      global mom_arc_radius
      set mom_arc_radius [expr abs($mom_arc_radius)]

      if {[CONF_CTRL_feed feed_linear] == 2} {
        set ::feed $::mom_feedrate
        LIB_CTRL_feed_output
      }

      MOM_suppress once I J K

      # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
      if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

        global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
        global mom_namespace_name mom_output_pos_type
        if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
          if {$mom_namespace_name == "::"} {
            set namespace ::
          } else {
            set namespace ::LOCAL_CSYS::
          }
          if {$mom_output_pos_type == "mom_pos"} {
            VMOV 3 ${namespace}mom_prev_pos prev_pos
            VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
          } else {
            VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
            VMOV 3 ${namespace}mom_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
          }
          VMOV 3 ${namespace}$mom_output_pos_type save_pos
        } else {
          set namespace ::
          set mom_output_pos_type mom_pos
          VMOV 3 mom_prev_pos prev_pos
          VMOV 3 mom_pos_arc_center pos_arc_center
          VMOV 3 mom_pos_arc_axis pos_arc_axis
          VMOV 3 mom_pos save_pos
        }
        VEC3_sub prev_pos pos_arc_center tmp_vec
        VEC3_unitize tmp_vec tmp_vec1
        VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
        VEC3_scale mom_arc_radius tmp_vec tmp_vec1
        VEC3_add pos_arc_center tmp_vec1 tmp_vec
        VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

        LIB_GE_command_buffer CIRCULAR
        LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]} @OUTPUT
        LIB_GE_command_buffer_output
        MOM_suppress once I J K
        VMOV 3 save_pos  ${namespace}$mom_output_pos_type
        set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]

        switch -- $::lib_arc_axis {
          0 {
            MOM_force once Y Z
          }
          1 {
            MOM_force once X Z
          }
          2 {
            MOM_force once X Y
          }
        }
      }

      if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
        LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
      }

      if {[EQ_is_gt $::mom_arc_angle 180.0]} {
        set mom_arc_radius [expr -1.0*$mom_arc_radius]
      }
    } else {
      MOM_suppress once R
    }

  }

}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_clamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {return}

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer CLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template clamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fifth_axis] == 1} {

    LIB_GE_command_buffer CLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template clamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called before each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_unclamp_axis {} {

  if {[CONF_CTRL_clamp status] == 0} {return}

  if {[CONF_CTRL_clamp fifth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template unclamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template unclamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called after each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_rotate_axis {} {

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer RAPID_ROTARY
  LIB_GE_command_buffer {MOM_do_template rapid_rotary} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_CTRL_clamp_axis

}
# <Internal Documentation>
# Handling of the rotate axis
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_nc_header {} {

  global mom_output_file_basename lib_nc_header_name lib_flag
  global lib_selected_group_name mom_dnc_program_name mom_selected_group_name
  global mom_lib_program_name

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
    if {[LIB_PT_get_header_var lib_selected_group_name exists]} {
      set lib_selected_group_name [LIB_PT_get_header_var lib_selected_group_name]
    } else {
      set lib_selected_group_name [LIB_PT_get_header_var mom_oper_program]
    }
  }
  if {![info exists lib_selected_group_name]} {set lib_selected_group_name ""}
  set lib_nc_header_name $mom_output_file_basename

  switch -- [CONF_CTRL_setting header_name] {
    "output_file_basename"  {
            set lib_nc_header_name $mom_output_file_basename
          }
    "selected_group"  {
            set lib_nc_header_name $lib_selected_group_name
          }
    "ude_dnc_header"  {
            if {[info exists mom_dnc_program_name]} {set lib_nc_header_name $mom_dnc_program_name}
          }
    "ude"       {
            if {[info exists mom_lib_program_name]} {set lib_nc_header_name $mom_lib_program_name}
          }
    "ignore"    {
                        return 0
          }
                "default"     {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_setting header_name "short_template_syntax"
          }
  }

  set lib_nc_header_name [string trim $lib_nc_header_name]

  # Variable lib_nc_header_name is empty that means that mom_output_file_basename is used
  # and you are not in PP for this case selected_group is used -- this is not ""

  if {$lib_nc_header_name == ""} {set lib_nc_header_name $lib_selected_group_name}

  LIB_GE_command_buffer PROG_NUMBER

  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_program
  } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_MPF
#   Heidenhain  BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O1234
#
#____________________________________________________________________________________________
proc LIB_CTRL_sub_header {} {

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_subprogram
  } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_SPF
#   Heidenhain    BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O1234
#
#____________________________________________________________________________________________
proc LIB_SPF_pt_additional_variables_S840D {} {

  global lib_flag

  if {[CONF_CTRL_setting op_representation_structured]} {
    LIB_SPF_pretreatment_add_var MOM_structure_representation_mode mom_output_status 0
    LIB_SPF_pretreatment_add_var MOM_structure_representation_mode mom_display_name 0
    LIB_SPF_pretreatment_add_var MOM_structure_representation_mode mom_display_name_defined 0
    LIB_SPF_pretreatment_add_var MOM_structure_representation_mode mom_readonly_status 0
    LIB_SPF_pretreatment_add_var MOM_structure_representation_mode mom_type_status 0
  }
  #PR9239197 Add mom_lock_axis to pretreatment
  LIB_SPF_pretreatment_add_var MOM_lock_axis mom_lock_axis 0
}
# <Internal Documentation>
#
# Entrypoint to define additional variables which should be stored in pretreatment
# Controller specific
#
# LIB_SPF_pretreatment_add_var in this proc to add return variables from pretreatment
#
# <Internal Example>
# Sample code as comment in proc body
#______________________________________________________________________________
proc MOM_structure_representation_mode {} {

  global lib_flag

  set mom_output_status [LIB_SPF_get_pretreatment mom_output_status]
  set mom_display_name [LIB_SPF_get_pretreatment mom_display_name]
  set mom_display_name_defined [LIB_SPF_get_pretreatment mom_display_name_defined]
  set mom_readonly_status [LIB_SPF_get_pretreatment mom_readonly_status]
  set mom_type_status [LIB_SPF_get_pretreatment mom_type_status]

  if {$::lib_ge_pretreatment_runtime || ![string length $mom_output_status]} {return}

  set lib_flag(representation_collpased_output_status) $mom_output_status
  if {$lib_flag(representation_collpased_output_status) == "ON"} {
    if {$mom_display_name_defined == 1 && [string length $mom_display_name] > 0} {
      set lib_flag(representation_collpased_display_name) $mom_display_name
    }
    set lib_flag(representation_collpased_readonly_status) $mom_readonly_status
    set lib_flag(representation_collpased_type_status) $mom_type_status
  }

}
# <Internal Documentation>
# This event is triggered by an UDE
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_structure_representation {} {

  if {[CONF_CTRL_setting op_representation_structured]} {MOM_structure_representation_mode}

  eval global [uplevel #0 info vars]

  switch [info level -1] {
    "MOM_start_of_path"
    {
      if {![info exists lib_flag(representation_collpased_output_status)] || $lib_flag(representation_collpased_output_status) == "ON"} {

        if {[info exists lib_flag(representation_collpased_display_name)]} {
          set display_name $lib_flag(representation_collpased_display_name)
        } else {
          set display_name ""
        }

        if {[info exists lib_flag(representation_collpased_readonly_status)]} {
          switch -- $lib_flag(representation_collpased_readonly_status) {
            "READONLY"  {set readonly_status 1}
            "EDITABLE"  {set readonly_status 0}
            default     {set readonly_status 1}
          }
        } else {
          set readonly_status 1
        }

        if {[info exists lib_flag(representation_collpased_type_status)]} {
          switch -- $lib_flag(representation_collpased_type_status) {
            "OPERATION" {set type_status 1}
            "HEADER"    {set type_status 0}
            default     {set type_status 1}
          }
        } else {
          set type_status 1
        }

        LIB_CTRL_op_begin $readonly_status $type_status $display_name
      }
    }
    "MOM_end_of_path"
    {
      if {![info exists lib_flag(representation_collpased_output_status)] || $lib_flag(representation_collpased_output_status) == "ON"} {

        LIB_CTRL_op_end

      }

      if {[info exists lib_flag(representation_collpased_output_status)]}   {unset lib_flag(representation_collpased_output_status)}
      if {[info exists lib_flag(representation_collpased_display_name)]}  {unset lib_flag(representation_collpased_display_name)}
      if {[info exists lib_flag(representation_collpased_readonly_status)]}   {unset lib_flag(representation_collpased_readonly_status)}
      if {[info exists lib_flag(representation_collpased_type_status)]}   {unset lib_flag(representation_collpased_type_status)}
    }
  }
}
# <Internal Documentation>
# This command make the possibility to Expanded or Collapsed the representation at the HMI
# Calls directly LIB_CTRL_op_begin, based from which point it's called
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_op_begin {{bit0 0} {bit1 1} {otional_name ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_flag lib_ctrl mom_path_name lib_ge_env
  global mom_display_name mom_readonly_status mom_operation_type_enum

  switch -- $bit1 {
    0 - 1   {
        if {[string length $otional_name] > 0} {
          set path_name $otional_name
        } else {
          set path_name $mom_path_name
        }

      }
    default {set path_name $mom_path_name}
  }

  if {![info exists lib_flag(representation_collpased_mode_status)] || !$lib_flag(representation_collpased_mode_status)} {
    regsub -all "_" $path_name " " path_name
  } elseif {$lib_flag(representation_collpased_mode_status) && [string length $otional_name] == 0 && \
     [info exists mom_display_name] && [info exists mom_readonly_status]} {
    set path_name $mom_display_name
    switch -- $mom_readonly_status {
      "EDITABLE" - 1 {set bit0 1}
      "READONLY" - 0 {set bit0 0}
    }
    unset mom_display_name
    unset mom_readonly_status
  }

  #Mapping OperType
  set operation_map(100)  "UfMachiningOperationType"
  set operation_map(1)  "InstancedOper"
  set operation_map(2)  "OrphanOper"
  set operation_map(10)   "Oldopr"
  set operation_map(110)  "PocketMilling"
  set operation_map(210)  "SurfaceContour"
  set operation_map(211)  "VariableSurfaceContour"
  set operation_map(260)  "CavityMilling"
  set operation_map(261)  "FaceMilling"
  set operation_map(262)  "VolumnMilling"
  set operation_map(263)  "ZLevelMilling"
  set operation_map(264)  "HoleMilling"
  set operation_map(265)  "PlungeMilling"
  set operation_map(266)  "variableZLevel"
  set operation_map(510)  "TurningRough"
  set operation_map(520)  "TurningFinish"
  set operation_map(530)  "TurningTeachMode"
  set operation_map(540)  "TurningThread"
  set operation_map(550)  "TurningCenterDrill"
  set operation_map(560)  "TurningControl"
  set operation_map(600)  "HoleMaking"
  set operation_map(700)  "WireEDM"
  set operation_map(800)  "MillUser"
  set operation_map(900)  "GenericMotion"
  set operation_map(1000) "Probing"
  set operation_map(1010) "MillProbing"
  set operation_map(1020) "TurningProbing"
  set operation_map(1030) "MillToolProbing"
  set operation_map(1040) "TurningToolProbing"
  set operation_map(1100) "MillControl"
  set operation_map(1200) "LatheControl"
  set operation_map(1300) "WedmControl"
  set operation_map(1400) "LatheUd"
  set operation_map(1500) "WedmUser"
  set operation_map(1600) "MassEdit"
  set operation_map(1700) "ThreadMilling"
  set operation_map(1800) "UfInspTolerance"
  set operation_map(1900) "UfInspPath"
  set operation_map(2000) "UfInspOutput"
  set operation_map(2100) "UfInspMisc"
  set operation_map(2200) "UfInspAlign"
  set operation_map(2300) "UfInspSensor"
  set operation_map(2400) "UfInspConstruct"
  set operation_map(2500) "UfInspBoundingFeature"
  set operation_map(2600) "UfInspFeature"
  set operation_map(2700) "CylinderMilling"
  set operation_map(2800) "CannedCycle"
  set operation_map(2900) "LaserTeachmode"
  set operation_map(3000) "HoleDrilling"
  set operation_map(3100) "GrooveMilling"
  set operation_map(3200) "ChamferMilling"
  set operation_map(3300) "RadialGrooveMilling"

  set formatline  "<20< : <[expr [lindex [LIB_GE_sort_value [list [string length $::mom_part_name] [string length $::lib_ctrl(machining_operation_type_name)] [string length $::::mom_operation_name.png] [string length [CONF_CTRL_setting op_representation_postname]]] 1] 0] +2]< <5<"
  MOM_output_literal "CAM_OP_BEGIN \(\"$::mom_operation_name\",\"${lib_ge_env(major_version)}.${lib_ge_env(minor_version)}.${lib_ge_env(subminor_version)}\",[LIB_SPF_convert_binary_to_decimal $bit0$bit1]\)"
  MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CAMPartFileName"]" "$::mom_part_name" ";*HD*"]]

  if {[info exists operation_map($mom_operation_type_enum)]} {
    MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CAMOperationType"]" "$operation_map($mom_operation_type_enum)" ";*HD*"]]
  } else {
    MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CAMOperationType"]" "unknown" ";*HD*"]]
  }

  MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CAMOutputUnit"]" "[string map {"MM" "mm"} [string map {"IN" "inch"} $::mom_output_unit]]" ";*HD*"]]
  MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CAMPartUnit"]" "[string map {"MM" "mm"} [string map {"IN" "inch"} $::mom_part_unit]]" ";*HD*"]]
  MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CamPreviewPicture"]" "$::mom_operation_name.png" ";*HD*"]]
  MOM_output_literal [LIB_DC_format_string $formatline [list "\;[LIB_GE_MSG "CamPostProcessor"]" "[CONF_CTRL_setting op_representation_postname]" ";*HD*"]]

}
# <Internal Documentation>
# This command make the possibility to Expanded or Collapsed the representation at the HMI
#
# CAM header and CAM operations are encapsulated by the keywords:
#   CAM_OP_BEGIN (<Display name>, <Bitcode sequence>)
#   CAM_OP_END ()
#
# Arguments of CAM_OP_BEGIN:
#   <Display name> defines, how CAM header/operations will be shown in the HMI program editor.
#   <Bitcode sequence>
#   Bit 0: ReadonlyFlag (1 = readonly)
#     Value 1 (= readonly): The NC lines within the CAM_OP-Blocks are not editable. The lines are greyed out.
#     Value 0 (= editable): The NC lines within the CAM_OP-Blocks are editable.
#   Bit 1: Header/Operation Flag
#     Value 0: Header
#     Value 1: Operation
#   Bit 2-15: reserved
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_define_machining_operation_type_name {} {

  global mom_operation_type_enum lib_ctrl

  if {![info exists mom_operation_type_enum]} {return}

  switch -- $mom_operation_type_enum {
    1    {set lib_ctrl(machining_operation_type_name) "InstancedOper"          ; # mach_instanced_oper_subtype        }
    2    {set lib_ctrl(machining_operation_type_name) "OrphanOper"             ; # mach_orphan_oper_subtype           }
    10   {set lib_ctrl(machining_operation_type_name) "Oldopr"                 ; # mach_oldopr_subtype                }
    11   {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_mill_post_cmnds_subtype       }
    13   {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_lathe_post_cmnds_subtype      }
    17   {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_wed_post_cmnds_subtype        }
    110  {set lib_ctrl(machining_operation_type_name) "PocketMilling"          ; # mach_pocket_subtype                }
    210  {set lib_ctrl(machining_operation_type_name) "SurfaceContour"         ; # mach_surface_contour_subtype       }
    211  {set lib_ctrl(machining_operation_type_name) "VariableSurfaceContour" ; # mach_vasc_subtype                  }
    220  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_gssm_main_op_subtype          }
    221  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_gssm_sub_op_subtype           }
    222  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_gssm_grip_subtype             }
    230  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_param_line_subtype            }
    240  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_zig_zag_surf_subtype          }
    250  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_rough_to_depth_subtype        }
    260  {set lib_ctrl(machining_operation_type_name) "CavityMilling"          ; # mach_cavity_milling_subtype        }
    261  {set lib_ctrl(machining_operation_type_name) "FaceMilling"            ; # mach_face_milling_subtype          }
    262  {set lib_ctrl(machining_operation_type_name) "VolumnMilling"          ; # mach_volumn_milling_subtype        }
    263  {set lib_ctrl(machining_operation_type_name) "ZLevelMilling"          ; # mach_zlevel_milling_subtype        }
    264  {set lib_ctrl(machining_operation_type_name) "HoleMilling"            ; # mach_fb_hole_milling_subtype       }
    265  {set lib_ctrl(machining_operation_type_name) "PlungeMilling"          ; # mach_plunge_milling_subtype        }
    266  {set lib_ctrl(machining_operation_type_name) "variableZLevel"         ; # mach_vazl_milling_subtype          }
    310  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_lathe_rough_subtype           }
    320  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_lathe_finish_subtype          }
    330  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_lathe_groove_subtype          }
    340  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_lathe_thread_subtype          }
    350  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_drill_subtype                 }
    360  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_lathe_face_subtype            }
    450  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_point_to_point_subtype        }
    460  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_seq_curve_mill_subtype        }
    461  {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_seq_curve_lathe_subtype       }
    510  {set lib_ctrl(machining_operation_type_name) "TurningRough"           ; # mach_turn_rough_subtype            }
    520  {set lib_ctrl(machining_operation_type_name) "TurningFinish"          ; # mach_turn_finish_subtype           }
    530  {set lib_ctrl(machining_operation_type_name) "TurningTeachMode"       ; # mach_turn_teachmode_subtype        }
    540  {set lib_ctrl(machining_operation_type_name) "TurningThread"          ; # mach_turn_thread_subtype           }
    550  {set lib_ctrl(machining_operation_type_name) "TurningCenterDrill"     ; # mach_turn_cdrill_subtype           }
    560  {set lib_ctrl(machining_operation_type_name) "TurningControl"         ; # mach_turn_auxiliary_subtype        }
    600  {set lib_ctrl(machining_operation_type_name) "HoleMaking"             ; # mach_hole_making_subtype           }
    700  {set lib_ctrl(machining_operation_type_name) "WireEDM"                ; # mach_wedm_subtype                  }
    800  {set lib_ctrl(machining_operation_type_name) "MillUser"               ; # mach_mill_ud_subtype               }
    900  {set lib_ctrl(machining_operation_type_name) "GenericMotion"          ; # mach_gmc_subtype                   }
    1000 {set lib_ctrl(machining_operation_type_name) "Probing"                ; # mach_probing_subtype               }
    1010 {set lib_ctrl(machining_operation_type_name) "MillProbing"            ; # mach_mill_probing_subtype          }
    1020 {set lib_ctrl(machining_operation_type_name) "TurningProbing"         ; # mach_turn_probing_subtype          }
    1030 {set lib_ctrl(machining_operation_type_name) "MillToolProbing"        ; # mach_mill_tool_probing_subtype     }
    1040 {set lib_ctrl(machining_operation_type_name) "TurningToolProbing"     ; # mach_turn_tool_probing_subtype     }
    1100 {set lib_ctrl(machining_operation_type_name) "MillControl"            ; # mach_mill_mc_subtype               }
    1200 {set lib_ctrl(machining_operation_type_name) "LatheControl"           ; # mach_lathe_mc_subtype              }
    1300 {set lib_ctrl(machining_operation_type_name) "WedmControl"            ; # mach_wedm_mc_subtype               }
    1400 {set lib_ctrl(machining_operation_type_name) "LatheUd"                ; # mach_lathe_ud_subtype              }
    1500 {set lib_ctrl(machining_operation_type_name) "WedmUser"               ; # mach_wedm_ud_subtype               }
    1600 {set lib_ctrl(machining_operation_type_name) "MassEdit"               ; # mach_mass_edit_subtype             }
    1700 {set lib_ctrl(machining_operation_type_name) "ThreadMilling"          ; # mach_thread_milling_subtype        }
    1800 {set lib_ctrl(machining_operation_type_name) "UfInspTolerance"        ; # insp_tolerance_subtype             }
    1900 {set lib_ctrl(machining_operation_type_name) "UfInspPath"             ; # insp_path_subtype                  }
    2000 {set lib_ctrl(machining_operation_type_name) "UfInspOutput"           ; # insp_output_subtype                }
    2100 {set lib_ctrl(machining_operation_type_name) "UfInspMisc"             ; # insp_misc_subtype                  }
    2200 {set lib_ctrl(machining_operation_type_name) "UfInspAlign"            ; # insp_align_subtype                 }
    2300 {set lib_ctrl(machining_operation_type_name) "UfInspSensor"           ; # insp_sensor_subtype                }
    2400 {set lib_ctrl(machining_operation_type_name) "UfInspConstruct"        ; # insp_construct_subtype             }
    2500 {set lib_ctrl(machining_operation_type_name) "UfInspBoundingFeature"  ; # insp_bounding_feature_subtype      }
    2600 {set lib_ctrl(machining_operation_type_name) "UfInspFeature"          ; # insp_feature_subtype               }
    2700 {set lib_ctrl(machining_operation_type_name) "CylinderMilling"        ; # mach_cylinder_milling_subtype      }
    2800 {set lib_ctrl(machining_operation_type_name) "CannedCycle"            ; # mach_canned_cycle_subtype          }
    2900 {set lib_ctrl(machining_operation_type_name) "LaserTeachmode"         ; # mach_laser_teachmode_subtype       }
    3000 {set lib_ctrl(machining_operation_type_name) "HoleDrilling"           ; # mach_hole_drilling_subtype         }
    3100 {set lib_ctrl(machining_operation_type_name) "GrooveMilling"          ; # mach_groove_milling_subtype        }
    3200 {set lib_ctrl(machining_operation_type_name) "ChamferMilling"         ; # mach_chamfer_milling_subtype       }
    3300 {set lib_ctrl(machining_operation_type_name) "RadialGrooveMilling"    ; # mach_radial_groove_milling_subtype }
    3400 {set lib_ctrl(machining_operation_type_name) unknown                  ; # mach_planar_additive_subtype       }
    3500 {set lib_ctrl(machining_operation_type_name) "GenericFeature"         ; # mach_generic_feature_subtype       }
    3600 {set lib_ctrl(machining_operation_type_name) "DeviceGenericMotion"    ; # mach_device_gmc_subtype            }
    default {set lib_ctrl(machining_operation_type_name) unknown}
  }
}
# <Internal Documentation>
# This command make the possibility to Expanded or Collapsed the representation at the HMI.
#
# CAM header and CAM operations are encapsulated by the keywords:
#   CAM_OP_BEGIN (<Display name>, <Bitcode sequence>)
#   CAM_OP_END ()
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_lathe_thread_set {} {

  global mom_lathe_thread_type mom_lathe_thread_advance_type
  global mom_lathe_thread_lead_i mom_lathe_thread_lead_k
  global mom_motion_distance
  global mom_turn_thread_pitch_lead mom_turn_thread_pitch_end_increment

  set thread_type "CONSTANT"
  switch $mom_lathe_thread_advance_type {
    1 { set thread_type CONSTANT ; MOM_suppress once F}
    2 { set thread_type INCREASING ; MOM_force once F}
    default { set thread_type DECREASING ; MOM_force once F}
  }

  if {![string compare $thread_type "INCREASING"] || ![string compare $thread_type "DECREASING"] } {
    if { $mom_lathe_thread_type != 1 } {
      set LEAD $mom_turn_thread_pitch_lead
      set INCR $mom_turn_thread_pitch_end_increment
      set LENGTH $mom_motion_distance
      set ::feed [expr abs(pow($LEAD, 2) - pow($INCR, 2)) / (2 * $LENGTH)]
    }
  }

  if {[EQ_is_zero $mom_lathe_thread_lead_i] } {
    MOM_suppress once I ; MOM_force once K
  } elseif {[EQ_is_zero $mom_lathe_thread_lead_k] } {
    MOM_suppress once K ; MOM_force once I
  } else {
    MOM_force once I ; MOM_force once K
  }
}
# <Internal Documentation>
# This command called in MOM_lathe_thread_move_LIB
#
# Calculation for the F address for G34/G35 output
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_op_end {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  MOM_output_literal "CAM_OP_END \(\)"

}
# <Internal Documentation>
# This command make the possibility to Expanded or Collapsed the representation at the HMI.
#
# CAM header and CAM operations are encapsulated by the keywords:
#   CAM_OP_BEGIN (<Display name>, <Bitcode sequence>)
#   CAM_OP_END ()
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_parameter_definition {} {

  global mom_sys_home_pos lib_sys_home_param mom_sys_leader lib_sys_home_leader

  set commandcheck(LIB_CTRL_parameter_definition_ENTRY) [llength [info commands LIB_CTRL_parameter_definition_ENTRY]]
  set commandcheck(LIB_CTRL_parameter_definition_LIB_ENTRY) [llength [info commands LIB_CTRL_parameter_definition_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_parameter_definition_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition_LIB_ENTRY)} {LIB_CTRL_parameter_definition_LIB_ENTRY start} elseif {$commandcheck(LIB_CTRL_parameter_definition_ENTRY)} {LIB_CTRL_parameter_definition_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  regsub -all "=" $mom_sys_leader(X) "" lib_sys_home_leader(0)
  regsub -all "=" $mom_sys_leader(Y) "" lib_sys_home_leader(1)
  regsub -all "=" $mom_sys_leader(Z) "" lib_sys_home_leader(2)
  regsub -all "=" $mom_sys_leader(fourth_axis) "" lib_sys_home_leader(3)
  regsub -all "=" $mom_sys_leader(fifth_axis) "" lib_sys_home_leader(4)

  regsub -all "=" "_$mom_sys_leader(X)_HOME" "" lib_sys_home_param(0)
  regsub -all "=" "_$mom_sys_leader(Y)_HOME" "" lib_sys_home_param(1)
  regsub -all "=" "_$mom_sys_leader(Z)_HOME" "" lib_sys_home_param(2)
  regsub -all "=" "_$mom_sys_leader(fourth_axis)_HOME" "" lib_sys_home_param(3)
  regsub -all "=" "_$mom_sys_leader(fifth_axis)_HOME" "" lib_sys_home_param(4)

  if {[CONF_cycle832_mode cycle832_mode] == 1} {
    LIB_GE_command_buffer DEF_CAMTOL
    LIB_GE_command_buffer {MOM_output_literal "DEF REAL _camtolerance"} @CAMTOLERANCE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_parameter_definition_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition_LIB_ENTRY)} {LIB_CTRL_parameter_definition_LIB_ENTRY end} elseif {$commandcheck(LIB_CTRL_parameter_definition_ENTRY)} {LIB_CTRL_parameter_definition_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command defines and set the parameter.
#
# <Internal Example> _X_HOME,_Y_HOME,_Z_HOME,_A_HOME,_C_HOME ...
#
#____________________________________________________________________________________________
proc LIB_CTRL_feed_output {} {

  global mom_motion_type mom_motion_event mom_feed_cut_value mom_feed_cut_unit mom_feed_rate mom_feed_rate_per_rev
  global mom_cycle_feed_rate mom_output_unit feed_mode
  global feed lib_prev_feed lib_prev_feed_percent
  global mom_feed_engage_value mom_feed_engage_unit
  global mom_feed_retract_value mom_feed_retract_unit

  set commandcheck(LIB_CTRL_feed_output_ENTRY) [llength [info commands LIB_CTRL_feed_output_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {
    set tmp_motion_type [string tolower $mom_motion_type]
    if {[CONF_CTRL_feed feed_$tmp_motion_type] == "NX"} {
      if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
        MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
      } else {
        switch -- $feed_mode {
          IPM     -
          MMPM    -
          IPR     -
          MMPR    -
          DPM     -
          FRN     {
            MOM_set_address_format F Feed_${feed_mode}
            }
          INVERSE {MOM_set_address_format F Feed_INV}
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "P_CUT"} {
      if {(![string match "rapid" $tmp_motion_type] && ![string match "traverse" $tmp_motion_type] && ![string match "approach" $tmp_motion_type] \
      && ![string match "departure" $tmp_motion_type]) || $mom_feed_rate != $::mom_kin_rapid_feed_rate} {
      MOM_set_address_format F String
      if {![info exist lib_prev_feed] || (![EQ_is_equal $feed $mom_feed_cut_value] && $feed != $lib_prev_feed)} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
          set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
          set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
          if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
            MOM_force once F
          }
          set feed "=[CONF_CTRL_feed feed_cut]*$tmp_feed_percent"
          set lib_prev_feed_percent $tmp_feed_percent
        } else {
          set feed "=[CONF_CTRL_feed feed_cut]"
        }
      }
      set lib_prev_feed $feed

    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "MAX"} {
      MOM_set_address_format F String
      set feed [CONF_CTRL_feed feed_$tmp_motion_type]
    } else {
      MOM_set_address_format F String
      set tmp_feed $feed
      if {$tmp_motion_type == "cycle"} {
        set mom_cycle_feed_rate "=[CONF_CTRL_feed feed_$tmp_motion_type]"
      }
      set feed "=[CONF_CTRL_feed feed_$tmp_motion_type]"
      if {$tmp_motion_type == "cut" && ![EQ_is_equal $mom_feed_rate $mom_feed_cut_value]} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "=[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent"
        }
      }
      if {$tmp_motion_type == "engage" && ![EQ_is_equal $mom_feed_rate $mom_feed_engage_value]} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_engage_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "=[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent"
        }
      }
      if {$tmp_motion_type == "retract" && ![EQ_is_equal $mom_feed_rate $mom_feed_retract_value]} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_retract_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "=[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent"
        }
      }
      set lib_prev_feed $tmp_feed
    }

  } else {
    # use only NX-Values
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Output the feed dependent on the setting
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (FQ21)
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_set_feed_parameter {} {

  global mom_feed_cut_unit mom_output_unit mom_feed_rate feed
  global mom_cycle_feed_rate mom_cycle_feed_rate_per_rev
  global mom_feed_engage_value mom_feed_cut_value mom_feed_retract_value mom_feed_cycle_value
  global mom_feed_engage_unit mom_feed_cut_unit mom_feed_retract_unit mom_feed_cycle_value
  global mom_operation_type mom_motion_type lib_motion_type_list
  global lib_prev_feed_cut_value lib_flag mom_tool_name mom_kin_is_turbo_output
  global mom_feed_rate_output_mode mom_feed_rate_per_rev
  global lib_prev_cycle_definition_mode mom_cycle_definition_mode
  global lib_prev_feed_engage_value lib_prev_feed_retract_value

  set lib_flag(feed_turbo_mode_disable) 0
  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {

    foreach type $lib_motion_type_list {
      set tmp_motion_type [string tolower $type]
      if {[CONF_CTRL_feed exists feed_$tmp_motion_type]} {
        if {[CONF_CTRL_feed feed_$tmp_motion_type] != "NX"} {
          set lib_flag(feed_turbo_mode_disable) 1
          set mom_kin_is_turbo_output "FALSE"
        }
      }
    }
    if {$lib_flag(feed_turbo_mode_disable) == 1} {MOM_reload_kinematics_variable mom_kin_is_turbo_output}

    # check if "drilling" "Thread Milling" "Cylinder Milling" are the previous operation and the current cycle output is different
    # to the previous operation
    if {($mom_operation_type == "Drilling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Thread Milling")} {
      if {![info exists lib_prev_cycle_definition_mode] || $lib_prev_cycle_definition_mode != $mom_cycle_definition_mode } {
        set check_cycle_definition_mode 1
      } else {
        set check_cycle_definition_mode 0
      }
      set lib_prev_cycle_definition_mode $mom_cycle_definition_mode
    } else {
      set check_cycle_definition_mode 0
      set lib_prev_cycle_definition_mode 1
    }
    if {[info level 1] != "MOM_start_of_path" || ($mom_tool_name == [LIB_SPF_get_pretreatment mom_tool_name -1]        && \
      (([info exist lib_prev_feed_cut_value]    && ![EQ_is_equal $mom_feed_cut_value $lib_prev_feed_cut_value])          || \
      ([info exist lib_prev_feed_engage_value]  && ![EQ_is_equal $mom_feed_engage_value $lib_prev_feed_engage_value])    || \
      ([info exist lib_prev_feed_retract_value] && ![EQ_is_equal $mom_feed_retract_value $lib_prev_feed_retract_value])  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Hole Making"                                                  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Point to Point"                                               || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Drilling"))                                                   || \
      $check_cycle_definition_mode == 1} {

      MOM_force once F
      if {[CONF_CTRL_feed feed_engage] != "NX" && [CONF_CTRL_feed feed_engage] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_engage_value/25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_engage_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_engage_value
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_engage_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_engage_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_engage] = [LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Engage Move"]" "output_0" "1"
      }

      if {$mom_operation_type == "Thread Milling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Hole Making" || $mom_operation_type == "Point to Point" || ($mom_operation_type == "Drilling" && $::mom_cycle_definition_mode == 0)} {
        set mom_feed_rate $mom_feed_cut_value
        set mom_cycle_feed_rate $mom_feed_cut_value
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_cut_value
          set mom_cycle_feed_rate_per_rev $mom_feed_cut_value
          set mom_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
          set mom_cycle_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
        set mom_motion_type "CYCLE"
        LIB_SPF_feedrate_set
        if {[CONF_CTRL_feed feed_cycle] != "NX" && [CONF_CTRL_feed feed_cycle] != "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cycle] = [LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Cycle Move"]" "output_0" "1"
        } elseif {[CONF_CTRL_feed feed_cycle] == "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Cutting"]" "output_0" "1"
        }
      } else {
        set mom_kin_is_turbo_output "FALSE"
        if {[CONF_CTRL_feed feed_cut] != "NX" && [CONF_CTRL_feed feed_cut] != "P_CUT"} {
          if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
            set mom_feed_rate [expr $mom_feed_cut_value/25.4]
          } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
            set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
          } else {
            set mom_feed_rate $mom_feed_cut_value
          }
          if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
            set mom_feed_rate_per_rev $mom_feed_cut_value
          }
          set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
          set mom_motion_type "UNKNOWN"
          LIB_SPF_feedrate_set
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Cutting"]" "output_0" "1"
        }
      }

      if {[CONF_CTRL_feed feed_retract] != "NX" && [CONF_CTRL_feed feed_retract] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_retract_value/25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_retract_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_retract_value
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_retract_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_retract_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_retract] = [LIB_SPF_eliminate_zero $feed 3] ;[LIB_GE_MSG "Retract Move"]" "output_0" "1"
      }

      set lib_prev_feed_cut_value $mom_feed_cut_value
      set lib_prev_feed_engage_value $mom_feed_engage_value
      set lib_prev_feed_retract_value $mom_feed_retract_value
    }
  }
}
# <Internal Documentation>
#
# Set the feed parameter if nessesary
# only if property feed_linear is set to 2(parameter)
#
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (F[#21])
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_cut_move_LIB {} {

  set commandcheck(LIB_CTRL_cut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_LIB {} {

  set commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY) [llength [info commands LIB_CTRL_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_engage_move_LIB {} {

  set commandcheck(LIB_CTRL_engage_move_LIB_ENTRY) [llength [info commands LIB_CTRL_engage_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_retract_move_LIB {} {

  set commandcheck(LIB_CTRL_retract_move_LIB_ENTRY) [llength [info commands LIB_CTRL_retract_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_firstcut_move_LIB {} {

  set commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_firstcut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_approach_move_LIB {} {

  set commandcheck(LIB_CTRL_approach_move_LIB_ENTRY) [llength [info commands LIB_CTRL_approach_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_stepover_move_LIB {} {

  set commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY) [llength [info commands LIB_CTRL_stepover_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_departure_move_LIB {} {

  set commandcheck(LIB_CTRL_departure_move_LIB_ENTRY) [llength [info commands LIB_CTRL_departure_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_return_move_LIB {} {

  set commandcheck(LIB_CTRL_return_move_LIB_ENTRY) [llength [info commands LIB_CTRL_return_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_traversal_move_LIB {} {

  set commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY) [llength [info commands LIB_CTRL_traversal_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sidecut_move_LIB {} {

  set commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_sidecut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_from_move_LIB {} {

  set commandcheck(LIB_CTRL_from_move_LIB_ENTRY) [llength [info commands LIB_CTRL_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_default_move_LIB {} {

  set commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_default_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_move_LIB {} {

  set commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cycle_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_lift_move_LIB {} {

  set commandcheck(LIB_CTRL_lift_move_LIB_ENTRY) [llength [info commands LIB_CTRL_lift_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_undefined_move_LIB {} {

  set commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY) [llength [info commands LIB_CTRL_undefined_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_automatic_rotary_positioning_output {} {

  global mom_pos mom_out_angle_pos mom_feed_rate mom_warning_info
  global auto_rot_pos

  LIB_GE_command_buffer AUTOMATIC_ROTARY_positioning

  LIB_GE_command_buffer {LIB_GE_message "Automatic repositioning $mom_warning_info"} @MESSAGE

  LIB_GE_command_buffer {
    LIB_GE_message "retract"
                set mom_pos(0) $auto_rot_pos(retract,0)
                set mom_pos(1) $auto_rot_pos(retract,1)
                set mom_pos(2) $auto_rot_pos(retract,2)
                set mom_feed_rate $auto_rot_pos(retract,feed)
                MOM_do_template rapid_move
  } @RETRACT

  LIB_GE_command_buffer {
    #Cancel continious mode
    if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
      LIB_ROTARY_absolute_reset
    } else {
      LIB_ROTARY_simultaneous_reset
    }

    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}

  } @RETRACT_HOME

  LIB_GE_command_buffer {
    LIB_GE_message "repositionnning"
    set mom_out_angle_pos(0) $auto_rot_pos(reposition,0)
    set mom_out_angle_pos(1) $auto_rot_pos(reposition,1)
    MOM_do_template rapid_move
  } @REPOSITIONNNING

  LIB_GE_command_buffer {
    LIB_GE_message "approach"
    set mom_pos(0) $auto_rot_pos(approach,0)
    set mom_pos(1) $auto_rot_pos(approach,1)
    set mom_pos(2) $auto_rot_pos(approach,2)
    set mom_feed_rate $auto_rot_pos(approach,feed)
    MOM_do_template rapid_move
  } @APPROACH

  LIB_GE_command_buffer {
    LIB_GE_message "engage"
    set mom_pos(0) $auto_rot_pos(engage,0)
    set mom_pos(1) $auto_rot_pos(engage,1)
    set mom_pos(2) $auto_rot_pos(engage,2)
    set mom_feed_rate $auto_rot_pos(engage,feed)
    MOM_do_template linear_move
  } @ENGAGE
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Output motions for automatic rotary positioning when over travel limit
#
# AUTOMATIC_ROTARY_positioning default list:
# @RETRACT @RETRACT_HOME @REPOSITIONNNING @APPROACH @ENGAGE
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_sys_leader_trailer_setting {} {
  global mom_sys_leader mom_sys_trailer

  set mom_sys_leader(SPOS) [CONF_CTRL_spindle spindle_orient]

  if {[regexp "DC\\(" $mom_sys_leader(SPOS)] == 1} {
    set mom_sys_trailer(SPOS) ")"
  } else {
    set mom_sys_trailer(SPOS) ""
  }
}
# <Internal Documentation>
# Update mom_sys_leader and trailer variables linked to basic ones
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_standard_path_between_rotary_motions_checking {{option default}} {

  if {$::lib_flag(local_namespace_output) == 1} {
    return
  }

  global mom_out_angle_pos mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit mom_lib_cycle800_dir
  global mom_prev_pos prev_convert_mom_out_angle_pos lib_parameter mom_pos lib_flag

  switch -- $option {
    "pos_to_sim"  {
      # motion POS to SIM
      # check[LIB_cycle800_DIR MOVE] to set limitation
      #CONF_CTRL_setting

      if {$lib_parameter(cycle800,_DIR) == -1} {
        if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] != "5_axis_dual_head"} {
          set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_4th_axis_min_limit]
          if {$mom_prev_pos(4) < -180} {set mom_prev_pos(4) -179.}
        } else {
          set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_5th_axis_min_limit]
          if {$mom_prev_pos(4) < -180} {set mom_prev_pos(4) -179.}

        }

      } elseif {$lib_parameter(cycle800,_DIR) == 1} {
        if {[LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_machine_type] != "5_axis_dual_head"} {
          set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_4th_axis_max_limit]
          if {$mom_prev_pos(4) > 180} {set mom_prev_pos(4) 179.}
        } else {
          set mom_prev_pos(4) [LIB_GE_chain_get_global_var_value $::lib_ge_active_chain mom_kin_5th_axis_max_limit]
          if {$mom_prev_pos(4) > 180} {set mom_prev_pos(4) 179.}
        }

      }

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_prev_pos(3) $prev_convert_mom_out_angle_pos(0)

      } else {
        set mom_prev_pos(3) 0

      }

      MOM_reload_variable -a mom_prev_pos
    }
    "pos_to_sim_next" {
      # motion POS to SIM
      # check[LIB_cycle800_DIR MOVE] to set limitation
      #CONF_CTRL_setting

      if {$lib_parameter(cycle800,_DIR) == -1} {

        set mom_pos(4) $mom_kin_5th_axis_min_limit
      } elseif {$lib_parameter(cycle800,_DIR) == 1} {

        set mom_pos(4) $mom_kin_5th_axis_max_limit
      }

      if {[info exists prev_convert_mom_out_angle_pos]} {

        set mom_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {

        set mom_pos(3) 0

      }

      MOM_reload_variable -a mom_pos

    }
    "sim_to_pos" {
      # motion SIM to POS
      # check mom_out_angle_pos(1) setting in LIB_SPF_convert_point proc
      # <NX1201 cam16012> new prereatment local csys
      if {$lib_flag(local_namespace_output) == 0} {
        if {[EQ_is_ge $mom_out_angle_pos(1) 0.0]} {
          set mom_lib_cycle800_dir 1
        } else {
          set mom_lib_cycle800_dir -1
        }
        set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) $mom_lib_cycle800_dir
      }
    }
  }
}
# <Internal Documentation>
#
# Used when [CONF_CTRL_moves standard_path_between_rotary_motions] == 1 for internal tool path
# Set right rotary position when lib_flag(mode_current_status) changes
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_parameter_call {} {


  if {[CONF_cycle832_mode cycle832_mode] == 1} {

    LIB_GE_command_buffer CAMTOLERANCE
    LIB_GE_command_buffer {MOM_output_literal "_camtolerance=[LIB_SPF_eliminate_zero [expr $::mom_inside_outside_tolerances(0)+$::mom_inside_outside_tolerances(1)] 6]"} @CAMTOLERANCE
    LIB_GE_command_buffer_output

  }
}
# <Internal Documentation>
#
# This command output parameter value.
# _camtolerance ...
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_user_camtolerance {} {

  global mom_siemens_tol

  if { [info exists mom_siemens_tol] } {

    LIB_GE_command_buffer USERTOLERANCE
    LIB_GE_command_buffer {MOM_output_literal "_camtolerance=[LIB_SPF_eliminate_zero $mom_siemens_tol 6]  ;  User Defined"} @USERTOLERANCE
    LIB_GE_command_buffer_output

    unset mom_siemens_tol
  }
}
# <Internal Documentation>
#
# Used to output user defined _camtolerance for cycle832, it is called in LIB_CTRL_before_first_motion_LIB
# CYCLE832 is outputed before origin output
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_before_first_motion_LIB {} {


  global mom_cutmthd_libref mom_operation_type
  global cycle832_camtolerance cycle832_v832 cycle832_tolm cycle832_otolm
  global mom_siemens_compressor lib_sav_kin_4th_axis_leader
  global mom_siemens_smoothing lib_sav_kin_5th_axis_leader
  global mom_siemens_feedforward mom_kin_machine_type
  global mom_siemens_top_surface_smooth
  global mom_siemens_rotary_tol siemens_method

  set commandcheck(LIB_CTRL_before_first_motion_LIB_ENTRY) [llength [info commands LIB_CTRL_before_first_motion_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_before_first_motion_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_before_first_motion_LIB_ENTRY)} {LIB_CTRL_before_first_motion_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_cycle_832
  LIB_GE_command_buffer {
    if {($::mom_current_motion == "initial_move" || $::mom_current_motion == "first_move") && \
      [CONF_cycle832_mode cycle832_mode] == 1} {

      # Set the method.
      if { [info exists mom_cutmthd_libref] } {
        switch -- $mom_cutmthd_libref {
          OPD0_00021 {set siemens_method "ROUGHING"}
          OPD0_00022 {set siemens_method "ROUGH-FINISHING"}
          OPD0_00023 {set siemens_method "FINISHING"}
          default    {set siemens_method "DESELECTION"}
        }
      } else {
        set siemens_method "DESELECTION"
      }
      if {[CONF_cycle832_mode siemens_cutmthd_libref] != "ON"} {
        # for other settings
        LIB_CONF_do_prop_custom_proc CONF_cycle832_mode siemens_cutmthd_libref "short_template_syntax"
        if {$siemens_method != "ROUGHING" && $siemens_method != "ROUGH-FINISHING" && $siemens_method != "FINISHING" && $siemens_method != "DESELECTION"} {
          LIB_GE_abort_message "siemens_method: $siemens_method: value is wrong. Please check CYCLE832 setting in the post !"
        }
      }

      # For the mode "Standard" and "Powerline".
      if {[CONF_S840D_controller sinumerik_control_version] != "Solutionline"} {
        switch [CONF_S840D_controller sinumerik_version] {
          "V5" {
            if {[info exists mom_siemens_compressor]} {
              if { $mom_siemens_compressor == "ON" } {
                set siemens_compressor "COMPCURV"
              } else {
                set siemens_compressor "COMPOF"
              }
              unset mom_siemens_compressor
            } elseif {[CONF_cycle832_mode siemens_compressor] == "ON" } {
              set siemens_compressor "COMPCURV"
            } else {
              set siemens_compressor "COMPOF"
            }

            if {[info exists mom_siemens_smoothing] } {
              if { $mom_siemens_smoothing == "ON"} {
                set siemens_smoothing "G642"
              } else {
                set siemens_smoothing "G60"
              }
              unset mom_siemens_smoothing
            } elseif {[CONF_cycle832_mode siemens_smoothing] == "ON" } {
              set siemens_smoothing "G642"
            } else {
              set siemens_smoothing "G60"
            }
          }
          "V6" {
            if {[info exists mom_siemens_compressor]} {
              if { $mom_siemens_compressor == "ON" } {
                set siemens_compressor "COMPCAD"
              } else {
                set siemens_compressor "COMPOF"
              }
              unset mom_siemens_compressor
            } elseif {[CONF_cycle832_mode siemens_compressor] == "ON" } {
              set siemens_compressor "COMPCAD"
            } else {
              set siemens_compressor "COMPOF"
            }

            if {[info exists mom_siemens_smoothing] } {
              if { $mom_siemens_smoothing == "ON"} {
                set siemens_smoothing "G642"
              } else {
                set siemens_smoothing "G64"
              }
              unset mom_siemens_smoothing
            } elseif {[CONF_cycle832_mode siemens_smoothing] == "ON" } {
              set siemens_smoothing "G642"
            } else {
              set siemens_smoothing "G64"
            }
          }
          "V7" {
            if {[info exists mom_siemens_compressor]} {
              if { $mom_siemens_compressor == "ON" } {
                set siemens_compressor "COMPCAD"
              } else {
                set siemens_compressor "COMPOF"
              }
              unset mom_siemens_compressor
            } elseif {[CONF_cycle832_mode siemens_compressor] == "ON" } {
              set siemens_compressor "COMPCAD"
            } else {
              set siemens_compressor "COMPOF"
            }

            if {[info exists mom_siemens_smoothing] } {
              if { $mom_siemens_smoothing == "ON"} {
                set siemens_smoothing "G645"
              } else {
                set siemens_smoothing "G60"
              }
              unset mom_siemens_smoothing
            } elseif {[CONF_cycle832_mode siemens_smoothing] == "ON" } {
              set siemens_smoothing "G645"
            } else {
              set siemens_smoothing "G60"
            }
          }
          default {}
        }

        if {[info exists mom_siemens_feedforward]} {
          if {$mom_siemens_feedforward == "ON"} {
            set siemens_feedforward "FFWON"
          } else {
            set siemens_feedforward "FFWOF"
          }
          unset mom_siemens_feedforward
        } elseif {[CONF_cycle832_mode siemens_feedforward] == "ON" } {
          set siemens_feedforward "FFWON"
        } else {
          set siemens_feedforward "FFWOF"
        }

        if {![string match "point*" [LIB_SPF_ask_operation_type]] && ![string match "probe*" [LIB_SPF_ask_operation_type]]} {
          if {[CONF_S840D_controller sinumerik_version] == "V7"} {
            set cycle832_v832 1
            switch -- $siemens_method {
              "ROUGHING"        { set cycle832_tolm 3}
              "ROUGH-FINISHING" { set cycle832_tolm 2}
              "FINISHING"       { set cycle832_tolm 1}
              default           { set cycle832_tolm 0}
            }
            LIB_CTRL_output_user_camtolerance
            LIB_SPF_call_cycle CYCLE832_v7

            if {$siemens_smoothing == "G60" } {
              LIB_GE_command_buffer SMOOTH
              LIB_GE_command_buffer {MOM_output_literal "$siemens_smoothing"} @SMOOTH
              LIB_GE_command_buffer_output
            }

            if {$siemens_feedforward == "FFWOF"  } {

              LIB_GE_command_buffer FEEDFORWARD
              LIB_GE_command_buffer {MOM_output_literal "$siemens_feedforward"} @FEEDFORWARD
              LIB_GE_command_buffer_output
            }

            if {$siemens_compressor == "COMPOF" } {
              LIB_GE_command_buffer COMPRESSOR
              LIB_GE_command_buffer {MOM_output_literal "$siemens_compressor"} @COMPRESSOR
              LIB_GE_command_buffer_output
            }
          } elseif {[CONF_S840D_controller sinumerik_version] == "V6" } {

            if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [CONF_CTRL_setting tcpm_mode] == "TRAORI" } {
              set siemens_5axis_output "TRAORI"
            } else {
              set siemens_5axis_output "TRAFOOF"
            }
            if {[info exists cycle832_v832]} {unset cycle832_v832}
            set list5 {COMPOF COMPCAD COMPCURV BSPLINE}
            set list4 {FFWOF FFWON BRISK}
            set list3 {G64 G641 G642}
            set list2 {TRAFOOF TRAORI TRAORI2}
            set list0 {DESELECTION FINISHING ROUGH-FINISHING ROUGHING}
            set tolm 0
            set i 0

            foreach b5 $list5 b4 $list4 b3 $list3 b2 $list2 b0 $list0 {
              if { [string match $b5 $siemens_compressor] } {
                set tolm [expr $tolm+$i*100000]
              }
              if { [string match $b4 $siemens_feedforward] } {
                set tolm [expr $tolm+$i*10000]
              }
              if { [string match $b3 $siemens_smoothing] } {
                set tolm [expr $tolm+$i*1000]
              }
              if { [string match $b2 $siemens_5axis_output] } {
                set tolm [expr $tolm+$i*100]
              }
              if { [string match $b0 $siemens_method] } {
                set tolm [expr $tolm+$i]
              }
              incr i
            }
            set cycle832_tolm $tolm
            LIB_CTRL_output_user_camtolerance
            LIB_SPF_call_cycle CYCLE832
          } elseif {[CONF_S840D_controller sinumerik_version]  == "V5"} {

            LIB_CTRL_output_user_camtolerance
            LIB_GE_command_buffer COMPRESS_SET
            LIB_GE_command_buffer {MOM_output_literal "\$MA_COMPRESS_POS_TOL\[X\] = _camtolerance*1.2"} @COMPRESS_X
            LIB_GE_command_buffer {MOM_output_literal "\$MA_COMPRESS_POS_TOL\[Y\] = _camtolerance*1.2"} @COMPRESS_Y
            LIB_GE_command_buffer {MOM_output_literal "\$MA_COMPRESS_POS_TOL\[Z\] = _camtolerance*1.2"} @COMPRESS_Z
            LIB_GE_command_buffer {
              if { ![string match "3_axis_mill" $mom_kin_machine_type] } {
                MOM_output_literal "\$MA_COMPRESS_POS_TOL\[$lib_sav_kin_4th_axis_leader\] = _camtolerance*12"
              }
            } @COMPRESS_4th
            LIB_GE_command_buffer {
              if { [string match "*5*" $mom_kin_machine_type] } {
                MOM_output_literal "\$MA_COMPRESS_POS_TOL\[$lib_sav_kin_5th_axis_leader\] = _camtolerance*12"
              }
            } @COMPRESS_5th
            LIB_GE_command_buffer_output

            LIB_GE_command_buffer cycle832_v5
            LIB_GE_command_buffer {
              MOM_output_literal "NEWCONF"

              # Output High Speed Machining codes
              MOM_output_literal "$siemens_feedforward"
              MOM_output_literal "UPATH"
              MOM_output_literal "SOFT"

              MOM_output_literal "$siemens_compressor"
              MOM_output_literal "$siemens_smoothing"
            } @cycle832_v5
            LIB_GE_command_buffer_output

          }

          # For drill operation.
        } else {
          if {[CONF_S840D_controller sinumerik_version] == "V7" || [CONF_S840D_controller sinumerik_version] =="V6" } {
            MOM_output_literal "CYCLE832()"
          } else {
            MOM_output_literal "G60"
          }
        }

        # For the mode "Solutionline".
      } else {

        # For the non-drill operation.
        if {![string match "point*" [LIB_SPF_ask_operation_type]] && ![string match "probe*" [LIB_SPF_ask_operation_type]]} {

          if {[CONF_S840D_controller sinumerik_version_sl] == 47} {

            set cycle832_otolm "1"; set cycle832_camtolerance "_camtolerance"

            # Get the value of "top".
            set top ""

            if {[info exists mom_siemens_top_surface_smooth]} {

              if {[string match "TOP*ON" $mom_siemens_top_surface_smooth]} {
                set top "_TOP_SURFACE_SMOOTH_ON+"
              } elseif {[string match "TOP*OFF" $mom_siemens_top_surface_smooth]} {
                set top "_TOP_SURFACE_SMOOTH_OFF+"
              } else {
                set top ""
              }

              unset mom_siemens_top_surface_smooth

            } elseif {[CONF_cycle832_mode siemens_top_surface_smooth] == "ON"} {
              set top "_TOP_SURFACE_SMOOTH_ON+"

            } elseif {[CONF_cycle832_mode siemens_top_surface_smooth] == "OFF"} {
              set top "_TOP_SURFACE_SMOOTH_OFF+"

            } else {
              set top ""
            }

            # Get the value of "rot".
            set rot ""

            if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {

              set rot "_ORI"

              if {[info exists mom_siemens_rotary_tol]} {

                set cycle832_otolm "$mom_siemens_rotary_tol"
                unset mom_siemens_rotary_tol

              } else {
                set cycle832_otolm "[CONF_cycle832_mode siemens_rotary_tol]"
              }
            }

            switch -- $siemens_method {
              "ROUGHING"        {set cycle832_tolm "_ROUGH"}
              "ROUGH-FINISHING" {set cycle832_tolm "_SEMIFIN"}
              "FINISHING"       {set cycle832_tolm "_FINISH"}
              default           {set cycle832_tolm "_OFF"; set top ""; set rot ""; set cycle832_otolm "1"}
            }
            LIB_CTRL_output_user_camtolerance

            set cycle832_tolm $top$rot$cycle832_tolm

            LIB_GE_command_buffer CYCLE832V47
            LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE832_v47} @CYCLE832V47
            LIB_GE_command_buffer_output

          } elseif {[CONF_S840D_controller sinumerik_version_sl] == 45} {

            set cycle832_otolm "1"; set cycle832_camtolerance "_camtolerance"

            # Get the value of "rot".
            set rot ""

            if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {

              set rot "_ORI"

              if {[info exists mom_siemens_rotary_tol]} {

                set cycle832_otolm "$mom_siemens_rotary_tol"
                unset mom_siemens_rotary_tol

              } else {
                set cycle832_otolm "[CONF_cycle832_mode siemens_rotary_tol]"
              }
            }

            switch -- $siemens_method {
              "ROUGHING"        {set cycle832_tolm "_ROUGH"}
              "ROUGH-FINISHING" {set cycle832_tolm "_SEMIFIN"}
              "FINISHING"       {set cycle832_tolm "_FINISH"}
              default           {set cycle832_tolm "_OFF"; set cycle832_otolm "1"}
            }

            LIB_CTRL_output_user_camtolerance
            LIB_GE_command_buffer CYCLE832V45
            LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE832_v45} @CYCLE832V45
            LIB_GE_command_buffer_output

          } elseif {[CONF_S840D_controller sinumerik_version_sl] == 44} {

            set cycle832_v832 "1"; set cycle832_camtolerance "_camtolerance"
            switch -- $siemens_method {
              "ROUGHING"        { set cycle832_tolm 3}
              "ROUGH-FINISHING" { set cycle832_tolm 2}
              "FINISHING"       { set cycle832_tolm 1}
              default           {set cycle832_tolm 0}

            }
            LIB_CTRL_output_user_camtolerance
            LIB_GE_command_buffer CYCLE832V44
            LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE832_v44} @CYCLE832V44
            LIB_GE_command_buffer_output
          }

          # For the drill operation.
        } else {
          if {[CONF_S840D_controller sinumerik_version_sl] >= "45"} {
            set cycle832_otolm "1"; set cycle832_tolm "_OFF"; set cycle832_camtolerance "0"
            LIB_GE_command_buffer CYCLE832V45_drill
            LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE832_v45} @CYCLE832V45_drill
            LIB_GE_command_buffer_output

          } elseif {[CONF_S840D_controller sinumerik_version_sl] == "44"} {
            if {[info exists cycle832_v832]} {unset cycle832_v832}
            if {[info exists cycle832_tolm]} {unset cycle832_tolm}
            if {[info exists cycle832_camtolerance]} { unset cycle832_camtolerance}
            LIB_GE_command_buffer CYCLE832V44_drill
            LIB_GE_command_buffer {LIB_SPF_call_cycle CYCLE832_v44} @CYCLE832V44_drill
            LIB_GE_command_buffer_output
          }
        }
      }
    }
  } @CYCLE832
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_before_first_motion_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_before_first_motion_LIB_ENTRY)} {LIB_CTRL_before_first_motion_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Used to output CYCLE832, it is called in LIB_SPF_first_tool_path_motion for first motion of each operation
# CYCLE832 is outputed before origin output
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc DEFINE_MACROS {} {
#=============================================================
global mom_pb_macro_arr

  set mom_pb_macro_arr(CYCLE81) \
  [list {CYCLE81 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE82) \
  [list {CYCLE82 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_dtb} 1 4 2 1 1 6 4}}]

  set mom_pb_macro_arr(CYCLE83_Deep) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$mom_cycle_step1} 1 4 5 1 1 9 4} \
  {{$mom_cycle_step2} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dts} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_frf} 1 3 5 1 1 8 3} \
  {1 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 4 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_o_dtd} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_dis1} 1 4 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE83_Break_Chip) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$mom_siemens_cycle_fdpr} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dam} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_frf} 1 3 5 1 1 8 3} \
  {0 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_o_vrt} 1 4 2 1 1 6 4} \
  {{$mom_siemens_cycle_o_dtd} 1 3 5 1 1 8 3}}]

  set mom_pb_macro_arr(CYCLE84) \
  [list {CYCLE84 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_mpit} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {{$mom_cycle_orient} 1 3 5 1 1 8 3} \
  {{$mom_spindle_speed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_sst1} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_o_var1} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_dam} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_vrt} 1 3 5 1 1 8 3}}]

  set mom_pb_macro_arr(CYCLE840) \
  [list {CYCLE840 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdr} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_enc} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_mpit} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE85_Bore) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$feed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_rff} 1 2 7 1 1 9 2}}]

  set mom_pb_macro_arr(CYCLE85_Bore_Dwell) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$feed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_rff} 1 2 7 1 1 9 2}}]

  set mom_pb_macro_arr(CYCLE86) \
  [list {CYCLE86 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_rpa} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_rpo} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_rpap} 1 4 5 1 1 9 4} \
  {{$mom_cycle_orient} 1 3 5 1 1 8 3}}]

  set mom_pb_macro_arr(CYCLE87) \
  [list {CYCLE87 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE88) \
  [list {CYCLE88 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE89) \
  [list {CYCLE89 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3}}]

  set mom_pb_macro_arr(CYCLE95) \
  [list {CYCLE95 ( , ) 0 {}} \
  {{{\"$mom_siemens_cycle_subroutine_name\"} 0} \
  {{$mom_siemens_cycle_mid} 1 3 5 1 1 8 3} \
  {{$mom_face_stock} 1 3 5 1 1 8 3} \
  {{$mom_radial_stock} 1 3 5 1 1 8 3} \
  {{$mom_stock_part} 1 3 5 1 1 8 3} \
  {{$mom_feed_cut_value} 1 3 5 1 1 8 3} \
  {{$mom_feed_stepover_value} 1 3 5 1 1 8 3} \
  {{$mom_feedrate_profile_cut} 1 3 5 1 1 8 3} \
  {{$mom_turn_cycle95_machining_type} 1 0 3 0 0 3} \
  {{$mom_local_return_dwell} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dam} 1 3 5 1 1 8 3} \
  {{$mom_retract_level_part_distance} 1 4 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE81,Solutionline) \
  [list {CYCLE81 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$mom_siemens_cycle_gmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_dmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE82,Solutionline) \
  [list {CYCLE82 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_dtb} 1 4 2 1 1 6 4} \
  {{$mom_siemens_cycle_gmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_dmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE83_Deep,Solutionline) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$mom_cycle_step1} 1 4 5 1 1 9 4} \
  {{$mom_cycle_step2} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dts} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_frf} 1 3 5 1 1 8 3} \
  {1 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 4 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_o_dtd} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_dis1} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_gmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 8 0 0 8}}]

  set mom_pb_macro_arr(CYCLE83_Break_Chip,Solutionline) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$mom_siemens_cycle_fdpr} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dam} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_frf} 1 3 5 1 1 8 3} \
  {0 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_o_vrt} 1 4 2 1 1 6 4} \
  {{$mom_siemens_cycle_o_dtd} 1 3 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_gmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 8 0 0 8}}]

  set mom_pb_macro_arr(CYCLE84,Solutionline) \
  [list {CYCLE84 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_mpit} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {{$mom_cycle_orient} 1 3 5 1 1 8 3} \
  {{$mom_spindle_speed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_sst1} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_o_var1} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_dam} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_vrt} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_pitm} 0} \
  {{$mom_siemens_cycle_o_ptab_sl} 0} \
  {{$mom_siemens_cycle_o_ptaba} 0} \
  {{$mom_siemens_cycle_gmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_dmode} 1 0 4 0 0 4} \
  {{$mom_siemens_cycle_amode} 1 0 7 0 0 7}}]

  set mom_pb_macro_arr(CYCLE840,Solutionline) \
  [list {CYCLE840 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdr} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_enc} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_mpit} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_o_pitm} 0} \
  {{$mom_siemens_cycle_o_ptab_sl} 0} \
  {{$mom_siemens_cycle_o_ptaba} 1 4 2 1 1 6 4} \
  {} \
  {{$mom_siemens_cycle_dmode} 1 0 4 0 0 4} \
  {{$mom_siemens_cycle_amode} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE85_Bore,Solutionline) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {} \
  {{$feed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_rff} 1 2 7 1 1 9 2} \
  {} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE85_Bore_Dwell,Solutionline) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$feed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_rff} 1 2 7 1 1 9 2} \
  {} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE86,Solutionline) \
  [list {CYCLE86 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_rpa} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_rpo} 1 4 5 1 1 9 4} \
  {{$mom_siemens_cycle_rpap} 1 4 5 1 1 9 4} \
  {{$mom_cycle_orient} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_gmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE87,Solutionline) \
  [list {CYCLE87 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE88,Solutionline) \
  [list {CYCLE88 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE89,Solutionline) \
  [list {CYCLE89 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_feed_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3}}]

  set mom_pb_macro_arr(CYCLE95,Solutionline) \
  [list {CYCLE95 ( , ) 0 {}} \
  {{{\"$mom_siemens_cycle_subroutine_name\"} 0} \
  {{$mom_siemens_cycle_mid} 1 3 5 1 1 8 3} \
  {{$mom_face_stock} 1 3 5 1 1 8 3} \
  {{$mom_radial_stock} 1 3 5 1 1 8 3} \
  {{$mom_stock_part} 1 3 5 1 1 8 3} \
  {{$mom_feed_cut_value} 1 3 5 1 1 8 3} \
  {{$mom_feed_stepover_value} 1 3 5 1 1 8 3} \
  {{$mom_feedrate_profile_cut} 1 3 5 1 1 8 3} \
  {{$mom_turn_cycle95_machining_type} 1 0 3 0 0 3} \
  {{$mom_local_return_dwell} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dam} 1 3 5 1 1 8 3} \
  {{$mom_retract_level_part_distance} 1 4 5 1 1 9 4} \
  {0 1 0 1 0 0 1} \
  {0 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE97) \
  [list {CYCLE97 ( , ) 0 {}} \
  {{{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_spl} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_fpl} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dm1} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dm2} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_app} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_rop} 1 3 5 1 1 8 3} \
  {{$mom_turn_cycle_total_depth} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_fal} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_iang} 1 3 5 1 1 8 3} \
  {0 0} \
  {{$mom_siemens_cycle_nrc} 1 0 2 1 1 2 0} \
  {{$mom_number_of_chases} 1 4 2 1 1 6 4} \
  {{$mom_turn_cycle97_machining_type} 0} \
  {{$mom_number_of_starts} 1 0 2 1 1 2 0} \
  {{$mom_minimum_clearance} 1 3 5 1 1 8 3}}]

  set mom_pb_macro_arr(CYCLE81,Incremental) \
  [list {CYCLE81 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE82,Incremental) \
  [list {CYCLE82 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE83_Deep,Incremental) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_step1} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_step2} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dts} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_frf} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {1 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_o_dtd} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_o_dis1} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE83_Break_Chip,Incremental) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \

  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_fdpr} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dam} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_frf} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {0 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 3 1 1 6 3} \
  {{$mom_siemens_cycle_o_vrt} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 2 1 1 5 3} \
  {{$mom_siemens_cycle_o_dtd} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 3 1 1 6 3}}]

  set mom_pb_macro_arr(CYCLE84,Incremental) \
  [list {CYCLE84 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_orient} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_spindle_speed} 1 2 5 1 1 7 2} \
  {{$mom_siemens_cycle_sst1} 1 2 5 1 1 7 2} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_o_var1} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_dam} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_o_vrt} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4}}]

  set mom_pb_macro_arr(CYCLE840,Incremental) \
  [list {CYCLE840 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_sdr} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_enc} 1 0 2 0 0 2} \
  {} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE85_Bore,Incremental) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$feed} 1 2 5 1 1 7 2} \
  {{$mom_siemens_cycle_rff} 1 2 5 1 1 7 2}}]

  set mom_pb_macro_arr(CYCLE85_Bore_Dwell,Incremental) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$feed} 1 2 6 1 1 8 2} \
  {{$mom_siemens_cycle_rff} 1 2 6 1 1 8 2}}]

  set mom_pb_macro_arr(CYCLE86,Incremental) \
  [list {CYCLE86 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_rpa} 1 3 3 1 1 6 3} \
  {{$mom_siemens_cycle_rpo} 1 3 3 1 1 6 3} \
  {{$mom_siemens_cycle_rpap} 1 3 3 1 1 6 3} \
  {{$mom_cycle_orient} 1 3 3 1 1 6 3}}]

  set mom_pb_macro_arr(CYCLE87,Incremental) \
  [list {CYCLE87 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE88,Incremental) \
  [list {CYCLE88 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 4 1 1 7 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE89,Incremental) \
  [list {CYCLE89 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 4 1 1 7 3}}]

  set mom_pb_macro_arr(CYCLE81,Solutionline,Incremental) \
  [list {CYCLE81 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 3 2 1 1 5 3} \
  {{$mom_siemens_cycle_gmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_dmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE82,Solutionline,Incremental) \
  [list {CYCLE82 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 2 1 1 5 3} \
  {{$mom_siemens_cycle_gmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_dmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE83_Deep,Solutionline,Incremental) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_cycle_step1} 1 3 5 1 1 8 3} \
  {{$mom_cycle_step2} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dts} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_frf} 1 3 5 1 1 8 3} \
  {1 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 3 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_o_dtd} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_dis1} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_gmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 8 0 0 8}}]

  set mom_pb_macro_arr(CYCLE83_Break_Chip,Solutionline,Incremental) \
  [list {CYCLE83 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$mom_siemens_cycle_fdpr} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dam} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_frf} 1 3 5 1 1 8 3} \
  {0 0} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_cycle_step3} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_vrt} 1 3 2 1 1 5 3} \
  {{$mom_siemens_cycle_o_dtd} 1 3 5 1 1 8 3} \
  {} \
  {{$mom_siemens_cycle_gmode} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 8 0 0 8}}]

  set mom_pb_macro_arr(CYCLE84,Solutionline,Incremental) \
  [list {CYCLE84 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_mpit} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {{$mom_cycle_orient} 1 3 5 1 1 8 3} \
  {{$mom_spindle_speed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_sst1} 1 2 7 1 1 9 2} \
  {0 0} \
  {1 0} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_o_var1} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_dam} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_vrt} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_pitm} 0} \
  {{$mom_siemens_cycle_o_ptab_sl} 0} \
  {{$mom_siemens_cycle_o_ptaba} 0} \
  {{$mom_siemens_cycle_gmode} 0} \
  {{$mom_siemens_cycle_dmode} 1 0 4 0 0 4} \
  {{$mom_siemens_cycle_amode} 1 0 7 0 0 7}}]

  set mom_pb_macro_arr(CYCLE840,Solutionline,Incremental) \
  [list {CYCLE840 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdr} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_sdac} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_enc} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_mpit} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_pit} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 8 3} \
  {{$mom_siemens_cycle_o_axn} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_ptab} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_o_techno} 1 0 2 0 0 2} \
  {{$mom_siemens_cycle_o_pitm} 0} \
  {{$mom_siemens_cycle_o_ptab_sl} 0} \
  {{$mom_siemens_cycle_o_ptaba} 1 3 2 1 1 5 3} \
  {} \
  {{$mom_siemens_cycle_dmode} 1 0 4 0 0 4} \
  {{$mom_siemens_cycle_amode} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE85_Bore,Solutionline,Incremental) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{$feed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_rff} 1 2 7 1 1 9 2} \
  {} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE85_Bore_Dwell,Solutionline,Incremental) \
  [list {CYCLE85 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$feed} 1 2 7 1 1 9 2} \
  {{$mom_siemens_cycle_rff} 1 2 7 1 1 9 2} \
  {} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE86,Solutionline,Incremental) \
  [list {CYCLE86 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_rapid_to} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_dtb} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_rpa} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_rpo} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_rpap} 1 3 5 1 1 8 3} \
  {{$mom_cycle_orient} 1 3 5 1 1 8 3} \
  {{$mom_siemens_cycle_gmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_dmode} 1 0 1 0 0 1} \
  {{$mom_siemens_cycle_amode} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE87,Solutionline,Incremental) \
  [list {CYCLE87 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE88,Solutionline,Incremental) \
  [list {CYCLE88 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 4 4 1 1 8 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 4 1 1 7 3} \
  {{$mom_siemens_cycle_sdir} 1 0 1 0 0 1}}]

  set mom_pb_macro_arr(CYCLE89,Solutionline,Incremental) \
  [list {CYCLE89 ( , ) 0 {}} \
  {{{$mom_cycle_retract_to_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_pos($mom_cycle_spindle_axis)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_clearance_plane} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {} \
  {{abs($mom_cycle_feed_to)} 1 {[CONF_CTRL_macro coordinate_decimal_place]} 5 1 1 9 4} \
  {{$mom_cycle_delay} 1 3 4 1 1 7 3}}]

  set mom_pb_macro_arr(CYCLE800) \
  [list {CYCLE800 ( , ) 0 {}} \
  {{{$lib_parameter(cycle800,_FR)} 0} \
  {{$lib_linked_var(CONF_S840D_cycle800@_TC)} 0} \
  {{$lib_linked_var(CONF_S840D_cycle800@_ST)} 1 0 6 0 0 6} \
  {{$lib_linked_var(CONF_S840D_cycle800@_MODE)} 1 0 3 0 0 3} \
  {{$lib_parameter(cycle800,_X0)} 1 6 5 0 1 11 6} \
  {{$lib_parameter(cycle800,_Y0)} 1 6 5 0 1 11 6} \
  {{$lib_parameter(cycle800,_Z0)} 1 6 5 0 1 11 6} \
  {{$lib_parameter(cycle800,_A)} 1 5 5 0 1 10 5} \
  {{$lib_parameter(cycle800,_B)} 1 5 5 0 1 10 5} \
  {{$lib_parameter(cycle800,_C)} 1 5 5 0 1 10 5} \
  {{$lib_parameter(cycle800,_X1)} 1 3 5 0 1 8 3} \
  {{$lib_parameter(cycle800,_Y1)} 1 3 5 0 1 8 3} \
  {{$lib_parameter(cycle800,_Z1)} 1 3 5 0 1 8 3} \
  {{$lib_parameter(cycle800,_DIR)} 1 0 2 0 0 2} \
  {{$lib_parameter(cycle800,_FR_I)} 1 0 3 0 0 2} \
  {{$lib_linked_var(CONF_S840D_cycle800@_DMODE)} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE800_reset) \
  [list {CYCLE800 ( , ) 0 {}} \
  {}]

  set mom_pb_macro_arr(CYCLE800_reset_turn) \
  [list {CYCLE800 ( , ) 0 {}} \
  {{{$lib_linked_var(CONF_S840D_cycle800@_FR)} 0} \
  {{$lib_linked_var(CONF_S840D_cycle800@_TC)} 0} \
  {{$lib_linked_var(CONF_S840D_cycle800@_ST)} 1 0 6 0 0 6} \
  {{$lib_linked_var(CONF_S840D_cycle800@_MODE)} 1 0 3 0 0 3} \
  {{0.0} 1 6 5 0 1 11 6} \
  {{0.0} 1 6 5 0 1 11 6} \
  {{0.0} 1 6 5 0 1 11 6} \
  {{0.0} 1 5 5 0 1 10 5} \
  {{0.0} 1 5 5 0 1 10 5} \
  {{0.0} 1 5 5 0 1 10 5} \
  {{0.0} 1 3 5 0 1 8 3} \
  {{0.0} 1 3 5 0 1 8 3} \
  {{0.0} 1 3 5 0 1 8 3} \
  {{$lib_parameter(cycle800,_DIR)} 1 0 2 0 0 2} \
  {{$lib_parameter(cycle800,_FR_I)} 1 0 2 0 0 2}}]

  set mom_pb_macro_arr(CYCLE832) \
  [list {CYCLE832 ( , ) 0 {}} \
  {{_camtolerance 0} \
  {{$cycle832_tolm} 1 0 6 0 0 6}}]

  set mom_pb_macro_arr(CYCLE832_v7) \
  [list {CYCLE832 ( , ) 0 {}} \
  {{_camtolerance 0} \
  {{$cycle832_tolm} 1 0 6 0 0 6} \
  {{$cycle832_v832} 0}}]

  set mom_pb_macro_arr(CYCLE832_v44) \
  [list {CYCLE832 ( , ) 0 {}} \
  {{{$cycle832_camtolerance} 0} \
  {{$cycle832_tolm} 1 0 6 0 0 6} \
  {{$cycle832_v832} 0}}]

  set mom_pb_macro_arr(CYCLE832_v45) \
  [list {CYCLE832 ( , ) 0 {}} \
  {{{$cycle832_camtolerance} 0} \
  {{$cycle832_tolm} 0} \
  {{$cycle832_otolm} 0}}]

  set mom_pb_macro_arr(CYCLE832_v47) \
  [list {CYCLE832 ( , ) 0 {}} \
  {{{$cycle832_camtolerance} 0} \
  {{$cycle832_tolm} 0} \
  {{$cycle832_otolm} 0}}]

  set mom_pb_macro_arr(MCALL) \
  [list {MCALL {} {} {} 0 {}} \
  {}]

  set mom_pb_macro_arr(ORIRESET) \
  [list {ORIRESET ( , ) 0 {}} \
  {{{$mom_out_angle_pos(0)} 1 5 5 1 1 10 5} \
  {{$mom_out_angle_pos(1)} 1 5 5 1 1 10 5}}]

}
proc LIB_CTRL_config_millturn {} {

  if {[CONF_SPF_advanced_settings chain_init] != "0"} {
    LIB_CONF_do_prop_custom_proc CONF_SPF_advanced_settings chain_init
    LIB_GE_copy_var_range lib_sav_sys_leader mom_sys_leader
  }
}
# <Internal Documentation>
# This procedure is called at each start_of_path and machine_mode events.
# It's implemented for multi chains. Content of [CONF_SPF_advanced_settings chain_init] is executed
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_polar_transmit {{mess "on"}} {

  global mom_motion_event mom_motion_type mom_prev_pos mom_pos mom_machine_mode
  global polar_mode_status lib_flag

  if {$mom_machine_mode == "TURN"} {return}

  if {[CONF_CTRL_moves polar_transmit] == "ON"} {
    # [CONF_CTRL_moves polar_transmit] == "ON"        : only for milling operation.
    # [CONF_CTRL_moves polar_transmit] == "ON_FOR_ALL": for milling and drilling
    if {[string match "point*" [LIB_SPF_ask_operation_type]] || [string match "probe*" [LIB_SPF_ask_operation_type]]} {return}
  }

  if {[CONF_CTRL_moves polar_transmit] != "OFF"} {
    if {$mess == "on"} {
      if {$lib_flag(first_transmit_move) == 0} {
        set polar_mode_status "ON"
        set lib_flag(first_transmit_move) 1
      }
    } elseif {$mess == "start" && [info exists polar_mode_status] && $polar_mode_status == "ON"} {
      LIB_GE_command_buffer POLAR_MODE
      LIB_GE_command_buffer {
        set mom_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        set mom_prev_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        MOM_reload_variable -a mom_prev_pos
        MOM_reload_variable -a mom_pos

        if {[CONF_CTRL_moves prepos_before_transmit] == "5th" || [CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
          if {$lib_flag(polar_rotary_axis) == 0} {
            set lib_flag(save_clamp_fourth_axis_setting) [CONF_CTRL_clamp fourth_axis]
            if {[CONF_CTRL_clamp fourth_axis] == 1} {
              MOM_do_template unclamp_fourth_axis
              MOM_do_template fourth_axis_rotate_move
              CONF_CTRL_clamp set fourth_axis 0
            } else {
              MOM_do_template fourth_axis_rotate_move
            }
          } else {
            set lib_flag(save_clamp_fifth_axis_setting) [CONF_CTRL_clamp fifth_axis]
            if {[CONF_CTRL_clamp fifth_axis] == 1} {
              MOM_do_template unclamp_fifth_axis
              MOM_do_template fifth_axis_rotate_move
              CONF_CTRL_clamp set fifth_axis 0
            } else {
              MOM_do_template fifth_axis_rotate_move
            }
          }
          if {[CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
            LIB_SPF_decompose_block_template "{Z} {X}" prepos_transmit FORCE [join "{Z} {X}"]
          }
        } elseif {[CONF_CTRL_moves prepos_before_transmit] != ""} {
          LIB_CONF_do_prop_custom_proc CONF_CTRL_moves prepos_before_transmit "short_template_syntax"
        }
      }  @OUTPUT_ROTARY_AXIS

      LIB_GE_command_buffer {
        MOM_do_template polar_mode
      } @OUTPUT
      LIB_GE_command_buffer_output

      set lib_flag(first_transmit_move) 1
      if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_enable_address Y}
    }
  }

  if {$mess == "off" && [info exists lib_flag(first_transmit_move)] && $lib_flag(first_transmit_move) == 1} {
    set polar_mode_status "OFF"

    LIB_GE_command_buffer TRAFOFF
    LIB_GE_command_buffer {
      MOM_do_template trafoof
      if {$lib_flag(polar_rotary_axis) == 0} {
        if {[info exists lib_flag(save_clamp_fourth_axis_setting)]} {CONF_CTRL_clamp set fourth_axis $lib_flag(save_clamp_fourth_axis_setting)}
      } else {
        if {[info exists lib_flag(save_clamp_fifth_axis_setting)]} {CONF_CTRL_clamp set fifth_axis $lib_flag(save_clamp_fifth_axis_setting)}
      }
    } @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(first_transmit_move) 0
    if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_disable_address Y}
  }
}
# <Internal Documentation>
# It's used to output polar code with axial mode when [CONF_CTRL_moves polar_transmit] property is set to 1
# This proc is called by LIB_SPF_polar_cart
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread_LIB {} {

  set commandcheck(MOM_lathe_thread_LIB_ENTRY) [llength [info commands MOM_lathe_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_thread_LIB {} {

  set commandcheck(MOM_start_of_thread_LIB_ENTRY) [llength [info commands MOM_start_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_lathe_thread_move_LIB {} {

  global mom_prev_pos mom_pos
  global thread_type

  set commandcheck(MOM_lathe_thread_move_LIB_ENTRY) [llength [info commands MOM_lathe_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer MOM_lathe_thread_move_LIB
  LIB_GE_command_buffer {LIB_CTRL_lathe_thread_set} @DEFAULT_THREAD_MOVE_SETTINGS
  LIB_GE_command_buffer {MOM_do_template thread_move_turn} @DEFAULT_THREAD_MOVE_TURN
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_thread_LIB {} {

  set commandcheck(MOM_end_of_thread_LIB_ENTRY) [llength [info commands MOM_end_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_channel_init {} {

  LIB_GE_command_buffer LIB_CTRL_channel_init
  LIB_GE_command_buffer {MOM_do_template channel_init CREATE} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_program event
#
# Specially useful for multichannels machine to reset addresses at the beginning of for each channel
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sys_leader_home {} {
  #this proc is only here for documentation purposes.
  #the real proc should be created in service layer
}
# <Internal Documentation>
# This function is called from MOM_start_of_path event
#
# Helpful to redefine mom_sys_leader variables overwritten by the original ones with the normal run
# This procedure should be redefined in service layer
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_subop_path_LIB {} {

  set commandcheck(MOM_start_of_subop_path_LIB_ENTRY) [llength [info commands MOM_start_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_inter_opr_rule_intent lib_flag

  # <17013.16 Interop path> Exit tool path and enter transition path
  if {[info exists mom_inter_opr_rule_intent] && [string match $mom_inter_opr_rule_intent "INTEROP_END"]} {
    if {$lib_flag(mode_current_status) == "pos"} {
      LIB_ROTARY_positioning_reset
    } elseif {$lib_flag(mode_current_status) == "sim"} {
      LIB_ROTARY_simultaneous_reset
    }
    set lib_flag(tool_path_motion) 0
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_LIB_ENTRY)} {MOM_start_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_subop_path.
# It can exit tool path and enter transition path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_subop_path_LIB {} {

  set commandcheck(MOM_end_of_subop_path_LIB_ENTRY) [llength [info commands MOM_end_of_subop_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_LIB_ENTRY)} {MOM_end_of_subop_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_transition_path_LIB {} {

  set commandcheck(MOM_start_of_transition_path_LIB_ENTRY) [llength [info commands MOM_start_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag mom_path_name lib_pretreatment tcpm_type
  global mom_interop_has_tool_change mom_interop_has_tool_change_container
  global mom_interop_has_tool_change_position

  if {$lib_flag(mode_current_status) == "pos"} {
    if {[CONF_CTRL_setting plane_output_supported] == "NONE"} {
      LIB_ROTARY_absolute_reset
    } else {
      LIB_ROTARY_positioning_reset
    }
  } elseif {$lib_flag(mode_current_status) == "sim"} {
    if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
      LIB_ROTARY_absolute_reset
    } else {
      LIB_ROTARY_simultaneous_reset
    }
  }

    if {$mom_interop_has_tool_change ==0 && [lsearch -exact $lib_pretreatment(operation_list) $mom_path_name] == 0} {
          MOM_first_tool_LIB
    }
  set ::rtcp_output 0
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_transition_path_LIB {} {

  set commandcheck(MOM_end_of_transition_path_LIB_ENTRY) [llength [info commands MOM_end_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_end_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_transition_rapid_move_LIB {} {

  set commandcheck(MOM_transition_rapid_move_LIB_ENTRY) [llength [info commands MOM_transition_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_transition_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_LIB_ENTRY)} {MOM_transition_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_inter_opr_rule_intent
  global mom_move_axis_rtcp_mode
  global mom_move_output_x
  global mom_out_angle_pos

  # Set value of output axis
  set 4th [string tolower $::mom_kin_4th_axis_leader]
  set 5th [string tolower $::mom_kin_5th_axis_leader]
  set ::mom_transition_${4th}_axis $mom_out_angle_pos(0)
  set ::mom_transition_${5th}_axis $mom_out_angle_pos(1)

  if {$mom_move_axis_rtcp_mode == 1} {
    set ::mom_transition_x_axis $::mom_mcs_goto(0)
    set ::mom_transition_y_axis $::mom_mcs_goto(1)
    set ::mom_transition_z_axis $::mom_mcs_goto(2)
  } else {
    set ::mom_transition_x_axis $::mom_pos(0)
    set ::mom_transition_y_axis $::mom_pos(1)
    set ::mom_transition_z_axis $::mom_pos(2)
  }

  # Set output axis
  set output_status 0
  foreach axis {x y z a b c} {
    if {[set ::mom_move_output_$axis] == 0} {
      MOM_suppress Once [string toupper $axis]_AXIS
    } else {
      MOM_force Once [string toupper $axis]_AXIS
      set output_status 1
    }
  }

  # Output rapid motion
  if {$output_status == 1 } {
    LIB_GE_command_buffer TRANSITION_RAPID_MOVE
    LIB_GE_command_buffer {LIB_CTRL_output_rtcp_mode} @SET_RTCP
    LIB_GE_command_buffer {MOM_do_template transition_rapid_move} @TRANSITION_RAPID_MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_transition_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_LIB_ENTRY)} {MOM_transition_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_transition_rapid_move.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_output_rtcp_mode {} {

  if {$::lib_ge_transition_rtcp_mode == 1 && $::rtcp_output ==0} {
    MOM_do_template traori
    set ::rtcp_output 1
  }
}
# <Internal Documentation>
# This function is called from MOM_transition_rapid_move_LIB.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_machine_axis_move_LIB {} {

  set commandcheck(MOM_machine_axis_move_LIB_ENTRY) [llength [info commands MOM_machine_axis_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  foreach axis {x y z a b c} {
    if {[set ::mom_move_output_$axis] == 0} {
      MOM_suppress Once [string toupper $axis]_AXIS
    } else {
      MOM_force Once [string toupper $axis]_AXIS
    }
  }

  LIB_GE_command_buffer MACHINE_AXIS_MOVE
  LIB_GE_command_buffer {MOM_force Once G;MOM_do_template machine_axis_move} @MACHINE_AXIS_MOVE
  LIB_GE_command_buffer_output

  MOM_force Once G_offset


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_machine_axis_move.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_abs_move_table { } {
  global lib_parameter lib_flag mom_pos mom_prev_pos mom_sys_leader mom_sys_trailer mom_out_angle_pos

  set tmp_sys_leader_restore($lib_parameter(abs_move,axis)) $mom_sys_leader($lib_parameter(abs_move,axis))
  set tmp_sys_trailer_restore($lib_parameter(abs_move,axis)) $mom_sys_trailer($lib_parameter(abs_move,axis))

  LIB_GE_command_buffer AXIS_FOR_5TH_AXIS_MOVE
  LIB_GE_command_buffer {
    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "real"
    }

    set tmp_sys_leader_real($lib_parameter(abs_move,axis)) $mom_sys_leader($lib_parameter(abs_move,axis))
    set tmp_sys_trailer_real($lib_parameter(abs_move,axis)) $mom_sys_trailer($lib_parameter(abs_move,axis))
    VMOV 2 mom_out_angle_pos save_out_angle_pos

    if {$lib_flag(local_namespace_output) == 0} {
      LIB_SPF_convert_point "reload"
    }
    set mom_out_angle_pos($lib_parameter(abs_move,angle_pos)) $save_out_angle_pos($lib_parameter(abs_move,angle_pos))
    if {($lib_parameter(abs_move,axis) == "fourth_axis" && $::mom_sys_4th_axis_has_limits == 0) || ($lib_parameter(abs_move,axis) == "fifth_axis" && $::mom_sys_5th_axis_has_limits == 0)} {
      set mom_sys_leader($lib_parameter(abs_move,axis)) "[lindex [split "$tmp_sys_leader_real($lib_parameter(abs_move,axis))" "="] 0]=DC("
      set mom_sys_trailer($lib_parameter(abs_move,axis)) ")"
    } else {
      set mom_sys_leader($lib_parameter(abs_move,axis)) $tmp_sys_leader_real($lib_parameter(abs_move,axis))
    }
  } @CalcAngle

  LIB_GE_command_buffer {
    MOM_enable_address $lib_parameter(abs_move,axis)
    if {[EQ_is_equal $::mom_prev_pos(0) $mom_pos(0)]} {MOM_suppress once X}
    if {[EQ_is_equal $::mom_prev_pos(1) $mom_pos(1)]} {MOM_suppress once Y}
    if {[EQ_is_equal $::mom_prev_pos(2) $mom_pos(2)]} {MOM_suppress once Z}
    MOM_do_template rapid_move
    MOM_do_template rapid_move CREATE
    MOM_disable_address $lib_parameter(abs_move,axis)
  } @AbsMoveMCS

  LIB_GE_command_buffer_output

  set $mom_sys_leader($lib_parameter(abs_move,axis)) $tmp_sys_leader_restore($lib_parameter(abs_move,axis))
  set $mom_sys_trailer($lib_parameter(abs_move,axis)) $tmp_sys_trailer_restore($lib_parameter(abs_move,axis))

}
# <Internal Documentation>
#
#
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_start_of_program_blk_form {} {
  global mom_blk_point_1  mom_blk_point_2 lib_blk_point_1 lib_blk_point_2
  global lib_blank_cylinder_vector lib_blank_cylinder_center lib_blank_cylinder_height lib_blank_cylinder_diameter

  LIB_GE_command_buffer BLK_form

  LIB_GE_command_buffer {

    set zero 0; set one 1
    VEC3_init one zero zero V0; VEC3_init zero one zero V1; VEC3_init zero zero one V2
    if {[info exists lib_blank_cylinder_center(0)] && ([VEC3_is_parallel lib_blank_cylinder_vector V2]) \
       && ([VEC3_is_parallel lib_blank_cylinder_center lib_blank_cylinder_vector] || [VEC3_is_zero lib_blank_cylinder_center])} {
      MOM_output_literal "WORKPIECE(,,,\"CYLINDER\",0,[format %.2f [expr $lib_blank_cylinder_center(2) - $lib_blank_cylinder_height/2]],[format %.2f $lib_blank_cylinder_height],\
      [format %.2f $lib_blank_cylinder_diameter])"
    } else {
      MOM_output_literal "WORKPIECE(,,,\"BOX\",0,[format %.2f $lib_blk_point_1(2)],[format %.2f [expr $lib_blk_point_2(2) - $lib_blk_point_1(2)]],[format %.2f [expr $lib_blk_point_2(2) - $lib_blk_point_1(2)]],\
      [format %.2f $lib_blk_point_1(0)],[format %.2f $lib_blk_point_1(1)],\
      [format %.2f [expr $lib_blk_point_2(0) - $lib_blk_point_1(0)]],\
      [format %.2f [expr $lib_blk_point_2(1) - $lib_blk_point_1(1)]])"
    }
  } @BLK_form_output

  LIB_GE_command_buffer_output

}
# <Documentation>
# Output the BLK Form /WORKPIECE lines
#
#____________________________________________________________________________________________

#ctrl_sinumerik_one_base.tcl

proc MOM_high_speed_setting {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_high_speed_setting_ENTRY) [llength [info commands MOM_high_speed_setting_ENTRY]]

  LIB_GE_command_buffer MOM_high_speed_setting_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_high_speed_setting_ENTRY)} {MOM_high_speed_setting_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_high_speed_setting_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_high_speed_setting_ENTRY)} {MOM_high_speed_setting_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}

#machine_ootb_turn_sinumerik.tcl

proc initialize_turn { } {
uplevel #0 {
set machine_mode "TURN"
set mom_kin_machine_type "2_axis_lathe"
}

# oem_ootb_5ax_sinumerik.tcl

proc OOTB_parameter_definition_LIB_ENTRY {position} {
#-------------------------------------------------------------
# The proc is used to definition 5 axis and feedrate information "DEF REAL _CAMTOLERANCE,DEF REAL _X_HOME, _Y_HOME, _Z_HOME, _A_HOME _C_HOME,DEF REAL _F_CUTTING, _F_ENGAGE, _F_RETRACT"
  global mom_date
  global mom_part_name
  global mom_sys_leader
  global mom_kin_machine_type
    global mom_sys_home_pos lib_sys_home_param
    global lib_sav_kin_4th_axis_leader
    global lib_sav_kin_5th_axis_leader
  global mom_kin_4th_axis_leader mom_kin_5th_axis_leader

   switch -- $position {
      "start" {
         if {[CONF_CTRL_setting plane_output] == "CYCLE800" && ([LIB_SPF_get_pretreatment axis_mode] == "POSITIONING" || [LIB_SPF_get_pretreatment axis_mode] == "CONSTANT") } {
            if {[info exists lib_sav_kin_4th_axis_leader]} {
               set mom_sys_leader(fourth_axis) $lib_sav_kin_4th_axis_leader
            }
            if {[info exists lib_sav_kin_5th_axis_leader]} {
               set mom_sys_leader(fifth_axis) $lib_sav_kin_5th_axis_leader
            }
         }
      }
      "end" {
         set fourth_home ""
         set fifth_home ""
         if {[string compare "3_axis_mill" $mom_kin_machine_type]} {
    if {[info exists lib_sav_kin_4th_axis_leader]} {
      set mom_sys_leader(fourth_axis_home) "${lib_sav_kin_4th_axis_leader}="
    } else {
      set mom_sys_leader(fourth_axis_home) "${mom_kin_4th_axis_leader}="
    }
            set fourth_home ", $lib_sys_home_param(3)"
            if {[string match "5_axis*" $mom_kin_machine_type]} {
    if {[info exists lib_sav_kin_5th_axis_leader]} {
      set mom_sys_leader(fifth_axis_home) "${lib_sav_kin_5th_axis_leader}="
    } else {
      set mom_sys_leader(fifth_axis_home) "${mom_kin_5th_axis_leader}="
    }
               set fifth_home ", $lib_sys_home_param(4)"
            } else {
               MOM_disable_address fifth_axis_home
            }
         } else {
            MOM_disable_address fifth_axis_home fourth_axis_home
         }

         LIB_GE_command_buffer PARAMETER

         LIB_GE_command_buffer "MOM_output_literal \"DEF REAL $lib_sys_home_param(0), $lib_sys_home_param(1), $lib_sys_home_param(2)$fourth_home$fifth_home\"" @PARAMETERLINE1
         LIB_GE_command_buffer {LIB_GE_message " "} @NEWLINE1
         LIB_GE_command_buffer {MOM_output_literal "$lib_sys_home_param(0)=[LIB_SPF_eliminate_zero $mom_sys_home_pos(0) 6] $lib_sys_home_param(1)=[LIB_SPF_eliminate_zero $mom_sys_home_pos(1) 6] $lib_sys_home_param(2)=[LIB_SPF_eliminate_zero $mom_sys_home_pos(2) 6]"} @PARAMETERLINE3
         LIB_GE_command_buffer {
                                 if {[string match "5_axis*" $mom_kin_machine_type]} {
                                    MOM_output_literal "$lib_sys_home_param(3)=[LIB_SPF_eliminate_zero $mom_sys_home_pos(3) 6] $lib_sys_home_param(4)=[LIB_SPF_eliminate_zero $mom_sys_home_pos(4) 6]"
                                 } elseif {[string match "4_axis*" $mom_kin_machine_type]} {
                                    MOM_output_literal "$lib_sys_home_param(3)=[LIB_SPF_eliminate_zero $mom_sys_home_pos(3) 6]"
                                 }
                               } @PARAMETERLINE4
         LIB_GE_command_buffer {LIB_GE_message " "} @NEWLINE2
         LIB_GE_command_buffer_output
      }
   }

}
proc OOTB_reset_rotary_to_zero {} {
#-------------------------------------------------------------
   LIB_SPF_reset_motions_to_zero "rot"
}
proc OEM_OOTB_output_orireset {} {
#-------------------------------------------------------------
   #The proc is used to output ORIRESET.
   global mom_out_angle_pos mom_init_pos lib_sav_kin_machine_type
   global mom_current_motion

   if { [info exists mom_current_motion] && ([string match "initial_move" $mom_current_motion] || [string match "first_move" $mom_current_motion])} {
     if { [CONF_S840D_controller sinumerik_version] == "V7" && [CONF_CTRL_setting tcpm_output] == "vector" && \
      [string match "5_axis*" $lib_sav_kin_machine_type] && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {

      #save mom_out_angle_pos
      set current_out_angle_pos(0) $mom_out_angle_pos(0)
      set current_out_angle_pos(1) $mom_out_angle_pos(1)

      if { $lib_sav_kin_machine_type == "5_axis_dual_table"} {
       set a $mom_out_angle_pos(0)
       set mom_out_angle_pos(0) $mom_out_angle_pos(1)
       set mom_out_angle_pos(1) $a
      }
      LIB_SPF_call_macro ORIRESET

      #restore mom_out_angle_pos
      set mom_out_angle_pos(0) $current_out_angle_pos(0)
      set mom_out_angle_pos(1) $current_out_angle_pos(1)
     }
  }
}

# template_service_s828d.tcl

procpostcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "99999999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         "N"
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "1"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "1"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "10000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "0.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}

# template_service_s840d.tcl

procpostcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "99999999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         "N"
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "1"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "1"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "10000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "0.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}

# template_service_sinumerik_one.tcl

procpostcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "99999999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         "N"
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "1"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "1"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "10000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "0.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}

# ctrl_template_base.tcl

proc LIB_SPF_set_initial_globals_LIB {} {


  uplevel #0 {

    set mom_system_tolerance                      0.0000001
    set mom_sys_control_out                       "("
    set mom_sys_control_in                        ")"

    ########## SYSTEM VARIABLE DECLARATIONS ##############
    set mom_sys_rapid_code                        "0"
    set mom_sys_linear_code                       "1"
    set mom_sys_circle_code(CLW)                  "2"
    set mom_sys_circle_code(CCLW)                 "3"
    set mom_sys_delay_code(SECONDS)               "4"
    set mom_sys_delay_code(REVOLUTIONS)           "4"
    set mom_sys_cutcom_plane_code(XY)             "17"
    set mom_sys_cutcom_plane_code(ZX)             "18"
    set mom_sys_cutcom_plane_code(XZ)             "18"
    set mom_sys_cutcom_plane_code(YZ)             "19"
    set mom_sys_cutcom_plane_code(ZY)             "19"
    set mom_sys_lathe_thread_advance_type(1)      "33"
    set mom_sys_lathe_thread_advance_type(2)      "34"
    set mom_sys_lathe_thread_advance_type(3)      "35"
    set mom_sys_cutcom_code(OFF)                  "40"
    set mom_sys_cutcom_code(LEFT)                 "41"
    set mom_sys_cutcom_code(RIGHT)                "42"
    set mom_sys_adjust_code                       "43"
    set mom_sys_adjust_code_minus                 "44"
    set mom_sys_adjust_cancel_code                "49"
    set mom_sys_unit_code(IN)                     "20"
    set mom_sys_unit_code(MM)                     "21"
    set mom_sys_cycle_start_code                  "79"
    set mom_sys_cycle_off                         "80"
    set mom_sys_cycle_drill_code                  "81"
    set mom_sys_cycle_drill_dwell_code            "82"
    set mom_sys_cycle_drill_deep_code             "83"
    set mom_sys_cycle_drill_break_chip_code       "73"
    set mom_sys_cycle_tap_code                    "84"
    set mom_sys_cycle_bore_code                   "85"
    set mom_sys_cycle_bore_drag_code              "86"
    set mom_sys_cycle_bore_no_drag_code           "76"
    set mom_sys_cycle_bore_dwell_code             "89"
    set mom_sys_cycle_bore_manual_code            "88"
    set mom_sys_cycle_bore_back_code              "87"
    set mom_sys_cycle_bore_manual_dwell_code      "88"
    set mom_sys_output_code(ABSOLUTE)             "90"
    set mom_sys_output_code(INCREMENTAL)          "91"
    set mom_sys_cycle_ret_code(AUTO)              "98"
    set mom_sys_cycle_ret_code(MANUAL)            "99"
    set mom_sys_reset_code                        "92"
    set mom_sys_feed_rate_mode_code(FRN)          "93"
    set mom_sys_spindle_mode_code(SFM)            "96"
    set mom_sys_spindle_mode_code(RPM)            "97"
    set mom_sys_spindle_max_rpm_code              "92"
    set mom_sys_spindle_cancel_sfm_code           "97"
    set mom_sys_return_code                       "28"
    set mom_sys_feed_rate_mode_code(DPM)          "94"
    set mom_sys_feed_rate_mode_code(IPM)          "94"
    set mom_sys_feed_rate_mode_code(IPR)          "95"
    set mom_sys_feed_rate_mode_code(MMPM)         "94"
    set mom_sys_feed_rate_mode_code(MMPR)         "95"
    set mom_sys_polar_mode(ON)                    "112"
    set mom_sys_polar_mode(OFF)                   "113"
    set mom_sys_program_stop_code                 "0"
    set mom_sys_optional_stop_code                "1"
    set mom_sys_end_of_program_code               "2"
    set mom_sys_start_of_subprogram               "98"
    set mom_sys_end_of_subprogram                 "99"
    set mom_sys_spindle_direction_code(CLW)       "3"
    set mom_sys_spindle_direction_code(CCLW)      "4"
    set mom_sys_spindle_direction_code(OFF)       "5"
    set mom_sys_spindle_orient_code               "19"
    set mom_sys_tool_change_code                  "6"
    set mom_sys_coolant_code(ON)                  "8"
    set mom_sys_coolant_code(FLOOD)               "8"
    set mom_sys_coolant_code(MIST)                "7"
    set mom_sys_coolant_code(THRU)                "26"
    set mom_sys_coolant_code(TAP)                 "27"
    set mom_sys_coolant_code(AIR)                 "7"
    set mom_sys_coolant_code(AIRTHRU)             "26"
    set mom_sys_coolant_code(OFF)                 "9"
    set mom_sys_tap_rigid_code                    "29"
    set mom_sys_rewind_code                       "30"
    set mom_sys_unclamp_code_fourth               "10"
    set mom_sys_clamp_code_fourth                 "11"
    set mom_sys_unclamp_code_fifth                "50"
    set mom_sys_clamp_code_fifth                  "51"
    set mom_sys_4th_axis_has_limits               "1"
    set mom_sys_5th_axis_has_limits               "1"
    set mom_sys_sim_cycle_drill                   "0"
    set mom_sys_sim_cycle_drill_dwell             "0"
    set mom_sys_sim_cycle_drill_deep              "0"
    set mom_sys_sim_cycle_drill_break_chip        "0"
    set mom_sys_sim_cycle_tap                     "1"
    set mom_sys_sim_cycle_bore                    "0"
    set mom_sys_sim_cycle_bore_drag               "0"
    set mom_sys_sim_cycle_bore_nodrag             "0"
    set mom_sys_sim_cycle_bore_manual             "0"
    set mom_sys_sim_cycle_bore_dwell              "0"
    set mom_sys_sim_cycle_bore_manual_dwell       "0"
    set mom_sys_sim_cycle_bore_back               "0"
    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
      set mom_sys_helix_pitch_type                  "rise_revolution"
    set mom_sys_spindle_ranges                    "9"
    set mom_sys_rewind_stop_code                  "\#"
    set mom_sys_zero                              "0"
    set mom_sys_opskip_block_leader               "/"
    set mom_sys_seqnum_start                      "10"
    set mom_sys_seqnum_incr                       "10"
    set mom_sys_seqnum_freq                       "1"
    set mom_sys_seqnum_max                        "9999"
    set mom_sys_lathe_x_double                    "1"
    set mom_sys_lathe_i_double                    "1"
    set mom_sys_lathe_y_double                    "1"
    set mom_sys_lathe_j_double                    "1"
    set mom_sys_lathe_x_factor                    "1"
    set mom_sys_lathe_y_factor                    "1"
    set mom_sys_lathe_z_factor                    "1"
    set mom_sys_lathe_i_factor                    "1"
    set mom_sys_lathe_j_factor                    "1"
    set mom_sys_lathe_k_factor                    "1"
    set mom_sys_leader(N)                         "N"
    set mom_sys_leader(M)           "M"
    set mom_sys_leader(M_spindle)                 "M"
    set mom_sys_leader(G)           "G"
    set mom_sys_leader(X)                         "X"
    set mom_sys_leader(Y)                         "Y"
    set mom_sys_leader(Z)                         "Z"
    set mom_sys_leader(fourth_axis)               "A"
    set mom_sys_leader(fifth_axis)                "B"
      set mom_sys_leader(sixth_axis)                "C"
    set mom_sys_trailer(M)            ""
    set mom_sys_trailer(M_spindle)                ""
    set mom_sys_trailer(G)            ""
    set mom_sys_trailer(X)                        ""
    set mom_sys_trailer(Y)                        ""
    set mom_sys_trailer(Z)                        ""
    set mom_sys_trailer(fourth_axis)              ""
    set mom_sys_trailer(fifth_axis)               ""
    set mom_sys_trailer(sixth_axis)               ""
    if {[info exists pc_initial_library_release_of_post] && $pc_initial_library_release_of_post > 50306} {
      set mom_sys_contour_feed_mode(LINEAR)         "AUTO"
      set mom_sys_rapid_feed_mode(LINEAR)           "AUTO"
      set mom_sys_cycle_feed_mode                   "AUTO"
    } else {
      set mom_sys_contour_feed_mode(LINEAR)         "MMPM"
      set mom_sys_rapid_feed_mode(LINEAR)           "MMPM"
      set mom_sys_cycle_feed_mode                   "MMPM"
    }
    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
    set mom_sys_feed_param(FRN,format)            "Feed_INV"
    set mom_sys_vnc_rapid_dogleg                  "1"
    set mom_sys_prev_mach_head                    ""
    set mom_sys_curr_mach_head                    ""
    set mom_sys_output_cycle95                    "1"
    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
    set mom_sys_retract_distance                  "10"
    set mom_sys_linearization_method              "angle"
    set mom_sys_post_description                  "This is a 5-Axis Milling Machine With\n\Dual Rotary Heads."
    set mom_sys_ugpadvkins_used                   "0"
    set mom_sys_post_builder_version              "9.0.1"
    set mom_sys_linear_turbo_command              "FALSE"
    set mom_sys_rapid_turbo_command               "FALSE"
    set mom_sys_circular_turbo_command            "FALSE"
    # will be added to post core later
    set mom_sys_turbo_global_add_vars_list        "mom_feedrate_mode mom_feedrate mom_motion_type mom_current_motion mom_pos_arc_center mom_pos_arc_axis oper_mcs_matrix"
    set mom_sys_output_transition_path            "0"
    set mom_sys_post_output_subprogram_enabled    "1"

    ####### KINEMATIC VARIABLE DECLARATIONS ##############
    set mom_kin_4th_axis_ang_offset               "0.0"
    set mom_kin_4th_axis_center_offset(0)         "0.0"
    set mom_kin_4th_axis_center_offset(1)         "0.0"
    set mom_kin_4th_axis_center_offset(2)         "0.0"
    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_4th_axis_incr_switch              "OFF"
    set mom_kin_4th_axis_leader                   "A"
#   set mom_kin_4th_axis_limit_action             "Warning"
    set mom_kin_4th_axis_max_limit                "360"
    set mom_kin_4th_axis_min_incr                 "0.001"
    set mom_kin_4th_axis_min_limit                "0"
    set mom_kin_4th_axis_plane                    "YZ"
    set mom_kin_4th_axis_point(0)                 "0.0"
    set mom_kin_4th_axis_point(1)                 "0.0"
    set mom_kin_4th_axis_point(2)                 "0.0"
    set mom_kin_4th_axis_rotation                 "standard"
    set mom_kin_4th_axis_type                     "Head"
    set mom_kin_4th_axis_vector(0)                "1"
    set mom_kin_4th_axis_vector(1)                "0"
    set mom_kin_4th_axis_vector(2)                "0"
    set mom_kin_4th_axis_zero                     "0.0"
    set mom_kin_5th_axis_ang_offset               "0.0"
    set mom_kin_5th_axis_center_offset(0)         "0.0"
    set mom_kin_5th_axis_center_offset(1)         "0.0"
    set mom_kin_5th_axis_center_offset(2)         "0.0"
    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set mom_kin_5th_axis_incr_switch              "OFF"
    set mom_kin_5th_axis_leader                   "B"
#   set mom_kin_5th_axis_limit_action             "Warning"
    set mom_kin_5th_axis_max_limit                "360"
    set mom_kin_5th_axis_min_incr                 "0.001"
    set mom_kin_5th_axis_min_limit                "0"
    set mom_kin_5th_axis_plane                    "ZX"
    set mom_kin_5th_axis_point(0)                 "0.0"
    set mom_kin_5th_axis_point(1)                 "0.0"
    set mom_kin_5th_axis_point(2)                 "0.0"
    set mom_kin_5th_axis_rotation                 "standard"
    set mom_kin_5th_axis_type                     "Head"
    set mom_kin_5th_axis_vector(0)                "0"
    set mom_kin_5th_axis_vector(1)                "1"
    set mom_kin_5th_axis_vector(2)                "0"
    set mom_kin_5th_axis_zero                     "0.0"
    set mom_kin_arc_output_mode                   "FULL_CIRCLE"
    set mom_kin_arc_valid_plane                   "XYZ"
    set mom_kin_clamp_time                        "2.0"
    set mom_kin_cycle_plane_change_per_axis       "0"
    set mom_kin_cycle_plane_change_to_lower       "0"
    set mom_kin_dependent_head                    "NONE"
    set mom_kin_flush_time                        "2.0"
    set mom_kin_helical_arc_output_mode           "FULL_CIRCLE"
    set mom_kin_ind_to_dependent_head_x           "0"
    set mom_kin_ind_to_dependent_head_z           "0"
    set mom_kin_independent_head                  "NONE"
    set mom_kin_linearization_flag                "1"
    ###set mom_kin_linearization_tol                 "0.01"
    set mom_kin_machine_type                      "5_axis_dual_head"
    set mom_kin_machine_zero_offset(0)            "0.0"
    set mom_kin_machine_zero_offset(1)            "0.0"
    set mom_kin_machine_zero_offset(2)            "0.0"
    set mom_kin_max_dpm                           "1000000"
    set mom_kin_max_frn                           "1000"
    set mom_kin_min_dpm                           "0.0"
    set mom_kin_min_frn                           "0.01"
    set mom_kin_output_unit                       "MM"
    set mom_kin_pivot_gauge_offset                "0.0"
    set mom_kin_pivot_guage_offset                ""
    set mom_kin_post_data_unit                    "MM"
    set mom_kin_retract_distance                  "500"
    set mom_kin_rotary_axis_method                "PREVIOUS"
    set mom_kin_spindle_axis(0)                   "0.0"
    set mom_kin_spindle_axis(1)                   "0.0"
    set mom_kin_spindle_axis(2)                   "1.0"
    set mom_kin_tool_change_time                  "12.0"
    set mom_kin_x_axis_limit                      "1000"
    set mom_kin_y_axis_limit                      "1000"
    set mom_kin_z_axis_limit                      "1000"
          set mom_kin_head_spindle_axis_correction      "ON"
    set mom_kin_head_gauge_point_correction       "ON"
    set mom_kin_combine_rapid_arc_motion          "Yes"

  }
}

proc MOM_start_of_program_LIB {} {


  global lib_flag
  set commandcheck(MOM_start_of_program_LIB_ENTRY) [llength [info commands MOM_start_of_program_LIB_ENTRY]]
  set commandcheck(LIB_CTRL_dnc_header) [llength [info commands LIB_CTRL_dnc_header]]
  set commandcheck(LIB_CTRL_nc_header) [llength [info commands LIB_CTRL_nc_header]]
  set commandcheck(LIB_CTRL_sub_header) [llength [info commands LIB_CTRL_sub_header]]
  set commandcheck(LIB_CTRL_parameter_definition) [llength [info commands LIB_CTRL_parameter_definition]]


  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_CTRL_dnc_header
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_dnc_header)} {LIB_CTRL_dnc_header}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[string match "MOM_start_of_program" [info level -1]]} {
    LIB_GE_command_buffer LIB_CTRL_nc_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_nc_header)} {LIB_CTRL_nc_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Program"}} @EVENT_MESSAGE
    LIB_GE_command_buffer {LIB_SPF_program_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer LIB_CTRL_sub_header
    LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sub_header)} {LIB_CTRL_sub_header}} @DEFAULT_ENTRY
    LIB_GE_command_buffer {LIB_SPF_sub_header_comment} @HEADER_COMMENT
    LIB_GE_command_buffer_output
  }

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Program"}

  LIB_GE_command_buffer LIB_CTRL_parameter_definition
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_parameter_definition)} {LIB_CTRL_parameter_definition}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
  if {[LIB_PT_get_header_var mom_sequence_mode exists]} {
    if {[LIB_PT_get_header_var mom_sequence_mode] == "OFF"} {
      MOM_set_seq_off
    } else {
      if {[CONF_CTRL_setting sequence_number] == 1} {
        MOM_set_seq_on
      } else {
        MOM_set_seq_off
      }
    }
  }
  } else {
    if {[CONF_CTRL_setting sequence_number] == 1} {
      MOM_set_seq_on
    } else {
      MOM_set_seq_off
    }
  }

    set ::mom_sys_csys_rot_code(ON)     [CONF_TEMPLATE_3P2 plane_name]
    set ::mom_sys_csys_rot_code(OFF)    [CONF_TEMPLATE_3P2 cancel_plane_name]

  # <NX1201 cam16012> new prereatment local csys
  # set global var lib_flag(plane_output_pos_type), 0 for mom_pos and 1 for mom_mcs_goto.
  if {[CONF_CTRL_setting plane_output_supported] != "NONE"} {
    set lib_flag(plane_output_pos_type) 1
  }

  LIB_GE_command_buffer PROGRAMSTART

  LIB_GE_command_buffer {LIB_GE_catch_do_template start_of_program "" 1} @START_OF_PROGRAM

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_program_LIB_ENTRY)} {MOM_start_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_path_LIB {} {

  set commandcheck(MOM_start_of_path_LIB_ENTRY) [llength [info commands MOM_start_of_path_LIB_ENTRY]]

  LIB_calc_lib_cutcom_radius

  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_update_tool_change_template
  # reset address expression
  if {[llength [info commands "MOM_set_address_expression"]]&&[info exists ::save_address_expression]} {
    if {[info exists ::save_address_expression(linear_move,X)]&&\
        [catch {MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" $::save_address_expression(linear_move,X)}]} {
      LIB_SPF_add_warning "Failed to reset address expression of 'X' in BLOCK_TEMPLATE 'linear_move'"
    }

    if {[info exists ::save_address_expression(linear_move,F)] && [catch {
      MOM_set_address_expression [CONF_CTRL_moves linear_template]   "F" $::save_address_expression(linear_move,F)
      MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" $::save_address_expression(circular_move,F)
    }]} {
      LIB_SPF_add_warning "Failed to reset feed rate address expression , the feed rate address name should be 'F'"
    }
    unset ::save_address_expression
  }

  # Bug 1299 Address H is missing in operations with tool axis change but no toolchange
  if {[MOM_ask_address_value G_adjust] == $::mom_sys_adjust_cancel_code} {MOM_force once H}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_path_LIB_ENTRY)} {MOM_start_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_sync_LIB {} {


  set commandcheck(MOM_sync_LIB_ENTRY) [llength [info commands MOM_sync_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SYNC

  LIB_GE_command_buffer {MOM_do_template sync_call} @SYNC_CALL

  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_sync_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_LIB_ENTRY)} {MOM_sync_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_set_csys_LIB {} {


  global lib_flag lib_sav_kin_machine_type mom_kin_machine_type
  global mom_init_pos plane_init_pos

  set commandcheck(MOM_set_csys_LIB_ENTRY) [llength [info commands MOM_set_csys_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![info exist lib_flag(absolute_kin)] || $lib_flag(absolute_kin) == 0} {
    # do nothing
  } else {
    LIB_SPF_calc_4th5th_axis_points
  }

  if {[CONF_CTRL_setting limit_output_angle] == 1} {
    LIB_SPF_limit_output_angle
  }

  # <NX1201 cam16012> new prereatment local csys
  # In new local csys mode, translate mom_pos and mom_mcs_goto from local to G54 in global namespace,
  # and get rotation matrix and origin of local coordinate system relative to G54.
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_csys_rotation_revise_output
    }

    # Move it from MOM_set_csys_LIB_ENTRY(OEM).
    if {[CONF_CTRL_setting fix_on_machine] == 0 && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" \
    && [CONF_CTRL_setting tcpm_output_supported] != "NONE" && [CONF_CTRL_setting tcpm_output] == "angle" \
    && [info exists lib_sav_kin_machine_type] && [string match "*table*" $lib_sav_kin_machine_type] } {

      LIB_SPF_calc_4th5th_axis_points

    if {$lib_sav_kin_machine_type == "5_axis_head_table"} {
      global mom_kin_4th_axis_point
      global mom_kin_pivot_gauge_offset
      array set mom_kin_4th_axis_point "0 0 1 0 2 0"
      set mom_kin_pivot_gauge_offset 0
      MOM_reload_kinematics
    }
  }

  # PR9233975: mom_init_pos is set in event MOM_set_csys from core code if user defined csys exists
  # variable plane_init_pos is used in LIB_CTRL_set_3P2_rotate_dir in case mom_init_pos is changed by that function
  array set plane_init_pos "0 $mom_init_pos(0) 1 $mom_init_pos(1) 2 $mom_init_pos(2) 3 $mom_init_pos(3) 4 $mom_init_pos(4)"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_csys_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_csys_LIB_ENTRY)} {MOM_set_csys_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_calc_lib_cutcom_radius {} {


  global mom_cutter_data_output_indicator mom_cut_data_type mom_cutcom_type mom_tool_diameter
  global lib_cutcom_radius mom_kin_arc_output_mode mom_sys_cutcom_code

  if {![info exists mom_cutter_data_output_indicator]} {
    set mom_cutter_data_output_indicator 0
  }
  if {![info exists mom_cutcom_type]} {
    set mom_cutcom_type 0
  }
  if {[CONF_CTRL_tool cutcom_actual_radius] == 0} {
    # no cutcom output even it is defined
    if {$mom_cutter_data_output_indicator == 1} {
      LIB_GE_abort_message "Cutcom contact not allowed"
    } else {
      set lib_cutcom_radius 0.0
    }
  } elseif {$mom_cutcom_type > 0} {
    # cutcom defined
    if {$mom_cut_data_type == "contact contour data"} {
      set lib_cutcom_radius 0.0
    } elseif {$mom_cut_data_type == "centerline data"} {
        set lib_cutcom_radius [expr $mom_tool_diameter/2]
    } else {
      set lib_cutcom_radius 0.0
    }
    if {[CONF_CTRL_setting turbo_mode] == 2 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
      LIB_SPF_turbo_status "enable" "advanced"
    }
  } else {
    # no cutcom defined
    if {[info exists lib_cutcom_radius] && $lib_cutcom_radius > 0.0} {
      set lib_cutcom_radius 0.0
    } else {
      set lib_cutcom_radius 0.0
    }
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_tool_LIB {} {


  global lib_flag mom_operation_is_interop

  set commandcheck(MOM_first_tool_LIB_ENTRY) [llength [info commands MOM_first_tool_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set lib_flag(tool_path_motion) 0

  # <17013.16 Interop path> As transition path has a given tool change point, it is not necessary to goto default tool change position.
  if {![info exists mom_operation_is_interop] && [CONF_CTRL_moves return_before_first_tool_change_pos] != ""} {
    LIB_RETURN_move CONF_CTRL_moves return_before_first_tool_change_pos
  }

  set lib_flag(first_tool_change) 1
  MOM_tool_change
  set lib_flag(first_tool_change) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_tool_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_tool_LIB_ENTRY)} {MOM_first_tool_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tool_change_LIB {{mode ""}} {


  global mom_cutcom_type mom_feed_cut_value mom_tool_number mom_tool_name mom_spindle_speed mom_cut_data_type
  global lib_prev_cutcom_type lib_prev_feed_cut_value lib_prev_tool_number lib_prev_spindle_speed_value lib_prev_cut_data_type
  global lib_flag mom_next_tool_status lib_prev_tool_name

  set commandcheck(MOM_tool_change_LIB_ENTRY) [llength [info commands MOM_tool_change_LIB_ENTRY]]
  set commandcheck(LIB_LOAD_attachment) [llength [info commands LIB_LOAD_attachment]]

  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer LIB_LOAD_attachment
  LIB_GE_command_buffer {if {$commandcheck(LIB_LOAD_attachment)} {LIB_LOAD_attachment}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  LIB_CHECK_adjust_register
  LIB_CHECK_tool_number

  LIB_GE_command_buffer TOOL_CHANGE

  LIB_GE_command_buffer {

    if {$mode == "IGNORE"} {
      # Ignore Toolchange
      # Maybe it is still necessary to examine the modality
    } elseif {$mode == "MANUAL"} {
      LIB_GE_command_buffer TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_change_template "short_template_syntax"

      } @TOOL_CHANGE_MANUAL

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool manual_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_MANUAL

      LIB_GE_command_buffer_output
    } else {
      LIB_GE_command_buffer TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {

        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"

      } @TOOL_CHANGE_AUTO

      LIB_GE_command_buffer {
        if {[CONF_CTRL_tool tool_preselect] == 1} {
          if {$mom_next_tool_status == "FIRST"} {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_last_template "short_template_syntax"
          } else {
            LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_preselect_template "short_template_syntax"
          }
        }
      } @PRESELECT_AUTO

      LIB_GE_command_buffer_output
    }

  } @TOOL_CHANGE

  LIB_GE_command_buffer {MOM_do_template tool_change_init CREATE} @TOOL_CHANGE_INIT
  LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT
  LIB_GE_command_buffer {LIB_CTRL_set_feed_parameter} @SET_FEED_PARAM

  LIB_GE_command_buffer_output

  if {![info exists mom_cutcom_type]} {set mom_cutcom_type 0}
  set lib_prev_cutcom_type $mom_cutcom_type
  set lib_prev_cut_data_type $mom_cut_data_type
  set lib_prev_feed_cut_value $mom_feed_cut_value
  set lib_prev_spindle_speed_value $mom_spindle_speed
  set lib_prev_tool_number $mom_tool_number
  set lib_prev_tool_name $mom_tool_name

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_change_LIB_ENTRY)} {MOM_tool_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_from_move_LIB {} {


  global feed_mode mom_feed_rate mom_kin_rapid_feed_rate

  set commandcheck(MOM_from_move_LIB_ENTRY) [llength [info commands MOM_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_moves output_from_position] == 1 } {
    if {![string compare $feed_mode "IPM"] || ![string compare $feed_mode "MMPM"]} {
      if {[EQ_is_ge $mom_feed_rate $mom_kin_rapid_feed_rate]} {
        MOM_rapid_move_LIB
      } else {
        MOM_linear_move_LIB
      }
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_from_move_LIB_ENTRY)} {MOM_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_update_tool_change_template {} {


  global lib_prev_feed_cut_value mom_feed_cut_value mom_tool_name

  LIB_GE_command_buffer UPDATE_TOOL

  LIB_GE_command_buffer {
      LIB_CTRL_set_feed_parameter
      set lib_prev_feed_cut_value $mom_feed_cut_value
  } @SET_FEED_PARAM
  LIB_GE_command_buffer {
      LIB_CHECK_adjust_register
  } @SET_ADJUST_REGISTER

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_move_LIB {} {

  global mom_motion_event mom_operation_name mom_output_mcs_name
  global mom_motion_type

  set commandcheck(MOM_first_move_LIB_ENTRY) [llength [info commands MOM_first_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check move

  LIB_SPF_check_decompose_first_move

  if {[info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])] && $mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name -1])} {
    LIB_main_origin_call
  }

  LIB_CHECK_adjust_register

  if {$mom_motion_event == "cycle_plane_change"} {
    LIB_SPF_add_warning "It is recommended to define a motion before first cycle."
  }
  catch {MOM_$mom_motion_event}
  # Handle the case user specify feed for rapid
  if {$mom_motion_type == "RAPID"} {
    LIB_SPF_last_rapid_pos
  }
  LIB_SPF_calc_abs_move_parameter
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_move_LIB_ENTRY)} {MOM_first_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_initial_move_LIB {} {

  global lib_flag mom_programmed_feed_rate mom_motion_event
  global mom_motion_type

  set commandcheck(MOM_initial_move_LIB_ENTRY) [llength [info commands MOM_initial_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CHECK_adjust_register
  LIB_SPF_spindle_set

  # <NX1201 cam17013> new prereatment local csys
  if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_output] == "vector" ||\
  ([CONF_CTRL_setting tcpm_output] == "angle" && [CONF_CTRL_setting fix_on_machine] != 0))} {
    if {[CONF_CTRL_setting turbo_mode] == 3 && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" &&\
      [CONF_CTRL_setting tcpm_output_supported] != "NONE"} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }
  }

  LIB_CTRL_handle_cycle_check move

  if {[EQ_is_zero $mom_programmed_feed_rate]} {
    MOM_rapid_move
    set mom_motion_event "rapid_move"
  } else {
    MOM_linear_move
    set mom_motion_event "linear_move"
    # Handle the case user specify feed for rapid
    if {$mom_motion_type == "RAPID"} {
      LIB_SPF_last_rapid_pos
    }

  }
  LIB_SPF_calc_abs_move_parameter

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_initial_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_LIB_ENTRY)} {MOM_initial_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_handle_cycle_check {arg} {


  global mom_cycle_type mom_spindle_status mom_spindle_startup_status

  if {([info exists mom_cycle_type] && ([string match "Exp_Deep_Drill_Breakchip" $mom_cycle_type] || [string match "Exp_Deep_Drill" $mom_cycle_type])) ||\
  ([info exists mom_spindle_startup_status] && $mom_spindle_startup_status == "OFF")} {

    switch -- $arg {
      "move"    {
            if {$mom_spindle_status == "OFF"} {MOM_disable_address S M_spindle}
          }
      "spindle" {
            MOM_enable_address S M_spindle
          }
      default   {
            LIB_GE_abort_message "Call LIB_CTRL_handle_cycle_check without the right arguments" "Please check"
          }
    }

  }
}
# <Internal Documentation>
#
# This function controlls the spindle rotation.
# The spindle should never be activated with the first movement if a single-lip drill is used.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_config_turbo {} {


  if {$::lib_ge_pretreatment_runtime} {return}
  if {![info exists ::mom_sys_advanced_turbo_output] || $::mom_sys_advanced_turbo_output != "TRUE"} {
    return
  }

  if {[CONF_CTRL_moves always_center_for_circle] == 1} {
    MOM_disable_address R
    MOM_enable_address I J K
  } else {
    MOM_enable_address R
    #MOM_disable_address I J K
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {$::mom_kin_arc_output_mode == "FULL_CIRCLE" } {
    set ::mom_sys_circular_turbo_command "TRUE"
  }

  if {[CONF_CTRL_feed feed_linear] == 2} {
    # Before NX1899, set MOM_linear_move_turbo_LIB at turbo block to output parameterized feed value
    # From NX1899, use advanced callback function to do the same thing
    if {$::lib_ge_env(major_version) < 1899} {
      set ::mom_sys_linear_turbo_command "TRUE"
      set ::mom_sys_circular_turbo_command "TRUE"
    } else {
      # In advanced turbo mode, LIB_SPF_feedrate_set is called in callback function, so disable feedrate setting in core code
      if {[llength [info commands MOM_set_turbo_feedrate_set]]} {
        MOM_set_turbo_feedrate_set OFF
      }
    }
  }

  if {$::mom_sys_linear_turbo_command == "TRUE" && [llength [info commands "MOM_linear_move_turbo_LIB"]]} {
    MOM_set_turbo_blocks LINEAR [linsert [CONF_Turbo_Templates linear_template_turbo]  0 "MOM_linear_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks LINEAR [CONF_Turbo_Templates linear_template_turbo]
  }

  if {$::lib_flag(first_transmit_move) == 0} {
    if {$::mom_sys_rapid_turbo_command == "TRUE" && [llength [info commands "MOM_rapid_move_turbo_LIB"]]} {
      MOM_set_turbo_blocks RAPID [linsert [CONF_Turbo_Templates rapid_template_turbo]  0 "MOM_rapid_move_turbo_LIB"]
    } else {
      MOM_set_turbo_blocks RAPID [CONF_Turbo_Templates rapid_template_turbo]
    }
  } else {
    if {$::mom_sys_linear_turbo_command == "TRUE" && [llength [info commands "MOM_linear_move_turbo_LIB"]]} {
      MOM_set_turbo_blocks RAPID [linsert [CONF_Turbo_Templates linear_template_turbo]  0 "MOM_linear_move_turbo_LIB"]
    } else {
      MOM_set_turbo_blocks RAPID [CONF_Turbo_Templates linear_template_turbo]
    }
  }

  if {$::mom_sys_circular_turbo_command == "TRUE" && [llength [info commands "MOM_circular_move_turbo_LIB"]]} {
    MOM_set_turbo_blocks CIRCULAR [linsert [CONF_Turbo_Templates circular_template_turbo] 0 "MOM_circular_move_turbo_LIB"]
  } else {
    MOM_set_turbo_blocks CIRCULAR [CONF_Turbo_Templates circular_template_turbo]
  }

  # The address X[$mom_pos(0)*$x_factor] will slow down turbo mode, x_factor only used in turning
  if {[llength [info commands "MOM_set_address_expression"]]} {
    if {$::x_factor == 1} {
      catch {
    set ::save_address_expression(linear_move,X) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "X" "\$mom_pos(0)"]
      }
    }
  if {[CONF_CTRL_feed feed_linear] != 2} {
    if {[catch {
      set ::save_address_expression(linear_move,F) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "F" "\$mom_feedrate"]
      set ::save_address_expression(circular_move,F) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "F" "\$mom_feedrate"]
    }]} {
      LIB_SPF_add_warning "Please use 'F' as feed rate address name in linear and circular block template"
    }
  }
    #when feedrate in one operation change from mmpm to mmpr we must write mom_feedrate_mode in to the advanced and set feed the mode into the G_feed Address
    set ::save_address_expression(linear_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves linear_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]
    set ::save_address_expression(circular_move,G_feed) [MOM_set_address_expression [CONF_CTRL_moves circular_template] "G_feed" "\$mom_sys_feed_rate_mode_code(\$mom_feedrate_mode)"]
  }
}
# <Internal Documentation>
#
# This procedure is executed at MOM_initial_move MOM_first_move MOM_lock_axis.
# It is used to config turbo blocks in advanced turbo mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB {} {


  global mom_machine_mode mom_pos
  global lib_flag lib_param lib_last_rapid_pos
  global dpp_return_motion_start
  global mom_output_pos_type mom_namespace_name

  set commandcheck(MOM_rapid_move_LIB_ENTRY) [llength [info commands MOM_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        MOM_suppress always S
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves rapid_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        }
        MOM_suppress off S
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
          switch -- $lib_flag(mode_current_status) {
            "std" {
              LIB_ROTARY_positioning_first_move
            }
            "pos" {
              LIB_ROTARY_positioning_first_move_pos
            }
            "sim" {
              LIB_ROTARY_positioning_first_move_sim
            }
          }
        } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized RAPID_MOVE]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer RAPID_MOVE
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {
      if {[info exists dpp_return_motion_start] && $dpp_return_motion_start} {
        LIB_CTRL_output_return_motion_for_rough_turn_cycle
      }

    } @ROUGH_TURN_CYCLE
    LIB_GE_command_buffer {
      if {![info exists dpp_return_motion_start] || !$dpp_return_motion_start} {
        if {$lib_flag(first_transmit_move) == 0} {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        } else {
          LIB_CTRL_feed_output
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
      }
    } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer RAPID_MOVE_SINGLE
    LIB_GE_command_buffer {
      if {[info exists dpp_return_motion_start] && $dpp_return_motion_start} {
        LIB_CTRL_output_return_motion_for_rough_turn_cycle
  }

    } @ROUGH_TURN_CYCLE
    LIB_GE_command_buffer {
      if {![info exists dpp_return_motion_start] || !$dpp_return_motion_start} {
        if {$lib_flag(first_transmit_move) == 0} {
          MOM_do_template [CONF_CTRL_moves rapid_template]
        } else {
          LIB_CTRL_feed_output
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }
  LIB_SPF_last_rapid_pos

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_LIB_ENTRY)} {MOM_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_linear_move_turbo_LIB {} {


  set commandcheck(MOM_linear_move_turbo_LIB_ENTRY) [llength [info commands MOM_linear_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_turbo_LIB_ENTRY)} {MOM_linear_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_linear_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_turbo_LIB {} {


  set commandcheck(MOM_rapid_move_turbo_LIB_ENTRY) [llength [info commands MOM_rapid_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_polar_cart]]} {LIB_SPF_polar_cart}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rapid_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rapid_move_turbo_LIB_ENTRY)} {MOM_rapid_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_rapid_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_turbo_LIB {} {


  set commandcheck(MOM_circular_move_turbo_LIB_ENTRY) [llength [info commands MOM_circular_move_turbo_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 2} {
    set ::feed $::mom_feedrate
    LIB_CTRL_feed_output
  }

  if {[CONF_CTRL_moves always_center_for_circle] != 1} {
    global mom_arc_radius
    set mom_arc_radius [expr abs($mom_arc_radius)]

    MOM_suppress once I J K
    switch -- $::tool_axis {
      0 {MOM_force once Y Z}
      1 {MOM_force once X Z}
      2 {MOM_force once X Y}
    }

    # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
    if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

      global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
      global mom_namespace_name mom_output_pos_type
      if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
        if {$mom_namespace_name == "::"} {
          set namespace ::
        } else {
          set namespace ::LOCAL_CSYS::
        }
        if {$mom_output_pos_type == "mom_pos"} {
          VMOV 3 ${namespace}mom_prev_pos prev_pos
          VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
        } else {
          VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
          VMOV 3 ${namespace}mom_arc_center pos_arc_center
          VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
        }
        VMOV 3 ${namespace}$mom_output_pos_type save_pos
      } else {
        set namespace ::
        set mom_output_pos_type mom_pos
        VMOV 3 mom_prev_pos prev_pos
        VMOV 3 mom_pos_arc_center pos_arc_center
        VMOV 3 mom_pos_arc_axis pos_arc_axis
        VMOV 3 mom_pos save_pos
      }
      VEC3_sub prev_pos pos_arc_center tmp_vec
      VEC3_unitize tmp_vec tmp_vec1
      VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
      VEC3_scale mom_arc_radius tmp_vec tmp_vec1
      VEC3_add pos_arc_center tmp_vec1 tmp_vec
      VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

      MOM_do_template [CONF_Turbo_Templates circular_template_turbo]

      VMOV 3 save_pos  ${namespace}$mom_output_pos_type

      MOM_suppress once I J K
      switch -- $::tool_axis {
        0 {MOM_force once Y Z}
        1 {MOM_force once X Z}
        2 {MOM_force once X Y}
      }

      set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]
    }

    if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
      LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
    }

    if {[EQ_is_gt $::mom_arc_angle 180.0]} {
      set mom_arc_radius [expr -1.0*$mom_arc_radius]
    }

  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_turbo_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_turbo_LIB_ENTRY)} {MOM_circular_move_turbo_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command wil be executed in advanced turbo mode when mom_sys_circular_turbo_command is set
# to "TRUE"
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_rapid_move_LIB_MODIF_first_move_turn {} {


  return 0

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_TURNING_mode {{option default}} {


  global x_factor lib_flag

  switch -- $option {
    "start" {

      set x_factor [LIB_SPF_check_x_factor TURN]

      if {![info exist lib_flag(save_rapid_template)]} {set lib_flag(save_rapid_template) [CONF_CTRL_moves rapid_template]}
      CONF_CTRL_moves set rapid_template [CONF_CTRL_moves rapid_template_turn]

      if {![info exist lib_flag(save_linear_template)]} {set lib_flag(save_linear_template) [CONF_CTRL_moves linear_template]}
      CONF_CTRL_moves set linear_template [CONF_CTRL_moves linear_template_turn]

      if {![info exist lib_flag(save_circular_template)]} {set lib_flag(save_circular_template) [CONF_CTRL_moves circular_template]}
      CONF_CTRL_moves set circular_template [CONF_CTRL_moves circular_template_turn]
    }
    "end" {
      set x_factor [LIB_SPF_check_x_factor MILL]

      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        unset lib_flag(save_rapid_template)
      }

      if {[info exists lib_flag(save_linear_template)]} {
        CONF_CTRL_moves set linear_template $lib_flag(save_linear_template)
        unset lib_flag(save_linear_template)
      }

      if {[info exists lib_flag(save_circular_template)]} {
        CONF_CTRL_moves set circular_template $lib_flag(save_circular_template)
        unset lib_flag(save_circular_template)
      }
    }
  }
}
# <Internal Documentation>
# Controls the turning mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_start {{option default}} {


  global mom_machine_mode mom_spindle_mode mom_spindle_preset_rpm_toggle mom_spindle_preset_rpm
  global mom_spindle_maximum_rpm mom_spindle_speed mom_mcs_goto mom_spindle_status
  global PI mom_spindle_maximum_rpm_toggle lib_flag

  if {$mom_spindle_status == "OFF"} {return}

  set commandcheck(LIB_SPINDLE_start_ENTRY) [llength [info commands LIB_SPINDLE_start_ENTRY]]

  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY start_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SPINDLE
  switch -- $option {
    "preset" {
      # turning only
      LIB_GE_command_buffer {
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {[EQ_is_zero $mom_spindle_speed]} {
            LIB_GE_error_message "Spindle speed should not be = 0.0" "Please check"
          }
          if {$mom_spindle_preset_rpm_toggle == 0 || [EQ_is_zero $mom_spindle_preset_rpm]} {
            set rval [expr abs($mom_mcs_goto(0))]
            if {$rval < 0.1} {set rval 1}
            set mom_spindle_preset_rpm [expr $mom_spindle_speed * 1000 / $PI / $rval / 2]
          }
          MOM_do_template spindle_rpm_preset
        } else {
          MOM_do_template spindle_rpm_preset CREATE
        }
      } @PRESET
    }
    "cycle" {
      LIB_GE_command_buffer {
        switch -- $mom_machine_mode {
          "MILL" {
            if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
              MOM_do_template spindle_rpm CREATE
            } else {
              MOM_do_template spindle_rpm
            }
          }
          "TURN" {
            if {$mom_spindle_mode == "RPM"} {
              MOM_do_template spindle_rpm_turn
            } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
            if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
              set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
            }
              # PR9564861: Output block spindle_smm_turn only if spindle mode is SFM/SMM before cycle under turning
            MOM_do_template spindle_smm_turn
            }
          }
        }
      } @CYCLE
    }
    "limit" {
      LIB_GE_command_buffer {
        # turning only
        if {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
          if {([info exists mom_spindle_maximum_rpm_toggle] && $mom_spindle_maximum_rpm_toggle == 1) || [CONF_CTRL_spindle spindle_max_rpm_output_always]} {
            if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
              set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
            }
            MOM_do_template spindle_max_rpm
          }
        }
      } @LIMIT
    }
    "default" {
      switch -- $mom_machine_mode {
        "MILL" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm CREATE
            } else {
              # Always RPM output for milling
              if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
                MOM_do_template spindle_rpm CREATE
              } elseif {[CONF_CTRL_spindle spindle_output_alone] == 1 || [info level 1] == "MOM_spindle_rpm"} {
                MOM_do_template spindle_rpm
              }
            }
            set ::check_list(spindle,status) 1
          } @DEFAULTMILL
        }
        "TURN" {
          LIB_GE_command_buffer {
            if {$mom_spindle_mode == "NONE" || $lib_flag(ignore_spindle_rpm)} {
              MOM_do_template spindle_rpm_turn CREATE
            } elseif {$mom_spindle_mode == "RPM"} {
              if {[MOM_do_template spindle_rpm_turn CREATE] != ""} {
                MOM_force_block once spindle_rpm_turn
                MOM_do_template spindle_rpm_turn
              }

            } elseif {$mom_spindle_mode == "SFM" || $mom_spindle_mode == "SMM"} {
              if {[EQ_is_zero $mom_spindle_maximum_rpm] || [EQ_is_gt $mom_spindle_maximum_rpm [CONF_CTRL_spindle max]]} {
                set mom_spindle_maximum_rpm [CONF_CTRL_spindle max]
              }
              if {[CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {
                MOM_do_template spindle_max_rpm
              }

              if {[MOM_do_template spindle_smm_turn CREATE] != ""} {
                MOM_force_block once spindle_smm_turn
                if {[CONF_CTRL_spindle spindle_max_rpm_output_alone] == 1} {MOM_do_template spindle_max_rpm CREATE}
                MOM_do_template spindle_smm_turn
              }

            }
          } @DEFAULTTURN
        }
      }
    }
  }
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPINDLE_start_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPINDLE_start_ENTRY)} {LIB_SPINDLE_start_ENTRY end_${option}}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Controls the spindle start conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPINDLE_end {} {


  LIB_GE_command_buffer SPINDLE_END
  LIB_GE_command_buffer {
    if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
      MOM_do_template spindle_off CREATE
    } else {
      MOM_do_template spindle_off
    }
  } @SPINDLE_OFF_1
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the spindle end conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_spindle_orient {} {

  global mom_machine_mode

  LIB_GE_command_buffer SPINDLE_ORIENT

  LIB_GE_command_buffer {
    if {$mom_machine_mode == "MILL"} {MOM_do_template spindle_off}
  } @SPINDLE_OFF

  LIB_GE_command_buffer {
    MOM_force Once M_spindle
    MOM_do_template spindle_orient
  } @M19_S

  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# It used to output spindle orient code M19 S.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move {} {


  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {
      # first tool_path motion with same tool and configuration as previous operation
      if {$lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_xlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXLU
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_ylu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYLU
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_zlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZLU
            }
        }
      } else {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_xul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXUL
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_yul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYUL
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_std_zul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZUL
            }
        }
      }
      unset lib_flag(current_plane_upper_than_previous)
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_xi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDXI
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_yi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDYI
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_std_zi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSESTDZI
          }
      }
    }
    set lib_flag(current_safety_position) 0
  }
  LIB_GE_command_buffer {
    LIB_CTRL_clamp_axis
  } @CLAMP
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the standard case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_pos {} {


  global tool_axis lib_flag
  global mom_motion_event

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_POS

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_pos) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z H
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    if {[hiset lib_flag(current_plane_upper_than_previous)]} {
      # first tool_path motion with same tool and configuration as previous operation
      if {$lib_flag(current_plane_upper_than_previous) == 1 && $lib_flag(current_safety_position) == 0} {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_xlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXLU
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_ylu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYLU
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_zlu]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZLU
            }
        }
      } else {
        switch -- $tool_axis {
          0 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_xul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEXUL
            }

          1 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_yul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEYUL
            }

          2 {
            LIB_GE_command_buffer {
              set decompose [CONF_CTRL_moves decompose_first_move_pos_zul]
              LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
            } @DECOMPOSEZUL
            }
        }
        unset lib_flag(current_plane_upper_than_previous)
      }
    } else {
      switch -- $tool_axis {
        0 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_xi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSXI
          }

        1 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_yi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSYI
          }

        2 {
          LIB_GE_command_buffer {
            set decompose [CONF_CTRL_moves decompose_first_move_pos_zi]
            LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
          } @DECOMPOSEPOSZI
          }
      }
    }
    set lib_flag(current_safety_position) 0
  }
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_first_move_sim {} {


  global mom_motion_event
  global lib_flag

  LIB_GE_command_buffer ROTARY_POSITIONING_FIRST_MOVE_SIM

  LIB_GE_command_buffer {
    if {[CONF_CTRL_coolant coolnt_output_before_motion] == 1} {
      LIB_WRITE_coolant on
    }
  } @OUTPUT_COOLNT

  if {$lib_flag(decompose_first_move_sim) == 0} {
    LIB_GE_command_buffer {
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves $mom_motion_event]
    } @NODECOMPOSE
  } else {
    LIB_GE_command_buffer {
      set decompose [CONF_CTRL_moves decompose_first_move_sim_z]
      LIB_SPF_decompose_block_template $decompose [CONF_CTRL_moves $mom_motion_event] FORCE [join $decompose]
    } @DECOMPOSE
  }
  LIB_GE_command_buffer_output
  set lib_flag(current_safety_position) 0
}
# <Internal Documentation>
# Controls the output order of the addresses depending on the tool axis
# for the case at the positioning simultanous first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_check_cutcom_condition {} {


  global mom_kin_is_turbo_output mom_cutcom_adjust_register_defined mom_tool_cutcom_register mom_tool_number
  global mom_motion_event mom_path_name
  global mom_pos mom_prev_pos tool_axis
  global lib_flag

  if {([LIB_SPF_get_pretreatment mom_cutcom_status] == "LEFT" || [LIB_SPF_get_pretreatment mom_cutcom_status] == "RIGHT")\
     && $mom_kin_is_turbo_output == "TRUE" && $mom_cutcom_adjust_register_defined == 0} {
    if {$mom_tool_cutcom_register != $mom_tool_number} {
      LIB_SPF_add_warning "Tool cutcom register 'INS->$mom_tool_cutcom_register<-' is different to tool number 'INS->$mom_tool_number<-' and it's not output. With turbo mode activated, Switch it to ON in the operation"
    }
  }

  if {[info exists lib_flag(check_cutcom_start_move)] && $lib_flag(check_cutcom_start_move) == 1} {
    if {$mom_motion_event == "circular_move" && [CONF_CTRL_setting cutcom_on_with_circle_allowed] == 0} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- has to be a linear move"

    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_mag move] > 0 && [VEC3_is_parallel move tool_vector] == 1 && [CONF_CTRL_setting cutcom_on_with_tool_axis_allowed] == 0} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G41/G42<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_start_move) 2
  } elseif {[info exists lib_flag(check_cutcom_end_move)] && $lib_flag(check_cutcom_end_move)} {
    if {$mom_motion_event == "circular_move" && [CONF_CTRL_setting cutcom_on_with_circle_allowed] == 0} {
      LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- has to be a linear move"
    } else {

      VEC3_sub mom_pos mom_prev_pos move_neg
      VEC3_negate move_neg move

      array set tool_vector "0 0 1 0 2 0"

      set tool_vector($tool_axis) 1.0

      if {[VEC3_is_parallel move tool_vector] == 1 && [CONF_CTRL_setting cutcom_on_with_tool_axis_allowed] == 0} {
        LIB_GE_error_message "CUTCOM error in Operation 'INS->$mom_path_name<-'" "First move after INS->G40<- cannot be parallel to tool axis"
      }
    }
    set lib_flag(check_cutcom_end_move) 0
  }

}
# <Internal Documentation>
#
# This allows to check the first move after cutcom is switched on or off
# This is meant to do checks like first move has not to be a circular move
# The flags lib_flag(check_cutcom_start_move) and lib_flag(check_cutcom_end_move) are triggering this check
# those flags are set in MOM_cutcom_on and MOM_cutcom_off
#
# Proc has to be moved to controller level to implement controller specific checks
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_generic_cycle_LIB {} {


  set commandcheck(MOM_generic_cycle_LIB_ENTRY) [llength [info commands MOM_generic_cycle_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_generic_cycle_status
  global mom_sys_output_contour_motion
  global mom_from_status
  global mom_start_status
  global mom_motion_type
  global mom_operation_name
  global dpp_return_motion_list
  global dpp_return_motion_start
  global dpp_first_buffer_for_return_motion
  global mom_post_oper_path

  if {$mom_generic_cycle_status == 1} {

    # Initialize G71/G72 output at generic cycle start
    LIB_CTRL_init_rough_turn_cycle_output

    # Check whether a start point has been set
    if {([info exists mom_from_status] && $mom_from_status == 1) || \
      ([info exists mom_start_status] && $mom_start_status == 1) || \
      ([info exists mom_motion_type] && [string match "APPROACH" $mom_motion_type])} {

      ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      # When posting both rough and finish turning cycle operation (Scenario 2), contour data of finish operation will be used for rough.
      # So NX will use extended command MOM_post_oper_path to post the finish operation in the rough operation to get contour data
      # and mom_post_oper_path is set to 1 in subpost run by MOM_post_oper_path.
      #
      # Then NX will use NC codes between events MOM_generic_cycle as contour data.
      # Because MOM_contour_start and MOM_contour_end don't output in MOM_post_oper_path.
      #
      # In other scenarios, skip the events between MOM_generic_cycle
      # and use NC codes between events MOM_contour_start and MOM_contour_end as contour data.
      ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      if {[info exists mom_post_oper_path] && ($mom_post_oper_path == 1)} {

        # Set start mark of finish contour data in output file
        LIB_CTRL_finish_turn_cycle_contour_start

      } else {

        # Skip to next generic which should be cycle off
        MOM_skip_handler_to_event generic_cycle
      }

    } else {

      LIB_GE_abort_message "$mom_operation_name: None of from point, start point or approach path is defined before turning cycle in this operation."
    }
  }

  if {$mom_generic_cycle_status == 0} {

    if {[info exist mom_sys_output_contour_motion] && \
      ($mom_sys_output_contour_motion == 1 || $mom_sys_output_contour_motion == 2)} {

      if {[info exists mom_post_oper_path] && ($mom_post_oper_path == 1)} {

        # Set end mark of finish contour data in output file
        LIB_CTRL_finish_turn_cycle_contour_end
      }

      # Flag to indicate return motion begin
      set dpp_return_motion_start 1

      # Flag to indicate the first buffer for return motion
      set dpp_first_buffer_for_return_motion 1

      # Create a list to store the return motion NC codes
      set dpp_return_motion_list [list]
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is used to handle turn rough and finish cycle with generic cycle enhancement.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_init_rough_turn_cycle_output {} {


  global mom_machine_control_motion_output
  global mom_sys_output_cycle95
  global mom_sys_output_contour_motion
  global mom_template_subtype
  global dpp_record_rough_cycle_seq
  global mom_machine_cycle_subroutine_name
  global dpp_finish_feed
  global mom_feed_cut_value
  global dpp_turn_cycle_g_code
  global mom_operation_name

  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # "mom_sys_output_contour_motion" can be set [ 0 | 1 | 2 ].
  #  0: No contour output
  #  1: Part contour
  #  2: Tracking path contour
  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  # Initialize mom_sys_output_contour_motion to 0 as default.
  set mom_sys_output_contour_motion 0

  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # So far, machine cycle motion has been supported in following three scenarios.
  #
  # Scenario 1: single rough turning cycle operation.
  # Scenario 2: both rough and finish turning cycle operation.
  #             (The following two conditions should be fulfilled in this scenario.)
  #             Condition 1: contour data of rough and finish operations should be same.
  #                          This is checked by user when operations are created, not checked by post processor.
  #             Condition 2: subroutine name of rough operation should be same as the finish operation name.
  # Scenario 3: single finish turning cycle operation.
  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  # When "Machine Cycle" is selected as Motion Output in Machine control and
  # post processor is equipped with the ability to output rough turning cycle, then:
  if {([info exists mom_machine_control_motion_output] && $mom_machine_control_motion_output == 2) && \
    ([info exists mom_sys_output_cycle95] && $mom_sys_output_cycle95)} {

    # Check scenario 1
    if {[string match "FACING" $mom_template_subtype] || [string match "*ROUGH*" $mom_template_subtype]} {

      LIB_CTRL_set_contour_motion

    # Check scenario 2 or 3
    } elseif {[string match "*FINISH*" $mom_template_subtype]} {

      # Scenario 2
      if {[info exists dpp_record_rough_cycle_seq(begin,$mom_operation_name)]} {

        # Output G70 command
        set dpp_finish_feed $mom_feed_cut_value
        set dpp_turn_cycle_g_code 70

        LIB_GE_command_buffer TURN_CYCLE_FINISHING_IN_INITIAL
        LIB_GE_command_buffer {MOM_do_template turn_cycle_finishing} @TURN_CYCLE_FINISHING_IN_INITIAL
        LIB_GE_command_buffer_output

        MOM_force once G_motion X Z

      # Scenario 3
      } else {

        LIB_CTRL_set_contour_motion
      }

    # Other scenarios
    } else {

      LIB_GE_abort_message "$mom_operation_name: The machine cycle motion has not been supported in current operation type so far."
    }

    # Don't output cutcom until rough turning cycle called
    MOM_disable_address G_cutcom
  }

}
# <Internal Documentation>
# This command is used to prepare to generate contour data and customize sequence number output mode.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_set_contour_motion {} {


  global mom_cutcom_status
  global dpp_save_cutcom_status
  global mom_sys_output_contour_motion

  if {$mom_cutcom_status=="LEFT" || $mom_cutcom_status=="RIGHT"} {

    # If user adds cutcom UDE, save the status and notify NX/Post to process part contour data.
    set dpp_save_cutcom_status $mom_cutcom_status
    set mom_sys_output_contour_motion 1

  } else {

    # If user does not add cutcom UDE, notify NX/Post to process tracking path data.
    set mom_sys_output_contour_motion 2
  }

}
# <Internal Documentation>
# This command is to set contour motion as part contour data (value 1) or tracking path data (value 2)
# depending on whether cutter compensation UDE has been set or not.
#
# This command is used in LIB_CTRL_init_rough_turn_cycle_output.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_finish_turn_cycle_contour_start {} {


  global mom_template_subtype

  if {[string match "*FINISH*" $mom_template_subtype]} {

    # Set the start mark of finish contour data
    MOM_set_seq_off

    LIB_GE_command_buffer TURN_CYCLE_CONTOUR_START_TAG
    LIB_GE_command_buffer {MOM_output_literal "(CONTOUR TURN START)"} @TURN_CYCLE_CONTOUR_START_TAG
    LIB_GE_command_buffer_output

    MOM_force once G_motion X Z
  }

}
# <Internal Documentation>
# This command is to set start mark of finish contour data in output file in subpost run by MOM_post_oper_path.
#
# This command is used in proc MOM_generic_cycle when mom_generic_cycle_status is 1.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_finish_turn_cycle_contour_end {} {


  global mom_template_subtype

  if {[string match "*FINISH*" $mom_template_subtype]} {

    # Set the end mark of finish contour data
    LIB_GE_command_buffer TURN_CYCLE_CONTOUR_END_TAG
    LIB_GE_command_buffer {MOM_output_literal "(CONTOUR TURN END)"} @TURN_CYCLE_CONTOUR_END_TAG
    LIB_GE_command_buffer_output

    MOM_set_seq_on
  }

}
# <Internal Documentation>
# This command is to set end mark of finish contour data in output file in subpost run by MOM_post_oper_path.
#
# This command is used in proc MOM_generic_cycle when mom_generic_cycle_status is 0.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_linear_move_LIB {} {


  global lib_flag lib_param
  global mom_machine_mode

  set commandcheck(MOM_linear_move_LIB_ENTRY) [llength [info commands MOM_linear_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(tool_path_motion) == 1} {
    if {$::mom_machine_mode == "TURN"} {

      LIB_GE_command_buffer FIRST_MOVE_TURN

      LIB_GE_command_buffer {LIB_TURNING_mode start} @START_TURN_MODE
      LIB_GE_command_buffer {LIB_SPINDLE_start preset} @PRESET_SPINDLE_SPEED
      LIB_GE_command_buffer {
        MOM_suppress always S
        if {$lib_flag(decompose_first_move_turn) == 1} {
          LIB_SPF_decompose_block_template [CONF_CTRL_moves decompose_first_move_turn_order] [CONF_CTRL_moves linear_template] FORCE "X Y Z"
        } else {
          MOM_do_template [CONF_CTRL_moves linear_template]
        }
        MOM_suppress off S
      } @MOVE
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @SPINDLE_LIMIT
      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer_output

    } else {
      LIB_GE_command_buffer FIRST_MOVE_MILL

      LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
      LIB_GE_command_buffer {
          switch -- $lib_flag(mode_current_status) {
            "std" {
              LIB_ROTARY_positioning_first_move
            }
            "pos" {
              LIB_ROTARY_positioning_first_move_pos
            }
            "sim" {
              LIB_ROTARY_positioning_first_move_sim
            }
          }
        } @MOVE
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer COOLANT_ON
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 2
  } elseif {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
    if {$mom_machine_mode == "TURN"} {
      LIB_GE_command_buffer TURN
      LIB_GE_command_buffer {LIB_SPINDLE_start limit} @OUTPUT
      LIB_GE_command_buffer_output
    }

    LIB_GE_command_buffer OUTPUT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @SPINDLE_START
    LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } else {

        MOM_do_template [CONF_CTRL_moves linear_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } else {

        MOM_do_template [CONF_CTRL_moves linear_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_linear_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_linear_move_LIB_ENTRY)} {MOM_linear_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_circular_move_LIB {} {

  global lib_param

  set commandcheck(MOM_circular_move_LIB_ENTRY) [llength [info commands MOM_circular_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_param(cutting_tool_axis) != "" || [LIB_GE_commandbuffer_is_customized OUTPUT]} {
  LIB_GE_command_buffer OUTPUT
  LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
  LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
  LIB_GE_command_buffer {
    if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

      LIB_CTRL_output_contour_for_rough_turn_cycle

    } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

      LIB_CTRL_output_return_motion_for_rough_turn_cycle

    } else {

      MOM_do_template [CONF_CTRL_moves circular_template]
    }
  } @MOVE
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer OUTPUT_SINGLE
    LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
    LIB_GE_command_buffer {
      if {[info exists ::dpp_rough_turn_cycle_start] && $::dpp_rough_turn_cycle_start} {

        LIB_CTRL_output_contour_for_rough_turn_cycle

      } elseif {[info exists ::dpp_return_motion_start] && $::dpp_return_motion_start} {

        LIB_CTRL_output_return_motion_for_rough_turn_cycle

      } else {

        MOM_do_template [CONF_CTRL_moves circular_template]
      }
    } @MOVE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_LIB_ENTRY)} {MOM_circular_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_output_contour_for_rough_turn_cycle {} {


  global dpp_contour_list
  global mom_motion_event

  set o_buffer [MOM_do_template ${mom_motion_event}_rough_turn_cycle CREATE]
  lappend dpp_contour_list $o_buffer

}
# <Internal Documentation>
# This command is used to output the contour data for rough turn cycle.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_return_motion_for_rough_turn_cycle {} {


  global dpp_return_motion_list
  global mom_motion_event
  global dpp_motion_event

  LIB_CTRL_check_first_buffer_for_return_motion

  set dpp_motion_event [string range $mom_motion_event 0 [expr [string length $mom_motion_event]-6]]

  set o_buffer [MOM_do_template [CONF_CTRL_moves ${dpp_motion_event}_template] CREATE]
  lappend dpp_return_motion_list $o_buffer

}
# <Internal Documentation>
# This command is used to output the return motion for rough turn cycle.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_check_first_buffer_for_return_motion {} {


  global dpp_first_buffer_for_return_motion

  if {[info exists dpp_first_buffer_for_return_motion] && $dpp_first_buffer_for_return_motion == 1} {

    MOM_force once G_motion X Z
    set dpp_first_buffer_for_return_motion 0
  }

}
# <Internal Documentation>
# This command is used to check whether it is the first time to buffer MOM_do_template for return motion.
# if so, then force output G_motion, X and Z.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_helix_move_LIB {} {


  global mom_helix_turn_number
  global tool_axis

  set commandcheck(MOM_helix_move_LIB_ENTRY) [llength [info commands MOM_helix_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer OUTPUT
  LIB_GE_command_buffer {LIB_WRITE_coolant on} @COOLANT_ON
  LIB_GE_command_buffer {LIB_CIRCLE_set} @CIRCLE_SET
  LIB_GE_command_buffer {LIB_HELIX_nturn $tool_axis} @HELIX_NTURN
  LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves circular_template]} @MOVE
  LIB_GE_command_buffer_output

  unset mom_helix_turn_number

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_helix_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_LIB_ENTRY)} {MOM_helix_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_HELIX_nturn {axis} {


  global mom_prev_pos mom_pos mom_helix_pitch mom_arc_angle
  global mom_helix_turn_number mom_kin_machine_resolution

  set delta [expr abs($mom_pos($axis) - $mom_prev_pos($axis))]

  if {![EQ_is_equal $mom_helix_pitch 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number [expr floor([LIB_SPF_round [expr $delta / [expr abs($mom_helix_pitch)]] $mom_kin_machine_resolution])]
  } elseif {![EQ_is_equal $delta 0 $mom_kin_machine_resolution]} {
    set mom_helix_turn_number 1
  } else {
    set mom_helix_turn_number 0
  }

  if {[EQ_is_le $mom_arc_angle 360.0 $mom_kin_machine_resolution]} {
    MOM_suppress once helix_turn
  }
}
# <Internal Documentation>
# Calculate number of turns
# Linked to helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_on_ENTRY {option} {


  global mom_cutcom_adjust_register mom_tool_cutcom_register mom_tool_number
  global cutcom_adjust_register

  switch -- $option {
    "start" {
      if {[CONF_CTRL_setting cutcom_output] == 1} {
        if {$mom_tool_cutcom_register == 0} {
          set cutcom_adjust_register $mom_tool_number
        } else {
          set cutcom_adjust_register $mom_tool_cutcom_register
        }
      } else {
        set cutcom_adjust_register 0
      }
      if {[hiset mom_cutcom_adjust_register]} {set cutcom_adjust_register $mom_cutcom_adjust_register}
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning and at the end of MOM_cutcom_on procedure
# depending of the argument: start or end
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_off_ENTRY {option} {


  global cutcom_adjust_register

  switch -- $option {
    "end" {
      if {[hiset cutcom_adjust_register]} {unset cutcom_adjust_register}
    }
  }
}
# <Internal Documentation>
# This procedure is executed at the beginning and at the end of MOM_cutcom_off procedure
# depending of the argument: start or end
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_opstop_LIB {mess} {

  global mom_opstop_text mom_opstop_text_defined

  set commandcheck(MOM_opstop_LIB_ENTRY) [llength [info commands MOM_opstop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_opstop_text_defined] && $mom_opstop_text_defined == 1} {
      LIB_GE_command_buffer MOM_opstop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "along_with_stop"} {
          MOM_do_template opstop BUFFER
        } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_opstop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
          MOM_do_template opstop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_opstop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_opstop_LIB
      LIB_GE_command_buffer {
        MOM_do_template opstop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_opstop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "along_with_opstop"} {
        MOM_do_template opstop BUFFER
      } elseif {[CONF_SPF_msg opstop_comment_pos] == "after_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg opstop_comment_pos] == "before_opstop"} {
        MOM_do_template opstop
      }
    } @OUTPUT_AFTER_MSG
  }

  LIB_GE_command_buffer MOM_opstop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_opstop_text]} {unset mom_opstop_text}
  if {[hiset mom_opstop_text_defined]} {unset mom_opstop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opstop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_LIB_ENTRY)} {MOM_opstop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_stop_LIB {mess} {

  global mom_stop_text mom_stop_text_defined

  set commandcheck(MOM_stop_LIB_ENTRY) [llength [info commands MOM_stop_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mess == ""} {
    if {[hiset mom_stop_text_defined] && $mom_stop_text_defined == 1} {
      LIB_GE_command_buffer MOM_stop_LIB_text
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
          MOM_do_template stop BUFFER
        } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_BEFORE_MSG
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_stop_text" "output_2"
      } @MESSAGE
      LIB_GE_command_buffer {
        if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
          MOM_do_template stop
        }
      } @OUTPUT_AFTER_MSG
      LIB_GE_command_buffer_output
      set mom_stop_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_stop_LIB
      LIB_GE_command_buffer {
        MOM_do_template stop
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_stop_LIB_message
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "along_with_stop"} {
        MOM_do_template stop BUFFER
      } elseif {[CONF_SPF_msg stop_comment_pos] == "after_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_BEFORE_MSG
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_2"
    } @MESSAGE
    LIB_GE_command_buffer {
      if {[CONF_SPF_msg stop_comment_pos] == "before_stop"} {
        MOM_do_template stop
      }
    } @OUTPUT_AFTER_MSG
  }
  LIB_GE_command_buffer MOM_stop_LIB_INIT
  LIB_GE_command_buffer {
    MOM_do_template stop_init CREATE
  } @OUTPUT
  LIB_GE_command_buffer_output

  if {[hiset mom_stop_text]} {unset mom_stop_text}
  if {[hiset mom_stop_text_defined]} {unset mom_stop_text_defined}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_stop_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_LIB_ENTRY)} {MOM_stop_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_nurbs_move_LIB {} {


  set commandcheck(MOM_nurbs_move_LIB_ENTRY) [llength [info commands MOM_nurbs_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_nurbs_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_LIB_ENTRY)} {MOM_nurbs_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_start_LIB {} {


  set commandcheck(MOM_contour_start_LIB_ENTRY) [llength [info commands MOM_contour_start_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_turn_cycle_contour_start

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_contour_end_LIB {} {


  set commandcheck(MOM_contour_end_LIB_ENTRY) [llength [info commands MOM_contour_end_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_turn_cycle_contour_end

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_turn_cycle_contour_start {} {


  global dpp_turn_cycle_g_code
  global dpp_rough_turn_cycle_start
  global dpp_contour_list
  global dpp_return_motion_start

  # Flag to indicate return motion end
  set dpp_return_motion_start 0

  # Flag to indicate rough turning cycle contour begin
  set dpp_rough_turn_cycle_start 1

  # Set default G motion type for rough turning cycle
  set dpp_turn_cycle_g_code 71

  # Set rough turning cycle type according to the step angle
  LIB_CTRL_set_turning_cycle_type

  # Calculate the parameters for turning cycle block
  LIB_CTRL_calculate_parameters_for_turning_cycle_block

  # Create a list to store the contour NC codes, start tag and end tag
  set dpp_contour_list [list]

  # Store the start tag
  set o_buffer [MOM_do_template turn_cycle_start_tag CREATE]

  lappend dpp_contour_list $o_buffer

}
# <Internal Documentation>
# This command is used to detect the rough turning cycle type, calculate the cycle parameters
# and create a list to store the contour datas and start tag and end tag.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_set_turning_cycle_type {} {


  global mom_level_step_angle
  global dpp_turn_cycle_g_code
  global dpp_turn_cycle_retract
  global mom_clearance_from_faces
  global mom_clearance_from_diameters
  global dpp_turn_cycle_msg
  global mom_operation_name

  # Set rough turning cycle type according to the step angle
  if {[info exists mom_level_step_angle]} {

    if {[EQ_is_equal $mom_level_step_angle 270] || [EQ_is_equal $mom_level_step_angle 90]} {

      set dpp_turn_cycle_g_code 72
      set dpp_turn_cycle_retract $mom_clearance_from_faces
      set dpp_turn_cycle_msg "ROUGH FACE CYCLE"

    } elseif {[EQ_is_equal $mom_level_step_angle 180] || [EQ_is_equal $mom_level_step_angle 0]} {

      set dpp_turn_cycle_g_code 71
      set dpp_turn_cycle_retract $mom_clearance_from_diameters
      set dpp_turn_cycle_msg "ROUGH TURN CYCLE"

    } else {

      LIB_GE_abort_message "$mom_operation_name: Turning cycle type could not be set by variable mom_level_step_angle now."
    }
  }

}
# <Internal Documentation>
# This command is used to set turning cycle type according to the step angle.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_start.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_calculate_parameters_for_turning_cycle_block {} {


  global dpp_turn_cycle_cut_feed dpp_turn_cycle_cut_speed
  global mom_feed_cut_value mom_spindle_speed
  global dpp_turn_cycle_stock_x dpp_turn_cycle_stock_z
  global mom_stock_part mom_face_stock mom_radial_stock
  global dpp_save_cutcom_status
  global mom_level_step_angle
  global mom_cutcom_status

  # Set value for F and S.
  set dpp_turn_cycle_cut_feed $mom_feed_cut_value
  set dpp_turn_cycle_cut_speed $mom_spindle_speed

  # Calculate stocks for U and W.
  set dpp_turn_cycle_stock_x [expr [LIB_SPF_check_x_factor TURN] * ($mom_stock_part + $mom_radial_stock)]
  set dpp_turn_cycle_stock_z [expr $mom_stock_part + $mom_face_stock]

  # Adjust the sign of U and W and output tool nose radius compensation code.
  if {[info exists dpp_save_cutcom_status]} {

    if { $dpp_save_cutcom_status == "RIGHT"} {

      if {[EQ_is_equal $mom_level_step_angle 0]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]
        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]

      } elseif {[EQ_is_equal $mom_level_step_angle 90]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]

      } elseif {[EQ_is_equal $mom_level_step_angle 270]} {

        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]
      }

      set mom_cutcom_status $dpp_save_cutcom_status
      MOM_enable_address G_cutcom
      MOM_force once G_cutcom D

      LIB_GE_command_buffer TURN_CYCLE_CUTCOM_ON_RIGHT
      LIB_GE_command_buffer {MOM_do_template cutcom_on} @TURN_CYCLE_CUTCOM_ON_RIGHT
      LIB_GE_command_buffer_output
    }

    if {$dpp_save_cutcom_status == "LEFT"} {

      if {[EQ_is_equal $mom_level_step_angle 0]} {

        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]

      } elseif {[EQ_is_equal $mom_level_step_angle 90]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]
        set dpp_turn_cycle_stock_z [expr -$dpp_turn_cycle_stock_z]

      } elseif {[EQ_is_equal $mom_level_step_angle 180]} {

        set dpp_turn_cycle_stock_x [expr -$dpp_turn_cycle_stock_x]
      }

      set mom_cutcom_status $dpp_save_cutcom_status
      MOM_enable_address G_cutcom
      MOM_force once G_cutcom D

      LIB_GE_command_buffer TURN_CYCLE_CUTCOM_ON_LEFT
      LIB_GE_command_buffer {MOM_do_template cutcom_on} @TURN_CYCLE_CUTCOM_ON_LEFT
      LIB_GE_command_buffer_output
    }
  }

}
# <Internal Documentation>
# This command is used to calculate the parameters for rough turning cycle block.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_start.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_turn_cycle_contour_end {} {


  global dpp_rough_turn_cycle_start
  global dpp_contour_list
  global dpp_contour_list_length
  global mom_sys_output_contour_motion
  global mom_cutcom_status
  global mom_template_subtype
  global mom_profiling
  global mom_operation_name_list
  global mom_machine_cycle_subroutine_name

  # Flag to indicate rough turning cycle contour end
  set dpp_rough_turn_cycle_start 0

  # Store the end tag in the list
  set o_buffer [MOM_do_template turn_cycle_end_tag CREATE]
  lappend dpp_contour_list $o_buffer

  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  # When cutter compensation UDE isn't set, rough operation's contour data will be overridden
  # with associated finish operation by using extended command MOM_post_oper_path.
  # So far, NX will only override the contour data for roughing OD & ID,
  # because FACING does not have associated finishing operation.
  ##++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  # Override rough contour data with finish operation
  if {[string match "*ROUGH*" $mom_template_subtype] && \
    ($mom_sys_output_contour_motion == 2)} {

    if {[lsearch $mom_operation_name_list $mom_machine_cycle_subroutine_name] >= 0} {

      LIB_CTRL_override_rough_contour_data_with_finish
    }
  }

  # Get the length of the list
  set dpp_contour_list_length [llength $dpp_contour_list]

  # Calculate start and end line number of contour
  LIB_CTRL_calculate_contour_line_number

  # Output G70 G71 or G72 command depending on operation type
  LIB_CTRL_output_turning_cycle_command

  # Output the contour NC codes
  if {[CONF_CTRL_turn sequence_number_output_mode] == 0} {

    for {set i 0} {$i<$dpp_contour_list_length} {incr i} {
      if {$i==0 || $i==$dpp_contour_list_length-1} {
        MOM_set_seq_on
      }
      set line [lindex $dpp_contour_list $i]
      MOM_output_literal $line
      MOM_set_seq_off
    }

  } else {

    foreach line $dpp_contour_list {
      MOM_output_literal $line
    }
  }

  # Restore outputing sequence number
  MOM_set_seq_on

  # Output the return motion NC codes
  global dpp_return_motion_list
  foreach line $dpp_return_motion_list {
    MOM_output_literal $line
  }

  # Additional profiling can be selected in a rough opeation and output after rough turning cycle.
  # If user adds profile in tool path, some conditions should be checked to fulfill.
  if {[info exists mom_profiling] && ($mom_profiling == 1)} {

    LIB_CTRL_output_additional_profiling
  }

  # Set NX/Post to end contour output mode
  set mom_sys_output_contour_motion 0

  # Cancle tool nose radius compensation
  if {[info exists mom_cutcom_status]} {

    if {$mom_cutcom_status=="LEFT" || $mom_cutcom_status=="RIGHT"} {

      MOM_force once G_cutcom

      LIB_GE_command_buffer TURN_CYCLE_CUTCOM_OFF
      LIB_GE_command_buffer {MOM_do_template cutcom_off} @TURN_CYCLE_CUTCOM_OFF
      LIB_GE_command_buffer_output

      set mom_cutcom_status "UNDEFINED"
    }
  }

}
# <Internal Documentation>
# This command is used to output the contour data and adjust the sequence number.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_override_rough_contour_data_with_finish {} {


  global mom_machine_cycle_subroutine_name
  global dpp_contour_list
  global mom_operation_name

  # Run a finish operation with MOM_post_oper_path in rough operation
  set res [MOM_post_oper_path $mom_machine_cycle_subroutine_name "finish_operation_program.ptp"]

  # Flag to find the begin of contour data in output file
  global mom_finish_contour_data_start
  set mom_finish_contour_data_start 0

  # Get contour data from "finish_operation_program.ptp"
  if {$res == 1} {

    set dpp_contour_list [list]

    lappend dpp_contour_list [MOM_do_template turn_cycle_start_tag CREATE]

    # Open output file "finish_operation_program.ptp"
    if {[catch {set src [open "finish_operation_program.ptp" RDONLY]} fid]} {

      LIB_GE_abort_message "$mom_operation_name: Fail to open the file finish_operation_program.ptp."
    }

    # Only capture NC codes between "(CONTOUR TURN START)" and "(CONTOUR TURN END)"
    # and append them into contour list
    while {[eof $src] == 0} {

      set line [gets $src]

      if {[string match "*(CONTOUR TURN START)*" $line]} {

        set mom_finish_contour_data_start 1
        continue

      }

      if {[string match "*(CONTOUR TURN END)*" $line]} {

        set mom_finish_contour_data_start 0
        break
      }

      if {$mom_finish_contour_data_start == 1} {

        if {[string trim $line] != ""} {
          lappend dpp_contour_list $line
        }
      }
    }

    close $src

    catch {file delete "finish_operation_program.ptp"}

    lappend dpp_contour_list [MOM_do_template turn_cycle_end_tag CREATE]

  } else {

    LIB_GE_abort_message "$mom_operation_name: Fail to run the operation $mom_machine_cycle_subroutine_name with extended command MOM_post_oper_path."
  }

}
# <Internal Documentation>
# This command is used to override rough contour data with corresponding finish when cutter compensation UDE is not set.
# Rough operation's subroutine name should be the same as the associated finish operation's name.
# Use MOM_post_oper_path to run a finish operation in rough operation and output the NC codes into "finish_operation_program.ptp".
# Read the contour data from this file and append into a list used for rough operation.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_calculate_contour_line_number {} {


  global mom_seqnum
  global dpp_turn_cycle_seqno_begin
  global dpp_turn_cycle_seqno_end
  global mom_sys_seqnum_incr
  global dpp_record_rough_cycle_seq
  global mom_machine_cycle_subroutine_name
  global dpp_contour_list_length

  # Calculate start and end line number of contour in NC code
  # which will be output as the parameters of rough turning cycle command.

  if {[CONF_CTRL_turn sequence_number_output_mode] == 0} {

    if {![info exists mom_seqnum]} {

      global mom_def_sequence_start
      set dpp_turn_cycle_seqno_begin [expr $mom_def_sequence_start+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_def_sequence_start+3*$::mom_def_sequence_increment]

    } else {

      set dpp_turn_cycle_seqno_begin [expr $mom_seqnum+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_seqnum+3*$::mom_def_sequence_increment]
    }

  } else {

    if {![info exists mom_seqnum]} {

      global mom_def_sequence_start
      set dpp_turn_cycle_seqno_begin [expr $mom_def_sequence_start+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_def_sequence_start+(1+$dpp_contour_list_length)*$::mom_def_sequence_increment]

    } else {

      set dpp_turn_cycle_seqno_begin [expr $mom_seqnum+2*$::mom_def_sequence_increment]
      set dpp_turn_cycle_seqno_end [expr $mom_seqnum+(1+$dpp_contour_list_length)*$::mom_def_sequence_increment]
    }
  }

  # Record the rough turning cycle start seq and end seq.
  set dpp_record_rough_cycle_seq(begin,$mom_machine_cycle_subroutine_name) $dpp_turn_cycle_seqno_begin
  set dpp_record_rough_cycle_seq(end,$mom_machine_cycle_subroutine_name) $dpp_turn_cycle_seqno_end

}
# <Internal Documentation>
# This command is used to calculate and record start and end line number of contour in NC codes.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_turning_cycle_command {} {


  global mom_template_subtype
  global dpp_finish_feed
  global mom_feed_cut_value
  global dpp_turn_cycle_g_code

  if {[string match "FACING" $mom_template_subtype] || \
    [string match "*ROUGH*" $mom_template_subtype]} {

    # Output G71 or G72 command
    LIB_CTRL_lathe_roughing
  }

  if {[string match "*FINISH*" $mom_template_subtype]} {

    # Output G70 command

    LIB_GE_command_buffer TURN_CYCLE_FINISHING_TAG
    LIB_GE_command_buffer {MOM_output_literal "(Finish Turn Cycle)"} @TURN_CYCLE_FINISHING_TAG
    LIB_GE_command_buffer_output

    set dpp_finish_feed $mom_feed_cut_value
    set dpp_turn_cycle_g_code 70

    LIB_GE_command_buffer TURN_CYCLE_FINISHING
    LIB_GE_command_buffer {MOM_do_template turn_cycle_finishing} @TURN_CYCLE_FINISHING
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This command is used to output turning cycle command depending on the operation template type.
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_output_additional_profiling {} {


  global mom_operation_name
  global mom_template_subtype
  global mom_sys_output_contour_motion
  global mom_finishing_cut_method
  global mom_stock_part mom_face_stock mom_radial_stock
  global mom_finish_equidistant_stock mom_finish_face_stock mom_finish_radial_stock
  global dpp_turn_cycle_g_code
  global dpp_finish_feed
  global mom_feedrate_profile_cut

  # Check Condition 1.
  if {[string match "FACING" $mom_template_subtype] || [string match "*ROUGH*" $mom_template_subtype]} {

    # Check Condition 2.
    if {$mom_sys_output_contour_motion == 1} {

      # Check Condition 3.
      if {$mom_finishing_cut_method == 7} {

        # Check Condition 4.
        if {[EQ_is_equal $mom_finish_equidistant_stock $mom_stock_part] && \
          [EQ_is_equal $mom_finish_face_stock $mom_face_stock] && \
          [EQ_is_equal $mom_finish_radial_stock $mom_radial_stock]} {

          # Output additional profiling.
          set dpp_turn_cycle_g_code 70
          set dpp_finish_feed $mom_feedrate_profile_cut

          LIB_GE_command_buffer TURN_CYCLE_FINISHING_IN_ADDITIONAL_PROFILING
          LIB_GE_command_buffer {MOM_do_template turn_cycle_finishing} @TURN_CYCLE_FINISHING_IN_ADDITIONAL_PROFILING
          LIB_GE_command_buffer_output

        } else {

          LIB_GE_abort_message "$mom_operation_name: Profile stock should be the same with rough stock."
        }

      } else {

        LIB_GE_abort_message "$mom_operation_name: Strategy of path settings should be Finish All."
      }

    } else {

      LIB_GE_abort_message "$mom_operation_name: Additional Profiling can only be used when Cutter Compensation UDE is set."
    }

  } else {

    LIB_GE_abort_message "$mom_operation_name: Additional Profiling can only be used in FACING or ROUGH operation."
  }

}
# <Internal Documentation>
# This command is used to check whether output additional profiling data or not.
# If add profile in toolpath, the following conditions should be checked to fulfill.
#
# ==>> Condition 1: Operation type is FACING or ROUGH
# ==>> Condition 2: Cutter compensation UDE has been set
# ==>> Condition 3: Strategy of path settings is Finish All
# ==>> Condition 4: Profile stock is the same with rough stock
#
# This command is used in proc LIB_CTRL_turn_cycle_contour_end.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_lathe_roughing {} {


  LIB_GE_command_buffer TURN_CYCLE_LATHE_ROUGHING
  LIB_GE_command_buffer {
    MOM_do_template lathe_roughing
    MOM_force Once G_motion
    MOM_do_template lathe_roughing_1
  } @TURN_CYCLE_LATHE_ROUGHING
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command is used to run lathe roughing cycle function.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_gohome_move_LIB {} {


  global mom_motion_type

  set commandcheck(MOM_gohome_move_LIB_ENTRY) [llength [info commands MOM_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_motion_type == "GOHOME_DEFAULT"} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
  } else {
    MOM_rapid_move
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_LIB_ENTRY)} {MOM_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_path_LIB {} {


  global lib_flag
  global mom_next_oper_has_tool_change mom_current_oper_is_last_oper_in_program mom_next_main_mcs mom_main_mcs
  global mom_path_name mom_operation_name mom_machine_mode mom_out_angle_pos mom_kin_is_turbo_output mom_tool_axis
  global mom_flip_a_axis mom_tool_holder_angle_for_cutting
  global lib_pretreatment mom_tool_pitch mom_polar_status mom_coordinate_output_mode
  global mom_output_mcs_name lib_parameter nxt_oper_tool_axis
  global lib_prev_tool_name mom_next_tool_name mom_operation_is_interop
  global lib_prev_tool_adjust_register mom_tool_adjust_register

  set commandcheck(MOM_end_of_path_LIB_ENTRY) [llength [info commands MOM_end_of_path_LIB_ENTRY]]
  set commandcheck(LIB_unset_variables_in_end_of_path) [llength [info commands LIB_unset_variables_in_end_of_path]]

  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CTRL_handle_cycle_check "spindle" ;# to be sure S and M_spindle addresses are enable for next operation

  if {[CONF_CTRL_setting turbo_mode] == 1} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode disable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {[info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE"} {
    if {[llength [info commands MOM_set_turbo_feedrate_set]]} {MOM_set_turbo_feedrate_set ON}
  }

  if {$mom_machine_mode != "TURN" && [CONF_CTRL_moves polar_off_end_of_path] == "OFF"} {
    set mom_polar_status OFF
    set mom_coordinate_output_mode OFF
  }

  if {![info exists mom_output_mcs_name($mom_operation_name)]}      {set mom_output_mcs_name($mom_operation_name) $mom_main_mcs}
  if {![info exists mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1])]} {set mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) $mom_next_main_mcs}

  # mom_pos(3) and mom_pos(4) are not overwritten if there is an CSYS-Rotation with Toolaxis Z and parallel to TA
  # PR10021397: compare last tool axis of current operation with first tool axis of next operation,
  # because mom_tool_axis saved in pretreatment is always from last motion event.
  if {[LIB_SPF_get_pretreatment "init_tool_axis,0" 1] == ""} {
    array set nxt_oper_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  } else {
    array set nxt_oper_tool_axis "0 [LIB_SPF_get_pretreatment "init_tool_axis,0" 1] 1 [LIB_SPF_get_pretreatment "init_tool_axis,1" 1] 2 [LIB_SPF_get_pretreatment "init_tool_axis,2" 1]"
  }
  if {([CONF_CTRL_moves reset_rotary_axis_end_of_path] == "ON" && ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] &&\
    [LIB_SPF_get_pretreatment axis_mode next] != "SIMULTANEOUS") ||\
     ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
    set lib_prev_tool_adjust_register $mom_tool_adjust_register
  }

  if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES" ||\
  ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]) && [CONF_CTRL_moves safety_motion_when_mcs_changes] == 1)} {

    switch -- $mom_machine_mode {
      "TURN" {
        LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,TURN
        LIB_GE_command_buffer {LIB_TURNING_mode end} @TURN_END
        LIB_GE_command_buffer_output
      }
      "MILL" {
        LIB_CTRL_polar_transmit "off"
        if {$lib_flag(tool_path_motion) > 0} {
          if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,SIM
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_simultaneous_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          } else {
            #!!! if next op has different mom_out_angle_pos reset as well
            # (maybe compare current and next angle from Pretreatment)
            LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,MILL,POS
            LIB_GE_command_buffer {
              if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $::lib_sav_kin_machine_type == "3_axis_mill" || $lib_flag(tool_axis_zm) == 1} {
                LIB_ROTARY_absolute_reset
              } else {
                LIB_ROTARY_positioning_reset
              }
            } @RESET_ROTARY
            LIB_GE_command_buffer_output
          }
        }
      }
    }

    # <17013.16 Interop path> Inter-operation doesn't need postprocessor defined return NC codes.
    if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
      return
    }
    LIB_GE_command_buffer TOOL_OR_MCS_CHANGE,COMMON

    if {$::mom_oper_tool != "NONE" || ([info exist lib_prev_tool_name] && $lib_prev_tool_name != $mom_next_tool_name) } {
    LIB_GE_command_buffer {LIB_local_origin_reset} @LOCAL_ORIG_RESET
    LIB_GE_command_buffer {
      if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
        LIB_WRITE_coolant off
      }
    } @COOLANT_OFF
    LIB_GE_command_buffer {
      if {$mom_next_oper_has_tool_change == "YES" || $mom_current_oper_is_last_oper_in_program == "YES"} {
        LIB_SPINDLE_end
      }
    } @SPINDLE_OFF
    LIB_GE_command_buffer {
      if {$mom_current_oper_is_last_oper_in_program == "YES"} {
        if {[CONF_CTRL_moves return_end_of_pgm] != ""} {
          LIB_RETURN_move CONF_CTRL_moves return_end_of_pgm
        }
      } else {
        if {[CONF_CTRL_moves return_tool_change_pos] != ""} {
          LIB_RETURN_move CONF_CTRL_moves return_tool_change_pos
        }
      }
    } @RETURN_MOVE
    }
    LIB_GE_command_buffer_output

    set lib_flag(tool_path_motion) 0

  } else {

    switch -- $mom_machine_mode {
      "TURN" {

        set nxt_flip_a_axis [LIB_SPF_get_pretreatment mom_flip_a_axis 1]
        set nxt_tool_holder_angle_for_cutting [LIB_SPF_get_pretreatment mom_tool_holder_angle_for_cutting 1]
        # PR9295960: Check existence of mom_flip_a_axis and mom_tool_holder_angle_for_cutting in current operation
        if {$nxt_flip_a_axis == "" && [info exists mom_flip_a_axis]} {
          set nxt_flip_a_axis $mom_flip_a_axis
        }
        if {$nxt_tool_holder_angle_for_cutting == "" && [info exists mom_tool_holder_angle_for_cutting]} {
          set nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting
        }

        if {![info exists mom_tool_holder_angle_for_cutting] || ![EQ_is_equal $nxt_tool_holder_angle_for_cutting $mom_tool_holder_angle_for_cutting]} {

          LIB_GE_command_buffer TURN_HOLDER_ORIENT_CHANGE

          # check if B axis position change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {
            if {[CONF_CTRL_moves return_safety_pos] != ""} {
              LIB_RETURN_move CONF_CTRL_moves return_safety_pos
            }
          } @RETURN_MOVE
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output

        } elseif {[info exists mom_flip_a_axis] && $nxt_flip_a_axis != $mom_flip_a_axis} {

          LIB_GE_command_buffer TURN_TOOL_FLIP_CHANGE
          # check if spindle direction change
          set lib_flag(tool_path_motion) 0
          LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_STOP
          LIB_GE_command_buffer {MOM_do_template spindle_init CREATE} @SPINDLE_INIT

          LIB_GE_command_buffer_output
        }

      }
      "MILL" {
        if {$lib_flag(first_transmit_move) == 1 && ([CONF_CTRL_moves polar_off_end_of_path] == "OFF" || ![VEC3_is_equal mom_tool_axis nxt_oper_tool_axis] || [LIB_SPF_get_pretreatment axis_mode next] == "SIMULTANEOUS") ||\
           ($mom_output_mcs_name($mom_operation_name) != $mom_output_mcs_name([LIB_SPF_get_pretreatment mom_operation_name 1]))} {
          LIB_CTRL_polar_transmit "off"
        }

        LIB_GE_command_buffer MILL_AXIS_CHANGE

        # If the variable does not exist in the query, an blank is returned

        LIB_GE_command_buffer {

          if {[LIB_SPF_pt_exists_not_empty "out_angle_pos_last,0" 0]} {
            set out_angle_pos(0) [LIB_SPF_get_pretreatment "out_angle_pos_last,0" 0]
            set out_angle_pos(1) [LIB_SPF_get_pretreatment "out_angle_pos_last,1" 0]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set out_angle_pos(0) $mom_out_angle_pos(0)
            set out_angle_pos(1) $mom_out_angle_pos(1)
          }

          if {[LIB_SPF_pt_exists_not_empty "mom_out_angle_pos,0" 1]} {
            set nxt_out_angle_pos(0) [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 1]
            set nxt_out_angle_pos(1) [LIB_SPF_get_pretreatment "mom_out_angle_pos,1" 1]
          } else {
            #This is only the case if current operation has no toolpath (e.g. MILL_CONTROL Operation)
            set nxt_out_angle_pos(0) $out_angle_pos(0)
            set nxt_out_angle_pos(1) $out_angle_pos(1)
          }

          # PR#9554274 incase operation's current status is not same as axis mode. It happened if there is only rapid motions in operation like GMC operation.
          if {([LIB_SPF_get_pretreatment axis_mode] != [LIB_SPF_get_pretreatment axis_mode 1] && ([LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || [LIB_SPF_get_pretreatment axis_mode 1] == "SIMULTANEOUS") )||\
              [LIB_SPF_is_floating $nxt_out_angle_pos(0)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(0) $out_angle_pos(0) $::mom_kin_4th_axis_min_incr] ||\
            [LIB_SPF_is_floating $nxt_out_angle_pos(1)] > 0 && ![EQ_is_equal $nxt_out_angle_pos(1) $out_angle_pos(1) $::mom_kin_5th_axis_min_incr] ||\
            ($lib_flag(mode_current_status) == "sim" &&  [LIB_SPF_get_pretreatment axis_mode] == "POSITIONING")} {
            if {$mom_machine_mode == "MILL" && $lib_flag(tool_path_motion) > 0} {
              if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" || $lib_flag(mode_current_status) == "sim"} {
                if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
                  LIB_ROTARY_absolute_reset
                } else {
                LIB_ROTARY_simultaneous_reset
                }
              } else {
                #!!! if next op has different mom_out_angle_pos reset as well
                # (maybe compare current and next angle from Pretreatment)

                if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {
                  LIB_ROTARY_absolute_reset
                } else {
                  LIB_ROTARY_positioning_reset
                }
              }
              set lib_flag(tool_path_motion) 0
              if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
            }
          }
        } @RESET

        LIB_GE_command_buffer_output

      }
    }

  }

  # unset Variables if needed
  LIB_GE_command_buffer LIB_unset_variables_in_end_of_path
  LIB_GE_command_buffer {if {$commandcheck(LIB_unset_variables_in_end_of_path)} {LIB_unset_variables_in_end_of_path}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_path_LIB_ENTRY)} {MOM_end_of_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# * store oper info (for operation list)
# * mom_next_oper_has_tool_change == "YES"
# * mom_next_oper_is_last_oper_in_program == "YES"
# * mom_next_main_mcs != mom_main_mcs
# * check rot axis change PT
# if abs
# LIB_ROTARY_absolute_reset
# if sim
# LIB_ROTARY_simultaneous_reset
# if pos
# LIB_ROTARY_positioning_reset
# * retract before set axes (if needed) PT
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_unset_variables_in_end_of_path {} {


  if {[info exists ::lib_spf(do_convert_point)]}    {unset ::lib_spf(do_convert_point)}

  set ::lib_parameter(special_cycle,name) ""

  if {$::mom_next_oper_has_tool_change == "YES" || $::mom_current_oper_is_last_oper_in_program == "YES"} {
    if {[info exists ::mom_tool_pitch]} {unset ::mom_tool_pitch}
  }
}
# <Internal Documentation>
#
#  Unset Variables in End_of_path
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_program_LIB {} {


  set commandcheck(MOM_end_of_program_LIB_ENTRY) [llength [info commands MOM_end_of_program_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer TOOL_CHANGE_EOP
  LIB_GE_command_buffer {
    MOM_force once T M
    switch -- [join [CONF_CTRL_tool tool_change_eop]] {
      "off" {
        # nothing
      }
      "first_tool" {
        set ::mom_tool_name $::mom_next_tool_name
        set ::mom_tool_number $::mom_next_tool_number
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "unload_tool" {
        set ::mom_tool_number 0
        LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
      }
      "default" {
        if {[string is integer -strict [CONF_CTRL_tool tool_change_eop]]} {
          set ::mom_tool_number [CONF_CTRL_tool tool_change_eop]
          LIB_CONF_do_prop_custom_proc CONF_CTRL_tool auto_change_template "short_template_syntax"
        }
      }
    }
  } @TOOL_CHANGE_END_OF_PROGRAM
  LIB_GE_command_buffer_output
  LIB_GE_command_buffer END_OF_PROGRAM
  LIB_GE_command_buffer {MOM_do_template end_of_program} @END_OF_PROG
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_program_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_program_LIB_ENTRY)} {MOM_end_of_program_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_reset {} {

  global lib_flag

  set commandcheck(LIB_ROTARY_absolute_reset_ENTRY) [llength [info commands LIB_ROTARY_absolute_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_output] == "vector"} {
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_reset_ENTRY)} {LIB_ROTARY_absolute_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_reset {} {


  global lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    if {[CONF_CTRL_setting tcpm_output] == "angle"} {
      LIB_GE_command_buffer SIMULTANEOUS_RESET_G434
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @ADJUST_OFF
      LIB_GE_command_buffer_output
    } elseif {[CONF_CTRL_setting tcpm_output] == "vector"} {
      LIB_GE_command_buffer SIMULTANEOUS_RESET_G435
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @ADJUST_OFF
      LIB_GE_command_buffer_output
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    }
    # <NX1201 cam16012> new prereatment local csys
    if {$lib_flag(local_namespace_output)} {
      LIB_SPF_set_output_pos
    }
    set lib_flag(mode_current_status) "std"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_reset_ENTRY)} {LIB_ROTARY_simultaneous_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#  Switch off simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAFOOF
# Heidenhain: M129 / TCPM
# Fanuc: G49
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_reset {} {


  global lib_flag

  set commandcheck(LIB_ROTARY_positioning_reset_ENTRY) [llength [info commands LIB_ROTARY_positioning_reset_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$lib_flag(mode_current_status) != "std"} {
    LIB_CSYS_plane_output_reset
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_reset_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_reset_ENTRY)} {LIB_ROTARY_positioning_reset_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch off positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_simultaneous_init {} {


  global mom_kin_is_turbo_output mom_post_in_simulation
  global tcpm_type lib_flag

  set commandcheck(LIB_ROTARY_simultaneous_init_ENTRY) [llength [info commands LIB_ROTARY_simultaneous_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_output] == "angle" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  LIB_CTRL_unclamp_axis

  if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {return}
  if {$lib_flag(mode_current_status) != "sim"} {
    if {[CONF_CTRL_setting tcpm_output] != "angle" && [CONF_CTRL_setting tcpm_output] != "vector"} {
      LIB_SPF_add_warning "The entry 'INS->[CONF_CTRL_setting tcpm_output]<-' for tcpm_output is not allowed, angles will be used"
      CONF_CTRL_setting set tcpm_output "angle"
    }
    if {[CONF_CTRL_setting tcpm_output] == "angle"} {
      set tcpm_type 1
      MOM_enable_address fourth_axis fifth_axis
      MOM_force once fourth_axis fifth_axis
      MOM_disable_address X_vector Y_vector Z_vector
    } elseif {[CONF_CTRL_setting tcpm_output] == "vector"} {
      set tcpm_type 2
      MOM_enable_address X_vector Y_vector Z_vector
      MOM_force once  X_vector Y_vector Z_vector
      MOM_disable_address fourth_axis fifth_axis
    }

    LIB_GE_command_buffer MILL,SIMULTANEOUS

    LIB_GE_command_buffer {
      MOM_do_template tool_length_adjust CREATE
      MOM_force once H
    } @TOOL_LENGTH_ADJUST
    LIB_GE_command_buffer {
      MOM_set_address_format G_csys_rot Zero_real
      MOM_do_template set_tcpm_on
      MOM_set_address_format G_csys_rot Digit_2
    } @ROTARY_SIMULTANEOUS

    LIB_GE_command_buffer_output
    # <NX1201 cam16012> new prereatment local csys
    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_output] == "vector" ||\
      ([CONF_CTRL_setting tcpm_output] == "angle" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    set lib_flag(mode_current_status) "sim"
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_simultaneous_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_simultaneous_init_ENTRY)} {LIB_ROTARY_simultaneous_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: TRAORI
# Heidenhain: M128 / TCPM
# Fanuc: G43.4
#____________________________________________________________________________________________
proc LIB_ROTARY_absolute_init {} {

  global mom_kin_is_turbo_output mom_post_in_simulation
  global tcpm_type lib_flag

  set commandcheck(LIB_ROTARY_absolute_init_ENTRY) [llength [info commands LIB_ROTARY_absolute_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && [CONF_CTRL_setting tcpm_output] == "angle" && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    # mom_tool_axis variable can not be used with turbo mode
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {
    MOM_disable_address X_vector Y_vector Z_vector
  } else {
    MOM_enable_address fourth_axis fifth_axis
    MOM_force once fourth_axis fifth_axis
    MOM_disable_address X_vector Y_vector Z_vector
  }

  LIB_CTRL_polar_transmit "start"

  LIB_GE_command_buffer TOOL_ADJUST
  LIB_GE_command_buffer {
    MOM_do_template tool_length_adjust CREATE
    MOM_force once G_adjust H
  } @OUTPUT
  LIB_GE_command_buffer_output

  set lib_flag(mode_current_status) "std"

  LIB_GE_command_buffer UNCLAMP
  LIB_GE_command_buffer {LIB_CTRL_unclamp_axis} @UNCLAMP
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_absolute_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_absolute_init_ENTRY)} {LIB_ROTARY_absolute_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on absolute rotary mode
#  (link to the controller)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_ROTARY_positioning_init {} {


  global mom_kin_is_turbo_output mom_post_in_simulation
  global lib_flag
  global mom_kin_machine_type mom_sys_leader
  global mom_init_pos mom_init_alt_pos mom_pos mom_alt_pos mom_out_angle_pos mom_prev_out_angle_pos
  global mom_kin_4th_axis_direction mom_kin_4th_axis_leader mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_kin_5th_axis_direction mom_kin_5th_axis_leader mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  if {[CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1} {return}

  set commandcheck(LIB_ROTARY_positioning_init_ENTRY) [llength [info commands LIB_ROTARY_positioning_init_ENTRY]]

  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_setting turbo_mode] == 1 && $mom_post_in_simulation == 0 && $lib_flag(feed_turbo_mode_disable) == 0} {
    set mom_kin_is_turbo_output [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
    if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode enable"}
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
  }

  MOM_disable_address X_vector Y_vector Z_vector

  if {$lib_flag(mode_current_status) != "pos"} {
    LIB_CTRL_set_3P2_rotate_dir
    LIB_CSYS_plane_output_init
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_ROTARY_positioning_init_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_ROTARY_positioning_init_ENTRY)} {LIB_ROTARY_positioning_init_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on positioning rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: AROT / CYCLE800
# Heidenhain: CYCL DEF 19 or PLANE SPATIAL
# Fanuc: G68 / G68.1 / G68.2
#____________________________________________________________________________________________
proc LIB_CTRL_KINEMATICS_set_simultanous_kin {} {


  global mom_sys_leader lib_sav_kin_4th_axis_leader lib_sav_kin_5th_axis_leader
  global lib_sav_kin_machine_type mom_kin_4th_axis_point lib_flag
  set commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY) [llength [info commands LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_sim_kin 4th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 4th_axis_has_limit $::mom_sys_4th_axis_has_limits}
  if {[CONF_SPF_sim_kin 5th_axis_has_limit] == ""} {CONF_SPF_sim_kin set 5th_axis_has_limit $::mom_sys_5th_axis_has_limits}
  if {![CONF_SPF_sim_kin 4th_axis_has_limit] || ![CONF_SPF_sim_kin 5th_axis_has_limit]} {
#     set optimized rotary axis on
  }

  # Move it from LIB_SPF_KINEMATICS_set_simultanous_kin_ENTRY(OEM).
  if {($lib_flag(local_namespace_output) == 0 || [CONF_CTRL_setting fix_on_machine] == 0) && [CONF_CTRL_setting tcpm_output] == "angle"} {
        if {[string match "5_axis*" $lib_sav_kin_machine_type] && $lib_sav_kin_machine_type != "5_axis_dual_head"} {
      if {[CONF_SPF_sim_kin 4th_axis] == "real" && [CONF_SPF_sim_kin 5th_axis] == "real"} {
        set mom_sys_leader(fourth_axis) $lib_sav_kin_4th_axis_leader
        set mom_sys_leader(fifth_axis) $lib_sav_kin_5th_axis_leader
      }
      LIB_GE_copy_var_range mom_kin lib_sav_kin

      LIB_SPF_calc_4th5th_axis_points
      if {$lib_sav_kin_machine_type == "5_axis_head_table"} {
        global mom_kin_4th_axis_point
        global mom_kin_pivot_gauge_offset
        array set mom_kin_4th_axis_point "0 0 1 0 2 0"
        set mom_kin_pivot_gauge_offset 0
        MOM_reload_kinematics
      }
        } elseif { $lib_sav_kin_machine_type == "4_axis_table"} {
      if {[CONF_SPF_sim_kin 4th_axis] == "real"} {
        set mom_sys_leader(fourth_axis) $lib_sav_kin_4th_axis_leader
      }
      LIB_GE_copy_var_range mom_kin lib_sav_kin
      LIB_SPF_calc_4th5th_axis_points
        }
    }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY)} {LIB_CTRL_KINEMATICS_set_simultanous_kin_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Switch on shortest distance for simultaneous rotary mode
#  (link to the controller)
#
# <Internal Example>
#
# Siemens: Leader "C=DC("  Trailer ")"
# Heidenhain: M126
#____________________________________________________________________________________________
proc LIB_RETURN_move {Addresses {property ""}} {


  global mom_sys_home_pos mom_prev_pos mom_prev_out_angle_pos
  global tool_axis lib_flag mom_operation_type

  set commandcheck(LIB_RETURN_move_ENTRY) [llength [info commands LIB_RETURN_move_ENTRY]]

  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[string match $mom_operation_type "Device Generic Motion"]} {
      return
  }

  if {$property != ""} {
    set object $Addresses
    set Addresses [$Addresses $property]
  } else {
    set object ""
  }

  set line_nbr -1
  set break_it 0

        foreach axes $Addresses {
          incr line_nbr

    if {[catch {foreach axis $axes {}}]} {
      set axes [list $axes]
    }

    foreach axis $axes {
            MOM_force once G_return
      switch -- $axis {
        "Z" {
                #WRITE_coolant off
                if {[CONF_CTRL_moves return_mode] == "value"} {
                  if {[hiset tool_axis] && $tool_axis == 2} {MOM_do_template tool_length_adjust_off}
                              MOM_force once Z
            MOM_suppress once X Y
            LIB_GE_command_buffer AXIS_MOVE_Z
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Z
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Z
            LIB_GE_command_buffer {MOM_do_template return_home_Z} @RETURN_HOME_Z
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
                MOM_force once Z
        }
        "Y" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 1} {MOM_do_template tool_length_adjust_off}
            MOM_force once Y
            MOM_suppress once X Z
            LIB_GE_command_buffer AXIS_MOVE_Y
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_Y
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_Y
            LIB_GE_command_buffer {MOM_do_template return_home_Y} @RETURN_HOME_Y
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once Y
        }
        "X" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0} {MOM_do_template tool_length_adjust_off}
            MOM_force once X
            MOM_suppress once Y Z
            LIB_GE_command_buffer AXIS_MOVE_X
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_X
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_X
            LIB_GE_command_buffer {MOM_do_template return_home_X} @RETURN_HOME_X
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once X
        }
        "YX" -
        "XY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0 || [hiset tool_axis] && $tool_axis == 1} {MOM_do_template tool_length_adjust_off}
            MOM_force once X Y
            MOM_suppress once Z
            LIB_GE_command_buffer AXIS_MOVE_XY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_XY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_XY
            LIB_GE_command_buffer {MOM_do_template return_home_XY} @RETURN_HOME_XY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          MOM_force once X Y
        }
        "XZ" -
        "ZX" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 0 || [hiset tool_axis] && $tool_axis == 2} {MOM_do_template tool_length_adjust_off}
            MOM_force once X Z
            MOM_suppress once Y
            LIB_GE_command_buffer AXIS_MOVE_ZX
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZX
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZX
            LIB_GE_command_buffer {MOM_do_template return_home_ZX} @RETURN_HOME_ZX
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          set mom_prev_pos(0) $mom_sys_home_pos(0)
          MOM_force once Z X
        }
        "YZ" -
        "ZY" {
                if {[CONF_CTRL_moves return_mode] == "value"} {
            if {[hiset tool_axis] && $tool_axis == 1 || [hiset tool_axis] && $tool_axis == 2} {MOM_do_template tool_length_adjust_off}
            MOM_force once Y Z
            MOM_suppress once X
            LIB_GE_command_buffer AXIS_MOVE_ZY
            LIB_GE_command_buffer {MOM_do_template return_move} @RETURN_MOVE_ZY
            LIB_GE_command_buffer_output
          } else {
            LIB_GE_command_buffer AXIS_HOME_ZY
            LIB_GE_command_buffer {MOM_do_template return_home_ZY} @RETURN_HOME_ZY
            LIB_GE_command_buffer_output
          }
          set mom_prev_pos(1) $mom_sys_home_pos(1)
          set mom_prev_pos(2) $mom_sys_home_pos(2)
          MOM_force once Y Z
        }
        "4th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]]} {
            MOM_force once fourth_axis
            LIB_GE_command_buffer AXIS_HOME_4TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th} @RETURN_HOME_4TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            MOM_force once fourth_axis
          }
        }
        "5th" {
          if {![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fifth_axis
            LIB_GE_command_buffer AXIS_HOME_5TH
            LIB_GE_command_buffer {MOM_do_template return_home_5th} @RETURN_HOME_5TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fifth_axis
          }
        }
        "4th5th" {
          if {![EQ_is_zero [MOM_ask_address_value fourth_axis]] || ![EQ_is_zero [MOM_ask_address_value fifth_axis]]} {
            MOM_force once fourth_axis fifth_axis
            LIB_GE_command_buffer AXIS_HOME_45TH
            LIB_GE_command_buffer {MOM_do_template return_home_4th5th} @RETURN_HOME_45TH
            LIB_GE_command_buffer_output
            set mom_prev_out_angle_pos(0) 0.0
            set mom_prev_out_angle_pos(1) 0.0
            MOM_force once fourth_axis fifth_axis
          }
        }
        "" {
                #Do Nothing
        }
        "default" {
          if {[LIB_SPF_exists_block_template $axes 1] == 1} {
            MOM_do_template $axes
          } elseif {[LIB_SPF_exists_block_template $axes 1] == -1 && ![catch {set dummy [MOM_do_template $axes CREATE]}]} {
            # Thats the case when 'MOM_has_definition_element' command does not exist (older NX versions)
            #legacy
            MOM_output_literal $dummy
          } else {
            if {$object == ""} {
              #when LIB_RETURN_move is not called with a conf_object as argument
              LIB_RETURN_move_LIB_ENTRY $axes
            } else {
              if {[info proc LIB_RETURN_move_LIB_ENTRY] == "LIB_RETURN_move_LIB_ENTRY"} {
                #legacy
                LIB_RETURN_move_LIB_ENTRY $axes
              } else {
                LIB_CONF_do_prop_custom_proc $object $property "no_special_syntax" $line_nbr
                set break_it 1
                break
              }
            }
          }
        }
      }
    }
    if {$break_it} {break}
  }
  set lib_flag(current_safety_position) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_RETURN_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_RETURN_move_ENTRY)} {LIB_RETURN_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Documentation>
# This procedure writes the NC code for return motions to the output file. Settings for home motions [CONF_CTRL_moves return_mode]
# are taken into consideration for the output format of the return motions.
#
# <Arguments>
# Addresses
# String with space to separate axis names that perform a return move.
# Valid options:
# X / Y / Z / XY / ZX / ZY or a template name
# property
# Reserved argument.
#
# <Returnvalue>
# None.
#
# <Example>
# name: Example using axis names
# code: LIB_RETURN_move "Z XY"
# desc: Writes return moves for Z and then XY to the output file in Fanuc format.
#      Result is:
#      G0 G28 G91 Z0.
#      G0 G28 G91 X0. Y0.
# <Example>
# name: Example using template names
# code: LIB_RETURN_move "custom_return_template1 custom_return_template2"
# desc: Assuming we have two custom specific block templates custom_return_template1 and custom_return_template2,
# you can call them in this command by their name. It's okay to mix template names and axes names (see example 1).
#____________________________________________________________________________________________
proc LIB_main_origin_call {{offset_nbr ""} {create ""}} {


  global mom_fixture_offset_value mom_sys_leader
  global lib_main_zero_register lib_flag

  if {[CONF_CTRL_origin use_main] == 1} {
    if {$mom_fixture_offset_value <= 6} {
      set lib_main_zero_register [expr $mom_fixture_offset_value + 53]
      set mom_sys_leader(G_zero) "G"
    } elseif {$mom_fixture_offset_value <= 306} {
      #set leader_origin_def "G10L20P"
      set lib_main_zero_register [expr $mom_fixture_offset_value - 6]
      set mom_sys_leader(G_zero) "G54.1 P"
    } else {
      if {![hiset lib_flag(error_main_zero_register)]} {
        set error [LIB_SPF_add_warning "Fixture offset value should be < 306 : G54 is used"]
        set lib_flag(error_main_zero_register) 1
      }
      set lib_main_zero_register 1
    }
    LIB_GE_command_buffer MAIN_ZERO
    LIB_GE_command_buffer {MOM_do_template main_zero $create} @OUTPUT
    LIB_GE_command_buffer_output
  }
}
# <Documentation>
# This procedure writes the NC code for the fixture offset of the active coordinate system to the output file, when the property
# CONF_CTRL_origin use_main is set to On.
# <Arguments>
# offset_nbr
# Reserved argument.
# create
# Reserved argument.
# <Example>
# name: Output active origin
# code: LIB_main_origin_call
# desc: Outputs G54 when the fixture offset is set to 1.
#____________________________________________________________________________________________
proc LIB_local_origin_call {} {


  global mom_origin mom_tool_axis mom_csys_matrix mom_sys_csys_rot_code
  global lib_flag
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z

  if {[LIB_SPF_csys_examine_local] == "default" && [EQ_is_equal $mom_tool_axis(2) 1.0]} {
    set mom_origin(0) 0.0
    set mom_origin(1) 0.0
    set mom_origin(2) 0.0
  }

  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_local_csys_rotation [CONF_TEMPLATE_3P2 rot_direction][CONF_TEMPLATE_3P2 rot_order] [CONF_TEMPLATE_3P2 rot_mode] [CONF_TEMPLATE_3P2 rot_address]
  } else {
        LIB_SPF_csys_3D_rotation [CONF_TEMPLATE_3P2 rot_direction][CONF_TEMPLATE_3P2 rot_order] [CONF_TEMPLATE_3P2 rot_mode] [CONF_TEMPLATE_3P2 rot_address]
  }

  set mom_origin(0) $lib_coord_ref_X
  set mom_origin(1) $lib_coord_ref_Y
  set mom_origin(2) $lib_coord_ref_Z

}
# <Internal Documentation>
# Output the local origin call
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_local_origin_reset {} {

  global lib_flag

  # not yet implemented
  # MOM_output_literal "TRANS"
  # set lib_flag(local_origin_activated) 0

}
# <Internal Documentation>
# Output the main origin reset
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_init {} {


  global mom_sys_csys_rot_code
  global lib_flag lib_parameter lib_sav_kin_machine_type
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3 lib_coord_ang_4
  # <NX1201 cam16012> new prereatment local csys
  # In new local csys mode, enter local namespace and switch output mode before plane init
  LIB_GE_command_buffer LOCAL_CSYS_INIT
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_set}} @LOCAL_POS_SET
  LIB_GE_command_buffer_output

  LIB_CTRL_unclamp_axis
  set lib_flag(tcpm_dir_with_std_path_btw_rot_motions) 1

      LIB_rotate_axis_before_plane
      # Output rotate angle to affect G53.1 choose solution
      if {([CONF_TEMPLATE_3P2 rotate_before] != "1" && [CONF_TEMPLATE_3P2 rotate_dir] != 0) || ([info exists ::lib_flag(preferred_solution)] && $::lib_flag(preferred_solution) != "OFF") } {
        LIB_CTRL_rotate_axis
      }
      if {[CONF_CTRL_origin use_local] == 1} {
        set lib_parameter(csys_rot,_X0) $lib_coord_ref_X; set lib_parameter(csys_rot,_Y0) $lib_coord_ref_Y; set lib_parameter(csys_rot,_Z0) $lib_coord_ref_Z
      } else {
        set lib_parameter(csys_rot,_X0) 0.0; set lib_parameter(csys_rot,_Y0) 0.0; set lib_parameter(csys_rot,_Z0) 0.
      }
      set lib_parameter(csys_rot,retract) 1
      MOM_disable_address fourth_axis fifth_axis
      MOM_force once X Y Z I_rot J_rot K_rot
      MOM_set_address_format G_csys_rot Zero_real
      LIB_GE_command_buffer CSYS2_ON
      LIB_GE_command_buffer {MOM_do_template set_csys_on} @OUTPUT1
      LIB_GE_command_buffer {MOM_do_template set_csys_on_2} @OUTPUT2
      LIB_GE_command_buffer_output
      MOM_set_address_format G_csys_rot Digit_2
      MOM_force once X Y Z I_rot J_rot K_rot


  LIB_rotate_axis_after_plane

  LIB_CTRL_clamp_axis

  set lib_flag(mode_current_status) "pos"
}
# <Internal Documentation>
# output the plane
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CSYS_plane_output_reset {} {


  global mom_sys_csys_rot_code
  global lib_flag lib_sav_kin_machine_type

  #OUT [LIB_SPF_csys_examine_local] mom_tool_axis(2)
  if {$lib_flag(mode_current_status) == "std"} {return}

  LIB_local_origin_reset

  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer LOCAL_CSYS_RESET
  LIB_GE_command_buffer {if {$lib_flag(local_namespace_output)} {LIB_SPF_local_pos_reset}} @LOCAL_POS_RESET
  LIB_GE_command_buffer_output

  if {[string match "*.*" $mom_sys_csys_rot_code(OFF)]} {
    MOM_set_address_format G_csys_rot Zero_real
    LIB_GE_command_buffer CSYS_OFF_REAL
    LIB_GE_command_buffer {MOM_do_template set_csys_off} @OUTPUT
    LIB_GE_command_buffer_output
    MOM_set_address_format G_csys_rot Digit_2
  } else {
    LIB_GE_command_buffer CSYS_OFF
    LIB_GE_command_buffer {MOM_do_template set_csys_off} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[string match "*4_axis*" $lib_sav_kin_machine_type]} {
    MOM_enable_address fourth_axis
  } else {
    MOM_enable_address fourth_axis fifth_axis
  }
  set lib_flag(mode_current_status) "std"

}
# <Internal Documentation>
# reset plane
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_pos {} {


  global mom_prev_out_angle_pos mom_out_angle_pos mom_polar_status mom_current_motion
  global lib_flag mom_operation_type

  if {[string match $mom_operation_type "Device Generic Motion"]} {
    return
  }

  if {$mom_current_motion == "initial_move"} {
    if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1} {
      set lib_flag(safety_retract_status) 1
    } else {
      set lib_flag(safety_retract_status) 0
    }
  }

  if {[CONF_CTRL_moves safety_motion_after_toolchange] == 1 || $mom_current_motion != "initial_move"} {
  if {[info exists mom_prev_out_angle_pos] && $mom_polar_status != "ON" && [CONF_CTRL_moves standard_path_between_rotary_motions] == 0} {
    if {[CONF_CTRL_moves safety_retract_before_fourth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)]} {
      if {[EQ_is_gt [expr abs($mom_out_angle_pos(0) - $mom_prev_out_angle_pos(0))] [CONF_CTRL_moves safety_retract_before_fourth_axis_minimum_value]]} {
        set lib_flag(safety_retract_status) 1
      }
    }

    if {[CONF_CTRL_moves safety_retract_before_fifth_axis] == 1 && ![EQ_is_equal $mom_prev_out_angle_pos(1) $mom_out_angle_pos(1)]} {
      if {[EQ_is_gt [expr abs($mom_out_angle_pos(1) - $mom_prev_out_angle_pos(1))] [CONF_CTRL_moves safety_retract_before_fifth_axis_minimum_value]]} {
        set lib_flag(safety_retract_status) 1
      }
    }
  }

  if {[info exists lib_flag(safety_retract_status)] && $lib_flag(safety_retract_status) == 1} {
    if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move CONF_CTRL_moves return_safety_pos}
    set lib_flag(tool_path_motion) 1
    set lib_flag(safety_retract_status) 0
    }
  }
  # not possible with this controller
  # LIB_CTRL_prepos_before_plane
}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_first_tool_path_motion_sim {} {

  global lib_flag

  if {[CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    LIB_GE_command_buffer TCPM_PREPOS_PLANE
    LIB_GE_command_buffer {
      if {$lib_flag(local_namespace_output)} {
        LIB_SPF_local_csys_rotation "ZXZ" "euler"
      } else {
        LIB_SPF_convert_point "plane_no_reset"
        LIB_SPF_csys_3D_rotation "ZXZ" "euler"
        LIB_GE_snapshot LOAD_PERMANENT $::lib_spf_convert_kin_snapshot
      }
    } @CP_PLANE
    LIB_GE_command_buffer {LIB_ROTARY_positioning_init} @INIT
    LIB_GE_command_buffer {LIB_SPINDLE_start} @START_SPINDLE
    LIB_GE_command_buffer {LIB_ROTARY_positioning_first_move_pos} @MOTION
    LIB_GE_command_buffer {LIB_ROTARY_positioning_reset} @RESET

    if {$lib_flag(local_namespace_output) == 0} {
      LIB_GE_command_buffer {LIB_SPF_convert_point "reload"} @CP_RELOAD
      LIB_GE_command_buffer {
        if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
          LIB_SPF_KINEMATICS_set_absolut_output_kin
        } else {
          LIB_SPF_KINEMATICS_set_simultanous_kin
        }
      } @KIN_SIM
    } else {
            global mom_mcs_goto mom_pos
      VMOV 3 mom_mcs_goto mom_pos
    }
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This command is called with LIB_SPF_first_tool_path_motion
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_dwell_set {} {


  global mom_cycle_delay_mode ;# SECONDS, REVOLUTIONS, OFF ,ON
  global mom_cycle_delay mom_cycle_delay_revs mom_spindle_rpm

  if {$mom_cycle_delay_mode == "ON"} {set mom_cycle_delay [CONF_CTRL_drill default_cycle_delay]}

  if {$mom_cycle_delay_mode == "OFF"} {
    set mom_cycle_delay 0
    return
  }

  if {$mom_cycle_delay_mode == "REVOLUTIONS"} {
    catch {set mom_cycle_delay [expr $mom_cycle_delay_revs * (60 / $mom_spindle_rpm)]}
  }

  if {$mom_cycle_delay > [CONF_CTRL_drill max_delay]} {set mom_cycle_delay [CONF_CTRL_drill max_delay]}
  if {$mom_cycle_delay < [CONF_CTRL_drill min_delay]} {set mom_cycle_delay [CONF_CTRL_drill min_delay]}
}
# <Internal Documentation>
# This procedure is executed at the cycle event.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill : output CYCLE81 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_move_LIB {} {


  global lib_flag
  set commandcheck(MOM_drill_move_LIB_ENTRY) [llength [info commands MOM_drill_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------


  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_LIB_ENTRY)} {MOM_drill_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_dwell_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_dwell : output CYCLE82 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell_move_LIB {} {


  set commandcheck(MOM_drill_dwell_move_LIB_ENTRY) [llength [info commands MOM_drill_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_LIB_ENTRY)} {MOM_drill_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_deep_LIB {} {


  global mom_cycle_step1 mom_tool_diameter mom_cycle_feed_to

  LIB_CYCLE_set

  if {[hiset mom_cycle_step1]} {
    set mom_cycle_step1 [expr abs($mom_cycle_step1)]
  } else {
    set mom_cycle_step1 0
  }

  if {$mom_cycle_step1 == 0} {
    if {[hiset mom_tool_diameter]} {set mom_cycle_step1 [expr $mom_tool_diameter / 2]} else {set mom_cycle_step1 2}
    LIB_SPF_add_warning "With CYCLE/DEEP, STEP1 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step1]<-'"
  }
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

}
# <Internal Documentation>
# MOM_drill_deep : output CYCLE83_Deep (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep_move_LIB {} {


  global mom_cycle_feed_to mom_cycle_step1
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_drill_deep_move_LIB_ENTRY) [llength [info commands MOM_drill_deep_move_LIB_ENTRY]]


  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_LIB_ENTRY)} {MOM_drill_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_LIB {} {


  global mom_cycle_step1 mom_tool_diameter mom_cycle_feed_to

  LIB_CYCLE_set

  if {[hiset mom_cycle_step1]} {
    set mom_cycle_step1 [expr abs($mom_cycle_step1)]
  } else {
    set mom_cycle_step1 0
  }

  if {$mom_cycle_step1 == 0} {
    if {[hiset mom_tool_diameter]} {set mom_cycle_step1 [expr $mom_tool_diameter / 2]} else {set mom_cycle_step1 2}
    LIB_SPF_add_warning "With CYCLE/BREAKCHIP, STEP1 should be defined. Default value used by the post : 'INS->[format %.1f $mom_cycle_step1]<-'"
  }
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}
}
# <Internal Documentation>
# MOM_drill_break_chip : output CYCLE83_Break_Chip (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_mill_hole_move_LIB {} {

    set commandcheck(MOM_mill_hole_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_move_LIB_ENTRY]]

    LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_SPF_add_warning "Hole milling machine cycle is not supported on this controller"

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer MOM_mill_hole_move_LIB_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_LIB_ENTRY)} {MOM_mill_hole_move_LIB_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# This function outputs a warning as hole milling subprogram is not supported on this controller
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_mill_hole_thread_move_LIB {} {

    set commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY) [llength [info commands MOM_mill_hole_thread_move_LIB_ENTRY]]

    LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_SPF_add_warning "Thread milling machine cycle is not supported on this controller"

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer MOM_mill_hole_thread_move_LIB_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_LIB_ENTRY)} {MOM_mill_hole_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called fom MOM-Event and controls the handling to the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# This function outputs a warning as thread milling subprogram is not supported on this controller
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_break_chip_move_LIB {} {


  global mom_cycle_feed_to mom_cycle_step1
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_drill_break_chip_move_LIB_ENTRY) [llength [info commands MOM_drill_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_LIB_ENTRY)} {MOM_drill_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_tap
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_move_LIB {} {


  set commandcheck(MOM_tap_move_LIB_ENTRY) [llength [info commands MOM_tap_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_LIB_ENTRY)} {MOM_tap_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_float_LIB {} {


  LIB_CYCLE_set

}
# <Internal Documentation>
# MOM_tap_float
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float_move_LIB {} {


  set commandcheck(MOM_tap_float_move_LIB_ENTRY) [llength [info commands MOM_tap_float_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_LIB_ENTRY)} {MOM_tap_float_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_deep_LIB {} {

  global mom_cycle_step1 mom_cycle_feed_to
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  LIB_CYCLE_set

  if {![info exists mom_cycle_step1] || [EQ_is_zero $mom_cycle_step1]} {
    LIB_SPF_add_warning "Step value of Tap Deep cycle cannot be zero!"
  }
}
# <Internal Documentation>
# MOM_tap_deep
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep_move_LIB {} {


  global mom_cycle_feed_to mom_cycle_step1
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_tap_deep_move_LIB_ENTRY) [llength [info commands MOM_tap_deep_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_LIB_ENTRY)} {MOM_tap_deep_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_tap_break_chip_LIB {} {

  global mom_cycle_step1 mom_cycle_feed_to
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  LIB_CYCLE_set

  if {![info exists mom_cycle_step1] || [EQ_is_zero $mom_cycle_step1]} {
    LIB_SPF_add_warning "Step value of Tap Break Chip cycle cannot be zero!"
  }

}
# <Internal Documentation>
# MOM_tap_break_chip
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip_move_LIB {} {


  global mom_cycle_feed_to mom_cycle_step1
  if {[EQ_is_gt $mom_cycle_step1 [expr abs($mom_cycle_feed_to)]]} {set mom_cycle_step1 [expr abs($mom_cycle_feed_to)]}

  set commandcheck(MOM_tap_break_chip_move_LIB_ENTRY) [llength [info commands MOM_tap_break_chip_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_tap_set
  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_LIB_ENTRY)} {MOM_tap_break_chip_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore : output CYCLE85_Bore (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_move_LIB {} {


  set commandcheck(MOM_bore_move_LIB_ENTRY) [llength [info commands MOM_bore_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_LIB_ENTRY)} {MOM_bore_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_dwell_LIB {} {


  LIB_CYCLE_set

}
# <Internal Documentation>
# MOM_bore_dwell : output CYCLE85_Bore_Dwell (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell_move_LIB {} {


  set commandcheck(MOM_bore_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_LIB_ENTRY)} {MOM_bore_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_drag_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_drag : output CYCLE89 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag_move_LIB {} {


  set commandcheck(MOM_bore_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_LIB_ENTRY)} {MOM_bore_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_no_drag_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_no_drag : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag_move_LIB {} {


  set commandcheck(MOM_bore_no_drag_move_LIB_ENTRY) [llength [info commands MOM_bore_no_drag_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_LIB_ENTRY)} {MOM_bore_no_drag_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_back_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_back : output CYCLE86 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back_move_LIB {} {


  set commandcheck(MOM_bore_back_move_LIB_ENTRY) [llength [info commands MOM_bore_back_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_LIB_ENTRY)} {MOM_bore_back_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual : output CYCLE87 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_move_LIB {} {


  set commandcheck(MOM_bore_manual_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_LIB_ENTRY)} {MOM_bore_manual_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_bore_manual_dwell : output CYCLE88 (default)
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_move_LIB {} {


  set commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY) [llength [info commands MOM_bore_manual_dwell_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_LIB_ENTRY)} {MOM_bore_manual_dwell_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_drill_text_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_drill_text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text_move_LIB {} {


  set commandcheck(MOM_drill_text_move_LIB_ENTRY) [llength [info commands MOM_drill_text_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_LIB_ENTRY)} {MOM_drill_text_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_thread_LIB {} {


  LIB_CYCLE_set
}
# <Internal Documentation>
# MOM_thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_move_LIB {} {


  set commandcheck(MOM_thread_move_LIB_ENTRY) [llength [info commands MOM_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CYCLE_move

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_LIB_ENTRY)} {MOM_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# MOM_thread_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_off_LIB {} {


  set commandcheck(MOM_cycle_off_LIB_ENTRY) [llength [info commands MOM_cycle_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer CYCLE_OFF
  LIB_GE_command_buffer {
    if {[LIB_SPF_get_pretreatment cycle_tap] == "YES" && [CONF_CTRL_drill cycle_tap] == "rigid"} {
      MOM_do_template spindle_tap_rigid_init CREATE
    }
    if {[CONF_CTRL_drill cancel_cycle] == "G80"} {
      MOM_do_template cycle_off
    } elseif {[MOM_ask_address_value G_motion] > 1 } {
      MOM_do_template cycle_off
    }
  } @OFF
  LIB_GE_command_buffer {MOM_do_template cycle_init CREATE} @INIT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CYCLE_set {} {

  LIB_GE_command_buffer CYCLE_SET_start
  LIB_GE_command_buffer {
  global mom_cycle_feed_rate mom_cycle_feed_rate_mode mom_cycle_feed_rate_per_rev mom_spindle_rpm
    if {[string match *PR* [string toupper $mom_cycle_feed_rate_mode]]} {
      set mom_cycle_feed_rate [expr $mom_cycle_feed_rate_per_rev * $mom_spindle_rpm]
    }
  } @CYCLE_FEED
  LIB_GE_command_buffer_output

  LIB_CYCLE_dwell_set
}
# <Internal Documentation>
# Controls the drilling cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_set {} {

  global mom_tool_pitch mom_cycle_feed_rate_per_rev
  global mom_cycle_thread_pitch
  global mom_cycle_thread_right_handed
  global mom_spindle_direction
  global mom_spindle_rpm mom_spindle_speed
  global mom_retract_spindle
  global mom_path_name
  global feed_mode
  global feed

  if {[info exists mom_tool_pitch]} {
    set pitch $mom_tool_pitch
  } elseif {[info exists mom_cycle_thread_pitch]} {
    set pitch $mom_cycle_thread_pitch
  } else {
    if {[CONF_CTRL_drill tool_pitch_used] == 0} {
      set pitch $mom_cycle_feed_rate_per_rev
    } else {
      set pitch 0
      LIB_GE_abort_message "INS->$mom_path_name<- : No pitch defined on the tool." "Please use Tap tool."
    }
  }

  if {![info exists mom_spindle_speed] || [EQ_is_zero $mom_spindle_speed]} {
    LIB_GE_abort_message "INS->$mom_path_name<- : spindle speed is 0." "Please verify."
  }

  if {[string match "*PR" [CONF_CTRL_drill cycle_tap_feed_type]]} {
    set feed $pitch
    MOM_set_address_format F Feed_[CONF_CTRL_drill cycle_tap_feed_type]
    #<lili 05-20-2019> In this case, G95 should be outputed, reset feed_mode.
    set feed_mode [CONF_CTRL_drill cycle_tap_feed_type]
  } elseif {[string match "*PR" $feed_mode]} {
    set feed $pitch
  } else {
    set feed [expr $pitch*$mom_spindle_rpm]
  }

  LIB_CYCLE_tap_g_code_string_determine_for_standard
}
# <Internal Documentation>
# Controls the tapping cycle setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_move {} {


  global mom_cycle_feed_to mom_cycle_retract_to_pos mom_cycle_rapid_to_pos
  global mom_sys_cycle_tap_code mom_sys_cycle_tap_rigid_code mom_spindle_direction
  global mom_motion_event mom_sys_tap_rigid_code
  global cycle_peck_size lib_parameter cycle_factor
  global lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos lib_flag tool_axis
  global mom_namespace_name mom_cycle_rapid_to mom_cycle_clearance_plane mom_pos

  LIB_GE_command_buffer START_CYCLE
  LIB_GE_command_buffer {LIB_SPINDLE_start cycle} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer PREPOS_IN_CYCLE
  LIB_GE_command_buffer {
  if {$lib_flag(tool_path_motion) == 1} {
    switch -- $tool_axis {
        0 {LIB_SPF_decompose_block_template "{Y Z} {G_adjust X H}" "cycle_move" FORCE "G_adjust X Y Z H"}
        1 {LIB_SPF_decompose_block_template "{X Z} {G_adjust Y H}" "cycle_move" FORCE "G_adjust X Y Z H"}
        2 {LIB_SPF_decompose_block_template "{X Y} {G_adjust Z H}" "cycle_move" FORCE "G_adjust X Y Z H"}
    }
  }
  } @PREPOS_DEFAULT
  LIB_GE_command_buffer_output
  set lib_flag(tool_path_motion) 2

  switch -- $tool_axis {
    0 {set cycle_factor [LIB_SPF_check_x_factor MILL]}
    1 {set cycle_factor 1}
    2 {set cycle_factor 1}
  }

  # <NX1201 cam16012> new prereatment local csys
  # PR9772886: Override feed_to_pos/rapid_to_pos/retract_to_pos by related value in local namespace
  if {$lib_flag(local_namespace_output)} {
    LIB_SPF_recalculate_cycle_pos
  }

  LIB_SPF_retract_to_pos

  # Replace negative rapid_to by clearance_plane to keep safety distance in Cycle.
  LIB_GE_command_buffer RAPIDTOPOS_IN_CYCLE
  LIB_GE_command_buffer {
    if {$mom_cycle_rapid_to < 0} {
      set mom_cycle_rapid_to $mom_cycle_clearance_plane
      set mom_cycle_rapid_to_pos($tool_axis)  [expr $mom_pos($tool_axis) + $mom_cycle_rapid_to]
    }
  } @RAPIDTOPOS_ADJUST
  LIB_GE_command_buffer_output

  set cycle_peck_size [expr ($mom_cycle_feed_to*(-1.0))]     ;# single peck size most cycles

  LIB_WRITE_coolant on

  if {[info exists lib_parameter(special_cycle,name)] && $lib_parameter(special_cycle,name) != ""} {
    LIB_CYCLE_move_special_$lib_parameter(special_cycle,name)
  } else {
    switch -- $mom_motion_event {
      "drill_move"    {
              LIB_GE_command_buffer DRILL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_dwell_move"  {
              LIB_GE_command_buffer DRILL_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_deep_move"   {
              LIB_GE_command_buffer DRILL_DEEP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_deep} @OUTPUT
              LIB_GE_command_buffer_output

            }
      "drill_break_chip_move" {
              LIB_GE_command_buffer DRILL_BREAK_CHIP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_drill_break_chip} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_move"    {
              if {[CONF_CTRL_drill cycle_tap] == "rigid"} {
                LIB_GE_command_buffer TAP_MOVE_RIGID
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Coordinate
                  set mom_sys_cycle_tap_code $mom_sys_cycle_tap_rigid_code($mom_spindle_direction)
                } @SETTING_BEFORE
                LIB_GE_command_buffer {
                  if {[MOM_ask_address_value M_rigid_tap] != $mom_sys_tap_rigid_code} {MOM_force once S}
                  MOM_do_template spindle_tap_rigid
                } @RIGID_MODE_OUTPUT
                LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
                LIB_GE_command_buffer {
                  MOM_set_address_format G_motion Digit_2
                  set mom_sys_cycle_tap_code 84
                }  @SETTING_AFTER
                LIB_GE_command_buffer_output
              } else {
                LIB_GE_command_buffer TAP_MOVE
                LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
                LIB_GE_command_buffer_output
              }
            }
      "tap_float_move"  {
              LIB_GE_command_buffer TAP_FLOAT_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_deep_move"   {
              LIB_GE_command_buffer TAP_DEEP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "tap_break_chip_move"   {
              LIB_GE_command_buffer TAP_BREAK_CHIP_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_tap_deep} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_move"     {
              LIB_GE_command_buffer BORE_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_dwell_move"   {
              LIB_GE_command_buffer BORE_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_drag_move"  {
              LIB_GE_command_buffer BORE_DRAG_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_drag} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_no_drag_move"   {
              LIB_GE_command_buffer BORE_NO_DRAG_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_no_drag} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_back_move"  {
              LIB_GE_command_buffer BORE_BACK_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_back} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_manual_move"  {
              LIB_GE_command_buffer BORE_MANUAL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_manual} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "bore_manual_dwell_move" {
              LIB_GE_command_buffer BORE_MANUAL_DWELL_MOVE
              LIB_GE_command_buffer {MOM_do_template cycle_bore_manual_dwell} @OUTPUT
              LIB_GE_command_buffer_output
            }
      "drill_text_move"   {# nothing for the moment}
      "thread_move"     {# nothing for the moment}
    }
  }

  LIB_CTRL_cycle_retract_handling

  if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
    namespace eval $::mom_namespace_name {
      array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
      array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]
    }
  } else {
    array set lib_prev_cycle_retract_to_pos [array get mom_cycle_retract_to_pos]
    array set lib_prev_cycle_rapid_to_pos [array get mom_cycle_rapid_to_pos]

}
# <Internal Documentation>
# Controls the drilling move setting conditions
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CYCLE_tap_g_code_string_determine_for_standard {} {


  global mom_cycle_thread_right_handed
  global mom_spindle_direction
  global mom_sys_cycle_tap_code

  if {[info exists mom_cycle_thread_right_handed]} {

    if {$mom_cycle_thread_right_handed == "TRUE"} {

      set mom_sys_cycle_tap_code "84"

    } else {

      set mom_sys_cycle_tap_code "74"
    }

  } elseif {[info exists mom_spindle_direction]} {

    if {$mom_spindle_direction == "CLW"} {

      set mom_sys_cycle_tap_code "84"

    }

    if {$mom_spindle_direction == "CCLW"} {

      set mom_sys_cycle_tap_code "74"
    }
  } else {
      set mom_sys_cycle_tap_code "84"
  }

}
# <Internal Documentation>
# Controls the tapping cycle setting conditions.
#
# Determine the tapping G code according to thread direction for standard mode in tap move.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_retract_handling {} {

  global mom_cycle_retract_to_pos mom_cycle_rapid_to_pos tool_axis
  global mom_cycle_retract_to mom_cycle_rapid_to mom_pos
  global mom_cycle_retract_mode mom_namespace_name

  # If mom_cycle_retract_mode is "AUTO", for continuous drilling in local csys namespace,
  # rapidTo and retractTo are recalculated and may be different, but we don't need to output redundant NC code "G0 Z.."
  if {$mom_cycle_retract_mode == "AUTO"} {return}

# 31.01.2018 HES Why we retract only if mom_cycle_retract_mode is "MANUAL"
# change it if rapid and retract is different
# if {![EQ_is_equal $mom_cycle_retract_to $mom_cycle_rapid_to] && $mom_cycle_retract_mode == "MANUAL"} {}
  if {![EQ_is_equal $mom_cycle_retract_to $mom_cycle_rapid_to]} {
    # <NX1201 cam16012> new prereatment local csys
    if {[info exists mom_namespace_name] && [namespace exists $mom_namespace_name]} {
      # Should set mom_pos or mom_mcs_goto in specify namespace mom_namespace_name if exist
      uplevel #0 {
        namespace eval $::mom_namespace_name {
          set tmp_posz $mom_pos($tool_axis)
          set tmp_mcs_gotoz $mom_mcs_goto($tool_axis)
          set mom_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
          set mom_mcs_goto($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
          MOM_do_template [CONF_CTRL_moves rapid_template]
          set mom_pos($tool_axis) $tmp_posz
          set mom_mcs_goto($tool_axis) $tmp_mcs_gotoz
        }
      }
    } else {
      set tmpz $mom_pos($tool_axis)
      set mom_pos($tool_axis) $mom_cycle_retract_to_pos($tool_axis)
      LIB_GE_command_buffer CYCLE_RETRACT
      LIB_GE_command_buffer {MOM_do_template [CONF_CTRL_moves rapid_template]} @OUTPUT
      LIB_GE_command_buffer_output
      set mom_pos($tool_axis) $tmpz
    }
    MOM_force once R_cycle Q_cycle
  }

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CHECK_adjust_register {} {


  global mom_path_name mom_tool_adjust_register mom_tool_length_adjust_register mom_tool_number
  global lib_flag

  LIB_GE_command_buffer CHECK_adjust_register
  LIB_GE_command_buffer {
    if {$mom_tool_length_adjust_register == 0} {set mom_tool_adjust_register $mom_tool_number}

    if {[CONF_CTRL_tool max_d_number] != 0 && $mom_tool_length_adjust_register > [CONF_CTRL_tool max_d_number]} {
      if {![hiset lib_flag(error_adjust_register,$mom_path_name)]} {
        set error [LIB_SPF_add_warning "Adjust register $mom_tool_length_adjust_register not possible ([CONF_CTRL_tool max_d_number] max) ... Adjust register $mom_tool_number (same as tool_number) is used"]
        set lib_flag(error_adjust_register,$mom_path_name) 1
      }
      set mom_tool_adjust_register $mom_tool_number
    }
  } @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Check for adjust register
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CHECK_tool_number {} {


  global mom_tool_number mom_tool_name

  if {[CONF_CTRL_tool max_tool_number] != 0 && $mom_tool_number > [CONF_CTRL_tool max_tool_number]} {
    set error [LIB_SPF_add_warning "Maximum tool number allowed : [CONF_CTRL_tool max_tool_number]. Check tool $mom_tool_name"]
  }
}
# <Internal Documentation>
# Check the tool number
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_before_plane {} {


  if {[CONF_TEMPLATE_3P2 rotate_before] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis before plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_rotate_axis_after_plane {} {


  if {[CONF_TEMPLATE_3P2 rotate_after] == "1"} {
    LIB_CTRL_rotate_axis
  }
}
# <Internal Documentation>
# Check to rotate the axis after plane handling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_WRITE_coolant {{option default}} {


  global mom_coolant_mode mom_coolant_status mom_kin_is_turbo_output

  switch -- $option {
    "on"  {
      if {![hiset mom_coolant_mode] || $mom_coolant_mode == ""} {set mom_coolant_mode [CONF_CTRL_coolant coolant_status]}
      if {$mom_coolant_mode == "OFF"} {return}

      LIB_GE_command_buffer COOLNT_on
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_output_before_motion] != 0} {
          MOM_do_template coolant_on
        }
      } @COOLNT_on_std
      LIB_GE_command_buffer_output
    }
    "off" {
      LIB_GE_command_buffer COOLNT_off
      LIB_GE_command_buffer {
        if {[info exists mom_kin_is_turbo_output] && $mom_kin_is_turbo_output == "TRUE" && [MOM_ask_address_value M_coolant] != $::mom_sys_coolant_code(OFF)} {
          MOM_force once M_coolant ; #needs when turbo mode is activated (Bug#669)
        }
        MOM_do_template coolant_off
      } @COOLNT_on_std
      LIB_GE_command_buffer {
        if {[CONF_CTRL_coolant coolnt_auto] == 0} {
          set mom_coolant_mode "OFF"
          set mom_coolant_status "OFF"
        }
      } @COOLNT_on_std_2
      LIB_GE_command_buffer_output
    }
  }
}
# <Internal Documentation>
# This procedure is executed to output coolant on or off
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CIRCLE_set {} {


  global lib_arc_axis mom_arc_radius

  switch -- $lib_arc_axis {
    0 {MOM_suppress once I}
    1 {MOM_suppress once J}
    2 {MOM_suppress once K}
  }

  LIB_SPF_check_arc_radius
  if {[info level -1] == "MOM_helix_move_LIB"} {
    if {[CONF_CTRL_moves always_center_for_circle] != 1} {
      MOM_suppress once I J K
      MOM_force once X Y Z R
      if {[expr fmod($::mom_arc_angle,360)] > 180} {
        set mom_arc_radius [expr abs($mom_arc_radius) * -1]
      } else {
        set mom_arc_radius [expr abs($mom_arc_radius) * +1]
      }

    } else {
      MOM_suppress once R
      MOM_force once X Y Z
    }
  } else {
    if {[CONF_CTRL_moves always_center_for_circle] != 1} {
      set mom_arc_radius [expr abs($mom_arc_radius)]

      if {[CONF_CTRL_feed feed_linear] == 2} {
        set ::feed $::mom_feedrate
        LIB_CTRL_feed_output
      }

      MOM_suppress once I J K

      # Set the tolerance to 0.1 because the calculation in NX is not exact (Bug #1280)
      if {[EQ_is_equal $::mom_arc_angle 360 0.1] || [EQ_is_equal $::mom_arc_angle 180.0 0.1]} {

        global mom_prev_pos mom_pos_arc_center mom_pos_arc_axis mom_pos oper_mcs_matrix
        global mom_namespace_name mom_output_pos_type
        if {[info exists mom_namespace_name] && [info exists mom_output_pos_type]} {
          if {$mom_namespace_name == "::"} {
            set namespace ::
          } else {
            set namespace ::LOCAL_CSYS::
          }
          if {$mom_output_pos_type == "mom_pos"} {
            VMOV 3 ${namespace}mom_prev_pos prev_pos
            VMOV 3 ${namespace}mom_pos_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_pos_arc_axis pos_arc_axis
          } else {
            VMOV 3 ${namespace}mom_prev_mcs_goto prev_pos
            VMOV 3 ${namespace}mom_arc_center pos_arc_center
            VMOV 3 ${namespace}mom_arc_axis pos_arc_axis
          }
          VMOV 3 ${namespace}$mom_output_pos_type save_pos
        } else {
          set namespace ::
          set mom_output_pos_type mom_pos
          VMOV 3 mom_prev_pos prev_pos
          VMOV 3 mom_pos_arc_center pos_arc_center
          VMOV 3 mom_pos_arc_axis pos_arc_axis
          VMOV 3 mom_pos save_pos
        }
        VEC3_sub prev_pos pos_arc_center tmp_vec
        VEC3_unitize tmp_vec tmp_vec1
        VEC3_cross tmp_vec1 pos_arc_axis tmp_vec
        VEC3_scale mom_arc_radius tmp_vec tmp_vec1
        VEC3_add pos_arc_center tmp_vec1 tmp_vec
        VMOV 3 tmp_vec ${namespace}$mom_output_pos_type

        MOM_do_template [CONF_CTRL_moves circular_template]
        MOM_suppress once I J K
        VMOV 3 save_pos  ${namespace}$mom_output_pos_type
        set ::mom_arc_angle [expr $::mom_arc_angle - 90.0]

        switch -- $::lib_arc_axis {
          0 {
            MOM_force once Y Z
          }
          1 {
            MOM_force once X Z
          }
          2 {
            MOM_force once X Y
          }
        }
      }

      if {[EQ_is_gt $::mom_arc_angle 360 0.1]} {
        LIB_GE_abort_message "Variable mom_arc_angle is greater than 360 degree"
      }

      if {[EQ_is_gt $::mom_arc_angle 180.0]} {
        set mom_arc_radius [expr -1.0*$mom_arc_radius]
      }
    } else {
      MOM_suppress once R
    }
  }
}
# <Internal Documentation>
# This procedure is called by MOM_circular_move and MOM_helix_move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_clamp_axis {} {


  if {[CONF_CTRL_clamp status] == 0} {return}
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {return}

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer CLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template clamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fifth_axis] == 1} {

    LIB_GE_command_buffer CLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template clamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template clamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer CLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template clamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called before each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_unclamp_axis {} {


  if {[CONF_CTRL_clamp status] == 0} {return}

  if {[CONF_CTRL_clamp fifth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FIFTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fifth_axis CREATE] != ""} {MOM_force once M_clamp_fifth; MOM_do_template unclamp_fifth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FIFTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fifth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

  if {[CONF_CTRL_clamp fourth_axis] == 1} {
    LIB_GE_command_buffer UNCLAMP_FOURTH
    LIB_GE_command_buffer {if {[MOM_do_template unclamp_fourth_axis CREATE] != ""} {MOM_force once M_clamp_fourth; MOM_do_template unclamp_fourth_axis}} @OUTPUT
    LIB_GE_command_buffer_output
  } else {
    LIB_GE_command_buffer UNCLAMP_FOURTH_CREATE
    LIB_GE_command_buffer {MOM_do_template unclamp_fourth_axis CREATE} @OUTPUT
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is called after each rotary motion
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_CTRL_rotate_axis {} {


  LIB_CTRL_unclamp_axis

  LIB_GE_command_buffer RAPID_ROTARY
  LIB_GE_command_buffer {MOM_do_template rapid_rotary} @OUTPUT
  LIB_GE_command_buffer_output

  LIB_CTRL_clamp_axis

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_nc_header {} {


  global mom_attr_PROGRAMVIEW_PROGRAM_NUMBER
  global mom_output_file_basename lib_nc_header_number
  global lib_selected_group_name mom_dnc_program_name
  global mom_lib_program_name lib_flag

  #<cam17013 new pretreatment>
  if {$lib_flag(load_pretreatment)} {
    if {[LIB_PT_get_header_var lib_selected_group_name exists]} {
      set lib_selected_group_name [LIB_PT_get_header_var lib_selected_group_name]
    } else {
      set lib_selected_group_name [LIB_PT_get_header_var mom_oper_program]
    }
  }
  if {![info exists lib_selected_group_name]} {set lib_selected_group_name ""}
  set lib_nc_header_number $mom_output_file_basename

  switch -- [CONF_CTRL_setting header_name] {
    "mom_attr_PROGRAMVIEW_PROGRAM_NUMBER" {
      if {$lib_flag(load_pretreatment)} {
      if { ![LIB_PT_get_header_var mom_attr_PROGRAMVIEW_PROGRAM_NUMBER exists] } {
        set lib_nc_header_number "0001"
      } else {
        set lib_nc_header_number [LIB_PT_get_header_var mom_attr_PROGRAMVIEW_PROGRAM_NUMBER]
        }
      } else {
        set lib_nc_header_number "0001"
      }
    }
    "output_file_basename" {set lib_nc_header_number $mom_output_file_basename}
    "selected_group" {
      set lib_nc_header_number $lib_selected_group_name
    }
    "ude_dnc_header" {
      if {[info exists mom_dnc_program_name]} {set lib_nc_header_number $mom_dnc_program_name}
    }
    "ude" {
      if {[info exists mom_lib_program_name]} {set lib_nc_header_number $mom_lib_program_name}
    }
    "ignore" {
                  return 0
    }
                "default" {
      LIB_CONF_do_prop_custom_proc CONF_CTRL_setting header_name "short_template_syntax"
    }
  }
  # Variable lib_nc_header_number is empty that means that mom_output_file_basename is used
  # and you are not in PP
  # for this case selected_group is used -- this is not ""

  if {$lib_nc_header_number == ""} {set lib_nc_header_number $lib_selected_group_name}

  if {![LIB_SPF_is_number $lib_nc_header_number]} {
    LIB_SPF_add_warning "The entry 'INS->$lib_nc_header_number<-' for the header with argument 'INS->[CONF_CTRL_setting header_name]<-' need a number as value. 0001 will be used"
    set lib_nc_header_number 0001
  }

  if {[EQ_is_gt $lib_nc_header_number 9999]} {LIB_SPF_add_warning "Header_number 'INS->$lib_nc_header_number<-' should be < 9999: 9999 will be used"}

  LIB_GE_command_buffer PROG_NUMBER
  LIB_GE_command_buffer {
      MOM_suppress once N
      MOM_do_template header_program
      } @FIRST_LINE
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure contain the output that is done before the Commentary_Header
#
# <Internal Example>
#   Siemens     %_N_${lib_nc_header_name}_MPF
#   Heidenhain  BEGIN PGM ${lib_nc_header_name} MM
#   Fanuc     O${lib_nc_header_number}
#
#____________________________________________________________________________________________
proc LIB_SPF_pt_additional_variables_fanuc {} {


  #PR9239197 Add mom_lock_axis to pretreatment
  LIB_SPF_pretreatment_add_var MOM_lock_axis mom_lock_axis 0
}
# <Internal Documentation>
#
# Entrypoint to define additional variables which should be stored in pretreatment
# Controller specific
#
# LIB_SPF_pretreatment_add_var in this proc to add return variables from pretreatment
#
# <Internal Example>
# Sample code as comment in proc body
#______________________________________________________________________________
proc LIB_CTRL_set_feed_parameter {} {


  global mom_feed_cut_unit mom_output_unit mom_feed_rate feed
  global mom_cycle_feed_rate mom_cycle_feed_rate_per_rev
  global mom_feed_engage_value mom_feed_cut_value mom_feed_retract_value mom_feed_cycle_value
  global mom_feed_engage_unit mom_feed_cut_unit mom_feed_retract_unit mom_feed_cycle_value
  global mom_operation_type mom_motion_type lib_motion_type_list
  global lib_prev_feed_cut_value lib_flag mom_tool_name mom_kin_is_turbo_output
  global lib_prev_feed_engage_value lib_prev_feed_retract_value
  global lib_prev_cycle_definition_mode mom_cycle_definition_mode
  global lib_prev_feed_engage_value lib_prev_feed_retract_value

  set lib_flag(feed_turbo_mode_disable) 0
  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {

    foreach type $lib_motion_type_list {
      set tmp_motion_type [string tolower $type]
      if {[CONF_CTRL_feed exists feed_$tmp_motion_type]} {
        if {[CONF_CTRL_feed feed_$tmp_motion_type] != "NX"} {
          set lib_flag(feed_turbo_mode_disable) 1
          set mom_kin_is_turbo_output "FALSE"
        }
      }
    }
    if {$lib_flag(feed_turbo_mode_disable) == 1} {MOM_reload_kinematics_variable mom_kin_is_turbo_output}

    # check if "drilling" "Thread Milling" "Cylinder Milling" are the previous operation and the current cycle output is different
    # to the previous operation
    if {($mom_operation_type == "Drilling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Thread Milling")} {
      if {![info exists lib_prev_cycle_definition_mode] || $lib_prev_cycle_definition_mode != $mom_cycle_definition_mode } {
        set check_cycle_definition_mode 1
      } else {
        set check_cycle_definition_mode 0
      }
      set lib_prev_cycle_definition_mode $mom_cycle_definition_mode
    } else {
      set check_cycle_definition_mode 0
      set lib_prev_cycle_definition_mode 1
    }
    if {[info level 1] != "MOM_start_of_path" || ($mom_tool_name == [LIB_SPF_get_pretreatment mom_tool_name -1]        && \
      (([info exist lib_prev_feed_cut_value]    && ![EQ_is_equal $mom_feed_cut_value $lib_prev_feed_cut_value])          || \
      ([info exist lib_prev_feed_engage_value]  && ![EQ_is_equal $mom_feed_engage_value $lib_prev_feed_engage_value])    || \
      ([info exist lib_prev_feed_retract_value] && ![EQ_is_equal $mom_feed_retract_value $lib_prev_feed_retract_value])  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Hole Making"                                                  || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Point to Point"                                               || \
      [LIB_SPF_get_pretreatment mom_operation_type -1] == "Drilling"))                                                   || \
      $check_cycle_definition_mode == 1} {

      MOM_force once F
      if {[CONF_CTRL_feed feed_engage] != "NX" && [CONF_CTRL_feed feed_engage] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_engage_value/25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_engage_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_engage_value
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_engage_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_engage_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_engage] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Engage Move"])" "output_0" "1"
      }

      if {$mom_operation_type == "Thread Milling" || $mom_operation_type == "Cylinder Milling" || $mom_operation_type == "Hole Making" || $mom_operation_type == "Point to Point" || ($mom_operation_type == "Drilling" && $::mom_cycle_definition_mode == 0)} {
        set mom_feed_rate $mom_feed_cut_value
        set mom_cycle_feed_rate $mom_feed_cut_value
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_cut_value
          set mom_cycle_feed_rate_per_rev $mom_feed_cut_value
          set mom_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
          set mom_cycle_feed_rate [expr $mom_feed_cut_value * $::mom_spindle_rpm]
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
        set mom_motion_type "CYCLE"
        LIB_SPF_feedrate_set
        if {[CONF_CTRL_feed feed_cycle] != "NX" && [CONF_CTRL_feed feed_cycle] != "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cycle] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cycle Move"])" "output_0" "1"
        } elseif {[CONF_CTRL_feed feed_cycle] == "P_CUT"} {
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cycle Move"])" "output_0" "1"
        }
      } else {
        set mom_kin_is_turbo_output "FALSE"
        if {[CONF_CTRL_feed feed_cut] != "NX" && [CONF_CTRL_feed feed_cut] != "P_CUT"} {
          if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
            set mom_feed_rate [expr $mom_feed_cut_value/25.4]
          } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
            set mom_feed_rate [expr $mom_feed_cut_value * 25.4]
          } else {
            set mom_feed_rate $mom_feed_cut_value
          }
          if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
            set mom_feed_rate_per_rev $mom_feed_cut_value
          }
          set mom_feed_rate_output_mode [string toupper $mom_feed_cut_unit]
          set mom_motion_type "UNKNOWN"
          LIB_SPF_feedrate_set
          LIB_GE_message "[CONF_CTRL_feed feed_cut] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Cutting"])" "output_0" "1"
        }
      }

      if {[CONF_CTRL_feed feed_retract] != "NX" && [CONF_CTRL_feed feed_retract] != "P_CUT"} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set mom_feed_rate [expr $mom_feed_retract_value/25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set mom_feed_rate [expr $mom_feed_retract_value * 25.4]
        } else {
          set mom_feed_rate $mom_feed_retract_value
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set mom_feed_rate_per_rev $mom_feed_retract_value
        }
        set mom_feed_rate_output_mode [string toupper $mom_feed_retract_unit]
        set mom_motion_type "UNKNOWN"
        LIB_SPF_feedrate_set
        LIB_GE_message "[CONF_CTRL_feed feed_retract] = [LIB_SPF_eliminate_zero $feed 3] ([LIB_GE_MSG "Retract Move"])" "output_0" "1"
      }

      set lib_prev_feed_cut_value $mom_feed_cut_value
      set lib_prev_feed_engage_value $mom_feed_engage_value
      set lib_prev_feed_retract_value $mom_feed_retract_value
    }
  }
}
# <Internal Documentation>
#
# Set the feed parameter if nessesary
# only if property feed_linear is set to 2(parameter)
#
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (F[#21])
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_feed_output {} {


  global mom_motion_type mom_motion_event mom_feed_cut_value mom_feed_cut_unit mom_feed_rate mom_feed_rate_per_rev
  global mom_cycle_feed_rate mom_output_unit feed_mode
  global feed lib_prev_feed lib_prev_feed_percent
  global mom_feed_engage_value mom_feed_engage_unit
  global mom_feed_retract_value mom_feed_retract_unit

  set commandcheck(LIB_CTRL_feed_output_ENTRY) [llength [info commands LIB_CTRL_feed_output_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_CTRL_feed feed_linear] == 0} {
    # use only NX-Values
  } elseif {[CONF_CTRL_feed feed_linear] == 1} {
    # use FAUTO (Feed from Tool definition
  } elseif {[CONF_CTRL_feed feed_linear] == 2} {
    set tmp_motion_type [string tolower $mom_motion_type]

    if {[CONF_CTRL_feed feed_$tmp_motion_type] == "NX"} {
      if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
        MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
      } else {
        switch -- $feed_mode {
          IPM     -
          MMPM    -
          IPR     -
          MMPR    -
          DPM     -
          FRN     {
            MOM_set_address_format F Feed_${feed_mode}
            }
          INVERSE {MOM_set_address_format F Feed_INV}
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "P_CUT"} {
      if {(![string match "rapid" $tmp_motion_type] && ![string match "traverse" $tmp_motion_type] && ![string match "approach" $tmp_motion_type] \
      && ![string match "departure" $tmp_motion_type]) || $mom_feed_rate != $::mom_kin_rapid_feed_rate} {
      MOM_set_address_format F String
      if {![info exist lib_prev_feed] || (![EQ_is_equal $feed $mom_feed_cut_value] && $feed != $lib_prev_feed)} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
          set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
          set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
          if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
          set feed "\[[CONF_CTRL_feed feed_cut]*$tmp_feed_percent\]"
          set lib_prev_feed_percent $tmp_feed_percent
      } else {
          set feed "\[[CONF_CTRL_feed feed_cut]\]"
        }
      }
      set lib_prev_feed $feed
    } elseif {[CONF_CTRL_feed feed_$tmp_motion_type] == "MAX"} {
      MOM_set_address_format F String
      set feed [CONF_CTRL_feed feed_$tmp_motion_type]
    } else {
      MOM_set_address_format F String
      set tmp_feed $feed
      if {$tmp_motion_type == "cycle"} {
        set mom_cycle_feed_rate "\[[CONF_CTRL_feed feed_$tmp_motion_type]\]"
      }
      set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]\]"
      if {$tmp_motion_type == "cut" && ![EQ_is_equal $mom_feed_rate $mom_feed_cut_value]} {
        if {[string range [string toupper $mom_feed_cut_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_cut_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_cut_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_cut_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      if {$tmp_motion_type == "engage" && ![EQ_is_equal $mom_feed_rate $mom_feed_engage_value]} {
        if {[string range [string toupper $mom_feed_engage_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_engage_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_engage_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_engage_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      if {$tmp_motion_type == "retract" && ![EQ_is_equal $mom_feed_rate $mom_feed_retract_value]} {
        if {[string range [string toupper $mom_feed_retract_unit] 0 1] == "MM" && $mom_output_unit != "MM"} {
          set tmp_feed_rate [expr $mom_feed_rate * 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev * 25.4]
        } elseif {[string range [string toupper $mom_feed_retract_unit] 0 1] != "MM" && $mom_output_unit != "IN"} {
          set tmp_feed_rate [expr $mom_feed_rate / 25.4]
          set tmp_feed_rate_per_rev [expr $mom_feed_rate_per_rev / 25.4]
        } else {
          set tmp_feed_rate $mom_feed_rate
          set tmp_feed_rate_per_rev $mom_feed_rate_per_rev
        }
        if {[string match *PR* [string toupper $mom_feed_retract_unit]]} {
          set tmp_feed_rate $tmp_feed_rate_per_rev
        }
        set tmp_feed_percent [expr ($tmp_feed_rate/$mom_feed_retract_value)]
        set tmp_feed_percent [LIB_SPF_eliminate_zero $tmp_feed_percent 3]
        if {![info exists lib_prev_feed_percent] || ![EQ_is_equal $lib_prev_feed_percent $tmp_feed_percent]} {
          MOM_force once F
        }
        set lib_prev_feed_percent $tmp_feed_percent
        if {![EQ_is_equal $tmp_feed_percent 1.0]} {
          set feed "\[[CONF_CTRL_feed feed_$tmp_motion_type]*$tmp_feed_percent\]"
        }
      }
      set lib_prev_feed $tmp_feed
    }

  } else {
    # use only NX-Values
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_feed_output_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_feed_output_ENTRY)} {LIB_CTRL_feed_output_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Output the feed dependent on the setting
# NX      normal feedrate output
# P_CUT   feedrate output as percentage of Cut Feed
# Param   feedrate output as Parameter (FQ21)
#
#
# <Internal Example>
#
#______________________________________________________________________________
proc LIB_CTRL_cut_move_LIB {} {


  set commandcheck(LIB_CTRL_cut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cut_move_LIB_ENTRY)} {LIB_CTRL_cut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_rapid_move_LIB {} {


  set commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY) [llength [info commands LIB_CTRL_rapid_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_rapid_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_rapid_move_LIB_ENTRY)} {LIB_CTRL_rapid_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_engage_move_LIB {} {


  set commandcheck(LIB_CTRL_engage_move_LIB_ENTRY) [llength [info commands LIB_CTRL_engage_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_engage_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_engage_move_LIB_ENTRY)} {LIB_CTRL_engage_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_retract_move_LIB {} {


  set commandcheck(LIB_CTRL_retract_move_LIB_ENTRY) [llength [info commands LIB_CTRL_retract_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_retract_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_retract_move_LIB_ENTRY)} {LIB_CTRL_retract_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_firstcut_move_LIB {} {


  set commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_firstcut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_firstcut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_firstcut_move_LIB_ENTRY)} {LIB_CTRL_firstcut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_approach_move_LIB {} {


  set commandcheck(LIB_CTRL_approach_move_LIB_ENTRY) [llength [info commands LIB_CTRL_approach_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_approach_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_approach_move_LIB_ENTRY)} {LIB_CTRL_approach_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_stepover_move_LIB {} {


  set commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY) [llength [info commands LIB_CTRL_stepover_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_stepover_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_stepover_move_LIB_ENTRY)} {LIB_CTRL_stepover_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_departure_move_LIB {} {


  set commandcheck(LIB_CTRL_departure_move_LIB_ENTRY) [llength [info commands LIB_CTRL_departure_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_departure_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_departure_move_LIB_ENTRY)} {LIB_CTRL_departure_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_return_move_LIB {} {


  set commandcheck(LIB_CTRL_return_move_LIB_ENTRY) [llength [info commands LIB_CTRL_return_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_return_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_return_move_LIB_ENTRY)} {LIB_CTRL_return_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_traversal_move_LIB {} {


  set commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY) [llength [info commands LIB_CTRL_traversal_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_traversal_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_traversal_move_LIB_ENTRY)} {LIB_CTRL_traversal_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sidecut_move_LIB {} {


  set commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY) [llength [info commands LIB_CTRL_sidecut_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_sidecut_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_sidecut_move_LIB_ENTRY)} {LIB_CTRL_sidecut_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_from_move_LIB {} {


  set commandcheck(LIB_CTRL_from_move_LIB_ENTRY) [llength [info commands LIB_CTRL_from_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_from_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_from_move_LIB_ENTRY)} {LIB_CTRL_from_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_move_LIB {} {


  set commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_move_LIB_ENTRY)} {LIB_CTRL_gohome_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_gohome_default_move_LIB {} {


  set commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY) [llength [info commands LIB_CTRL_gohome_default_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_gohome_default_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_gohome_default_move_LIB_ENTRY)} {LIB_CTRL_gohome_default_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}

# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_cycle_move_LIB {} {


  set commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY) [llength [info commands LIB_CTRL_cycle_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_cycle_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_cycle_move_LIB_ENTRY)} {LIB_CTRL_cycle_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_lift_move_LIB {} {


  set commandcheck(LIB_CTRL_lift_move_LIB_ENTRY) [llength [info commands LIB_CTRL_lift_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_lift_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_lift_move_LIB_ENTRY)} {LIB_CTRL_lift_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_undefined_move_LIB {} {


  set commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY) [llength [info commands LIB_CTRL_undefined_move_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_CTRL_undefined_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_undefined_move_LIB_ENTRY)} {LIB_CTRL_undefined_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function correspond from the first PB integration and should not be used.
# From founders of legacy this can not be deleted.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_standard_path_between_rotary_motions_checking {{option default}} {


  global mom_out_angle_pos mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global prev_convert_mom_out_angle_pos mom_prev_pos mom_pos

  switch -- $option {
    "pos_to_sim"  {
      # motion POS to SIM

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_prev_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_prev_pos(3) 0
      }

      MOM_reload_variable -a mom_prev_pos

    }
    "pos_to_sim_next" {
      # motion POS to SIM

      if {[info exists prev_convert_mom_out_angle_pos]} {
        set mom_pos(3) $prev_convert_mom_out_angle_pos(0)
      } else {
        set mom_pos(3) 0
      }

      MOM_reload_variable -a mom_pos

    }
    "sim_to_pos" {
      # motion SIM to POS
    }
  }
}
# <Internal Documentation>
#
# Used when [CONF_CTRL_moves standard_path_between_rotary_motions] == 1 for internal tool path
# Set right rotary position when lib_flag(mode_current_status) changes
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_config_millturn {} {


  if {[CONF_SPF_advanced_settings chain_init] != "0"} {
    LIB_CONF_do_prop_custom_proc CONF_SPF_advanced_settings chain_init
    LIB_GE_copy_var_range lib_sav_sys_leader mom_sys_leader
  }
}
# <Internal Documentation>
# This procedure is called at each start_of_path and machine_mode events.
# It's implemented for multi chains. Content of [CONF_SPF_advanced_settings chain_init] is executed
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_version_mom_sys {} {
  global mom_sys_feed_rate_mode_code mom_sys_spindle_max_rpm_code mom_sys_output_code mom_sys_cycle_ret_code
  global mom_sys_lathe_thread_advance_type

}
# <Internal Documentation>
# Can be used to update mom_sys variables dependent on properties settings.
# This proc is called by LIB_SPF_default_initial_setting "default"
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_CTRL_polar_transmit {{mess "on"}} {
  global mom_motion_event mom_motion_type mom_prev_pos mom_pos mom_machine_mode
  global mom_sys_leader
  global polar_mode_status lib_flag

  if {$mom_machine_mode == "TURN" || [string match "point*" [LIB_SPF_ask_operation_type]] || [string match "probe*" [LIB_SPF_ask_operation_type]]} {return}

  if {[CONF_CTRL_moves polar_transmit] == "ON"} {
    if {$mess == "on"} {
      if {$lib_flag(first_transmit_move) == 0} {
        set polar_mode_status "ON"
        set lib_flag(first_transmit_move) 1 ;# first motion is not recalculated in polar mode anymore
      }
    } elseif {$mess == "start" && [info exists polar_mode_status] && $polar_mode_status == "ON"} {
      LIB_GE_command_buffer POLAR_MODE
      LIB_GE_command_buffer {
        set mom_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        set mom_prev_pos([expr 3+$lib_flag(polar_rotary_axis)]) 0.0
        MOM_reload_variable -a mom_prev_pos
        MOM_reload_variable -a mom_pos

        if {[CONF_CTRL_moves prepos_before_transmit] == "5th" || [CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
          if {$lib_flag(polar_rotary_axis) == 0} {
            set lib_flag(save_clamp_fourth_axis_setting) [CONF_CTRL_clamp fourth_axis]
            if {[CONF_CTRL_clamp fourth_axis] == 1} {
              MOM_do_template unclamp_fourth_axis
              MOM_do_template fourth_axis_rotate_move
              CONF_CTRL_clamp set fourth_axis 0
            } else {
              MOM_do_template fourth_axis_rotate_move
            }
          } else {
            set lib_flag(save_clamp_fifth_axis_setting) [CONF_CTRL_clamp fifth_axis]
            if {[CONF_CTRL_clamp fifth_axis] == 1} {
              MOM_do_template unclamp_fifth_axis
              MOM_do_template fifth_axis_rotate_move
              CONF_CTRL_clamp set fifth_axis 0
            } else {
              MOM_do_template fifth_axis_rotate_move
            }
          }
          if {[CONF_CTRL_moves prepos_before_transmit] == "5th_Z_X"} {
            LIB_SPF_decompose_block_template "{Z} {X}" prepos_transmit FORCE [join "{Z} {X}"]
          }
        } elseif {[CONF_CTRL_moves prepos_before_transmit] != ""} {
          LIB_CONF_do_prop_custom_proc CONF_CTRL_moves prepos_before_transmit "short_template_syntax"
        }

        set mom_sys_leader(Y) "C"
        if {$mom_motion_event == "rapid_move"} {set mom_motion_event "linear_move"}

        set lib_flag(save_rapid_template)  [CONF_CTRL_moves rapid_template]
        CONF_CTRL_moves set rapid_template [CONF_CTRL_moves linear_template]
        set mom_sys_rapid_code 1 ;# advanced turbo mode
      } @OUTPUT_ROTARY_AXIS

      LIB_GE_command_buffer {
        MOM_do_template polar_mode
      } @OUTPUT
      LIB_GE_command_buffer_output

      set lib_flag(first_transmit_move) 1
      if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_enable_address Y}
    }
  }

  if {$mess == "off" && [info exists lib_flag(first_transmit_move)] && $lib_flag(first_transmit_move) == 1} {
    set polar_mode_status "OFF"

    LIB_GE_command_buffer TRAFOFF
    LIB_GE_command_buffer {
      MOM_do_template polar_mode

      set mom_sys_leader(Y) "Y"
      if {$lib_flag(polar_rotary_axis) == 0} {
        MOM_force once fourth_axis
        if {[info exists lib_flag(save_clamp_fourth_axis_setting)]} {CONF_CTRL_clamp set fourth_axis $lib_flag(save_clamp_fourth_axis_setting)}
      } else {
        MOM_force once fifth_axis
        if {[info exists lib_flag(save_clamp_fifth_axis_setting)]} {CONF_CTRL_clamp set fifth_axis $lib_flag(save_clamp_fifth_axis_setting)}
      }
      #PR9261330 check if exists lib_flag(save_rapid_template)
      if {[info exists lib_flag(save_rapid_template)]} {
        CONF_CTRL_moves set rapid_template $lib_flag(save_rapid_template)
        set mom_sys_rapid_code 0 ;# advanced turbo mode
        unset lib_flag(save_rapid_template)
      }
    } @OUTPUT
    LIB_GE_command_buffer_output

    set lib_flag(first_transmit_move) 0
    if {$::lib_machine_mode == "3_AXIS_MILL_TURN"} {MOM_disable_address Y}
  }
}
# <Internal Documentation>
# It's used to output polar code with axial mode when [CONF_CTRL_moves polar_transmit] property is set to 1
# This proc is called by LIB_SPF_polar_cart
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread_LIB {} {

  set commandcheck(MOM_lathe_thread_LIB_ENTRY) [llength [info commands MOM_lathe_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_LIB_ENTRY)} {MOM_lathe_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_start_of_thread_LIB {} {

  set commandcheck(MOM_start_of_thread_LIB_ENTRY) [llength [info commands MOM_start_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 1

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_LIB_ENTRY)} {MOM_start_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_lathe_thread_move_LIB {} {


  global mom_prev_pos mom_pos mom_lathe_thread_lead_i mom_lathe_thread_lead_k
  global thread_type

  set commandcheck(MOM_lathe_thread_move_LIB_ENTRY) [llength [info commands MOM_lathe_thread_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if { [EQ_is_zero $mom_lathe_thread_lead_i] } {
    MOM_suppress once I ; MOM_force once K
  } elseif { [EQ_is_zero $mom_lathe_thread_lead_k] } {
    MOM_suppress once K ; MOM_force once I
  } else {
    MOM_force once I ; MOM_force once K
  }

  LIB_GE_command_buffer OUTPUT
  LIB_GE_command_buffer { MOM_do_template lathe_thread_move } @MOVE
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_LIB_ENTRY)} {MOM_lathe_thread_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc MOM_end_of_thread_LIB {} {

  set commandcheck(MOM_end_of_thread_LIB_ENTRY) [llength [info commands MOM_end_of_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  set lib_flag(lathe_thread_motion) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_LIB_ENTRY)} {MOM_end_of_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM-Event and controls the handling of the controller
#
# The function should not be overwritten, this can be controlled with the standard mechnismen
# as described in the documentations. Changes will lead to an undesirable behavior.
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_channel_init {} {


  LIB_GE_command_buffer LIB_CTRL_channel_init
  LIB_GE_command_buffer {MOM_do_template channel_init CREATE} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_start_of_program event
#
# Specially useful for multichannels machine to reset addresses at the beginning of for each channel
#
# <Internal Example>
# >> This function is a black box procedure <<
#____________________________________________________________________________________________
proc LIB_CTRL_sys_leader_home {} {
  #this proc is only here for documentation purposes.
  #the real proc should be created in service layer
}
# <Internal Documentation>
# This function is called from MOM_start_of_path event
#
# Helpful to redefine mom_sys_leader variables overwritten by the original ones with the normal run
# This procedure should be redefined in service layer
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_subop_path_LIB {} {


  global mom_inter_opr_rule_intent mom_RTCP lib_flag lib_pretreatment mom_path_name
  global mom_current_oper_is_last_oper_in_program mom_fixture_offset_value mom_output_for_mcs
  global mom_ToolMountJunction mom_tool_adjust_register
  global lib_kin_4th_axis_point lib_kin_5th_axis_point
  global mom_kin_4th_axis_point mom_kin_5th_axis_point

  if {![info exists lib_kin_4th_axis_point]} {
    # Save mom_kin_4th/5th_axis_point of rtcp-on mode to reload kinematic after its rtcp mode change
    array set lib_kin_4th_axis_point "0 $mom_kin_4th_axis_point(0) 1 $mom_kin_4th_axis_point(1) 2 $mom_kin_4th_axis_point(2)"
    array set lib_kin_5th_axis_point "0 $mom_kin_5th_axis_point(0) 1 $mom_kin_5th_axis_point(1) 2 $mom_kin_5th_axis_point(2)"
  }

  if {![info exists mom_inter_opr_rule_intent]} {
    return
  }
  # A rtcp mode event is defined, do nothing
  if {[string match $mom_inter_opr_rule_intent ""]} {
    if {[string match $mom_RTCP "OFF"]} {
      set lib_flag(tcpm_mode) 0
    }
    return
  }

  # <cam17013.16 Interop path> Handle tool change event and set MCS events defined in transition path
  if {[string match $mom_inter_opr_rule_intent "'Tool Change Container"]} {
    if {$lib_flag(tcpm_mode) == 1} {
      LIB_CTRL_set_tcpm_mode OFF
    }
    set lib_flag(tcpm_mode) 1
    return
  } elseif {[string match $mom_inter_opr_rule_intent "'Output for MCS"]} {
    # Set mcs for transition path
    switch -- $mom_output_for_mcs {
      "0" {
        # output current operation mcs
        if {$mom_current_oper_is_last_oper_in_program == "YES"} {
          LIB_SPF_add_warning "Operation $mom_path_name is the last operation in program. Switch to MCS of previous operation."
          set mom_fixture_offset_value [LIB_SPF_get_pretreatment mom_fixture_offset_value -1]
        } else {
          set mom_fixture_offset_value [LIB_SPF_get_pretreatment mom_fixture_offset_value 1]
        }
      }
      "1" {
        # output previous operation mcs
        if {[lsearch -exact $lib_pretreatment(operation_list) $mom_path_name] == 0} {
          LIB_SPF_add_warning "Operation $mom_path_name is the first operation in program. Switch to MCS of current operation."
          set mom_fixture_offset_value [LIB_SPF_get_pretreatment mom_fixture_offset_value 1]
        } else {
          set mom_fixture_offset_value [LIB_SPF_get_pretreatment mom_fixture_offset_value -1]
        }
      }
      "2" {
        # output MTCS (G53 non-model)
      }
    }
    set lib_flag(interop_mcs_change) $mom_output_for_mcs
  }

  if {[info exists mom_ToolMountJunction] && [string match $mom_ToolMountJunction "OFF"]} {
    if {$lib_flag(tcpm_mode) == 1 && [string match $mom_RTCP "OFF"]} {
      LIB_CTRL_set_tcpm_mode OFF
      LIB_SPF_calc_4th5th_axis_points
    }

    if {$lib_flag(tcpm_mode) == 0} {
      if {[string match $mom_RTCP "ON"]} {
        LIB_CTRL_set_tcpm_mode ON
      } else {
        MOM_force once G_adjust H
      }
    }
  } else {
    if {[string match $mom_RTCP "ON"]} {
      LIB_CTRL_set_tcpm_mode OFF
    }
    set mom_tool_adjust_register 0
  }
}
# <Internal Documentation>
# This function is called from MOM_start_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_subop_path_LIB {} {


  global mom_tool_adjust_register mom_ToolMountJunction lib_prev_tool_adjust_register lib_flag

  if {[info exists mom_ToolMountJunction] && [string match $mom_ToolMountJunction "ON"]} {
    set mom_tool_adjust_register $lib_prev_tool_adjust_register
    if {$lib_flag(interop_mcs_change) != 2} {
      MOM_force once G_csys_rot
      LIB_CTRL_set_tcpm_mode OFF
    }
  }
}
# <Internal Documentation>
# This function is called from MOM_end_of_subop_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_transition_path_lib {} {

  set commandcheck(MOM_start_of_transition_path_LIB_ENTRY) [llength [info commands MOM_start_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag mom_path_name lib_pretreatment mom_RTCP tcpm_type
  global mom_tool_adjust_register lib_prev_tool_adjust_register

  # <17013.16 Interop path> Exit tool path and enter transition path
  if {$lib_flag(mode_current_status) == "pos"} {
    if {[CONF_CTRL_setting plane_output_supported] == "NONE"} {
      LIB_ROTARY_absolute_reset
    } else {
      LIB_ROTARY_positioning_reset
    }
  } elseif {$lib_flag(mode_current_status) == "sim"} {
    if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
      LIB_ROTARY_absolute_reset
    } else {
      LIB_ROTARY_simultaneous_reset
    }
  }
  set lib_flag(tool_path_motion) 0
  set lib_flag(interop_mcs_change) 0
  set lib_flag(tcpm_mode) 0
  if {![info exists lib_prev_tool_adjust_register]} {
    set lib_prev_tool_adjust_register 0
  }

  if {[lsearch -exact $lib_pretreatment(operation_list) $mom_path_name] == 0} {
    # In first transition path, close tool length compensation to support simulation without tool
    set mom_tool_adjust_register 0
  } else {
    # Current transition path have the same tool number with next tool path, but it uses previous tool and its adjust register until tool change event
    set mom_tool_adjust_register $lib_prev_tool_adjust_register
  }

  LIB_GE_command_buffer MCS_INIT
  LIB_GE_command_buffer {
    if {[llength [info commands LIB_main_origin_call]]} {LIB_main_origin_call}
  } @INTEROP_ORIGIN
  LIB_GE_command_buffer_output

  # Initialize tcpm type
  if {[CONF_CTRL_setting tcpm_output] == "angle"} {
    set tcpm_type 1
    MOM_disable_address X_vector Y_vector Z_vector
  } elseif {[CONF_CTRL_setting tcpm_output] == "vector"} {
    set tcpm_type 2
    MOM_disable_address fourth_axis fifth_axis
  }

  # The default RTCP mode is "ON"
  if {[string match $mom_RTCP "ON"]} {
    LIB_CTRL_set_tcpm_mode ON
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_LIB_ENTRY)} {MOM_start_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This function is called from MOM_start_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_transition_path_lib {} {


  set commandcheck(MOM_end_of_transition_path_LIB_ENTRY) [llength [info commands MOM_end_of_transition_path_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_current_oper_is_last_oper_in_program mom_RTCP mom_tool_adjust_register lib_prev_tool_adjust_register

  LIB_CTRL_set_tcpm_mode OFF
  LIB_SPF_set_output_pos

  # <cam17013.16 Interop path> next tool path has tool change event
  if {[LIB_SPF_get_pretreatment mom_tool_change_type 1] != 0 ||\
    $mom_current_oper_is_last_oper_in_program == "YES"} {
    LIB_GE_command_buffer TOOL_CHANGE_OR_END
    LIB_GE_command_buffer {LIB_local_origin_reset} @LOCAL_ORIG_RESET
    LIB_GE_command_buffer {LIB_WRITE_coolant off}  @COOLANT_OFF
    LIB_GE_command_buffer {LIB_SPINDLE_end} @SPINDLE_OFF
    LIB_GE_command_buffer {
      if {$mom_current_oper_is_last_oper_in_program == "YES"} {
        if {[CONF_CTRL_moves return_end_of_pgm] != ""} {
          LIB_RETURN_move CONF_CTRL_moves return_end_of_pgm
        }
      } else {
        if {[CONF_CTRL_moves return_tool_change_pos] != ""} {
          LIB_RETURN_move CONF_CTRL_moves return_tool_change_pos
        }
      }
    } @RETURN_MOVE
    LIB_GE_command_buffer_output
  }

  set lib_prev_tool_adjust_register $mom_tool_adjust_register

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_transition_path_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_LIB_ENTRY)} {MOM_end_of_transition_path_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This function is called from MOM_end_of_transition_path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_machine_axis_move_LIB {} {
  set commandcheck(MOM_machine_axis_move_LIB_ENTRY) [llength [info commands MOM_machine_axis_move_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_axis_move_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_LIB_ENTRY)} {MOM_machine_axis_move_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This function is called from MOM_machine_axis_move.
# mom_xaxis_status 1 - have a user defined axis value: machine limit or specify
#                  0 - not active
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_set_tcpm_mode {{option "ON"}} {


  global lib_flag lib_kin_4th_axis_point lib_kin_5th_axis_point
  global mom_kin_4th_axis_point mom_kin_5th_axis_point

  if {$option == "ON"} {
    LIB_GE_command_buffer INTEROP_TCPM_INIT
    LIB_GE_command_buffer {
      MOM_do_template tool_length_adjust CREATE
      MOM_force once H
    } @INTEROP_TOOL_LENGTH_ADJUST
    LIB_GE_command_buffer {
      MOM_set_address_format G_csys_rot Zero_real
      MOM_do_template set_tcpm_on
      MOM_set_address_format G_csys_rot Digit_2
    } @INTEROP_ROTARY_SIMULTANEOUS
    LIB_GE_command_buffer_output

    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_output] == "vector" ||\
    ([CONF_CTRL_setting tcpm_output] == "angle" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos "::" "mom_mcs_goto"
    }

    if {[info exists lib_kin_4th_axis_point]} {
      array set mom_kin_4th_axis_point "0 $lib_kin_4th_axis_point(0) 1 $lib_kin_4th_axis_point(1) 2 $lib_kin_4th_axis_point(2)"
      array set mom_kin_5th_axis_point "0 $lib_kin_5th_axis_point(0) 1 $lib_kin_5th_axis_point(1) 2 $lib_kin_5th_axis_point(2)"
      # Update mom_kin_4th/5th_axis_point in core code
      MOM_reload_kinematics_variable mom_kin_4th_axis_point mom_kin_5th_axis_point
    }

    set lib_flag(tcpm_mode) 1
  } else {
    if {[CONF_CTRL_setting tcpm_output] == "angle"} {
      LIB_GE_command_buffer INTEROP_RESET_G434
      LIB_GE_command_buffer {
        MOM_force once G_csys_rot
        MOM_do_template set_tcpm_off
      } @INTEROP_TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @INTEROP_ADJUST_OFF
      LIB_GE_command_buffer_output
    } elseif {[CONF_CTRL_setting tcpm_output] == "vector"} {
      LIB_GE_command_buffer INTEROP_RESET_G435
      LIB_GE_command_buffer {
        MOM_do_template set_tcpm_off
      } @INTEROP_TCPM_OFF
      LIB_GE_command_buffer {
        MOM_do_template tool_length_adjust_off CREATE
      } @INTEROP_ADJUST_OFF
      LIB_GE_command_buffer_output
    }

    if {$lib_flag(local_namespace_output) && ([CONF_CTRL_setting tcpm_output] == "vector" ||\
      ([CONF_CTRL_setting tcpm_output] == "angle" && [CONF_CTRL_setting fix_on_machine] != 0))} {
      LIB_SPF_set_output_pos
    }

    set lib_flag(tcpm_mode) 0
  }
}
# <Internal Documentation>
# This function is used to set tcpm mode status (ON/OFF) in transition path.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_CTRL_set_3P2_rotate_dir {} {


  global mom_kin_machine_type mom_sys_leader
  global mom_init_pos mom_init_alt_pos mom_pos mom_alt_pos mom_out_angle_pos mom_prev_out_angle_pos
  global mom_kin_4th_axis_direction mom_kin_4th_axis_leader mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_kin_5th_axis_direction mom_kin_5th_axis_leader mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_operation_is_interop plane_init_pos lib_flag

  # for simultaneous operation, if enabling prepositioning tool, forbid fourth and fifth axis rotation direction setting
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [CONF_SPF_sim_kin tcpm_prepos_plane] == 1} {
    return
  }

  # Don't reselect solution if transition path exists
  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
    return
  }

  set rotate_dir [CONF_TEMPLATE_3P2 rotate_dir]
  if {[info exists lib_flag(preferred_solution)] && $lib_flag(preferred_solution) != "OFF"} {
    if {[CONF_TEMPLATE_3P2 rotate_dir] == "-" || [CONF_TEMPLATE_3P2 rotate_dir] == "+"} {
      LIB_SPF_add_warning "Set Preferred Solution is using, 3D rotate direction set to Auto"
      set rotate_dir 0
    }
  }

  if {[LIB_SPF_csys_examine_local] == "rotation"} {
    if {![string compare "5_axis_dual_head" $mom_kin_machine_type]} {
      set master_axis 4
    } else {
      set master_axis 3
    }

    if {$lib_flag(local_namespace_output) == 1} {
      set mom_init_pos(3) 0
      set mom_init_pos(4) 0
    } else {
      set plane_init_pos(3) [LIB_SPF_rotset $plane_init_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
      $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
      $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

      set plane_init_pos(4) [LIB_SPF_rotset $plane_init_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
      $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
      $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]

      if {($rotate_dir == "-" && [EQ_is_gt $plane_init_pos($master_axis) 0.0]) || \
      ($rotate_dir == "+" && [EQ_is_lt $plane_init_pos($master_axis) 0.0])} {

        set mom_init_pos(3) [LIB_SPF_rotset $mom_init_alt_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
        $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
        $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

        set mom_init_pos(4) [LIB_SPF_rotset $mom_init_alt_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
        $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
        $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]
      } else {
        # If user defines a local coordinate system, $mom_init_pos won't be zero and may excess angle limit.
        set mom_init_pos(3) [LIB_SPF_rotset $mom_init_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
        $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
        $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

        set mom_init_pos(4) [LIB_SPF_rotset $mom_init_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
        $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
        $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]
      }
    }

  } else {
    if {![string compare "5_axis_dual_head" $mom_kin_machine_type]} {
      set master_axis 1
    } else {
      set master_axis 0
    }
    if {($rotate_dir == "-" && [EQ_is_gt $mom_out_angle_pos($master_axis) 0.0]) || \
    ($rotate_dir == "+" && [EQ_is_lt $mom_out_angle_pos($master_axis) 0.0])} {

      set mom_out_angle_pos(0) [LIB_SPF_rotset $mom_alt_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction \
      $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) \
      $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]

      set mom_out_angle_pos(1) [LIB_SPF_rotset $mom_alt_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction \
      $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) \
      $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]
    }
  }

}
# <Internal Documentation>
# This function is used to set fourth and fifth axis angles output value according to user option.
# It is called from LIB_ROTARY_positioning_init.
#
# <Internal Example>
#____________________________________________________________________________________________

# template_service_template.tcl

proc postcon_initialize_sys_service {} {

  uplevel #0 {

#STAY#    ########## SYSTEM VARIABLE DECLARATIONS ##############
#STAY#    set mom_sys_cir_vector                        "Vector - Arc Start to Center"
#STAY#    set mom_sys_helix_pitch_type                  "rise_revolution"
#STAY#    set mom_sys_zero                              "0"
#STAY#    set mom_sys_opskip_block_leader               "/"
#STAY#    set mom_sys_seqnum_start                      "10"
#STAY#    set mom_sys_seqnum_incr                       "10"
#STAY#    set mom_sys_seqnum_freq                       "1"
#STAY#    set mom_sys_seqnum_max                        "9999"
#STAY#    set mom_sys_lathe_x_factor                    "1"
#STAY#    set mom_sys_lathe_y_factor                    "1"
#STAY#    set mom_sys_lathe_z_factor                    "1"
#STAY#    set mom_sys_lathe_i_factor                    "1"
#STAY#    set mom_sys_lathe_j_factor                    "1"
#STAY#    set mom_sys_lathe_k_factor                    "1"
#STAY#    set mom_sys_leader(N)                         "N"
#STAY#    set mom_sys_cycle_feed_mode                   "MMPM"
#STAY#    set mom_sys_feed_param(IPM,format)            "Feed_IPM"
#STAY#    set mom_sys_feed_param(IPR,format)            "Feed_IPR"
#STAY#    set mom_sys_feed_param(FRN,format)            "Feed_INV"
#STAY#    set mom_sys_contour_feed_mode(ROTARY)         "MMPM"
#STAY#    set mom_sys_contour_feed_mode(LINEAR_ROTARY)  "MMPM"
#STAY#    set mom_sys_feed_param(DPM,format)            "Feed_DPM"
#STAY#    set mom_sys_rapid_feed_mode(ROTARY)           "MMPM"
#STAY#    set mom_sys_rapid_feed_mode(LINEAR_ROTARY)    "MMPM"
#STAY#    set mom_sys_feed_param(MMPM,format)           "Feed_MMPM"
#STAY#    set mom_sys_feed_param(MMPR,format)           "Feed_MMPR"
#STAY#    set mom_sys_linearization_method              "angle"
#STAY#
#STAY#    ####### KINEMATIC VARIABLE DECLARATIONS ##############
#STAY#    set mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_4th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_4th_axis_rotation                 "standard"
#STAY#    set mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
#STAY#    set mom_kin_5th_axis_incr_switch              "OFF"
#STAY#    set mom_kin_5th_axis_rotation                 "standard"
#STAY#    set mom_kin_clamp_time                        "2.0"
#STAY#    set mom_kin_cycle_plane_change_per_axis       "0"
#STAY#    set mom_kin_cycle_plane_change_to_lower       "0"
#STAY#    set mom_kin_flush_time                        "2.0"
#STAY#    set mom_kin_linearization_flag                "1"
#STAY#    set mom_kin_linearization_tol                 "0.01"
#STAY#    set mom_kin_max_dpm                           "10000"
#STAY#    set mom_kin_max_fpm                           "15000"
#STAY#    set mom_kin_max_fpr                           "1000"
#STAY#    set mom_kin_max_frn                           "1000"
#STAY#    set mom_kin_min_dpm                           "0.0"
#STAY#    set mom_kin_min_fpm                           "0.1"
#STAY#    set mom_kin_min_fpr                           "0.1"
#STAY#    set mom_kin_min_frn                           "0.01"
#STAY#    set mom_kin_pivot_gauge_offset                "0.0"
#STAY#    set mom_kin_rapid_feed_rate                   "10000"
#STAY#    set mom_kin_retract_distance                  "500"
#STAY#    set mom_kin_rotary_axis_method                "PREVIOUS"
#STAY#    set mom_kin_tool_change_time                  "12.0"
#STAY#    set mom_kin_x_axis_limit                      "1000"
#STAY#    set mom_kin_y_axis_limit                      "1000"
#STAY#    set mom_kin_z_axis_limit                      "1000"

  }
}


# lib_document.tcl

proc LIB_DC_complete_formatline {string character} {

  set result ""
  foreach e $character {
    set escape {[ ] $}
    if {[string first $character $escape] != -1} {
      LIB_GE_abort_message "Not supported character at LIB_DC_complete_formatline" "Character '$character' is not possible for processing"
    }
    set escape {. \ + * ? ^ ( ) { } = ! < > | : -}
    if {[string first $character $escape] != -1} {set x "\\$e"} else {set x $e}
    set search "${x}(\[0-9\]+)${x}"
    while {[regexp -- [subst -nocommands -nobackslashes $search] $string all number]} {

      set result ""
      for { set n 1 } { $n <= $number } { incr n } {
        append result "$e"
      }

      regsub -- (?q)$all $string $result string
    }
  }
  return $string
}

# <Documentation>
# This procedure formats a string with a specified number of repeated characters.
# Use this procedure to format a simple line like "=========="
# or to format more complex strings using string lists as an input argument.
# The string must be defined in the following format:
# "character-number of repetitions-character".
#
# <Arguments>
# string
# String or string list in the requested format for each element
# (character-number-character).
# character
# Characters to be considered for repetitions in the string (list).
#
# <Returnvalue>
# formated string.
#
# <Example>
# name: Simple example
# code: set result [LIB_DC_complete_formatline "=10=" "="]
# desc: This example considers the character = in the string and repeats it 10 times.
# The variable result is equal to ==========.
# <Example>
# name: Complex example
# code: set formatline "| <3< :  <5<  <10< : >4> 5 |"
#      set variable [LIB_DC_complete_formatline $formatline [list "<" ">" " "]]
# desc: The procedure considers the characters <, > and  the space character in the string list
# and substitutes the defined string.
# The variable result is equal to | <<< : <<<<< <<<<<<<<<< : >>>> |.
#____________________________________________________________________________________________
proc LIB_DC_format_string {string character {ellipsis -1}} {

  global lib_dc_sub_character         ;# substitution character
  global lib_dc_left_justify lib_dc_right_justify   ;# characters of format string which define the text justification

  set string [LIB_DC_complete_formatline $string [list "<" ">" " " "="]]

  # analyze format string
  set lae [string length $string] ;# position of last element (string starts at 0!)

  set anz 0 ;# number of format elements
  set ipos 0

  for {set i 0} {$i < $lae} {incr i 1} {
    set pos [string range $string $i $i]  ;# go through string character by character
    if {$pos == [CONF_DC_settings left_justify] || $pos == [CONF_DC_settings right_justify]} {
      if {$ipos == 0} {
        # start of a formatstring
        set ipos 1 ;# Indicator that formatstring has started
        incr anz 1
        set eintrag($anz,p) $i
        if {$pos == [CONF_DC_settings left_justify]} {
          set eintrag($anz,b) l ;# left justified
        } else {
          set eintrag($anz,b) r ;# right justified
        }

      }

      # evaluate length as long as s or S is in the string
      set eintrag($anz,l) [expr $i - $eintrag($anz,p) + 1]

    } else {
      set ipos 0
    }
  }

  # extract text strings out of the list, truncate or fill with blanks
  for { set n 1 } { $n <= 999 } { incr n } {
    append BLANK " "
  }
  set numx 0
  foreach e $character {
    incr numx 1
    if {$ellipsis != -1 && $numx == $ellipsis} {set e [LIB_DC_ellipsis_character $e $eintrag($numx,l)]}
    if {$numx > $anz} {
      # more text than format strings
      set numx $anz ;# put all on last formatstring
    }
    # truncate text or fill with blanks, according to formatstring
    regsub -all " " $e "[CONF_DC_settings sub_char]" e   ;# substitute Blanks for later resubstitution
    set laes [string length $e]
    if {$laes > $eintrag($numx,l)} {
      # String is longer than format
      # will be truncated automatically in line below
    } else {
      if {$eintrag($numx,b) == "l"} {
        # string is shorter and left justified, fill with blanks to the right
        set e "$e$BLANK"
      } else {
        set tmp [string range $BLANK 0 [expr $eintrag($numx,l) - $laes - 1]]
        set e "$tmp$e"
      }
    }

    set tmp [string range $e 0 [expr $eintrag($numx,l) - 1]]
    regsub -all "[CONF_DC_settings sub_char]" $tmp " " text($numx)
  }
  # check if enough strings are in the list, if not fill with dummy strings
  while {$numx < $anz} {
    incr numx 1
    set text($numx) [string range $BLANK 0 [expr $eintrag($numx,l) - 1]]
  }

  # Now fill format string with text according to the evaluated positions, etc.
  set num 1
  set out ""  ;# initialize output text (formatted text)

  for {set i 0} {$i <= $lae} {incr i 1} {
    set pos [string range $string $i $i]  ;# go through string character by character
    if {$eintrag($num,p) == $i} {
      # check for next entry, if startposition is reached fill in the text
      append out $text($num)
      set i [expr $i + $eintrag($num,l) - 1]    ;# jump to next character after format field
      incr num 1 ;# initialize for next entry
      if {$num > $anz} {
        # create dummy for rest of calculation
        set eintrag($num,p) 0
      }
    } else {
      # add other text to output
      append out $pos
    }
  }

  # It is for center output
  regsub -all "' '" $out "" out

  return $out
}
# <Documentation>
# This procedure formats a list of string elements into a single text string according
# to a defined pattern of columns. It defines the length of a string element per column,
# the alignment of text within a column, and the separators between the columns.
#
# <Arguments>
# string
# Format definition for the list.
# In the example format: | >>>> __ <<<< +++ <<< |, the '|', '__', and '+++' are characters
# to separate the columns and are output as is.
# Valid options are:
# >>>> - Format of text element with right alignment justification
# (alignment character > must match with the configuration object CONF_DC_settings left_justify).
# <<<< - Format of text elements with left alignment justification
# (alignment character < must match with the definition in the configuration object CONF_DC_settings right_justify).
#
# Note: Text strings are truncated if they are longer than the format definition.
# character
# List of text string elements to be formatted.
# <Returnvalue>
# String.
#
# <Example>
# name: Example 1
# code: set returnvalue [LIB_DC_format_string "<<<<< <<<<< >>>>>" [list "Text" "1.1234" "mm"]]
# desc: returnvalue = "Text  1.123    mm"
# <Example>
# name: Example 2
# code: set returnvalue [LIB_DC_format_string "| T<<<< | D<< | <<<<<<<<<<<<<<<< |" [list "102" "1" "Milling Tool"]]
# desc: returnvalue = "| T102  | D1  | Milling Tool     |"
#____________________________________________________________________________________________
proc LIB_DC_check_variable {variable {defaulttext ""}} {

  if {[regexp -nocase -- {^(.*)\((.*)\)} $variable all body content]} {
    global $b
  } else {
    global $variable
  }

  if {[info exists $variable] && [regexp -nocase -- {^[0-9]|[a-z]+} [string trim $variable]]} {
    return [subst $$variable]
  } elseif {$defaulttext != ""} {
    return $defaulttext
  } else {
    return $variable
  }

}
# <Documentation>
# This procedure checks if a given expression is an existing variable and returns its current value.
# It returns the default_text if the variable does not exist.
# <Arguments>
# variable
#   Name of a variable.
# defaulttext
#   A text string that is returned if a variable does not exist or is not set.
#
# <Returnvalue>
# Value of the variable or the default text string.
#
# <Example>
# name: Example 1
# code: set variable [LIB_DC_check_variable mom_path_name "It's empty"]
# desc: The variable has the current value of mom_path_name.
#____________________________________________________________________________________________
proc LIB_DC_switch_variable {search list} {

  array set var [split $list "|"]

  foreach e [array names var] {
    if {$search == $e} {
      return $var($e)
    }
  }

}
# <Internal Documentation>
#
# Function as a switch, but is passed over a list separated by a pipe
#
# <Internal Example>
# set variable [LIB_DC_switch_variable $mom_kin_output_unit "IN|Inch|MM|Metric"]
#____________________________________________________________________________________________
proc LIB_DC_time_format {arg1 {splitter ":"}} {

  if {!$::lib_spf(clock,exists)} {
    set xx [split $arg1 "."]
    set sec [format %02i [expr round(0.[lindex $xx 1]*60.0)]]
    set xx [expr [lindex $xx 0]/60.0]
    set hh [format %02i [expr round(0.[lindex [split [expr [lindex [split $xx "."] 0]/24.0] "."] 1]*24.0)]]
    set min [format %02i [expr round(0.[lindex [split $xx "."] 1]*60.0)]]
    return "$hh$splitter$min$splitter$sec"
  }
  return [clock format [expr round($arg1*60)] -format "%H$splitter%M$splitter%S" -gmt 1]

}
# <Documentation>
# This procedure formats minute values into the time format hh:min:sec
# <Arguments>
# arg1
#   Input value in minutes.
# arg2 - optional -
#   Definition of the separator, if this is not a colon
# <Returnvalue>
# String representing time as hours, minutes, and seconds.
# <Example>
# name: Example 1: 59 minutes
# code: set timeval [LIB_DC_time_format "59"]
# desc: timeval = 00:59:00
# <Example>
# name: Example 2: 125 minutes
# code: set timeval [LIB_DC_time_format "125"]
# desc: timeval = 02:05:00
# <Example>
# name: Example 3: almost a day
# code: set timeval [LIB_DC_time_format "7199.5"]
# desc: timeval = 23:59:30
#____________________________________________________________________________________________
proc LIB_DC_escape_string {arg1} {

  regsub -all {[][*+?{}()<>"|.^$\\]} $arg1 {\\&} arg1
  return $arg1

}
# <Internal Documentation>
# This procedure identifies and marks TCL language control characters in an input string.
# The returned value is a literal text string with TCL escape characters to identify special characters to be output as plain text.
# <Internal Arguments>
# arg1
#   Input string.
# <Internal Returnvalue>
# String with TCL escape characters to mark literal text.
# <Internal Example>
# name: Example1
# code: set result [LIB_DC_escape_string {This [is] (the) {special} $test}]
# desc:result = "This \[is\] \(the\) \{special\} \$test"
#____________________________________________________________________________________________
proc LIB_DC_ellipsis_character {string length {postion "middlepath"} {placeholder "..."}} {
  set holder [string length $placeholder]
  set stringlength [string length $string]

  if {$stringlength <= $length} {return $string}

  switch -- $postion {
    start   {
          set string "$placeholder[string range $string [expr $stringlength-$length+$holder] [string length $string]]"
        }
    end   {
          set string "[string range $string 0 [expr $length-$holder-1]]$placeholder"
        }
    middle  {
          set fragment "$placeholder[string range $string [expr $stringlength-($length/2)+($holder/2)] [string length $string]]"
          set string "[string range $string 0 [expr $length-[string length $fragment]-1]]$fragment"
        }
    middlepath  {
          set fragment "$placeholder[string range $string [string length [file dirname [file dirname $string]]] $stringlength]"
          if {[string length $fragment] >= $length} {
            set string "$placeholder[string range $string [expr $stringlength-$length+$holder] [string length $string]]"
          } else {
            set string "[string range $string 0 [expr $length-[string length $fragment]-1]]$fragment"
          }
        }
    default   {}
  }

  return $string
}

# <Documentation>
# This function generates a shortened representation of a given string. It is mostly used for
# displaying long filenames and paths.
# <Arguments>
# string
#   String to be shortened.
# length
#   Maximum length to be displayed.
# postion
#   Position where the string shpild be shortened.
#   Valid arguments are:
# start      - shortens at the start of the string
# end        - shortens at the end of the string
# middle     - shortens in the middle of the string
# middlepath - shortens near the middle of the string in order to have the best path representation as possible
# placeholder
#   Character(s) used for the shortened part.
# <Example>
# set result [LIB_DC_ellipsis_character 123456789012345678901234567890 20 start]
# result = ...45678901234567890
# <Example>
# set result [LIB_DC_ellipsis_character 123456789012345678901234567890 20 end ....]
# result = 1234567890123456....
# <Example>
# set result [LIB_DC_ellipsis_character 123456789012345678901234567890 20 middle xxxx]
# result = 12345678xxxx34567890
# <Example>
# set result [LIB_DC_ellipsis_character "C:\\NextGeneration\\custom\\library\\machine\\installed_machines\\S840D\\Libraries\\lib_standard_post_func.pce" 60]
# result = C:\NextGeneration\cu...\Libraries\lib_standard_post_func.pce
# <Example>
# set result [LIB_DC_ellipsis_character "C:\\NextGeneration\\custom\\library\\machine\\installed_machines\\S840D\\Libraries\\lib_standard_post_func.pce" 38]
# result = ...ibraries\lib_standard_post_func.pce
#____________________________________________________________________________________________

# lib_file_handling.tcl

proc LIB_FH_unload_library {} {

  global lib_ge_user_function

  foreach e $lib_ge_user_function {
    MOM_unload_library [file join $e]
  }

}
# <Internal Documentation>
#
# Unload all librarys based at the names from the list
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_FH_close_all_files {} {

  global lib_fh_file_ids

  foreach e $lib_fh_file_ids {
    set error [LIB_FH_close_file $e]
  }

}
# <Internal Documentation>
#
# Close all open files based at the names from the list
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_FH_get_pathnames {{dir .}} {

  if {[file isdirectory $dir] && ![catch {
    set dir [file normalize $dir]
    set dir [glob -nocomplain -directory $dir -type d *]
  } err]} {
    return $dir
  } else {
    return ""
  }

}
# <Internal Documentation>
#
# Returns a list of pathnames based on the input directory.
#
# <Internal Example>
# e.g.
# LIB_FH_get_pathnames "D:/TEMP/"
#____________________________________________________________________________________________
proc LIB_FH_get_pathnames_recursive {{dir .}} {

  set dirs "" ; set dir [file normalize $dir]
  while {[llength $dir]} {
    set name [lindex $dir 0]
    set dir [concat [glob -nocomplain -directory [lindex $dir 0] -type d *] [lrange $dir 1 end]]
    lappend dirs $name
  }
  return $dirs

}
# <Internal Documentation>
#
# Returns a list of recursive pathnames based on the input directory.
#
# <Internal Example>
# e.g.
# LIB_FH_get_pathnames_recursive "D:/TEMP/"
#____________________________________________________________________________________________
proc LIB_FH_get_files_path {dir {extension *.*}} {

  set files ""
  if {[file isdirectory $dir] && ![catch {
    set dir [file normalize $dir]
    set files [glob -nocomplain -directory $dir -type f $extension]
  } err]} {
    return $files
  } else {
    return ""
  }

}
# <Internal Documentation>
#
# Returns a list of files inside the directory based from the criteria.
#
# <Internal Example>
# e.g.
# LIB_FH_get_files_path D:/Temp/ *.ini
#____________________________________________________________________________________________
proc LIB_FH_delete_files_path {dir {extension *.*} {recursive 0}} {

  lappend dirs [LIB_GE_format_path_names $dir]

  if {$recursive} {set dirs [LIB_FH_get_pathnames_recursive $dir]}

  foreach e $dirs {

    if {$::tcl_version < 8.6} {
      set check [glob -nocomplain -directory $e -type f $extension]
      if {[string length $check] == 0} {
        return
      }
      if {[LIB_FH_path_is_writable $e] && [file isdirectory $e] && [catch {eval file delete $check} err]} {
        MOM_log_message "Error/Warning at LIB_FH_delete_path_files '$err'"
      }
    } else {
      if {[LIB_FH_path_is_writable $e] && [file isdirectory $e] && [catch {eval file delete [glob -nocomplain -directory $e -type f $extension]} err]} {
        MOM_log_message "Error/Warning at LIB_FH_delete_path_files '$err'"
      }
    }
  }

}
# <Internal Documentation>
#
# Delete inside the defined directory the pattern of files.
#
# <Internal Example>
# e.g.
# LIB_FH_delete_files_path D:/Temp/ *.jpg
#____________________________________________________________________________________________
proc LIB_FH_check_file_progress {file {interrupt 0}} {

  set file [file normalize $file]
  set size [file size $file]

  after 100
  set interruption 0
  while {[file size $file] != $size} {
    after 100
    incr interruption
    if {$interrupt != 0 && $interruption >= $interrupt} {break}
  }
  set interruption 0
  while {![LIB_FH_file_is_writable $file]} {
    after 100
    incr interruption
    if {$interrupt != 0 && $interruption >= $interrupt} {break}
  }
  after 100

}
# <Internal Documentation>
#
# Checks if a file is used from another program.
# If it's not longer in progress, the loop would be stopped.
#
# <Internal Example>
# e.g.
# LIB_FH_check_file_progress D:/Temp/Test.txt
#____________________________________________________________________________________________
proc LIB_FH_path_is_writable {dir} {

  set name $dir/[clock clicks]
  if [catch {open $name w} fp] {return 0}
  close $fp
  file delete $name
  return 1

}
# <Internal Documentation>
#
# Checks if the defined directory is writable
#
# <Internal Example>
# e.g.
# LIB_FH_path_is_writable D:/Temp/
#____________________________________________________________________________________________
proc LIB_FH_file_is_writable {file} {

  if {[catch {file rename -force $file $file.temp} err]} {return 0}
  file rename -force $file.temp $file
  return 1

}
# <Internal Documentation>
#
# Checks if the defined file is writable
#
# <Internal Example>
# e.g.
# LIB_FH_file_is_writable D:/Temp/Test.txt
#____________________________________________________________________________________________
proc LIB_FH_delete_files {} {

  global lib_fh_file_delete

  foreach e $lib_fh_file_delete {
    set error [LIB_GE_cleanup_file $e]
  }

}
# <Internal Documentation>
#
# Delete all open files based at the names from the list
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_FH_format_database {filename {overwrite 0}} {

  if {[LIB_Shell_file_exists $filename 1]} {
    set machine_ascii [LIB_FH_file_to_list $filename]
  } else {
    LIB_GE_abort_message "Can't read file 'INS->$filename<-' at LIB_PS_format_database" "Please verify"
  }

  # Analysis
  set count -1 ; set linecount -1
  foreach e $machine_ascii {

    incr linecount

    if {[regexp -- "^FORMAT" [string trim $e]]} {

      incr count ; set linecount -1
      for { set n 0 } { $n < [llength $e] } { incr n } {
        set format(format,$count,$n,length) [string length [string trim [lindex $e $n]]]
        set format(format,$count,$n,index) [string trim [lindex $e $n]]
        set format(format,$count,elements) $n

        set max($count,$n) $format(format,$count,$n,length)
      }

    } elseif {[regexp -- "^DATA" [string trim $e]]} {

      set e [split $e "|"]
      for { set n 0 } { $n < [llength $e] } { incr n } {

        set format(data,$count,$linecount,$n,length) [string length [string trim [lindex $e $n]]]
        set format(data,$count,$linecount,$n,index) [string trim [lindex $e $n]]
        set format(data,$count,$linecount,elements) $n

        if {[info exists max($count,$n)] && $max($count,$n) < $format(data,$count,$linecount,$n,length)} {
          set max($count,$n) $format(data,$count,$linecount,$n,length)
        }
      }

    }
  }

  # Reorder
  set count -1 ; set new_machine_ascii "" ; set linecount -1
  foreach e $machine_ascii {

    incr linecount

    if {[regexp -- "^FORMAT" [string trim $e]]} {

      incr count ; set line "" ; set list "" ; set linecount -1
      for { set n 0 } { $n < [llength $e] } { incr n } {
        append line "<$max($count,$n)<   "
        lappend list $format(format,$count,$n,index)
      }
      set formatline [LIB_DC_complete_formatline [string trim $line] "<"]
      lappend new_machine_ascii [LIB_DC_format_string $formatline $list]

    } elseif {[regexp -- "^DATA" [string trim $e]]} {

      set e [split $e "|"] ; set line "" ; set list ""
      for { set n 0 } { $n < [llength $e] } { incr n } {

        append line "<$max($count,$n)< | "
        lappend list $format(data,$count,$linecount,$n,index)
      }
      set formatline [LIB_DC_complete_formatline [string range [string trim $line] 0 [expr [string length [string trim $line]] -2]] "<"]
      lappend new_machine_ascii [LIB_DC_format_string $formatline $list]

    } else {
      lappend new_machine_ascii $e
    }
  }

  if {$overwrite && $machine_ascii != $new_machine_ascii} {
    set error [LIB_FH_create_file $filename "w+" $new_machine_ascii]
  }

  return $new_machine_ascii

}
# <Documentation>
# This procedure formats the lines in a given .dat file to be exactly aligned per each column.
# The formatted lines are returned as a string list.
# Optionally, the .dat file can be updated directly with the formatted lines.
# <Arguments>
# filename
#   Complete pathname, filename, and extension of the .dat file to be formatted.
# overwrite
#   If this option is set to 1, the dat file is updated with the formatted lines.
# <Returnvalue>
# String list of the formatted lines from the dat file.
# <Example>
# name: format machine_database file
# code:  set curr_mac_db [file join [MOM_ask_env_var UGII_CAM_LIBRARY_MACHINE_ASCII_DIR] "machine_database.dat"]
# set machine_db [LIB_FH_format_database $curr_mac_db 1]
# desc: This command formats the the lines of the current machine_database.dat file and updates it.
#____________________________________________________________________________________________
proc LIB_FH_log_message_output {} {

  global lib_ge_log_message

  append output "\n"
  append output   "================================================================================================================================================================\n"
  append output   "Log Information for [LIB_GE_MSG "NGMK postprocessor"]:\n"
  LIB_GE_log_message_output
  foreach e $lib_ge_log_message {
    regsub -- (?q)"\\\\n" $e "" e
    append output "$e\n"
  }
  append output   "================================================================================================================================================================\n"

  if {[llength [info commands LIB_GE_log_message]]} {
    LIB_GE_log_message $output
  } else {
    MOM_log_message $output
  }

}
# <Internal Documentation>
#
# Output logfile  messages at once
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#______________________________________________________________________________________________
proc LIB_FH_create_directory {directory} {

  if {![LIB_Shell_directory_exists $directory]} {
    if {[catch {file mkdir $directory}]} {
      return 1
    }
  }
  return 0
}
# <Documentation>
# This procedure creates a new directory if it does not exist.
# <Arguments>
# directory
# The full pathname of the directory to be created.
# Directory can be specified in UNIX format (directory separator with /)
# or in Windows format (separator with \ (escaped backslash)).
# <Returnvalue>
# 0 - directory created or already exists
# 1 - error
# <Example>
# name: Example 1
# code: set error [LIB_FH_create_directory "C:\\Temp\\Test\\"]
# desc: If error = 0, the directory C:\Temp\Test is created (Windows format).
# <Example>
# name: Example 2
# code: set error [LIB_FH_create_directory "C:/Temp/Test"]
# desc: If error = 0, the directory C:\Temp\Test is created (UNIX format).
#______________________________________________________________________________________________
proc LIB_FH_search_path_recursively {folders {dirs .}} {

  set dirs "" ; lappend dirs [file join $folders] ; set initial $dirs ; set initialdir "" ; lappend initialdir [pwd]
  while {[llength $dirs]} {
    set name [lindex $dirs 0]
    if {[info tclversion] > 8.3} {
          set dirs [concat [glob -nocomplain -directory [lindex $dirs 0] -type d *] [lrange $dirs 1 end]]
    } else {
      cd [lindex $dirs 0] ; if {[catch {glob *}]} {lappend directories [lindex $dirs 0] ; set dirs [concat [lrange $dirs 1 end]] ; continue} else {set all [glob *]}
      foreach e $all {if {[LIB_Shell_directory_exists [file join [lindex $dirs 0] $e]]} {lappend dirs [file join [lindex $dirs 0] $e]}}
      set dirs [concat [lrange $dirs 1 end]]
    }
    lappend directories $name
  }
  cd [lindex $initialdir 0]
  return $directories
}
# <Documentation>
# This procedure iterates through subdirectories starting at a given pathname and returns a list of all found subdirectories.
#
# <Arguments>
# folders
# The full path name of the start directory for the search.
# dirs
# Not used.
#
# <Returnvalue>
# String list.
#
# <Example>
#
# set directories [LIB_FH_search_path_recursively "D:/Temp/Test"]
# directories = D:/Temp/Test D:/Temp/Test/Functions D:/Temp/Test/Librarys D:/Temp/Test/Librarys/Test
#____________________________________________________________________________________________
proc LIB_FH_search_file_glob {pathname filename resultname} {

  upvar $resultname hit

  if {![LIB_Shell_directory_exists $pathname]} {
    LIB_GE_abort_message "Defined path is not valid" "Check the first argument at LIB_FH_search_file_glob"
  }

  set resultname ""
  set code 0

  set tmp_dir [pwd]
  cd $pathname

  if {![catch {set files [glob $filename]}]} {
    foreach e $files {
      set filename [LIB_GE_format_path_names [file join $pathname $e]]
      if {[LIB_Shell_file_exists $filename 1]} {
              set resultname $filename
              set code 1
              break
      }
    }
  } else {
    set code 0
  }

  set hit $resultname
  cd $tmp_dir

  return $code

}
# <Documentation>
# This procedure searches for a file in a given directory using glob style search.
# This means that the filename can be specified with wildcards (*).
# The first match is returned in the search.
# <Arguments>
# pathname
# The full pathname of the directory to search for the file.
# Pathname can be specified in UNIX format (directory separator with /)
# or in Windows format (separator with \ (escaped backslash)).
# filename
# Filename with extension to be searched for. The filename may be specified in glob style.
# resultname
# Name of the variable to store the full path and name of the file that is found in the search.
# <Returnvalue>
# 0 - Nothing found.
# 1 - File matching the glob style has been found.
# <Example>
# name: Check if .tmp files exist
# code: set result [LIB_FH_search_file_glob C:\\Temp\\ *.tmp resultname]
# desc: If result = 1, there is at least one .tmp file in the given directory.
# <Example>
# name: Search for a nc file
# code: set result [LIB_FH_search_file_glob d:/ncfiles/ O12*.nc resultname]
# desc: If result = 1, there is a .nc file beginning with O12 in the given directory.
#____________________________________________________________________________________________
proc LIB_FH_file_to_list {filename {filename_to_list ""} {apportion 1}} {

  global lib_ge_definition_keyword

  if {![LIB_Shell_file_exists $filename 1]} {
    LIB_GE_log_message "The required file cannot be found: INS->LIB_FH_file_to_list '$filename'<-\n>>[info level 1] , [info level -1] , [info level -2]"
    LIB_GE_abort_message "The required file cannot be found: INS->LIB_FH_file_to_list '$filename'<-" "Please verify"
  }

  if {$filename_to_list != ""} {
    LIB_GE_lappend $filename_to_list $filename
  }

  set id [LIB_FH_open_file $filename r]
  set content [read $id]
  if {$apportion} {set content [split $content "\n"]}
  LIB_FH_close_file $id

  lappend lib_ge_definition_keyword(loop) [file join $filename]
  if {[regsub -all (?q)[file join $filename] $lib_ge_definition_keyword(loop) [file join $filename] lib_ge_definition_keyword(loop)] > 2} {
    #the same file was loaded more than 2 times --> Abort
    LIB_GE_abort_message "File loaded multiple times LIB_FH_file_to_list" "Please verify"
  }

  return $content

}
# <Documentation>
# This procedure reads the contents of a text file into a string list.
# The procedure can be used safely as it opens and closes the text file automatically and provides error handling.
# <Arguments>
# filename
#  The full pathname, filename, and extension to be read.
# Filename can be specified in UNIX format (directory separator with /)
# or in Windows format (directory separator with \ (escaped backslash)).
# filename_to_list
# Reserved option.
# If this option is specified, the function adds the filename of the text file
# to the string list named with this option. This may be useful to collect the
# names of all files that have been accessed.
# apportion
# By default this function splits lines at every linebreak \n.
# If you set this option to 0, the returned list is a single line.
# <Returnvalue>
# List of text strings.
# <Example>
# set filelist [LIB_FH_file_to_list C:\\Temp\\Test.txt]
#______________________________________________________________________________________________
proc LIB_FH_file_writable {file} {

  # file writable returns always 0 at TCL 8.4.x

  if {[catch {close [open [file join $file] w]} err]} {
    # Could not create file in $file
    return 0
  } else {
    # Created file in $file
    return 1
  }

}
# <Documentation>
# This procedure checks if a given file is writable or not.
# <Arguments>
# file
# The full pathname, filename, and extension to be checked.
# Filename can be specified in UNIX format (directory separator with /)
# or in Windows format (separator with \ (escaped backslash)).
# <Returnvalue>
# 1 - if the file is writable.
# 0 - if the file is not writable (e.g. set to readonly)
# <Example>
# set status [LIB_FH_file_writable C:\\Temp\\Test.txt]
# If status = 1, you can write to the Test.txt file.
#______________________________________________________________________________________________
proc LIB_FH_list_to_file {list filename {fileoption w+}} {

  if {[string first "w" $fileoption] && [LIB_Shell_file_exists $filename 1]} {catch {file delete $filename}}
  set fileid [LIB_FH_open_file $filename $fileoption]

  foreach e $list {
    puts $fileid $e
  }
  flush $fileid
  LIB_FH_close_file $fileid
  LIB_FH_check_file_progress $filename 10

}
# <Documentation>
# This procedure writes the contents of a given string list to a text file.
# <Arguments>
# list
#   String list to be written in the text file.
# filename
# The full pathname, filename, and extension to be written.
# Filename can be specified in UNIX format (directory separator with /)
# or in Windows format (separator with \ (escaped backslash)).
# fileoption
# Option arguments for the creation of the file (derived from the standard TCL open command). Valid options are:
# w - Open the file for writing only. Truncate it if it exists. If it does not exist, create a new file.
# w+ - Open the file for reading and writing. Truncate it if it exists. If it does not exist, create a new file.
# a - Open the file for writing only. If the file does not exist, create a new empty file. Set the file pointer to the end of the file prior to each write.
# a+ - Open the file for reading and writing. If the file does not exist, create a new empty file. Set the initial access position to the end of the file.
# <Returnvalue>
# None.
# <Example>
# LIB_FH_list_to_file $content "C:\\Temp\\Test.txt"
#______________________________________________________________________________
proc LIB_FH_file_to_list_line_numbers {filename counter} {

  global lib_ge_definition_keyword

  if {![LIB_Shell_file_exists $filename 1]} {
    LIB_GE_log_message "The required file cannot be found: INS->LIB_FH_file_to_list_line_numbers '$filename'<-\nStopping... \n>>[info level 1] , [info level -1] , [info level -2]"
    LIB_GE_abort_message "The required file cannot be found: INS->LIB_FH_file_to_list_line_numbers '$filename'<-" "Stopping..."
  }

  set fileid [LIB_FH_open_file $filename r]
  for { set n 1 } { $n < $counter } { incr n } {
    set count [gets $fileid data]
    if {$count >= 0} {lappend content $data} else {break}
  }
  LIB_FH_close_file $fileid

  lappend lib_ge_definition_keyword(loop) [file join $filename]
  if {[regsub -all (?q)[file join $filename] $lib_ge_definition_keyword(loop) [file join $filename] lib_ge_definition_keyword(loop)] > 2} {
    #the same file was loaded more than 2 times --> Abort
    LIB_GE_abort_message "File in a loop at LIB_FH_file_to_list" "Stopping..."
  }

  return $content

}
# <Documentation>
# This procedure reads a text file into a string list.
# This is the same function as LIB_FH_file_to_list,
# with the option to specify the number of lines to be read.
# <Arguments>
# filename
# The full pathname, filename, and extension to be read.
# Filename can be specified in UNIX format (directory separator with /)
# or in Windows format (separator with \ (escaped backslash)).
# counter
# Number of lines to be read.
# <Example>
# set filelist [LIB_FH_file_to_list_line_numbers C:\\Temp\\Test.txt 100]
#______________________________________________________________________________________________
proc LIB_FH_create_file {filename {fileoption "w+"} {filebody ""}} {

  set fileid [LIB_FH_open_file $filename $fileoption]
  if {[llength $filebody] > 0} {
    foreach e $filebody {
      puts $fileid $e
    }
  }
  LIB_FH_close_file $fileid

}
# <Documentation>
# This procedure creates a text file with a given directory and filename.
# If text or a list is provided, the text is written in the file.
# <Arguments>
# filename
# The full pathname, filename, and extension to be created.
# Filename can be specified in UNIX format (directory separator with /)
# or in Windows format (directory separator with \ (=escaped backslash)).
# fileoption
# Option argument for the creation of the file (derived from the standard TCL open command):
# w - Open the file for writing only. Truncate it if it exists. If it does not exist, create a new file.
# w+ - Open the file for reading and writing. Truncate it if it exists. If it does not exist, create a new file.
# a - Open the file for writing only. If the file does not exist, create a new empty file. Set the file pointer to the end of the file prior to each write.
# a+ - Open the file for reading and writing. If the file does not exist, create a new empty file. Set the initial access position to the end of the file.
# filebody
# Text to be written in the file. If you specify a list, each list element is written to a new line in the file.
# <Returnvalue>
# None.
# <Example>
# LIB_FH_create_file "C:\\Temp\\Test.txt" "w+" "This is text..."
#<Example>
# LIB_FH_create_file "C:/Temp/Test.txt" "a" [list "line 1" "line 2"]
#<Example>
# LIB_FH_create_file "C:/Temp/emptyfile.txt"
#______________________________________________________________________________________________
proc LIB_FH_cleanup_directory {directory expression} {

  global flag lib_ge_slash

  if {[llength [info commands MOM_LIB_DeleteFiles]]} {
    set directory "[LIB_GE_format_path_names [file join $directory]]$lib_ge_slash$lib_ge_slash"
    catch {set error [MOM_LIB_DeleteFiles "$directory" "$expression"]}
  }

}
# <Documentation>
# This procedure deletes all the files in a given directory.
#
# <Arguments>
# directory
# The full path name to the directory to be cleaned up. Windows and UNIX formats are supported.
# expression
# The file mask. All matching files are deleted.
#
# <Returnvalue>
# None.
#
# <Example>
# name: Example 1
# code: LIB_FH_cleanup_directory "H:\\Pool\\" "*.osd"
# desc: Deletes all files with filemask *.osd in the directory H:\Pool (note: in Windows directory format, you must use the escape character for the backslashes).
# <Example>
# name: Example 2
# code: LIB_FH_cleanup_directory "C:/Temp/mydir" "*"
# desc: Deletes all files in the directory C:\Temp\mydir (note: in UNIX directory format, you do not need to use the escape character for the forward slashes).
#_____________________________________________________________________________________________
proc LIB_FH_after_out_mark_single {arg1 {create ""}} {

  global mom_sys_control_out
  global mom_sys_control_in
  set create [LIB_GE_string_toupper $create]

  if {$create == "CREATE"} {
    return "$mom_sys_control_out<JE>${arg1}</JE>$mom_sys_control_in"
  } else {
    return [MOM_output_literal "$mom_sys_control_out<JE>${arg1}</JE>$mom_sys_control_in"]
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_FH_after_out_mark_start {arg1 {create ""}} {

  global mom_sys_control_out
  global mom_sys_control_in

  if {$create == "CREATE"} {
    return "$mom_sys_control_out<LIB_S>${arg1}</LIB_S>$mom_sys_control_in"
  } else {
    return [MOM_output_literal "$mom_sys_control_out<LIB_S>${arg1}</LIB_S>$mom_sys_control_in"]
  }
}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_FH_after_out_mark_end {arg1 {create ""}} {

  global mom_sys_control_out
  global mom_sys_control_in

  if {$create == "CREATE"} {
    return "$mom_sys_control_out<LIB_E>${arg1}</LIB_E>$mom_sys_control_in"
  } else {
    return [MOM_output_literal "$mom_sys_control_out<LIB_E>${arg1}</LIB_E>$mom_sys_control_in"]
  }

}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_FH_open_file {name {access r}} {

  global lib_fh_file_ids

  set lib_fh_file_ids [LIB_GE_linsert_index $lib_fh_file_ids 0 [open $name $access]]

  return [lindex $lib_fh_file_ids 0]

}
# <Documentation>
# This procedure creates and opens a new file, or opens an existing file,
# using the TCL command open and the specified file access type.
# After this command, the function LIB_FH_output_literal writes directly to this file.
# The file is automatically closed at the end of the postprocessing run.
# <Arguments>
# name
# The full pathname, filename, and extension to be created.
# Filename can be specified in UNIX format (directory separator with /)
# or in Windows format (separator with \ (escaped backslash)).
# fileoption
# Option arguments for the creation of the file (derived from the standard TCL open command). Valid options are:
# w - Open the file for writing only. Truncate it if it exists. If it does not exist, create a new file.
# w+ - Open the file for reading and writing. Truncate it if it exists. If it does not exist, create a new file.
# a - Open the file for writing only. If the file does not exist, create a new file. Set the file pointer to the end of the file prior to each write.
# a+ - Open the file for reading and writing. If the file does not exist, create a new file. Set the initial access position to the end of the file.
# <Returnvalue>
# File ID of the opened file. This file ID is not important when using LIB_FH_output_literal.
# <Example>
# name: Create new file
# code: LIB_FH_open_file d:\\tmp\\sub_prog.spf w+
# desc: Creates a new file sub_prog.spf and opens it for write access.
# <Example>
# name: Create new file and write to it
# code:  LIB_FH_open_file d:/tmp/newfile.txt w+
# LIB_FH_output_literal "this text goes into the txt file"
# desc: Creates a new file newfile.txt, opens it for write access, and writes to it.
#____________________________________________________________________________________________
proc LIB_FH_close_file {{optional_id 0}} {

  global lib_fh_file_ids lib_fh_trace_file

  if {$optional_id != 0} {set lib_fh_file_ids [LIB_GE_linsert_index $lib_fh_file_ids 0 $optional_id]}

  set current [lindex $lib_fh_file_ids 0]

  # If that's not a file ID e.g. file251e190 (\y = word boundary)
  # lili PR#9867890
  if {![regexp -- {^\yfile[^\\\/\.:]+$} $current] && $current != "stdin" && $current != "stdout"} {
    set lib_fh_trace_file 1
    MOM_close_output_file $current
    set lib_fh_trace_file 0
    set check 0
  } else {
    catch {flush $current}
    set check [catch {close $current}]
  }

  if {!$check} {set lib_fh_file_ids [lrange $lib_fh_file_ids 1 end]}

}
# <Internal Documentation>
# Closes the last file
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_FH_output_literal {output} {

  puts [lindex $::lib_fh_file_ids 0] $output

}
# <Documentation>
# This procedure writes text to the last file that was opened by LIB_FH_open_file.
# <Arguments>
# output
#   Text to be added to the last opened file.
# <Returnvalue>
# None.
# <Example>
# LIB_FH_output_literal "write this line to a file"
#____________________________________________________________________________________________
proc LIB_FH_escape_special_characters {output} {

  #regsub -all -- \\\\ $output \\\\\\\\ output
  #regsub -all -- \\\[ $output \\\\\[ output
  #regsub -all -- \\\] $output \\\\\] output
  #regsub -all -- \\\} $output \\\\\} output
  #regsub -all -- \\\{ $output \\\\\{ output
  #regsub -all -- \\\" $output \\\\\" output
  #regsub -all -- \\\$ $output \\\\\$ output
  #return $output

  #use faster code
  regsub -all {[][*+?{}()<>|.^$\\]} $output {\\&} output
  return $output

}
# <Documentation>
# This procedure adds escape characters before special TCL characters in a given string.
# The special characters are then considered to be plain text.
# <Arguments>
# output
#   String containing special TCL characters to be escaped.
# <Returnvalue>
# String with escape characters before special TCL characters.
# <Example>
# name: Example 1
# code: set result [LIB_FH_escape_special_characters {This string contains [special] characters"}]
# desc: result = This string contains \[special\] characters \@xmldoc_example_descr@quot
#____________________________________________________________________________________________
proc LIB_FH_reverse_escape_special_characters {output} {

  regsub -all -- \\\\\\\\ $output \\ output
  regsub -all -- \\\\\\\[ $output \[ output
  regsub -all -- \\\\\\\] $output \] output
  regsub -all -- \\\\\\\} $output \} output
  regsub -all -- \\\\\\\{ $output \{ output
  regsub -all -- \\\\\\\" $output \" output
  regsub -all -- \\\\\\\$ $output \$ output
  return $output

}
# <Documentation>
# This procedure reverses a string with escape characters back to a string with special TCL characters.
# It is the opposite function to LIB_FH_escape_special_characters.
# <Arguments>
# output
#   String with escaped characters to be reversed to special characters.
# <Returnvalue>
# String with special TCL characters.
# <Example>
# name: Example 1
# code: set result [LIB_FH_reverse_escape_special_characters {This string contains \[special\] characters\"}]
# desc: result = This string contains [special] characters"
#____________________________________________________________________________________________
proc LIB_FH_after_output {} {

  ###################################
  #
  # When program output is completed this will be launched
  #
  ###################################

  global mom_output_file_full_name

  if {[info exists ::lib_fh_do_after_output] && $::lib_fh_do_after_output != 0} {

    if {$mom_output_file_full_name == ""} {return}
    MOM_close_output_file $mom_output_file_full_name

    if {[CONF_FH activate_rework]} {
      # This is the entry point to add additional markers to the
      # file contents (e.g. old lib_upt.dll functionality
      set content [LIB_FH_after_output_rework_outfile [LIB_FH_file_to_list $mom_output_file_full_name]]
      set dummy [open $mom_output_file_full_name w+] ; close $dummy
      set error [LIB_FH_list_to_file $content $mom_output_file_full_name w]
    }

    MOM_open_output_file $mom_output_file_full_name

  }

  LIB_FH_close_file

}
# <Internal Documentation>
#
# >> It's still under development <<
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_FH_copy_outfile {} {

  global lib_spf mom_output_file_full_name

    if {![string equal -nocase [file join [string trimright $lib_spf(value,output_file_full_name) "."]] [file join [string trimright $mom_output_file_full_name "."]]]} {
    if {[LIB_Shell_file_exists $lib_spf(value,output_file_full_name) 1]} {MOM_remove_file $lib_spf(value,output_file_full_name)}
    if {![LIB_Shell_directory_exists [file dirname $lib_spf(value,output_file_full_name)]]} {
      set error [file mkdir [file dirname $lib_spf(value,output_file_full_name)]]
    }
    set error [file copy -force $mom_output_file_full_name $lib_spf(value,output_file_full_name)]
  }

}
# <Internal Documentation>
#
# >> It's still under development <<
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_FH_after_output_rework_outfile {content} {

  set commandcheck(LIB_FH_after_output_rework_outfile_ENTRY) [llength [info commands LIB_FH_after_output_rework_outfile_ENTRY]]

  LIB_GE_command_buffer LIB_FH_after_output_rework_outfile_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_FH_after_output_rework_outfile_ENTRY)} {LIB_FH_after_output_rework_outfile_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$commandcheck(LIB_FH_after_output_rework_outfile_ENTRY)} {set content [LIB_FH_after_output_rework_outfile_ENTRY $content]}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_FH_after_output_rework_outfile_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_FH_after_output_rework_outfile_ENTRY)} {LIB_FH_after_output_rework_outfile_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  return $content

}
# <Internal Documentation>
#
# >> It's still under development <<
#
# <Internal Example>
#
#____________________________________________________________________________________________

# lib_general.tcl

proc LIB_GE_chain_set_default_globals {args} {

  foreach pattern $args {
    foreach var [info vars ::${pattern}] {
      if {[array exists $var] == 0} {
        LIB_GE_chain_set_global_var default [namespace tail $var] [subst $[subst $var]]
      } elseif {[array names $var] != ""} {
        #only copy non empty arrays
        LIB_GE_chain_set_global_array default [namespace tail $var] [array get $var]
      }
    }
  }
}
# <Internal Documentation>
#
# LIB_GE_chain_set_default_globals will copy variables with names matching given patterns to a seperate namespace
# called ::KinChains::default
# Those values can be used to restore the default state of a given set of variables. (used in contex of multichain machines)
# (somehow similar to LIB_GE_copy_var_range)
#
# <Internal Example>
#
# LIB_GE_chain_set_default_globals mom_kin* mom_sys*
#
#____________________________________________________________________________________________
proc LIB_GE_chain_set_global_var {chain name value} {

  if {[lsearch ::KinChains::$chain [namespace child ::KinChains]] > -1} {
    #nothing to do
  } else {
    namespace eval ::KinChains::$chain {}
  }

  set ::KinChains::${chain}::${name} $value

}
# <Internal Documentation>
#
# LIB_GE_chain_set_global_var is a chain specific 'set' command.
# This alllows to define global variables 'chain specific'
# The values will be stored in a separate namespace. (::KinChains::your_chain_name)
# The values from that namespace can be made active by calling 'LIB_GE_chain_activate_chain_globals your_chain_name'
#
# <Internal Example>
#
# LIB_GE_chain_set_global_var your_chain_name mom_kin_machine_type 3_axis_mill
#
#____________________________________________________________________________________________
proc LIB_GE_chain_set_global_array {chain name ele_list} {

  if {[lsearch ::KinChains::$chain [namespace child ::KinChains]] > -1} {
    #nothing to do
  } else {
    namespace eval ::KinChains::$chain {}
  }

  array set ::KinChains::${chain}::${name} $ele_list

}
# <Internal Documentation>
#
# LIB_GE_chain_set_global_array is a chain specific 'array set' command.
# This alllows to define global arrays 'chain specific'
# The values will be stored in a separate namespace. (::KinChains::your_chain_name)
# The values from that namespace can be made active by calling 'LIB_GE_chain_activate_chain_globals your_chain_name'
#
# <Internal Example>
#
# LIB_GE_chain_set_global_array your_chain_name mom_kin_4th_axis_vector "0 0 1 1 2 1"
#
#____________________________________________________________________________________________
proc LIB_GE_chain_get_global_var_value {chain name} {

  if {[info exists ::KinChains::[subst $chain]::[subst $name]]} {
    return [subst $\{::KinChains::[subst $chain]::[subst $name]\}]
  } elseif {[info exists ::KinChains::default::[subst $name]]} {
    return [subst $\{::KinChains::default::[subst $name]\}]
  } else {
    LIB_GE_abort_message "ERROR in LIB_GE_chain_get_global_var_value" "variable '$name' does not exist"
  }
}
# <Internal Documentation>
#
# LIB_GE_chain_get_global_var_value of the given variable from the given chain namespace
# If no chain specific value is defined, default value will be returned
#
# <Internal Example>
#
# LIB_GE_chain_get_global_var_value your_chain_name mom_kin_machine_type
#
#____________________________________________________________________________________________
proc LIB_GE_ui {name type id_name parent sequence groupstat access} {

  set all "uplevel 1 {\n\
  set id $id_name\n\
  set \$id 0\n\
  set datatype(\$id)  $type\n\
  set access(\$id)  $access\n\
  set dialog(\$id)    {{$name}}\n\
  set descr(\$id)     {{$name}}\n\
  set group_status(\$id) $groupstat\n\
  set ui_parent(\$id) $parent\n\
  set ui_sequence(\$id) $sequence\n\
  }"

  if {1} $all

}
# <Documentation>
# This procedure creates individual UI structure elements that are within a configuration object.
# UI structure elements (nodes and groups) are defined in a configuration object like any other property using a single, readable line.
# The property structure is generated automatically.
# The configuration object is of special type UI_TREE ( LIB_GE_CREATE_obj My_UI_elements {UI_TREE} {....} ).
# <Arguments>
# name
# Text to be displayed in UI
# type
# Element type to be created. Valid options are NODE or GROUP.
# Note: Two levels of nodes are currently supported, the node parent can only be either root or another node.
# Two levels of groups are currently supported, the group parent can be either a node (only node of last level in current tree branch) or another group.
# Only GROUP elements are able to hold properties. Therefore a minimal tree branch definition consists of one node and one group.
# id_name
# Unique name for that element. This is the name to reference in properties to be displayed in that group.
# The name has to be a string without any blanks/spaces or special characters.
# Do not use prefix @CUI_ for your string. This prefix is reserved for CoreUI definitions (in core libraries).
# parent
# ID name of the parent to hold this element (keyword root references to top level of the tree).
# sequence
# Tree position of the element in question. Valid options are:
# 0 - Based list index.
# -1 - Indicates that the element is positioned automatically in the tree.
# groupstat
# For elements of type GROUP, this indicates if the default state of the group is closed (0) or open (1).
# access
# Defines the access level for the UI element. The code assigns access rights
# for each license level. The value is a 3 digit integer XYZ where X is the access code for a basic license,
# Y for an advanced license, and Z for a full license. The valid values for X,Y, and Z are 0 (hide), 1 (readonly) or 2 (full access).
# Note: The access level of a UI_TREE type property can be changed by the command LIB_GE_CONF_set_property_access, as it is for any
# common property.
# <Returnvalue>
# None.
#
# <Example>
# name: Example 1
# code: LIB_GE_ui  "My Ui Node" "NODE"  @MyNodeID root  0 1 222
# LIB_GE_ui  "My Ui SubNode" "NODE" @MySubNodeID @MyNodeID 0 1 222
# LIB_GE_ui  "My Ui Group" "GROUP" @MyGroupID @MySubNodeID 0 1 222
# desc:  To assign a property to @MyGroupID the ui_parent attribute of that property must be set to the value @MyGroupID.
# This can be done in two ways:
# 1) By setting the property definition (if you are the owner of the property): set ui_parent($id) @MyGroupID.
# 2) By calling LIB_GE_CONF_set_property_ui CONF_GE_msg date_format @MyGroupID 1 (see LIB_GE_CONF_set_property_ui).
#____________________________________________________________________________________________
proc LIB_GE_check_version {} {
  global lib_ge_check_version lib_ge_check_nx_version

  set lib_ge_check_nx_split [split [CONF_GE_check check_nx_version] "."]

  regexp -- {([0-9.]+)} [MOM_ask_env_var "UGII_FULL_VERSION"] all full_version
  if {[info exists full_version]} {
    set nx_version [split $full_version "."]
  } else {
    return
  }

  set check -1
  for { set n 0 } { $n < [llength $lib_ge_check_nx_split] } { incr n } {
    if {[string length [lindex $lib_ge_check_nx_split $n]] > 0 && [regexp -- {[0-9]+} $[lindex $lib_ge_check_nx_split $n]]} {

      if {[lindex $lib_ge_check_nx_split $n] == [lindex $nx_version $n] && $check != 0} {
        set check 1
      } else {
        set check 0
      }
    }
  }

  if {!$check} {LIB_GE_error_message "[LIB_GE_MSG "Current NX Version INS->$full_version<-"]" "[LIB_GE_MSG "Released on NX Version INS->[CONF_GE_check check_nx_version]<-"]"}

}
# <Internal Documentation>
#
# Check the version from lib_ge_check_nx_version, 8.x.x or 8.5.3 is possible
# It is controlled over flag lib_ge_check_version
#
# <Internal Example>
# set error [LIB_GE_check_version]
#____________________________________________________________________________________________
proc LIB_GE_layer_editor {} {

  global lib_pt_layer_editor_files lib_ge_layer_editor_files lib_ge_add_pack_and_send lib_pp_all_sourced_files

  if {$::lib_ge_pretreatment_runtime} {
    set ::lib_pt_layer_editor_files $::lib_ge_monitored_files
    #MOM_output_to_listing_device "lib_pt_layer_editor_files='$::lib_pt_layer_editor_files'"
  } else {
    set ::lib_ge_layer_editor_files $::lib_ge_monitored_files
    #MOM_output_to_listing_device "lib_ge_layer_editor_files='$::lib_ge_layer_editor_files'"
  }

}
# <Internal Documentation>
# This procedure is executed at start of program
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_check_file_with_extension {folder file extensionlist} {
  global lib_ge_slash
  foreach extension [string tolower $extensionlist] {
    set sourcefile [LIB_GE_format_path_names "$folder$lib_ge_slash$file$extension"]
    if {[LIB_Shell_file_exists $sourcefile 1]} {return $sourcefile}
    lappend debug(sourcecheck) $sourcefile
  }
  MOM_output_to_listing_device "================================================================================================================"
  MOM_output_to_listing_device "[LIB_GE_MSG "Files for loading not found, more information in the listing window or the systemlogfile"]"
  MOM_output_to_listing_device "================================================================================================================"
  lappend lib_ge_log_message "[LIB_GE_MSG "Files for loading not found, more information in the listing window or the systemlogfile"]:"
  lappend lib_ge_log_message "==============================================================================================================="
  foreach i $debug(sourcecheck) {
    set i [LIB_GE_format_path_names [LIB_GE_search_environment $i]]
    lappend lib_ge_log_message "--> $i"
    MOM_output_to_listing_device "--> $i"
  }
  LIB_GE_abort_message "[LIB_GE_MSG "Files for loading not found, more information in the listing window or the systemlogfile"]"

}
# <Internal Documentation>
# This procedure is to check if a file exists with an extension from the extensionlist
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_cleanup_file {filename} {
  global lib_ge_slash

  set filename [LIB_GE_format_path_names $filename]

  if {[llength [info commands MOM_LIB_DeleteFiles]]} {
    set directory  "[file dirname $filename]$lib_ge_slash"
    set expression "[file rootname [file tail $filename]][file extension $filename]"
    catch {set error [MOM_LIB_DeleteFiles "$directory" "$expression"]}
  } else {
    catch {set error [file delete -force $filename]}
  }

}
# <Internal Documentation>
# This function does a file cleanup
#
# Param 1 = Directory
# Param 2 = Expression
# Please, observed that Param 1 must lockt with "\\"
#
# <Internal Example>
# set error [LIB_GE_cleanup_file "H:\\Pool\\Test.osd"]
#_____________________________________________________________________________________________
proc LIB_GE_cleanup_list {list {newlist ""} {remove 0}} {

  set removelist $newlist
  if {$remove <= 0} {
    foreach e $list {
      if {[lsearch -exact $newlist $e] == -1} {lappend newlist $e}
    }
    if {$remove == -1} {
      set list $newlist ; set newlist ""
      foreach e $list {
        if {[lsearch -exact $removelist $e] == -1} {lappend newlist $e}
      }
    }
  } else {
    foreach e $list {
      while { [lsearch -exact $newlist $e] > -1} {
        set newlist [lreplace [K $newlist [set list {}]] [lsearch -exact $newlist $e] [lsearch -exact $newlist $e]]
      }
    }
  }
  return $newlist

}

# <Documentation>
# This function filters all duplicates from a list and returns the adjusted list.
# <Arguments>
# list
#   String list to be cleaned up.
# newlist
#   The name of an existing string list can be specified. If so, the new list is merged into this list by checking duplicates in both lists. This argument is optional.
# remove
#   When specifying an existing string list, this option tells the function either to remove duplicates from the existing list or not.
# <Returnvalue>
# Adjusted string list
# <Example>
# name: Example 1
# code:  set mylist [list car train plane bike car boat]
# set result [LIB_GE_cleanup_list $mylist]
# name: result = car train plane bike boat
# <Example>
# name: Example 2
# code:  set oldlist [list car train plane bike car boat]
# set newlist [list helicopter plane]
# set result [LIB_GE_cleanup_list $newlist $oldlist]
# name: result = car train plane bike car boat helicopter
# <Example>
# name: Example 3
# code:  set oldlist [list car train plane bike car boat]
# set newlist [list helicopter plane]
# set result [LIB_GE_cleanup_list $oldlist $newlist 1]
# name:  result = helicopter
# Duplicate elements that appear in both lists are removed.
#_____________________________________________________________________________________________
proc LIB_GE_format_path_names {pathname {exclusion 0} {forced 0} {escape 0}} {
  global lib_ge_slash lib_ge

  regsub -all "/" $pathname "\\" pathname
  binary scan $pathname H* pathbin
  if {[info exists lib_ge(format_path,$pathbin,$exclusion,$forced,$escape)]} {
    return $lib_ge(format_path,$pathbin,$exclusion,$forced,$escape)
  }

  if {[regexp -nocase -- {^[\\\\]|^[\/\/]} $pathname]} {
    regsub -all "/" $pathname "\\" pathname
  }

  if {$::lib_ge_platform && $forced == 0 || $forced == 1} {
    if {$exclusion} {set pathname "$pathname$lib_ge_slash"}
    regsub -all "/" $pathname "\\" pathname
    if {![regexp -nocase -- {^\\\\} $pathname]} {set unc 0} else {set unc 1}
        while {[regsub -- "(?q)\\\\" $pathname "\\" pathname]} {}
    if {$unc} {set pathname "\\$pathname"}
    if {$exclusion == 2} {regsub -all "(?q)\\" $pathname "\\\\" pathname}
  } elseif {!$::lib_ge_platform && $forced == 0 || $forced == 2} {
    if {$exclusion} {set pathname "$pathname$lib_ge_slash"}
    regsub -all "\\\\" $pathname "/" pathname
    if {![regexp -nocase -- {^//} $pathname]} {set unc 0} else {set unc 1}
    while {[regsub -- "(?q)//" $pathname "/" pathname]} {}
    if {$unc} {set pathname "/$pathname"}
  }

  if {$escape} {regsub -all "\\\\" $pathname "\\\\\\\\" pathname}

  set lib_ge(format_path,$pathbin,$exclusion,$forced,$escape) [string trim $pathname]
  return $lib_ge(format_path,$pathbin,$exclusion,$forced,$escape)

}

# <Documentation>
# This procedure formats a pathname from Unix or Windows
# format to the format of corresponding file system.
# <Arguments>
# pathname
#   Pathname to be formatted. It can be specified in Unix format (directory separator with /) or in Windows format (separator with \\ (=escaped backslash))
# exclusion
#   Closes the resulting path with a slash or backslash, when set to 1. Valid options are: 0 (no) and 1 (yes).
# forced
#   0 - automatically format path to the corresponding file system.
#   1 - format the path in Windows style.
#   2 - format the path in Unix style.
# escape
#   Adds escape character to all backslashes, when set to 1.  Valid options are: 0 (no) and 1 (yes).
# <Returnvalue>
# Formatted pathname.
# <Example>
# name: Example 1
# code: set result [LIB_GE_format_path_names "D:/Temp/mom/debug.out"]
# desc: result = D:\Temp\mom\debug.out (Windows format)
# <Example>
# name: Example 2
# code: set result [LIB_GE_format_path_names "D:\\Temp\\mom" 1]
# desc: result = D:\Temp\mom\ (Windows format)
# <Example>
# name: Example 3
# code: set result [LIB_GE_format_path_names "D:\\Temp\\mom" 1 2]
# desc: result = D:/Temp/mom/ (Unix format)
#____________________________________________________________________________________________
proc LIB_GE_sort_value {valuelist {sequence 0}} {
  if {$sequence == 1} {
    set valuelist [lsort -decreasing -real $valuelist]
  } elseif {$sequence == 0} {
    set valuelist [lsort -increasing -real $valuelist]
  }
  return [lindex $valuelist 0]

}
# <Documentation>
# This procedure returns the smallest or biggest value out of a list of values.
# <Arguments>
# valuelist
#   List containing numbers to be examined.
# sequence
#   0 - returns the smallest value.
#   1 - returns the biggest value.
# <Returnvalue>
# Smallest or biggest value.
# <Example>
# name: Smallest value
# code: set result [LIB_GE_sort_value {1 5 -11 2 9 -10 4 18 10 20 11 -1 19} 0]
# desc: result = -11
# <Example>
# name: Biggest value
# code: set result [LIB_GE_sort_value {1 5 -11 2 9 -10 4 18 10 20 11 -1 19} 1]
# desc: result = 20
#____________________________________________________________________________________________
proc LIB_GE_is_path {path} {

  if {[regexp -nocase -- {^[\\]{2}|^[A-Z][:][\\|\/]} $path]} {
    return 1
  } else {
    return 0
  }

}
# <Documentation>
# This procedure checks if a given pathname is a valid directory name.
# The existence of the directory is not checked. It's only a logical check.
# <Arguments>
# path
#   Pathname to check.
#   The pathname can be specified in Unix format (directory separator with /) or in Windows format (separator with \\ (=escaped backslash))
#   UNC pathname formats are valid as well.
# <Returnvalue>
# 0 - no valid pathname
# 1 - valid pathname
# <Example>
# name: Example 1
# code: set result [LIB_GE_is_path "C:\\Temp"]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [LIB_GE_is_path "d:/nc-progs"]
# desc: result = 1
# <Example>
# name: Example 3
# code: set result [LIB_GE_is_path "\\\\fileserver\\userdir\\user2"]
# desc: result = 1
#____________________________________________________________________________________________
proc LIB_GE_is_unc_path {path} {

  if {[regexp -nocase -- {^[\\]{2}|^[/]{2}} $path]} {
    return 1
  } else {
    return 0
  }

}
# <Documentation>
# This procedure checks if a given pathname is a valid UNC directory name .
# The existence of the directory is not checked. It's only a logical check.
# <Arguments>
# path
#   Pathname to check.
# <Returnvalue>
# 0 - no valid UNC pathname
# 1 - valid UNC pathname
# <Returnvalue>
# 0 - no valid pathname
# 1 - valid pathname
# <Example>
# name: Example 1
# code: set result [LIB_GE_is_unc_path "C:\\Temp"]
# desc: result = 0
# <Example>
# name: Example 1
# code: set result [LIB_GE_is_unc_path "\\\\fileserver\\userdir\\user2"]
# desc: result = 1
#____________________________________________________________________________________________
proc LIB_GE_set {para1 para2} {
  eval global [uplevel #0 info vars]

  if {[regexp -nocase -- {^(.*)\((.*)\)} $para1 a b c d]} {
    global $b
  } else {
    global $para1
  }

  set $para1 $para2

}
# <Documentation>
# This procedure sets a new global variable para1 with the value para2.
# It is not necessary to define the variable with global.
# <Arguments>
# para1
#   Name of the variable to define globally.
# para2
#   Value of the variable to set.
# <Returnvalue>
# None.
# <Example>
# LIB_GE_set test value
#____________________________________________________________________________________________
proc LIB_GE_lappend {para1 para2} {
  eval global [uplevel #0 info vars]

  if {[regexp -nocase -- {^(.*)\((.*)\)} $para1 a b c d]} {
    global $b
  } else {
    global $para1
  }

  lappend $para1 $para2

}
# <Documentation>
# This function appends the value para2 to the global list para1.
# It is not necessary to define the list para1 with global identifier.
# <Arguments>
# para1
#   Name of the variable to define globally.
# para2
#   Value to append to the global variable.
# <Returnvalue>
# None.
# <Example>
# LIB_GE_lappend test value
#____________________________________________________________________________________________
proc LIB_GE_ask_type_subtype {path_name tag type subtype} {
  global flag lib_ge_log_message
  global lib_ask_tag_from_operation
  global lib_get_type_subtype mom_path_name
  global mom_path_name mom_operation_id
  global mom_operation_type_enum mom_operation_type

  upvar $tag result_tag
  upvar $type result_type
  upvar $subtype result_subtype

  if {$path_name != $mom_path_name} {
    LIB_GE_abort_message "INS->LIB_GE_ask_type_subtype<- called with wrong argument INS->\"$path_name\"<-" "Currently only INS->\"mom_path_name\"<- (current operation) is supported as first argument"
  }

  if {[info exists mom_operation_id]} {
    set opertag $mom_operation_id
  }

  if {![info exists opertag] || ![regexp -nocase -- {^[0-9]} [string trim $opertag]]} {
    lappend lib_ge_log_message "[LIB_GE_MSG "TAG cannot be found in operation INS->$path_name<-"]"
    LIB_GE_abort_message "[LIB_GE_MSG "TAG cannot be found in operation INS->$path_name<-"]" "[LIB_GE_MSG "Please verify"]"
  }

  if {[info exists mom_operation_id] && [info exists mom_operation_type_enum]} {
    set opertag $mom_operation_id
    set opertype 100
    set opersubtype $mom_operation_type_enum
  } elseif {[info exists mom_operation_id] && [info exists mom_operation_type] && $mom_operation_type != ""} {
    set opertag $mom_operation_id
    set opertype 100
    set opersubtype $mom_operation_type
  } elseif {[llength [info commands JEDLL_GET_TYPE_SUBTYPE]]} {
    set error [JEDLL_GET_TYPE_SUBTYPE $opertag "$path_name,opertype" "$path_name,opersubtype"]
    if {$error!=0} {lappend lib_ge_log_message "Command JEDLL_GET_TYPE_SUBTYPE $::errorInfo"}

    if {[info exists jedll_get_type_subtype($path_name,opertype)]} {
      set opertype $jedll_get_type_subtype($path_name,opertype)
    } else {
      LIB_GE_error_message "[LIB_GE_MSG "JEDLL_GET_TYPE_SUBTYPE have at opertype 'INS->$path_name<-' no result"]"
    }

    if {[info exists jedll_get_type_subtype($path_name,opersubtype)]} {
      set opersubtype $jedll_get_type_subtype($path_name,opersubtype)
    } else {
      LIB_GE_error_message "[LIB_GE_MSG "JEDLL_GET_TYPE_SUBTYPE have at opersubtype 'INS->$path_name<-' no result"]"
    }
  } else {
    LIB_GE_abort_message "[LIB_GE_MSG "Unknown ID at 'INS->$mom_path_name<-'" "Please verify"]"
  }

  set result_tag $opertag
  set result_type $opertype
  set result_subtype $opersubtype

}
# <Internal Documentation>
# This function returns the tag, type and subtype of a given tool path name.
# <Internal Arguments>
# path_name
#   Name of the tool path to query.
# tag
#   Variable name where the tag should be stored.
# type
#   Variable name where the type should be stored.
# subtype
#   Variable name where the subtype should be stored.
# <Internal Returnvalue>
# TYPE     100 = machining operation
#
# SUBTYPE    1 = mach instanced oper
# SUBTYPE    2 = mach orphan oper
# SUBTYPE   10 = mach oldopr
# SUBTYPE   11 = mach mill post cmnds
# SUBTYPE   13 = mach lathe post cmnds
# SUBTYPE   17 = mach wed post cmnds
# SUBTYPE  110 = mach pocket
# SUBTYPE  210 = mach surface contour
# SUBTYPE  211 = mach vasc
# SUBTYPE  220 = mach gssm main op
# SUBTYPE  221 = mach gssm sub op
# SUBTYPE  222 = mach gssm grip
# SUBTYPE  230 = mach param line
# SUBTYPE  240 = mach zig zag surf
# SUBTYPE  250 = mach rough to depth
# SUBTYPE  260 = mach cavity milling
# SUBTYPE  261 = mach face milling
# SUBTYPE  262 = mach volumn milling
# SUBTYPE  263 = mach zlevel milling
# SUBTYPE  264 = mach fb hole milling
# SUBTYPE  265 = mach plunge milling
# SUBTYPE  266 = mach vazl milling
# SUBTYPE  310 = mach lathe rough
# SUBTYPE  320 = mach lathe finish
# SUBTYPE  330 = mach lathe groove
# SUBTYPE  340 = mach lathe thread
# SUBTYPE  350 = mach drill
# SUBTYPE  360 = mach lathe face
# SUBTYPE  450 = mach point to point
# SUBTYPE  460 = mach seq curve mill
# SUBTYPE  461 = mach seq curve lathe
# SUBTYPE  510 = mach turn rough
# SUBTYPE  520 = mach turn finish
# SUBTYPE  530 = mach turn teachmode
# SUBTYPE  540 = mach turn thread
# SUBTYPE  550 = mach turn cdrill
# SUBTYPE  560 = mach turn auxiliary
# SUBTYPE  600 = mach hole making
# SUBTYPE  700 = mach wedm
# SUBTYPE  800 = mach mill ud
# SUBTYPE  900 = mach gmc
# SUBTYPE 1000 = mach probing
# SUBTYPE 1100 = mach mill mc
# SUBTYPE 1200 = mach lathe mc
# SUBTYPE 1300 = mach wedm mc
# SUBTYPE 1400 = mach lathe ud
# SUBTYPE 1500 = mach wedm ud
# SUBTYPE 1600 = mach mass edit
# SUBTYPE 1700 = mach thread milling
# SUBTYPE 1800 = insp tolerance
# SUBTYPE 1900 = insp path
# SUBTYPE 2000 = insp output
# SUBTYPE 2100 = insp misc
# SUBTYPE 2200 = insp align
# SUBTYPE 2300 = insp sensor
# SUBTYPE 2400 = insp construct
# SUBTYPE 2500 = insp bounding feature
# SUBTYPE 2600 = insp feature
# SUBTYPE 2700 = mach cylinder milling subtype
# SUBTYPE 2800 = mach canned cycle subtype
# SUBTYPE 2900 = mach laser teachmode subtype
# SUBTYPE 3000 = mach hole drilling subtype
# SUBTYPE 3100 = mach groove milling subtype
# SUBTYPE 3200 = mach chamfer milling subtype
# SUBTYPE 3300 = mach radial groove milling subtype
#
# <Internal Example>
# set error [LIB_GE_ask_type_subtype $mom_path_name tag type subtype]
#____________________________________________________________________________________________
proc LIB_GE_is_volumill_op {{arg "init"}} {
  global mom_attr_OPER_VOLUMILL_OPERATION
  set retval 0
  if {[info exists mom_attr_OPER_VOLUMILL_OPERATION] && [regexp -nocase "volumill" $mom_attr_OPER_VOLUMILL_OPERATION]} {
    set retval 1
  }
  if {$arg == "reset" && [info exists mom_attr_OPER_VOLUMILL_OPERATION]} {
    unset mom_attr_OPER_VOLUMILL_OPERATION
  }
  return $retval
}
# <Internal Documentation>
# This function can be used to check if current operation is a Volumill Operation
# <Internal Arguments>
# arg
#    if set to reset, mom_attr_OPER_VOLUMILL_OPERATION will be unset
# <Internal Returnvalue>
# 0 : it is not a volumill operatiom
# 1 : it is a volumill operation
#____________________________________________________________________________________________
proc LIB_GE_is_imachining_op {} {
  global mom_operation_type_enum
  global mom_template_subtype
  set retval 0
  if {[info exists mom_operation_type_enum]} {
    if {$mom_operation_type_enum == 800 && [regexp -nocase "imachining" $mom_template_subtype]} {
      set retval 1
    }
  }
  return $retval
}
# <Internal Documentation>
# This function can be used to check if current operation is a Volumill Operation
# <Internal Arguments>
# --
# <Internal Returnvalue>
# 0 : it is not a iMachining operatiom
# 1 : it is a iMachining operation
#____________________________________________________________________________________________
proc LIB_GE_read_expression_value {expression {defaultValue ""} {errorHandling abortMsg} {formatDef ""}} {
  global flag count mom_libref std_warnings std_message

  set error_part 1
  set error_part [catch {set expr_value [MOM_ask_ess_exp_value $expression]}]

  if {[info exists expr_value] && $error_part == 0 && $expr_value != "No such variable defined in expression"} {

    if {$formatDef != ""} {
      if {[catch {set expr_value [format $formatDef $expr_value]}]} {
        set error [LIB_SPF_add_warning "'INS->LIB_GE_read_expression_value $expression<-', value 'INS->$expr_value<-' can not be formated as 'INS->$formatDef<-' --> formatting ignored"]
      }
    }

    return $expr_value

  } else {
    if {[string tolower $errorHandling] == "warning"} {
      set error [LIB_SPF_add_warning "No such variable defined in expression 'INS->$expression<-'"]
    } elseif {[string tolower $errorHandling] == "abortmsg"} {
      LIB_GE_abort_message "Expression error" "No such variable defined in expression 'INS->$expression<-'"
    } elseif {[string tolower $errorHandling] == "errormsg"} {
      LIB_GE_error_message "Expression error" "No such variable defined in expression 'INS->$expression<-'"
      set error [LIB_SPF_add_warning "No such variable defined in expression 'INS->$expression<-'"]
    }

    if {$defaultValue != ""} {
      if {[catch {set defaultValue [format $formatDef $defaultValue]}]} {
        set error [LIB_SPF_add_warning "'INS->LIB_GE_read_expression_value $expression<-', defaultValue 'INS->$defaultValue<-' can not be formated as 'INS->$formatDef<-' --> formatting ignored"]
      }
    }

    return $defaultValue
  }

}
# <Documentation>
# This procedure reads expression values out of NX. You can specify the error
# handling in the case when the expression is not defined.
# <Arguments>
# expression
#   Expression to be read.
# defaultValue
#   Value to be returned if expression is not defined.
#   If this option is not defined, an empty string is returned.
# errorHandling
#   Defines the type of message to be generated if the expression is not defined. Valid options are:
#   warning  - Add a warning to the warning list in listing window.
#   abortMsg - Abort postprocessor run.
#   errorMsg - Generate error message (popup dialog) and add a warning to the warning list in listing window.
#   noWarning (or any other value) - Do not generate any warning/message/abort.
# formatDef
#   Defines the format of the return value.
#   Valid values for this argument are valid format string definitions of the TCL format command.
# <Returnvalue>
# Value of the queried expression or default value if expression is not defined.
# <Example>
# set result [LIB_GE_read_expression_value "MY_EXPRESSION" "my_expression_default_value" warning]
#_______________________________________________________________________________
proc LIB_GE_delayed_output_message {event text {position "leave"} {option "output_1"}} {
  global lib_ge_tclversion lib_ge_delayed_output_message
  global mom_path_name

  switch -- $position {
    start     {set delayed_output "enter"}
    end     {set delayed_output "leave"}
    default   {set delayed_output "leave"}
  }

  if {$lib_ge_tclversion > 8.3} {
    set variablename "lib_ge_delayed_output_message($mom_path_name,$event,$delayed_output)"
    set proc_body "lappend $variablename \"LIB_GE_message \\\{$text\\\} $option\"\n"

    if {![info exists $variablename]} {
      set tracer "trace add execution $event $delayed_output \{LIB_GE_delayed_output_message_eval $mom_path_name $event $delayed_output\}"
      if {1} $tracer
    }

    if {1} $proc_body
  }
}
# <Documentation>
#
# This procedure outputs a message when postprocessing encounters a given MOM event.
#
# <Arguments>
# event
#    The MOM event that produces the message.
# text
#    The text string to be output in the message.
# position
#    The position to which the message is output, relative to postprocessing of the MOM event.
#    The valid arguments are start and end. Default value is end.
# option
#   Valid options are:
# create_0 = variable is returned directly
# create_1 = variable is returned with prefix from lib_ge_message_dspa1 and suffix from lib_ge_message_dspz1
# create_2 = variable is returned with prefix from lib_ge_message_dspa2 and suffix from lib_ge_message_dspz2
# create_3 = variable is returned with prefix from lib_ge_message_dspa3 and suffix from lib_ge_message_dspz3
# output_0 = variable is outputed directly
# output_1 = variable is outputed directly with prefix from lib_ge_message_dspa1 and suffix from lib_ge_message_dspz1
# output_2 = variable is outputed directly with prefix from lib_ge_message_dspa2 and suffix from lib_ge_message_dspz2
# output_3 = variable is outputed directly with prefix from lib_ge_message_dspa3 and suffix from lib_ge_message_dspz3
#
# <Returnvalue>
# The create options return the text value to the procedure. The output options execute a MOM_output_literal command and no value is returned
# <Example>
# LIB_GE_delayed_output_message MOM_end_of_path "This is my text" end output_1
# <Example>
# name: Example 2
# code: LIB_GE_delayed_output_message MOM_end_of_path "This is my text"
# desc: Both of these examples  write This is my text to the output file after processing the MOM_end_of_path event.
#____________________________________________________________________________________________
proc LIB_GE_delayed_output_message_eval {args} {
  global lib_ge_delayed_output_message

  set path_name [lindex $args 0]
  set proc      [lindex $args 1]
  set output    [lindex $args 2]

  foreach e $lib_ge_delayed_output_message($path_name,$proc,$output) {
    if {1} $e
  }
  set removetr "trace remove execution $proc $output \{LIB_GE_delayed_output_message_eval $path_name $proc $output\}"
  if {1} $removetr
}
# <Internal Documentation>
#
# This function is used to output the delayed_output_messages and remove the tracer.
#
# This is a BlackBox function. Don't use in your code - is called automatically
#____________________________________________________________________________________________
proc LIB_GE_message {message {option "output_1"} {forcelinenumber "0"} {replace_special_characters ""} {wordwrap "0"}} {
  global lib_flag
  global lib_ge_message_dspa1 lib_ge_message_dspz1
  global lib_ge_message_dspa2 lib_ge_message_dspz2
  global lib_ge_message_dspa3 lib_ge_message_dspz3
  global lib_ge_message_switch
  global mom_sys_control_out mom_sys_control_in
  global mom_post_in_simulation

  if {$replace_special_characters != ""} {
    set cache_replace_special_characters [CONF_GE_msg replace_special_characters]
    CONF_GE_msg set replace_special_characters $replace_special_characters
  }

  set suppress 0

  if {[string trim $message] != ""} {

    if {[CONF_GE_msg message_switch] && [info exists mom_sys_control_out] && [info exists mom_sys_control_in]} {
      set lib_ge_message_dspa1 $mom_sys_control_out
      set lib_ge_message_dspz1 $mom_sys_control_in
    }

    if {[lindex [info level -1] 0] != "MOM_insert"} {
      #if coming from MOM_insert we no longer do any translation or character replacement
      #But the use of TCL->, MOM-> and EXP-> Keywords is still supported
      set message [LIB_GE_MSG $message "" $replace_special_characters]
    }

    if {[string match "*MOM->*" $message]} {
      while {[regexp -- {(MOM->(?!.*MOM->))(.[^<][^-]+)(<-)} $message all start body end] > 0} {

        set replace ""
        if {[catch {
          if {[llength [info commands $body]]} {
            set replace [$body]
          } else {
            if {[regexp -nocase -- {^(.*)\((.*)\)} $body a b c]} {
              global $b
            } else {
              global $body
            }
            if {[info exists $body]} {
              set replace "[subst $$body]"
              if {[regexp -- {\$\{[^\}]+.} $replace]} {
                set replace [LIB_GE_search_pathname $replace]
              }
            }
          }
        } err]} {
          LIB_GE_error_message "[LIB_GE_MSG "The syntax from string is not ok at INS->[info level 0]<-"]" "[LIB_GE_MSG "Errorline is 'INS->$body<-'\n\n$err"]"
        }

          if {![regsub -- (?q)$all $message $replace message]} {break}

      }
    }

    if {[string match "*EXP->*" $message]} {
      while {[regexp -- {(EXP->(?!.*EXP->))(.[^<][^-]+)(<-)} $message all start body end] > 0} {

        set replace ""
        if {[catch {
          if {[llength [info commands $body]]} {
            set replace [$body]
          } else {
            set replace [LIB_GE_read_expression_value $body "-- [LIB_GE_MSG "No such variable defined in Expression 'INS->$body<-'"] --" "warning"]
          }
        } err]} {
          LIB_GE_error_message "[LIB_GE_MSG "The syntax from string is not ok at INS->[info level 0]<-"]" "[LIB_GE_MSG "Errorline is 'INS->$body<-'\n\n$err"]"
        }

          if {![regsub -- (?q)$all $message $replace message]} {break}

      }
    }

    if {[string match "*TCL->*" $message]} {
      while {[regexp -- {(TCL->(?!.*TCL->))(.+)(<-)} $message all start body end] > 0} {
        set replace "" ; set body [LIB_FH_escape_special_characters $body]
        if {[catch {set dummy [eval set replace "\[${body}\]"]} err]} {
          LIB_GE_error_message "[LIB_GE_MSG "The syntax from string is not ok at INS->[info level 0]<-"]" "[LIB_GE_MSG "Errorline is 'INS->$body<-'\n\n$err"]"
        }
        if {![regsub -- (?q)$all $message $replace message]} {break}
      }
    }
    if {[CONF_GE_msg message_to_upper]} {
      set message [LIB_GE_string_toupper $message]
    }
    if {![string compare "NEWLINE" $message]} {
      MOM_suppress once N
    }

  }

  if {[regexp "output" $option] == 1 && [CONF_GE_msg message_with_seqnum] != 1 && $forcelinenumber != "1"} {
    set suppress 1
    if {!$wordwrap} {MOM_suppress once N}
  }

  switch -- $option {

    "create_0"  {
      return "$message"
    }
    "create_1"  {
      return "[CONF_GE_msg message_dspa1]$message[CONF_GE_msg message_dspz1]"
    }
    "create_2"  {
      return "[CONF_GE_msg message_dspa2]$message[CONF_GE_msg message_dspz2]"
    }
    "create_3"  {
      return "[CONF_GE_msg message_dspa3]$message[CONF_GE_msg message_dspz3]"
    }
    "output_0"  {
      if {$wordwrap} {
        return [MOM_output_literal [LIB_GE_truncate_line MOM_output_literal "" "$message" "" [CONF_SPF_file max_line_length] $suppress]]
      } else {
        return [MOM_output_literal "$message"]
      }
    }
    "output_1"  {
      if {$wordwrap} {
        return [MOM_output_literal [LIB_GE_truncate_line MOM_output_literal [CONF_GE_msg message_dspa1] "$message" [CONF_GE_msg message_dspz1] [CONF_SPF_file max_line_length] $suppress]]
      } else {
        return [MOM_output_literal "[CONF_GE_msg message_dspa1]$message[CONF_GE_msg message_dspz1]"]
      }
    }
    "output_2"  {
      if {$wordwrap} {
        return [MOM_output_literal [LIB_GE_truncate_line MOM_output_literal [CONF_GE_msg message_dspa2] "$message" [CONF_GE_msg message_dspz2] [CONF_SPF_file max_line_length] $suppress]]
      } else {
        return [MOM_output_literal "[CONF_GE_msg message_dspa2]$message[CONF_GE_msg message_dspz2]"]
      }
    }
    "output_3"  {
      if {$wordwrap} {
        return [MOM_output_literal [LIB_GE_truncate_line MOM_output_literal [CONF_GE_msg message_dspa3] "$message" [CONF_GE_msg message_dspz3] [CONF_SPF_file max_line_length] $suppress]]
      } else {
        return [MOM_output_literal "[CONF_GE_msg message_dspa3]$message[CONF_GE_msg message_dspz3]"]
      }
    }
    "default"   {
      return "$message"
    }
  }

  if {$replace_special_characters != ""} {
    CONF_GE_msg set replace_special_characters $cache_replace_special_characters
  }

}
# <Documentation>
# This procedure is used to output comments, nc inserts, user messages, and more to the NC code output file. This is an enhanced string handling function that is called internally.
# You can use this procedure instead of MOM_output_literal to control the output with the prefix, suffix, and control codes.
# The following control codes are valid:
#
#
# MOM->XXX<- Inserts the values of MOM variables that are available at the respective event.
#
# EXP->XXX<- Inserts the values of expressions in NX.
#
# TCL->XXX<- Calls procedures and functions with TCL code.
#
# - How to handle it:
# LIB_GE_message "The Toolradius is TCL->expr MOM->mom_tool_diameter<-/2<- at the expression EXP->Test1<-"
# - very advanced example:
# LIB_GE_message "The Toolperimeter is TCL->format %.2f [expr 2*(2.0*asin(1.0))*(MOM->mom_tool_diameter<-/2)]<- at MOM->mom_tool_name<-"
# - or with a function call
# proc myproc {} {
#   return "now active"
# }
# LIB_GE_message "Laser TCL->myproc<-"
#
# <Arguments>
# message
#   Message to be output. Message can be enriched with control codes as described above.
# option
#   Output style. Valid options are:
# create_0 = variable is returned without prefix/suffix
# create_1 = variable is returned with prefix from dspa1 and suffix from dspz1 (both is set in PostConfig object message)
# create_2 = variable is returned with prefix from dspa2 and suffix from dspz2 (both is set in PostConfig object message)
# create_3 = variable is returned with prefix from dspa3 and suffix from dspz3 (both is set in PostConfig object message)
# output_0 = variable is written to the nc code without prefix/suffix
# output_1 = variable is written to the nc code with prefix from dspa1 and suffix from dspz1 (both is set in PostConfig object message)
# output_2 = variable is written to the nc code with prefix from dspa2 and suffix from dspz2 (both is set in PostConfig object message)
# output_3 = variable is written to the nc code with prefix from dspa3 and suffix from dspz3 (both is set in PostConfig object message)
# forcelinenumber
#    Output text to the NC code file with a line number (only for option output_0..output_3), provided that in the configuration object message the property message_with_seqnum is set to true.
#    Valid options are: 0 (no) and 1 (yes).
# replace_special_characters
#   Define character conversion if desired. Valid options are:
#     0 = Direct output.
#     1 = Replace special characters to international spelling.
#     2 = Replace special characters to html.
#     3 = Replace UTF-8 to Unicode.
# wordwrap
#   Allows a text string to wrap into the next line. Valid options are:
#   0 = No word wrap
#   1 = Split string to several lines if maximum string length exeeds [CONF_SPF_file max_line_length] (only for options output_0..output_3).
# <Returnvalue>
#   None for options output_0..output_3.
#   Formatted message for options create_0..create_3.
#
# <Example>
# name: Simple text output
# code: LIB_GE_message "This is the message text"
# desc: Creates a MOM_output_literal "This is the message text"
# <Example>
# name: Comment output
# code: LIB_GE_message "this is a comment" output_1
# desc: Writes this is a comment with respective comment prefix and suffix to the NC code output file.
# <Example>
# name: Creates a string with the value of an NX expression
# code: set result [LIB_GE_message EXP->R_Param1<- create_0]
# desc: result = value of R_Param1
#____________________________________________________________________________________________
proc LIB_GE_truncate_line {command leader text trailer {length 999} {suppress 0}} {

  set text    [string trim $text]
  if {!$suppress} {set tmpleader "$::mom_sys_leader(N)[MOM_ask_address_value N] $leader"} else {set tmpleader $leader}
  set lengthleader  [string length $tmpleader]
  set leadertext    [string length $text]
  set lengthtrailer   [string length $trailer]

  set length [expr ($length-($lengthleader+$lengthtrailer))-1]
  if {[string length $text] <= $length} {return "$leader[string trim $text]$trailer"}

  while {[string length $text] > 0} {

    if {[info exists tmp]} {if {$suppress} {MOM_suppress once N} ; $command "$leader[string trim $tmp]$trailer"}
    set tmp "" ; set check 0

    if {[string length $text] < $length || ![regexp {(.+ )} [string range $text 0 $length] all tmp]} {set tmp [string range $text 0 $length]}
    set tmp [string trim $tmp]

    #$command "vv$leader[string trim $tmp]$trailer"
    regsub $tmp $text "" text
    set text [string trim $text]
  }

  if {$suppress} {MOM_suppress once N}
  return "$leader[string trim $tmp]$trailer"

}
# <Documentation>
# This procedure splits a line into multiple lines if it extends beyond a defined maximum length.
# The output command (for example, MOM_output_literal, MOM_output_text) must be defined.
# <Arguments>
# command
#   MOM command to be used for the output. In most cases this is MOM_output_literal.
# leader
#   Character(s) to be added at the start of every output line.
# text
#   Text to output.
# trailer
#   Character(s) to be added at the end of every output line.
# length
#   Maximum output length per line. If the length of the current line is over the limit, a new line is output with the rest of the text.
# suppress
#    Valid options are:
# 1 - No line numbers are output
# 0 - Line number are output
# <Returnvalue>
# If the given text is shorter than length, the whole string is returned here.
# If the given text is longer, only the remaining part of text is returned here. The other parts are output
# directly with the command.
# <Example>
# name: Example 1
# code: set result [LIB_GE_truncate_line MOM_output_literal "" "$message" "" 80]
# desc: The string in the variable message is split and output with MOM_output_literal on several lines if it's longer than 80 characters.
# The remaining part is returned to the variable result.
# <Example>
# name: Example 2
# code: MOM_output_literal [LIB_GE_truncate_line MOM_output_literal "(" "$message" ")" 40 1]
# desc: The string in the variable message is split and output with MOM_output_literal on several lines if it's longer than 40 characters.
# The remaining part is output MOM_output_literal. Every line starts with ( and ends with ) and line numbers are suppressed.
#____________________________________________________________________________________________
proc LIB_GE_is_divisible {value {divider 2}} {

  if {$value % $divider == 0} {
    # even
    return 1
  } else {
    # uneven
    return 0
  }

}
# <Internal Documentation>
# This procedure checks if a given input value can be evenly divided. (2 is the default divider).
# The check is true if the divided resulting value is an integer value.
# <Internal Arguments>
# value
#   Number to be checked.
# divider
#   Divider to be applied.
# <Internal Returnvalue>
# 1 - Division result is an integer value
# 0 - Division result is not an integer (result is a decimal value)
# <Internal Example>
# name: Example 1
# code: set result [LIB_SPF_is_divisible 20]
# desc: result = 1
# <Internal Example>
# name: Example 2
# code: set result [LIB_SPF_is_divisible 21]
# desc: result = 0
# <Internal Example>
# name: Example 3 with optional divider 3
# code: set result [LIB_SPF_is_divisible 9 3]
# desc: result = 1
#____________________________________________________________________________________________
proc LIB_GE_MSG {text {possibilities ""} {replace_special_characters ""}} {
  global lib_flag lib_ge_pretreatment_runtime
  global lib_msg lib_ge_language
  global lib_ge_operator_language
  global lib_ge_controller_language

  if {$lib_flag(omit_translation)} {return $text}

  if {$replace_special_characters != ""} {
    set cache_replace_special_characters [CONF_GE_msg replace_special_characters]
    CONF_GE_msg set replace_special_characters $replace_special_characters
  }

  if {![info exists lib_ge_language]} {set lib_ge_language "english"} else {set lib_ge_language [string tolower $lib_ge_language]}

  if {[CONF_GE_language operator_language] != [string tolower [CONF_GE_language operator_language]]} {
    CONF_GE_language set operator_language [string tolower [CONF_GE_language operator_language]]
  }

  set index -1
  set lib_msg($index,english) "$text"

  if {![info exists lib_msg(array)]} {
    set lib_msg(array,org) [array get lib_msg]
    for { set n 0 } { $n < [llength $lib_msg(array,org)] } { incr n 2 } {
      lappend lib_msg(array,unsort) [list [lindex $lib_msg(array,org) $n] [list [lindex $lib_msg(array,org) [expr $n+1]]]]
    }
    # None core messages at first order in the list, so customer entries wins
    set lib_msg(array,sort) [lsort -index 0 $lib_msg(array,unsort)]
    regsub -all "\t" $lib_msg(array,org) " " lib_msg(array,org)
    set lib_msg(array,org) ""

    set array_str [join $lib_msg(array,sort)]
          set lib_msg(array,org) [join $array_str]

    for { set n 0 } { $n < [llength $lib_msg(array,org)] } { incr n } {
      set element [lindex $lib_msg(array,org) $n]
      if {[LIB_GE_is_divisible $n] && [llength [split $element ","]] == 3 && [LIB_GE_is_divisible [regsub -all "," $element "" dummy]]} {
        # Change the keyword to binary values end replace the variable name
        # orginal = lib_msg(0000,customer,english)
        # change keyword e.g. ,customer = 44 99 117 115 116 111 109 101 114
        # result = 00004499117115116111109101114,english
        # This is only the case at non core messages
        set search [string range $element [string first "," $element] [expr [string last "," $element]-1]]
        binary scan $search c* codeintercept
        regsub -all " " $codeintercept "" codeintercept
        regsub -all $search $element $codeintercept dummy
        lappend lib_msg(array) $dummy
        # Create the new variable
        set lib_msg($dummy) $lib_msg($element)
      } else {
        lappend lib_msg(array) [lindex $lib_msg(array,org) $n]
      }
    }
  }

  regsub -all "\t" $text " " text

  if {[string is integer $possibilities] && $possibilities == 1} {
    if {[CONF_GE_language controller_language] == ""} {
      set lib_ge_temp_language [string tolower $lib_ge_language]
    } else {
      set lib_ge_temp_language [CONF_GE_language controller_language]
    }
  } elseif {$possibilities != "" && (![llength [info commands LIB_SPF_is_integer]] || ![string is integer $possibilities])} {
    set lib_ge_temp_language [string tolower $possibilities]
  } elseif {[CONF_GE_language operator_language] != ""} {
    set lib_ge_temp_language [CONF_GE_language operator_language]
  } else {
    set lib_ge_temp_language $lib_ge_language
  }

  if {[string length $lib_ge_temp_language] && [string is digit $lib_ge_temp_language]} {
    LIB_GE_abort_message "The defined language is not supported 'INS->$lib_ge_temp_language<-'" "Check lib_ge_operator_language or lib_ge_language" "ERROR" 0
  }
  if {![info exists lib_ge_temp_language]} {LIB_GE_abort_message "There is no translation language defined INS->LIB_GE_MSG '$text'<-" "Please verify" "ERROR" 0}

  if {![info exists lib_flag(language_is_supported_by_os)]} {
    if {[llength [info commands MOM_ask_language_output_support]]} {
      set lib_flag(language_is_supported_by_os) [MOM_ask_language_output_support $lib_ge_temp_language]
      if {!$lib_flag(language_is_supported_by_os)} {
        set lib_flag(omit_translation) 1
        LIB_SPF_add_warning "Language 'INS->$lib_ge_temp_language<-' is not supported in current OS, therefore message/s will appear in English." 1 direct
        set lib_flag(omit_translation) 0
      }
    } else {
      set lib_flag(language_is_supported_by_os) 1
    }
  }

  if {!$lib_flag(language_is_supported_by_os)} {
    set lib_ge_temp_language "english"
  }

  for { set n 1 } { $n <= [regsub -all "INS->" $text "OUT->" text] } { incr n } {
    set z 0
    for { set x 0 } { $x <= [string length $text] } { incr x } {
      if {[regexp -nocase -- {(OUT->([^<]+)<-)} [string range $text 0 $x ] all search command]} {
        set buffer([expr $x+$z]) $command
        regsub -all "(?q)$search" $text "INS-><-" text
        if {[lsearch -exact $lib_msg(array) $text] > -1} {
          set index "[lindex [split [lindex $lib_msg(array) [expr [lsearch -exact $lib_msg(array) $text]-1]] ","] 0]"
          if {[array get lib_msg $index,$lib_ge_temp_language] != "" && $lib_msg($index,$lib_ge_temp_language) != "NOT TRANSLATED"} {
            set text $lib_msg($index,$lib_ge_temp_language)
          } else {
            if {[CONF_GE_language message_is_not_translated] && [lsearch -exact $lib_flag(not_translated) "$index $lib_msg($index,core)"] < 0} {
              set lib_flag(omit_translation) 1
              incr lib_flag(nottranslated)
              lappend lib_flag(not_translated) "$index $lib_msg($index,core)"
              LIB_SPF_add_warning "Language 'INS->$lib_ge_temp_language<-' is not fully translated, therefore SUBST->\$::lib_flag(nottranslated)<- message/s will appear in English." 1 direct
              set lib_flag(omit_translation) 0
            }
            set lib_ge_temp_language "core"
            set text $lib_msg($index,$lib_ge_temp_language)
          }
        } else {
          set z [expr $x+$z] ; set x 0
        }
      }
    }
    if {[info exists buffer]} {
      foreach e [lsort -dictionary [array names buffer]] {
        regsub -- "INS-><-" $text "$buffer($e)" text
      }
    }
    regsub -all "OUT-><-" $text "'UNKNOWN'" text
    if {[info exists buffer]} {unset buffer}
  }

  set debug 0

  if {[regexp -- {^[.0-9]+$} $text] && ([info exists lib_msg($text,$lib_ge_temp_language)] || [array get lib_msg $index,english] != "")} {
    if {[info exists lib_msg($text,$lib_ge_temp_language)] && $lib_msg($text,$lib_ge_temp_language) != "NOT TRANSLATED"} {
      LIB_GE_return [LIB_GE_replace_special_characters $lib_msg($text,$lib_ge_temp_language)] $debug
    } elseif {[array get lib_msg $index,english] != ""} {
      LIB_GE_return [LIB_GE_replace_special_characters $lib_msg($index,english)] $debug
    }
  } elseif {[lsearch -exact $lib_msg(array) $text] > -1} {
    set a [lindex [split [lindex $lib_msg(array) [expr [lsearch -exact $lib_msg(array) $text]-1]] ","] 0]
    if {[info exists lib_msg($a,$lib_ge_temp_language)] && \
        $lib_msg($a,$lib_ge_temp_language) != "NOT TRANSLATED"} {
      if {$possibilities == 2} {return $a}
      LIB_GE_return [LIB_GE_replace_special_characters $lib_msg($a,$lib_ge_temp_language)] $debug
    } elseif {[info exists lib_msg($a,english)]} {
      if {$possibilities == 2} {return $a}
      LIB_GE_return [LIB_GE_replace_special_characters $lib_msg($a,english)] $debug
    } else {
      # The case if no translation found
      LIB_GE_return [LIB_GE_replace_special_characters $text] $debug
    }
  } else {
    LIB_GE_return [LIB_GE_replace_special_characters $text] $debug
  }

  if {$replace_special_characters != ""} {
    CONF_GE_msg set replace_special_characters $cache_replace_special_characters
  }

}
# <Documentation>
# This procedure translates postprocessor core messages into the desired language.
# The desired language is derived from the NX variable UGII_LANG but can be overwritten in
# PostConfigurator with [CONF_GE_language operator_language].
# In order to translate text, the messages have to be defined in the language files.
# System messages are defined in lib_msg (encrypted). Controller messages are defined in
# ctrl_XXXX_base_msg. Additional messages can be added in a customer_msg file in the following
# format:
#set lib_msg(0000,customer,core)           "File INS-><- not found"
#set lib_msg(0000,customer,english)        "File INS-><- not found"
#set lib_msg(0000,customer,german)         "Datei INS-><- nicht gefunden"
#set lib_msg(0000,customer,french)         "Fichier INS-><- non trouvé"
#set lib_msg(0000,customer,italian)        "File INS-><- non trovato"
#set lib_msg(0001,customer,core)           "Message2"
#set lib_msg(0001,customer,english)        "Message2"
#set lib_msg(0001,customer,german)         "Nachricht2"
#set lib_msg(0001,customer,french)         "Message2"
#set lib_msg(0001,customer,italian)        "Messaggio2"
#
# <Arguments>
# text
#   Text to be translated. Text must match the lib_msg(xx,yy,core) part to be translated.
# possibilities
#   Language - the language of the returned message (for example, German: direct translation into desired language and omit default language setting).
#   1 - use controller language instead of operator language.
#   2 - for debug purpose: display message number of respective message.
# replace_special_characters
#   Define character conversion if desired. Valid options are:
#     0 = direct output
#     1 = replace special characters to international spelling
#     2 = replace special characters to html
#     3 = replace UTF-8 to Unicode
#
# <Returnvalue>
# Translated text. If no translation could be found, the text is returned unchanged.
# <Example>
# name: Standard translation
# code: set message [LIB_GE_MSG "Configuration file does not exist"]
# desc: The message contains the text translated into the current postprocessor language.
# <Example>
# name: Translation of variable text
# code: set message [LIB_GE_MSG "File can not be copied from INS->xxx<- to INS->zzz<-"]
# desc: Variable text must be between INS-> and <-. Only the remaining text is translated and the
#      variable text is inserted between INS-><-. The text in the message file has to
#      contain the INS-><- statement (see description above).
# <Example>
# name: Translation of variable text, example 2
# code: set message [LIB_GE_MSG "File INS->C:\\Temp\\xxx.txt<- not found"]
# desc: The text File not found is translated. C:\\Temp\\xxx.txt is conserved as it is.
# <Example>
# name: Translation into special language
# code: set message [LIB_GE_MSG "SURFACE COORDINATE" "german"]
# desc: The message contains the translated text in German.
#____________________________________________________________________________________________
proc LIB_GE_MSG_INV {text {possibilities 0}} {
  while {[regexp -nocase -- {(CONV->)(.*?)(<-)} $text all first translationtext last]} {
    set message ""
    set message [LIB_GE_MSG $translationtext $possibilities]
    regsub "$first$translationtext$last" $text $message text
  }

  return $text

}
# <Internal Documentation>
# In this function, the text in the appropriate language UGII_LANG is only translated,
# if it set at CONV->xxx<-.
# Optional wildcards can be used in the example.
#
# The standard language UGII_LANG is overwritten if the variable lib_ge_operator language set
#
# Special situations and control possibilities
# Possibilitie 1. (Special issue of language when describing variable according lib_ge_controller_language)
# Possibilitie 2. (Special issue on the client side so only the error code an not the message is represents)
#
# <Internal Example>
# set message [LIB_GE_MSG_INV ";CONV->CIRCLE DIAMETER<-"]
# set message [LIB_GE_MSG_INV "1. CONV->STARTING POINT 2RD AXIS<- 2. CONV->STARTING POINT 3RD AXIS<-"]
#____________________________________________________________________________________________
proc LIB_GE_string_toupper {arg {check 0}} {
  global lib_ge_tclversion

  set count 0 ; set pattern "\(\(MOM|EXP|TCL|INS|OUT|BUFFER|CONV\)->\[^<-\]+<-\)"

  while {[regexp -- $pattern $arg all result]} {
    incr count ; set command($count) $result
    regsub -- $pattern $arg "-@$count@-" arg
  }
  set arg [string toupper $arg]
  for { set n 1 } { $n <= $count } { incr n } {
    regsub -- "-@$n@-" $arg $command($n) arg
  }
  return $arg

}
# <Documentation>
# This procedure converts a text string to upper case. Use this function when working with multibyte
# strings as the standard TCL function string toupper causes problems when converting special characters.
# <Arguments>
# arg
#   Text string to convert to uppercase.
# check
#   Valid options are:
# 1 - Special characters (like umlaut) are converted before doing the uppercase conversion.
# 0 - Special characters are not converted.
# <Returnvalue>
# Converted string.
# <Example>
# set text [LIB_GE_string_toupper $text]
#____________________________________________________________________________________________
proc LIB_GE_string_tolower {arg {check 0}} {
  global lib_ge_tclversion

  set count 0 ; set pattern "\(\(MOM|EXP|TCL|INS|OUT|BUFFER|CONV\)->\[^<-\]+<-\)"

  while {[regexp -- $pattern $arg all result]} {
    incr count ; set command($count) $result
    regsub -- $pattern $arg "-@$count@-" arg
  }
  set arg [string tolower $arg]
  for { set n 1 } { $n <= $count } { incr n } {
    regsub -- "-@$n@-" $arg $command($n) arg
  }
  return $arg

}
# <Documentation>
# This procedure converts a text string to upper case. Use this function when working with multibyte
# strings as the standard TCL function string tolower causes problems when converting special characters.
# <Arguments>
# arg
#   Text string to convert to uppercase.
# check
#   Valid options are:
# 1 - Special characters (like umlaut) are converted before doing the uppercase conversion.
# 0 - Special characters are not converted.
# <Returnvalue>
# Converted string.
# <Example>
# set text [LIB_GE_string_tolower $text]
#____________________________________________________________________________________________
proc LIB_GE_string_equal {arg1 arg2 {nocase ""}} {
  global lib_ge_tclversion

  if {$nocase != ""} {
    if {$lib_ge_tclversion < 8.4} {
      if {[LIB_GE_string_toupper $arg1] == [LIB_GE_string_toupper $arg2]} {
        return 1
      } else {
        return 0
      }
    } else {
      return [string equal -nocase $arg1 $arg2]
    }
  } else {
    if {$lib_ge_tclversion < 8.4} {
      if {$arg1 == $arg2} {
        return 1
      } else {
        return 0
      }
    } else {
      return [string equal $arg1 $arg2]
    }
  }
}
# <Internal Documentation>
# The Tcl function "string equal" is with TCL8.1 not available.
# If it is equal return 1 otherwise 0
#
# <Internal Example>
# set text [LIB_GE_string_equal Hello hello -nocase]
# or
# set text [LIB_GE_string_equal Hello Hello]
#____________________________________________________________________________________________
proc LIB_GE_string_range_toupper {text {from 0} {to "end"}} {
  set textblock [LIB_GE_string_toupper [string range $text $from $to]]

  if {$from > 0} {
    set textblock "[string range $text 0 [expr $from - 1]]$textblock"
  }
  if {$to == "end"} {
    return "$textblock"
  } else {
    return "$textblock[string range $text [expr $to + 1] end]"
  }

}
# <Documentation>
# This procedure converts a part of a text string to upper case letters.
# <Arguments>
# text
#   Text to partially convert to uppercase
# from
#   Integer - Position of the first character to convert (zero-based) in the string.
# to
#   Integer - Position of the last character to convert in the string.
#   end -  Converts text until the last character
# <Returnvalue>
# Converted string.
# <Example>
# name: Example 1
# code: set text [LIB_GE_string_range_toupper "operations with no moves" 0 0]
# desc: result = "Operations with no moves"
# <Example>
# name: Example 2
# code: set text [LIB_GE_string_range_toupper "operations with no moves" 11 14]
# desc: result = "operations WITH no moves"
# <Example>
# name: Example 3
# code: set text [LIB_GE_string_range_toupper "operations with no moves" 16 end]
# desc: result = "operations with NO MOVES"
#____________________________________________________________________________________________
proc LIB_GE_replace_special_characters {text {special 0} {interaction 1}} {
  global lib_flag

  set match $text
  if {$special != 0 && [CONF_GE_msg replace_special_characters] > 0} {set special [CONF_GE_msg replace_special_characters]}

  set text [LIB_Shell_replace_special_characters $text $special]

  if {$interaction == 1} {
    set text [LIB_GE_comment_convert $text]
  } elseif {$interaction == 2} {
    return [string match $match $text]
  }

  return $text

}

# <Documentation>
# This procedure converts multibyte text into a different character set.
# <Arguments>
# text
#   Text to be converted.
# special
#     Target character set to convert the special characters. Valid options are:
# 0 - no conversion, leave text as it is
# 1 = replace special characters to international spelling. Considers diameter, degree, inch and dollar sign.
# 2 = replace special characters to html
# 3 = replace UTF-8 to Unicode
# 4 = replace special characters to international spelling. No conversion of diameter, degree, inch and dollar sign.
# 5 = replace special characters to xml
# 6 = replace special characters to batch
# 7 = replace special characters to batch (for regex pattern of FINDSTR)
# 8 = replace special characters to MOM__part_attributes
# interaction
#   1 - Do the conversion and return the converted text.
#   2 - Check if text needs conversion. Returns 1 if text needs a conversion, or 0 if text needs no conversion (has no special characters).
# <Returnvalue>
# Converted text when interaction is set to 1 (default). Returns 0 or 1 after conversion check when interaction is set to 0.
#
# <Example>
# set text [LIB_Shell_replace_special_characters $text]
#____________________________________________________________________________________________
proc LIB_GE_comment_convert {comment} {
  global lib_msg_comment_replace_character
  global lib_msg_comment_case

  if {[CONF_GE_msg comment_case] == "upper"} {
    set comment [LIB_GE_string_toupper $comment]
  } elseif {[CONF_GE_msg comment_case] == "lower"} {
    set comment [LIB_GE_string_tolower $comment]
  }

  if {[CONF_GE_msg comment_replace_character] != ""} {
    set i [split [CONF_GE_msg comment_replace_character] | ]
    set z [llength $i]
    for {set t 0} {$t < [expr $z / 2]} {
      regsub -all [lindex $i [expr 2*$t - 2]] $comment [lindex $i [expr 2*$t - 1]] comment
    } {incr t}
  }
  return $comment
}
# <Documentation>
# This procedure converts a text string in the desired format for a comment to the NC code ouput file.
# The desired format is controlled with the properties [CONF_GE_msg comment_case] to convert text
# to upper or lower case and [CONF_GE_msg comment_replace_character] to replace special characters.
# <Arguments>
# comment
#   String to be output as a comment.
# <Returnvalue>
# Formatted string.
# <Example>
# set variable [LIB_GE_comment_convert "comment"]
#____________________________________________________________________________________________
proc LIB_GE_error_message {msg1 {msg2 ""} {option "WARNING"} {translation 1} {force 0}} {

  if {$::lib_ge_pretreatment_runtime} {
    MOM_log_message "Error message:\n$msg1\n$msg2"
    return
  }

  if {$translation} {
    set msg1 [LIB_GE_MSG $msg1 "" 0]
    set msg2 [LIB_GE_MSG $msg2 "" 0]
  }

  catch {
    if {![CONF_SPF_warning outputerror]} {
      LIB_SPF_add_warning "$msg1 - $msg2"
      if {!$force} {return}
    }
  }

  if {[llength [info commands MOM_display_message]] && [regexp -nocase -- {ERROR|INFORMATION|WARNING} $option] && $::lib_ge_env(major_version) >= 9} {

    # MOM_display_message <message> <title> <type>
    # <type> = I (info) | E (error) | W (Warning)
    if {[string length $msg2] != 0} {
      set msg "$msg1\n$msg2"
    } else {
      set msg "$msg1"
    }
    switch -- $option {
      "ERROR"   {set option "E"}
      "INFORMATION" {set option "I"}
      "WARNING"   {set option "W"}
      default   {set option "W"}
    }
    if {$translation} {
      MOM_display_message $msg "[LIB_GE_MSG "Postprocessor error message"]" $option
    } else {
      MOM_display_message $msg "Postprocessor" $option
    }

  } elseif {[llength [info commands JEDLL_PP_MESSAGE_DIALOG]]} {

    if {$translation} {
      set response [JEDLL_PP_MESSAGE_DIALOG "[LIB_GE_MSG PP-MESSAGE]" "$msg1\n\n$msg2\n" $option]
    } else {
      set response [JEDLL_PP_MESSAGE_DIALOG "PP-MESSAGE" "$msg1\n\n$msg2\n" $option]
    }

  } else {

    switch -- [string toupper $option] {
      "ERROR"   {set option 1}
      "INFORMATION"   {set option 2}
      "QUESTION"  {set option 3}
      "WARNING"   {set option 4}
    }

    if {$translation} {
      set error [LIB_GE_wish $msg1 $msg2 "[LIB_GE_MSG PP-MESSAGE]" 2 $option]
    } else {
      set error [LIB_GE_wish $msg1 $msg2 "PP-MESSAGE" 2 $option]
    }
  }
}

# <Documentation>
# This procedure issues an error message that is displayed in a message box during the postprocessing run.
# Note: the message is formatted with Post Configurator internal functions and may contain text
# to be translated (see LIB_GE_msg). The setting from [CONF_GE_msg comment_case] is also
# applied before showing the message dialog.
# <Arguments>
# msg1
#   Error message to be displayed.
# msg2
#   First line (title) for the dialog box.
# option
#   Type of the message. This will influence the displayed icon of the dialog box.
#   Valid options are:
#   ERROR, INFORMATION, QUESTION or WARNING.
# translation
#   Translate the text before displaying the message (see LIB_GE_MSG). Valid options are: 0 (no) and 1 (yes).
# force
#   Reserved.
# <Returnvalue>
# None.
# <Example>
# name: Example with translation
# code: LIB_GE_error_message "File INS->$datafile<- not found" "Please verify"
# desc: The text is translated and a warning message is displayed.
# <Example>
# name: Example 2
# code: LIB_GE_error_message "Post processing has finished" "That's it" "INFORMATION"
# desc: The text is translated and an information message is displayed.
#____________________________________________________________________________________________
proc LIB_GE_abort_message {msg1 {msg2 ""} {option "ERROR"} {translation 1} {force 0}} {

  if {$::lib_ge_pretreatment_runtime} {
    MOM_log_message "Abort message:\n$msg1\n$msg2"
    return
  }

  if {![CONF_SPF_warning outputabort]} {
    LIB_SPF_add_warning "$msg1 - $msg2"
    if {!$force} {return}
  }

  global lib_ge

  # Hide more then once output
  if {[info exists lib_ge(abort_message_status)] && $lib_ge(abort_message_status)} {return} else {set lib_ge(abort_message_status) 1}

  if {$translation} {
    set msg1 [LIB_GE_MSG $msg1 "" 0]
    set msg2 [LIB_GE_MSG $msg2 "" 0]
  }

  if {[llength [info commands MOM_display_message]] && [regexp -nocase -- {ERROR|INFORMATION|WARNING} $option] && $::lib_ge_env(major_version) >= 9} {

    # MOM_display_message <message> <title> <type>
    # <type> = I (info) | E (error) | W (Warning)
    if {[string length $msg2] != 0} {
      set msg "$msg1\n$msg2"
    } else {
      set msg "$msg1"
    }
    switch -- $option {
      "ERROR"   {set option "E"}
      "INFORMATION" {set option "I"}
      "WARNING"   {set option "W"}
      default   {set option "W"}
    }
    if {$translation} {
      MOM_display_message $msg "[LIB_GE_MSG "Postprocessor abort message"]" $option
    } else {
      MOM_display_message $msg "PP-ABORT-MESSAGE" $option
    }

  } elseif {[llength [info commands JEDLL_PP_MESSAGE_DIALOG]]} {
    if {$translation} {
      set response [JEDLL_PP_MESSAGE_DIALOG "[LIB_GE_MSG PP-MESSAGE]" "$msg1 \n\n$msg2\n" $option 1 "ABORT"]
    } else {
      set response [JEDLL_PP_MESSAGE_DIALOG "PP-MESSAGE" "$msg1 \n\n$msg2\n" $option 1 "ABORT"]
    }
  } else {

    switch -- [string toupper $option] {
      "ERROR"   {set option 1}
      "INFORMATION"   {set option 2}
      "QUESTION"  {set option 3}
      "WARNING"   {set option 4}
    }

    if {$translation} {
      set error [LIB_GE_wish $msg1 $msg2 "[LIB_GE_MSG PP-MESSAGE]" 2 $option]
    } else {
      set error [LIB_GE_wish $msg1 $msg2 "PP-MESSAGE" 2 $option]
    }
  }

  LIB_FH_close_all_files

  uplevel #0 {
    MOM_abort [LIB_GE_MSG "!!! Postprocessing was canceled !!!"]
  }
}
# <Documentation>
# Issues an abort message that causes the postprocessing to stop. A dialog box will be displayed.
# Note: the message is formatted with PostConfigurator internal functions and may contain text
# to be translated (see LIB_GE_MSG). The setting from [CONF_GE_msg comment_case] is also
# be applied before NX shows the message dialog.
# <Arguments>
# msg1
#   Error message to be displayed.
# msg2
#   First line (title) for the dialog box.
# option
#   Type of the message. This influences the displayed icon of the dialog box.
#   Valid options are:
#   ERROR, INFORMATION, QUESTION or WARNING
# translation
#   Translate the text before displaying the message (see LIB_GE_MSG). Valid options are: 0 (no) and 1 (yes).
# force
#   Reserved.
# <Returnvalue>
# None.
# <Example>
# name: Example with translation
# code: LIB_GE_abort_message "File INS->$datafile<- not found" "Please verify"
# desc: The text is translated and an error message is displayed.
# <Example>
# name: Example 2
# code: LIB_GE_abort_message "Post processing will stop now" "It's too late for work now.." "INFORMATION"
# desc: The text is translated and an information message is displayed.
#__________________________________________________________________
proc LIB_GE_message_dialog {args} {
  global lib_ge_log_message

  foreach {a b c d e f g} $args {break}
  if {[llength [info commands JEDLL_PP_MESSAGE_DIALOG]]} {
    switch -- $d {
      1 {return [JEDLL_PP_MESSAGE_DIALOG [LIB_GE_MSG $a] [LIB_GE_MSG $b] [LIB_GE_MSG $c] $d $e]}
      2 {return [JEDLL_PP_MESSAGE_DIALOG [LIB_GE_MSG $a] [LIB_GE_MSG $b] [LIB_GE_MSG $c] $d $e $f]}
      3 {return [JEDLL_PP_MESSAGE_DIALOG [LIB_GE_MSG $a] [LIB_GE_MSG $b] [LIB_GE_MSG $c] $d $e $f $g]}
      default {return [JEDLL_PP_MESSAGE_DIALOG [LIB_GE_MSG $a] [LIB_GE_MSG $b] [LIB_GE_MSG $c]]}
    }
  } elseif {[llength [info commands MOM_display_message]]} {

    switch -- $d {
      1 {return [MOM_display_message [LIB_GE_MSG $b] [LIB_GE_MSG $c] $c $e]}
      2 {return [MOM_display_message [LIB_GE_MSG $b] [LIB_GE_MSG $c] $c $e $f]}
      3 {return [MOM_display_message [LIB_GE_MSG $b] [LIB_GE_MSG $c] $c $e $f $g]}
      default {return [MOM_display_message [LIB_GE_MSG $b] [LIB_GE_MSG $c]]}
    }
  } else {
    LIB_GE_error_message "Command 'JEDLL_PP_MESSAGE_DIALOG' does not exist" "Check LIB_Execute"
    lappend lib_ge_log_message "Command 'JEDLL_PP_MESSAGE_DIALOG' does not exist, check LIB_Execute\n"
  }
}

# <Documentation>
# This procedure displays a dialog box and waits for user interaction.
# This function currently only works on Windows platforms. Use LIB_GE_wish for other software operating systems.
# <Arguments>
# args
#   There are three mandatory and four optional arguments to be passed:
#   Mandatory:
#   argument1: title of the message
#   argument2: message
#   argument3: message type (valid options: ERROR, WARNING, INFORMATION, QUESTION)
#
#   Optional:
#   argument4: number of buttons (1-3)
#   argument5: label button 1
#   argument6: label button 2
#   argument7: label button 3
# <Returnvalue>
# The index of the selected button.
#
# <Example>
# name: Simple error message
# code: LIB_GE_message_dialog "Dialog title" "Message" "ERROR"
# desc: A simple error message with OK button is displayed.
# <Example>
# name: 1 button dialog box
# code: LIB_GE_message_dialog "Dialog title" "Message" "WARNING" 1 "I agree"
# desc: A warning message is displayed with I agree button.
# <Example>
# name: 2 buttons dialog box
# code: set response [LIB_GE_message_dialog "Dialog title" "Message" "QUESTION" 2 YES NO]
# desc: A question is displayed. Response holds the user choice: 1-yes, 2-no.
# <Example>
# name: 3 buttons dialog box
# code: set response [LIB_GE_message_dialog "Dialog title" "Message" "INFORMATION" 3 "button1" "button2" "button3"]
# desc: An information is displayed. Response holds the user choice: 1-button1, 2-button2, 3-button3
#____________________________________________________________________________________________
proc LIB_GE_wish {msg {submsg ""} {title ""} {type 2} {icon 4} {replace_special_characters ""}} {
  global env lib_spf lib_ge_env lib_ge_slash lib_ge_wish lib_flag lib_ge_temppath

  if {![llength [info commands MOM_ask_env_var]]} {MOM_output_to_listing_device "\t$msg\n\t$submsg" ; return}

  if {$replace_special_characters != ""} {
    set cache_replace_special_characters [CONF_GE_msg replace_special_characters]
    CONF_GE_msg set replace_special_characters $replace_special_characters
  }

  set wish    [LIB_GE_format_path_names [file join "$lib_ge_env(cam_auxiliary_dir)" "ugwish.exe"]]
  set controlfile   [LIB_GE_format_path_names [file join "$lib_ge_env(tmp_dir)" "controlfile.tcl"]]
  set executionfile   [LIB_GE_format_path_names [file join "$lib_ge_env(tmp_dir)" "executionfile.tcl"]]
  set msg     [LIB_GE_MSG $msg]
  set submsg    [LIB_GE_MSG $submsg]
  set title     [LIB_GE_MSG $title]

  switch -- $type {
    1     {set type "abortretryignore"}
    2     {set type "ok"}
    3     {set type "okcancel"}
    4     {set type "retrycancel"}
    5     {set type "yesno"}
    6     {set type "yesnocancel"}
    default   {set type "ok"}
  }

  switch -- $icon {
    1     {set icon "error"}
    2     {set icon "info"}
    3     {set icon "question"}
    4     {set icon "warning"}
    default   {set icon "warning"}
  }

  if {$submsg != ""} {set msg "$msg\n\n$submsg"}

  if {[llength [info commands MOM_display_message]] && $type == 1 && [regexp -- {1|2|4} $icon] && $::lib_ge_env(major_version) >= 9} {

    # MOM_display_message <message> <title> <type>
    # <type> = I (info) | E (error) | W (Warning)
    if {[string length $submsg] != 0} {
      set msg "$msg\n$submsg"
    }
    switch -- $icon {
      1     {set icon "E"}
      2     {set icon "I"}
      4     {set icon "W"}
      default   {set icon "W"}
    }
    MOM_display_message $msg $title $icon

  } elseif {[file exists $wish]} {

    if [file exists $executionfile] {
      set error [file delete -force $executionfile]
    }

    set content ""
    lappend content "wm withdraw ."
    lappend content "update"
    lappend content ""

    lappend content {
      proc LIB_FH_reverse_escape_special_characters {output} {
      #@.pce@
        regsub -all -- \\\\\\\\ $output \\ output
        regsub -all -- \\\\\\\[ $output \[ output
        regsub -all -- \\\\\\\] $output \] output
        regsub -all -- \\\\\\\} $output \} output
        regsub -all -- \\\\\\\{ $output \{ output
        regsub -all -- \\\\\\\" $output \" output
        regsub -all -- \\\\\\\$ $output \$ output
        return $output
      }
    }
    lappend content ""
    lappend content "set title \"\""
    lappend content "set msg \"\""
    lappend content "set controlfile \"\""
    lappend content ""
    lappend content "if \{\[llength \$argv\] == 1\} \{"
    lappend content "\tset controlfile \[lindex \$argv 0\]"
    lappend content "\}"
    lappend content ""
    lappend content "if \{\[llength \$argv\] == 2\} \{"
    lappend content "\tset controlfile \[lindex \$argv 0\]"
    lappend content "\tset msg \[lindex \$argv 1\]"
    lappend content "\}"
    lappend content ""
    lappend content "if \{\[llength \$argv\] > 2\} \{"
    lappend content "\tset controlfile \[lindex \$argv 0\]"
    lappend content "\tset title \[lindex \$argv 1\]"
    lappend content "\tset msg \[lindex \$argv 2\]"
    lappend content "\}"
    lappend content ""
    lappend content "if \{\[string length \[string trim \$title\]\] == 0 \} \{"
    lappend content "\tset title \"Siemens Industry Software GmbH & Co. KG\""
    lappend content "\}"
    lappend content ""
    lappend content "# Allow users to continue or stop after the message popup."
    lappend content "set msg \"\[string trim \$msg\]\""
    lappend content ""
    lappend content "# Open the inter process communication file to record the responses"
    lappend content "# from the dialog and then close the file"
    lappend content ""

    if {![info exists lib_ge_wish(output_error_info)]} {
      lappend content "set fid \[open \"\$controlfile\" w+\]"
      lappend content ""
      lappend content "switch \[tk_messageBox -title \"\$title\" -message \"\[LIB_FH_reverse_escape_special_characters \"$msg\"]\" -type $type -icon $icon\] \{"
      lappend content "\tok \{"
      lappend content "\t\tputs \$fid \"ok\""
      lappend content "\t\}"
      lappend content "\tyes \{"
      lappend content "\t\tputs \$fid \"yes\""
      lappend content "\t\}"
      lappend content "\tno \{"
      lappend content "\t\tputs \$fid \"no\""
      lappend content "\t\}"
      lappend content "\tabort \{"
      lappend content "\t\tputs \$fid \"abort\""
      lappend content "\t\}"
      lappend content "\tretry \{"
      lappend content "\t\tputs \$fid \"retry\""
      lappend content "\t\}"
      lappend content "\tignore \{"
      lappend content "\t\tputs \$fid \"ignore\""
      lappend content "\t\}"
      lappend content "\tcancel \{"
      lappend content "\t\tputs \$fid \"cancel\""
      lappend content "\t\}"
      lappend content "\tdefault \{"
      lappend content "\t\tputs \$fid \"default\""
      lappend content "\t\}"
      lappend content "\}"
      lappend content ""
      lappend content "close \$fid"
      lappend content "file attributes \"\$controlfile\" -readonly 1"
      lappend content ""
    } else {
      lappend content "set error \[tk_messageBox -title \"\$title\" -message \"\[LIB_FH_reverse_escape_special_characters \$msg\]\" -type $type -icon $icon\]"
    }

    lappend content "wm withdraw .; destroy ."

    set error [LIB_Shell_list_to_file $content $executionfile]

    # A separated process will be created to construct the Tk dialog.
    # This process will communicate with the main process via the state of a scratch file.
    # This scratch file will collect the messages that need to be conveyed from the
    # child process to the main process.

    if {$lib_spf(clock,exists)} {
      set resultfile [LIB_GE_format_path_names [file join "$lib_ge_temppath$lib_ge_slash" "${env(USERNAME)}_controlfile_[clock clicks].txt"]]
    } else {
      set resultfile [LIB_GE_format_path_names [file join "$lib_ge_temppath$lib_ge_slash" "${env(USERNAME)}_controlfile_${lib_spf(clock,random)}.txt"]]
    }

    if [file exists $controlfile] {
      set error [file delete -force $controlfile]
    }

    # Note that the argument order for mom_pause.tcl has been changed
    # The assumption at this point is we will always have the communication file as the first
    # argument and optionally the title and message as the second and third arguments

    set msg [LIB_FH_escape_special_characters $msg]
    open "|\"[file join $wish]\" \"[file join $executionfile]\" \"[file join $resultfile]\" {$title} {$msg}"

    if {![info exists lib_ge_wish(output_error_info)]} {

      # Waiting for the mom_pause to complete its process...
      # - This is indicated when the scratch file materialized and became read-only.
      while {![file exists $resultfile] || [LIB_FH_file_writable $resultfile]} {after 100}

      # Delay a 100 milli-seconds to ensure that sufficient time is given for the other process to complete.
      after 100

      if {[file exists $executionfile]} {
        set error [file delete -force $executionfile]
      }

      # Open the scratch file to read and process the information. Close it afterward.

      set fid [LIB_FH_open_file "$resultfile" r]
      set res [string trim [gets $fid]]
      switch -- $res {
        ok  {
          set lib_ge_wish(result) 1
        }
        yes   {
          set lib_ge_wish(result) 2
        }
        no  {
          set lib_ge_wish(result) 3
        }
        abort   {
          set lib_ge_wish(result) 4
        }
        retry   {
          set lib_ge_wish(result) 5
        }
        ignore  {
          set lib_ge_wish(result) 6
        }
        cancel  {
          LIB_FH_close_file $fid
          if {[info exists fid]} {unset fid}
          if [LIB_Shell_file_exists $resultfile 1] {
            set error [file delete -force $resultfile]
          }

          set lib_ge_wish(result) 7

          uplevel #0 {
            MOM_abort [LIB_GE_MSG "!!! Postprocessing was canceled !!!"]
          }
        }
        default {
          set lib_ge_wish(result) 0
        }
      }
    }
  } else {

    MOM_output_to_listing_device "\t$msg\n\t$submsg"
    MOM_abort [LIB_GE_MSG "!!! Postprocessing was canceled !!!"]
    return

  }

  # Close the scratch file
  if {[info exists fid]} {
    LIB_FH_close_file $fid
    after 100
  }

  if {[file exists $resultfile]} {
    set error [file delete -force $resultfile]
  }

  if {[file exists $executionfile]} {
    set error [file delete -force $executionfile]
  }

  if {$replace_special_characters != ""} {
    CONF_GE_msg set replace_special_characters $cache_replace_special_characters
  }

}
# <Documentation>
# This procedure displays a dialog box and waits for user interaction.
# <Arguments>
# msg
#   Message to be displayed.
# submsg
#   Second message line.
# title
#   Title of the dialog box.
# type
# 1 = abortretryignore  --> Displays three buttons whose symbolic names are abort, retry and ignore.
# 2 = ok      --> Displays one button whose symbolic name is ok.
# 3 = okcancel    --> Displays two buttons whose symbolic names are ok and cancel.
# 4 = retrycancel   --> Displays two buttons whose symbolic names are retry and cancel.
# 5 = yesno   --> Displays two buttons whose symbolic names are yes and no.
# 6 = yesnocancel   --> Displays three buttons whose symbolic names are yes, no and cancel.
# icon
# 1 =  error
# 2 =  info
# 3 =  question
# 4 =  warning
# replace_special_characters
#   By default the text is output as it is.
#   Tcl/Tk has issues with special characters, so you might want to convert it before outputting by giving one of the following options:
# 0 - no conversion, leave text as it is (default)
# 1 - replace special characters to international spelling. Considers diameter, degree, inch and dollar sign.
# 2 - replace special characters to html
# 3 - replace UTF-8 to Unicode
# 4 - replace special characters to international spelling. No conversion of diameter, degree, inch and dollar sign.
# 5 - replace special characters to xml
# 6 - replace special characters to batch
# 7 - replace special characters to batch (for regex pattern of FINDSTR)
# 8 - replace special characters to MOM__part_attributes
# <Returnvalue>
# The selected button will be returned:
# 1 = ok
# 2 = yes
# 3 = no
# 4 = abort
# 5 = retry
# 6 = ignore
# 7 = cancel
# <Example>
# name: Simple message
# code: LIB_GE_wish "Message"
# desc: A simple message with ok button is displayed.
# <Example>
# name: Simple message with ok, cancel
# code: LIB_GE_wish "Message" "" "Message title" 3
# desc: A simple message with ok and cancel button is displayed.
# <Example>
# name: Retry or Cancel
# code: set response [LIB_GE_wish "Nc-Code cannot be sent to the printer." "Printer is not ready" "Printer issue" 4 4]
# desc: A warning is displayed. The varialbe response holds the user choice of 5-retry or 7-cancel
#____________________________________________________________________________________________
proc LIB_GE_append_mom_o_buffer {arg1} {

  global mom_o_buffer

  append mom_o_buffer "\n$arg1"
}
# <Internal Documentation>
#
# Output information from MOM_before_output
# If you generate an output from MOM_before_output (or any sub proc of MOM_before_output) by calling
# proc OUT, this ended up in an error (Bug #1327)
# This proc is called in proc 'OUT' to replace MOM_output_literal by modifying mom_o_buffer when OUT
# was called from MOM_before_output
#
#____________________________________________________________________________________________
proc LIB_GE_read_database {environment datafile variablelist {formatdescription "FORMAT"} {datedescription "DATA"} {mode "abort"}} {

  global lib_ge

  set lib_ge(database,hex) [LIB_SPF_convert_string_to_hex "$environment,$datafile,$variablelist,$formatdescription,$datedescription,$mode"]

  if {[info exists lib_ge($lib_ge(database,hex),returnlist)]} {
    return $lib_ge($lib_ge(database,hex),returnlist)
  }

  # check is input a environment or a directory
  if {![regexp -nocase -- {[a-z]+[\:]|[\/]|[\\]} $environment]} {
    set environmentvariablevalue [MOM_ask_env_var $environment]
    set datafile [LIB_GE_format_path_names [file join $environmentvariablevalue/$datafile]]
  } else {
    set datafile [LIB_GE_format_path_names [file join $environment/$datafile]]
  }

  # Required date is read, so the list can be used
  if {![info exists lib_ge($lib_ge(database,hex),value)]} {
    if {[file exist $datafile]} {
      set lib_ge($lib_ge(database,hex),value) [LIB_FH_file_to_list $datafile]
      regsub -all "\t" $lib_ge($lib_ge(database,hex),value) " " lib_ge($lib_ge(database,hex),value)
    } else {
      if {![string match "abort" $mode]} {
        for { set n 0 } { $n < [llength $variablelist] } { incr n } {
          lappend outvariablelist "No information available"
        }
        return $outvariablelist
      } else {
        LIB_GE_abort_message "File INS->$datafile<- not found" "Please verify"
      }
    }
  }

  set formatline ""
  for { set n 0 } { $n < [llength $variablelist] } { incr n } {
    set formatvariable$n [lindex $variablelist $n]
    set variable_formatline_index($n) -1
    set formatcount "formatvariable$n"
    eval set formatvariable($n) $$formatcount
  }

  foreach line $lib_ge($lib_ge(database,hex),value) {

    if {[regexp -nocase -- {#} $line] || [string trim $line] == ""} {
      continue
    }

    set variable ""
    set dataline [LIB_GE_cleanupline $line "|" 1]
    set formatline_temp [LIB_GE_cleanupline $line " "]

    if {[lindex $formatline_temp 0] == $formatdescription} {
      set formatline [LIB_GE_cleanupline $line " "]

      for { set n 0 } { $n < [llength $variablelist] } { incr n } {
        set temp "formatvariable($n)"
        if {$formatvariable($n) != 0 || $formatvariable($n) != -1} {
          set variable_formatline_index($n) [lsearch -exact $formatline [eval set temp $$temp]]
        } else {
          set variable_formatline_index($n) -1
        }

      }
      continue
    }

    if {[string trim [lindex $dataline 0 ]] == $datedescription} {

      for { set n 0 } { $n < [llength $variablelist] } { incr n } {
        set temp "variable_formatline_index($n)"
        if {[info exists $temp] && [eval set temp $$temp] != -1} {
          lappend variable [string trim [lindex $dataline [eval set temp $temp]]]
        }
      }

      if {[info exists variable] && $variable != ""} {
        lappend outvariablelist $variable
      }

    } else {

      for { set n 0 } { $n < [llength $variablelist] } { incr n } {
        set variable_formatline_index($n) -1
      }

    }
  }

  if {[info exists outvariablelist]} {
    set lib_ge($lib_ge(database,hex),returnlist) $outvariablelist
    return $outvariablelist
  } else {
    LIB_GE_error_message "File content from INS->$datafile<- cannot evaluated" "Please verify"
  }

}
# <Documentation>
# This procedure reads an ascii file-based database in NX-library style. This procedure automatically
# opens, reads, and closes the file. The procedure provides error handling when the file does not exist.
# <Arguments>
# environment
#   Location of the database. You may provide either an NX environment variable or a file pathname.
# datafile
#   Filename and extension of the database.
# variablelist
#   Columns to read in the database. The columns are defined as a listand the names are case sensitive.
#   Columns are searched in the FORMAT line of the database.
# formatdescription
#   Identifier for the database header. Usually don't touch.
# datedescription
#   Identifier for the database lines. Usually don't touch.
# mode
#   Action if the database file cannot be found. Options are:
#   abort - postprocessing is aborted
#   <other> - Function returns the message 'No information available' for each column defined in variablelist.
# <Returnvalue>
# String list containing the parsed data.
# <Example>
# name: Example 1: on standard db
# code: set dbdata [LIB_GE_read_database "UGII_CAM_LIBRARY_MACHINE_DATA_DIR" "machine_database.dat" "LIBRF T POST"]
# desc: The variable dbdata contains all the data of the machine_database in the columns LIBRF, T and POST.
# <Example>
# name: Example 2: on user db
# code: set dbdata [LIB_GE_read_database "d:\\temp\\" "mazak_zerodef.ini" "ON NN"]
# desc: assume the mazak_zerodef contains data in the following format:
# FORMAT    ON        NN
# DATA | G54.1P1   |  G54
# DATA | G54.1P2   |  G55
# DATA | G54.1P3   |  G56
# Then the function returns: dbdata= {{G54.1P1 G54} {G54.1P1 G55} {G54.1P1 G56}}
# You may now access the info like this:
# foreach entry $dbdata {
#    set db(on) [lindex $entry 0]
#    set db(nn) [lindex $entry 1]
# }
#____________________________________________________________________________________________
proc LIB_GE_copy_var_range {to_var_prefix from_var_prefix} {
  set from_var_pattern "uplevel \#0 \{info vars ${from_var_prefix}*\}"

  set from_var_names [if {1} $from_var_pattern]

  foreach from_var $from_var_names {
    global $from_var

    regsub $from_var_prefix $from_var $to_var_prefix to_var

    global $to_var

    if {[array exists $from_var] == 0} {
      set $to_var [subst $$from_var]
    } elseif {[array get $from_var] != ""} {
      #only copy non empty arrays
      array set $to_var [array get $from_var]
    }
  }
}
# <Documentation>
# This procedure copies a whole range of global variables (scalars and arrays) that are identified by a prefix
# to a new range of variables.
# The name of the new range of variables is based on a new defined prefix.
# <Arguments>
# to_var_prefix
#   Prefix to add to the copied MOM variables.
# from_var_prefix
#   Prefix identifying the MOM variables to be copied.
# <Returnvalue>
# None.
# <Example>
# name: Example 1
# code: LIB_GE_copy_var_range kin_rot1 mom_kin_4th
# desc: This copies all the variables of the pattern mom_kin_4th* to variables of pattern kin_rot1*.
# For example:
# mom_kin_4th_axis_ang_offset to kin_rot1_axis_ang_offset
# mom_kin_4th_axis_center_offset(0) to kin_rot1_axis_center_offset(0)
#____________________________________________________________________________________________
proc LIB_GE_time {{time 0}} {
  global lib_parameter

  if {!$::lib_spf(clock,exists)} {return $::lib_ge_time}

  if {$time != 0} {
    return [clock format $time -format [CONF_GE_msg time_format]]
  } elseif {[CONF_GE_debug make_values_static] == 1} {
    return [clock format 936860940 -format [CONF_GE_msg time_format]]
  } else {
    return [clock format [clock seconds] -format [CONF_GE_msg time_format]]
  }

}
# <Documentation>
# This procedure returns time as a string using the time format defined in
# the property [CONF_GE_msg time_format].
# <Arguments>
# time
#   Time in seconds. If no value is given, the current time is returned.
# <Returnvalue>
# Formatted time.
# <Example>
# MOM_output_literal "(it is now: [LIB_GE_time])"
#____________________________________________________________________________________________
proc LIB_GE_date {{date 0}} {
  global lib_parameter

  if {!$::lib_spf(clock,exists)} {return $::lib_ge_date}

  if {$date != 0} {
    return [clock format $date -format [CONF_GE_msg date_format]]
  } elseif {[CONF_GE_debug make_values_static] == 1} {
    return [clock format 936860940 -format [CONF_GE_msg date_format]]
  } else {
    return [clock format [clock seconds] -format [CONF_GE_msg date_format]]
  }

}
# <Documentation>
# This procedure returns date as a formated stringusing the date format defined in
# the property [CONF_GE_msg date_format].
# <Arguments>
# date
#   Date in seconds since Thu Jan 01 01:00:01 CET 1970. If no value is given, the current time is returned.
# <Returnvalue>
# Formatted date.
# <Example>
# MOM_output_literal "(it is now: [LIB_GE_date])"
#____________________________________________________________________________________________
proc LIB_GE_string_append {string number {subst 0}} {

  set newstring ""
  for { set n 0 } { $n < $number } { incr n } {
    append newstring $string
  }
  if {$subst} {set newstring [subst $newstring]}
  return $newstring
}
# <Internal Documentation>
# This allows to set 'datatype' attribute of a given property in a given CONF-object
# <Internal Arguments>
# string
#   The String which should repeat
# number
#   Number of iteration
# <Internal Returnvalue>
# New String
# <Internal Example>
# set returnvalue [LIB_GE_string_append 123 3]
#____________________________________________________________________________________________
proc LIB_GE_create_json_array {arg} {
  regsub -all "," $arg "" arg
  if {[llength $arg] > 1} {
    set list ""
    for { set n 0 } { $n < [llength $arg] } { incr n } {
      if {$n < [expr [llength $arg]-1]} {
        append list "\"[string trim [lindex $arg $n]]\", "
      } else {
        append list "\"[string trim [lindex $arg $n]]\""
      }
    }
    return $list
  } else {
    return "\"$arg\""
  }
}
# <Internal Documentation>
# This give you an array list for json back
# <Internal Arguments>
# arg
#   The list of values
# <Internal Returnvalue>
# New Arraystring
# <Internal Example>
# set returnvalue [LIB_GE_buffer_output_create_array "12 13 14"]
# returnvalue: "12", "13", "14"
#____________________________________________________________________________________________
proc LIB_GE_activate_inspect_tool_tracer {} {
  trace add execution LIB_GE_command_buffer_output leave LIB_GE_command_buffer_output_inspect_tool_tracer
}
# <Internal Documentation>
# This is an internal function called in MOM__part_attributes in the case 'inspect tool' is active.
# It will activate a tracer on LIB_GE_command_buffer_output (on leave)
# This is related to bug #2083 (some buffers not shown in inspect tool)
#
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_output_inspect_tool_tracer {args} {
  if {$::inspect_tool_closed_buffer == ""} {
    ##MOM_output_to_listing_device "  !!! need to be closed from tracer !!!"
    MOM_command_buffer_end [lindex [lindex $::inspect_tool_active_buffers end] 1] [lindex [lindex $::inspect_tool_active_buffers end] 2]
  }

  set ::inspect_tool_active_buffers [lreplace $::inspect_tool_active_buffers end end]
  set ::inspect_tool_closed_buffer ""
}
# <Internal Documentation>
# This is an internal trace function on LIB_GE_command_buffer_output (on leave).
# This is related to bug #2083 (some buffers not shown in inspect tool)
# If 'LIB_GE_command_buffer_output' was aborted by a 'return -code return' command in the buffer
# this tracer will make sure that inspect tool gets the information that current buffer was terminated.
#
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_edit_insert {proc_name buffer_name code tag pos ref_tag} {

  LIB_GE_command_buffer_manipulate $proc_name $buffer_name "insert" "$code" "$tag" "$pos" "$ref_tag"

}
# <Documentation>
# This procedure inserts an element in a command buffer list.
# It is used to add more output or actions to an existing command buffer at a specific position.
# The new code to execute must be referenced by a tag name.
#
# <Arguments>
# proc_name
#   Name of the procedure to which the buffer (to be manipulated) belongs.
# buffer_name
#   Name of the buffer to be manipulated.
# code
#   TCL code to be added to the buffer in question.
# tag
#   Tag/identifier to be assigned to the new code. Tag names of code added thru this function must not start with @.
#   The @ sign is reserved for the tags of the initial buffer definition.
#   In addition, the combination of the name of the calling procedure, the name of current section, and the
#   tag name must be unique.
#   Both conditions are checked in the code and postprocessing is aborted if one of the conditions is not met.
# pos
#    Indicates the position relative to ref_tag. Possible values are before or after.
# ref_tag
#    Name of the tag used as reference for the insert position.
# <Example>
# name: Example 1
# code: LIB_GE_command_buffer_edit_insert PROC_my_output Buffer1 {LIB_GE_message "This is my code added to Buffer1"} MyTag1 after @Tag1
#
# desc: Buffer1 in PROC_my_output is enhaced by the message This is my code added to Buffer1. This message will be output after
# the existing output referenced by @Tag1.
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_edit_remove {proc_name buffer_name args} {

  set to_evaluate "LIB_GE_command_buffer_manipulate $proc_name $buffer_name remove"
  foreach a $args {
    append  to_evaluate " $a"
  }

  if {1} $to_evaluate
}
# <Documentation>
# This procedure removes an element from a command buffer.
# <Arguments>
# proc_name
#   Name of the proc to which the buffer (to be manipulated) belongs.
# buffer_name
#   Name of the buffer to be manipulated.
# args
#    One or more names of tags to be removed from the command buffer in question.
# <Example>
# name: Example 1
# code: LIB_GE_command_buffer_edit_remove PROC_my_output Buffer1 @Tag1 @Tag3
# desc: In Buffer1for PROC_my_output, the output referenced by @Tag1 and @Tag3 is removed.
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_edit_move {proc_name buffer_name tag pos ref_tag} {

  LIB_GE_command_buffer_manipulate $proc_name $buffer_name "move" "$tag" "$pos" "$ref_tag"

}
# <Documentation>
# This procedure resequences the output of a command buffer.
#
# <Arguments>
# proc_name
#   Name of the procedure to which the buffer (to be manipulated) belongs.
# buffer_name
#   Name of the buffer to be manipulated.
# tag
#   Tag to be moved.
# pos
#   Indicates the position relative to ref_tag. Possible values are before or after.
# ref_tag
#   Name of the tag used as reference for the new position.
#
# <Example>
# name: Example 1
# code: LIB_GE_command_buffer_edit_move PROC_my_output Buffer1 @Tag1 after @Tag3
#
# desc: In Buffer1 for PROC_my_output, the output referenced by @Tag1 comes after the output referenced by @Tag3.
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_edit_replace {proc_name buffer_name ref_tag code tag} {

  LIB_GE_command_buffer_manipulate $proc_name $buffer_name "replace" "$ref_tag" "$code" "$tag"

}
# <Documentation>
# This procedure replaces one of the tagged output lines of a command buffer by another tagged output line.
#
# <Arguments>
# proc_name
#   proc to which the buffer (to be manipulated) belongs.
# buffer_name
#   Name of the buffer to be manipulated.
# ref_tag
#   Tag to be replaced.
# code
#   TCL code to be added to the buffer in question (replacing ref_tag).
# tag
#   Tag to be assigned to the new TCL code. Tag names of code added thru this function must not start with @.
# The @ sign is reserved for the tags of the initial buffer definition.
# In addition, the combination of the name of the calling procedure, the name of current section, and the
# tag name must be unique.
# Both conditions arechecked in the code and postprocessing is aborted if one of the conditions is not met.
#
# <Example>
# name: Example 1
# code: LIB_GE_command_buffer_edit_replace PROC_my_output Buffer1 @Tag1 {MOM_output_literal "do this instead of code linked to @Tag1"} MyTag1
# desc: In Buffer1 for PROC_my_output, the output referenced by @Tag1 is replaced by the output referenced by MyTag1.
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_edit_append {proc_name buffer_name code tag} {

  LIB_GE_command_buffer_manipulate $proc_name $buffer_name append $code $tag

}
# <Documentation>
# This procedure  appends TCL code or output to an existing command buffer.
#
# <Arguments>
# proc_name
#   Name of the procedure to which the buffer (to be manipulated) belongs.
# buffer_name
#   Name of the buffer to be manipulated.
# code
#   TCL code or output to be appended to the buffer in question.
# tag
#   Tag/identifier to be assigned to the new code. Tag names of code added thru this function must not start with @.
#   The @ sign is reserved for the tags of the initial buffer definition.
#   In addition, the combination of the name of the calling procedure, the name of current section, and the
#   tag name must be unique.
#   Both conditions are checked in the code and postprocessing is aborted if one of the conditions is not met.
#
# <Example>
# name: Example 1
# code: LIB_GE_command_buffer_edit_append PROC_my_output Buffer1 {MOM_output_literal "this will be at the end of the current buffer definition"} MyTag1
# desc: In Buffer1 in PROC_my_output, the output referenced by MyTag1 is added to the end of the buffer.
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_edit_prepend {proc_name buffer_name code tag} {

  LIB_GE_command_buffer_manipulate $proc_name $buffer_name prepend $code $tag

}
# <Documentation>
# This procedure prepends TCL code or output to a existing command buffer.
#
# <Arguments>
# proc_name
#   Name of the procedure to which the buffer (to be manipulated) belongs.
# buffer_name
#   Name of the buffer to be manipulated.
# code
#   TCL code to be prepended to the buffer in question.
# tag
#   Tag to be assigned to the new code. Tag names of code added thru this function must not start with @.
# The @ sign is reserved for the tags of the initial buffer definition.
# In addition, the combination of the name of the calling procedure, the name of current section, and the
# tag name must be unique.
#
# Both conditions are checked in the code and postprocessing is aborted if one of the conditions is not met.
#
# <Example>
# name: Example 1
# code: LIB_GE_command_buffer_edit_prepend PROC_my_output Buffer1 {MOM_output_literal "this will be at the beginning of the current buffer definition"} MyTag1
# desc: In Buffer1for PROC_my_output, the output referenced by MyTag1 is added to the start of the buffer.
#____________________________________________________________________________________________
proc LIB_GE_command_buffer_get_def_tags {full_list} {
  foreach {tag command} $full_list {
    lappend result_list $tag
  }
  return $result_list
}
# <Internal Documentation>
#
# BLACKBOX function to extract a list of tags from a list of tags and commands
#
# input : {@1 command @2 command @3 command @4 command}
# output: {@1 @2 @3 @4}
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_commandbuffer_is_customized {buffer_name} {

  return [expr [namespace exists ::buffer::[lindex [info level -1] 0]::$buffer_name] && [info exists ::buffer::[lindex [info level -1] 0]::${buffer_name}::buffer_manipulate]]
}
# <Internal Documentation>
#
# BLACKBOX function to know if buffer is customized.
# This function should be used directly in the procedure where buffer is defined
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_linsert {current_list pos ref value} {

  set ind [lsearch -exact $current_list $ref]

  if {$ind != -1} {
    if {$pos == "before"} {
      return [linsert $current_list $ind $value]
    } elseif {$pos == "after"} {
      return [linsert $current_list [expr $ind + 1] $value]
    }
  } else {
    if {[LIB_GE_output_buffer_manipulation_warning]} {
      LIB_SPF_add_warning "Error in function INS->LIB_GE_linsert '$ref'<-, reference value cannot be found."
    }
    return $current_list
  }

}
# <Internal Documentation>
# LIB_GE_linsert allows to insert an element to a list either before or after a defined list element.
# This is done based on list content (list element) instead of list index.
# The defined reference element will be searched in the list and the new element will then be added
# before or after that element.
#
# The return value of that function is the new list
# Currenty if the ref element is not found, the inital list will be returned (without any error/warning message)
#
# <Arguments>
# current_list
#   the list to be modifyied
# pos
#    before
# or
#    after
#    (indicates the position relativ to reference list element)
# ref
#    reference element in current list (list element (string) not list index)
# value
#    value to be added to the list at the defined position
# <Internal Example>
# name: Example 1
# code:
# set current_list "elemet1 element2 element3 element4"
# set new_list [LIB_GE_linsert $current_list "after" "element2" new_element]
#
# desc: new_list will then contain "elemet1 element2 new_element element3 element4"
#
#____________________________________________________________________________________________
proc LIB_GE_lsearch_index {list index value} {

  set i 0
  foreach sublist $list {
    if {[string equal [lindex $sublist $index] $value]} {
      return $i
    }
    incr i
  }
  return -1
}
# <Internal Documentation>
#
# BLACKBOX function to use when searching within nested lists
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_lremove {current_list value} {

  set ind [lsearch -exact $current_list $value]

  if {$ind != -1} {
    return [lreplace $current_list $ind $ind]
  } else {
    if {[LIB_GE_output_buffer_manipulation_warning]} {
      LIB_SPF_add_warning "Error in function INS->LIB_GE_lremove '$value'<-, reference value cannot be found."
    }
    return $current_list
  }
}
# <Internal Documentation>
# LIB_GE_lremove allows to remove an element of a list.
# This is done based on list content (list element) instead of list index.
#
# The return value of that function is the new list
# Currenty if the ref element is not found, the inital list will be returned (without any error/warning message)
#
# <Arguments>
# current_list
#   the list to be modifyied
# value
#   value to be removed from list
# <Internal Example>
# name: Example 1
# code:
# set current_list "elemet1 element2 element3 element4"
# set new_list [LIB_GE_lremove $current_list "element2"]
#
# desc: new_list will then contain "elemet1 element3 element4"
#
#____________________________________________________________________________________________
proc LIB_GE_lreplace {current_list element new_element} {

  set ind [lsearch -exact $current_list $element]

  if {$ind != -1} {
    return [lreplace $current_list $ind $ind $new_element]
  } else {
    if {[LIB_GE_output_buffer_manipulation_warning]} {
      LIB_SPF_add_warning "Error in function INS->LIB_GE_lreplace '$element'<-, reference value cannot be found."
    }
    return $current_list
  }
}
# <Internal Documentation>
# LIB_GE_lreplace allows to relplace an element of a given list by an other value.
# This is done based on list content (list element) instead of list index.
# The defined reference element will be searched in the list and the new element will then replace the reference element.
#
# The return value of that function is the new list
# Currenty if the ref element is not found, the inital list will be returned (without any error/warning message)
#
# <Arguments>
# current_list
#   the list to be modifyied
# element
#    value to be replaced
# new_element
#    new value to be put to the list at position of 'element'
# <Internal Example>
# name: Example 1
# code:
# set current_list "elemet1 element2 element3 element4"
# set new_list [LIB_GE_lreplace $current_list "element2" new_element]
#
# desc: new_list will then contain "elemet1 new_element element3 element4"
#
#____________________________________________________________________________________________
proc LIB_GE_linsert_index {current_list index new_element} {

  set ind [lsearch -exact $current_list $new_element]

  if {$ind == -1} {
    return [linsert $current_list $index $new_element]
  } else {
    return $current_list
  }
}
# <Internal Documentation>
# LIB_GE_linsert_index allows to insert an element of a given list to a defined position.
# The defined reference element will be searched in the list and the new element will then insert the reference element,
# if this does not yet exist.
#
# The return value of that function is the new list
# Currenty if the new element exists already, the inital list will be returned (without any error/warning message)
#
# <Arguments>
# current_list
#   the list to be modifyied
# index
#    inserting position
# new_element
#    new value to be put to the list at position of 'index'
# <Internal Example>
# name: Example 1
# code:
# set current_list "elemet1 element2 element3 element4"
# set new_list [LIB_GE_linsert_index $current_list 0 new_element]
#
# desc: new_list will then contain "new_element elemet1 element2 element3 element4"
#
#____________________________________________________________________________________________
proc LIB_GE_output_buffer_manipulation_warning {} {

  if {[CONF_GE_debug show_buffer_manipulate_warning] == 2} {
    #always
    return 1
  }

  if {[CONF_GE_debug show_buffer_manipulate_warning] == 1 && $::lib_ge_env(major_version) < 12} {
    #only in PostConfigurator not supported in version < 12 --> always
    return 1
  } elseif {[CONF_GE_debug show_buffer_manipulate_warning] == 1 && [info exists ::mom_output_file_basename] && $::mom_output_file_basename == "postprocess_preview"} {
    #only in PostConfigurator >= 12
    return 1
  } else {
    #Off
    return 0
  }

}
# <Internal Documentation>
# Check condition to output buffer manipulation warnings
#
# The return value of that function is 0 or 1 to define to suppress or to output the warnings
#
# <Arguments>
#   --
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_GE_get_parent_proc {{type ""}} {
  if {[info level] <= 2} {
    return "!!LEVEL 0!!"
  } else {
    if {$type == "all"} {
      return [info level -2]
    } else {
      return [lindex [info level -2] 0]
    }
  }
}
# <Internal Documentation>
#
# This can be used to get the name of the parent proc of a given proc
# It handles the case where parent is "level0"
#
# optional argument:
# type :  "all" --> output the parent proc name including the arguments passed to parent proc
#   all other values or omitted --> just the name of the proc
#
#
#
# <Internal Example>
# MOM_output_literal "parent of current proc = [LIB_GE_get_parent_proc]"
# MOM_output_literal "parent of current proc (including arguments passed to parent) = [LIB_GE_get_parent_proc all]"
#
#
#____________________________________________________________________________________________
proc LIB_GE_get_proc {{type ""}} {
  if {[info level] < 2} {
    return "!!LEVEL 0!!"
  } else {
    if {$type == "all"} {
      return [info level -1]
    } else {
      return [lindex [info level -1] 0]
    }
  }
}
# <Internal Documentation>
#
# This can be used to get the name of the current proc
#
# optional argument:
# type :  "all" --> output the parent proc name including the arguments passed to parent proc
#   all other values or omitted --> just the name of the proc
#
#
#
# <Internal Example>
# MOM_output_literal "current proc name = [LIB_GE_get_proc]"
# MOM_output_literal "current proc name (and its current arguments) = [LIB_GE_get_proc all]"
#
#
#____________________________________________________________________________________________
proc LIB_GE_linked_var {n1 n2 m} {
  global $n1

  if {$n2 == "dummy"} {return}
  set a "" ; set b ""
  foreach {a b} [split $n2 "@"] {break}
  if {$a != "" && $b != ""} {
    set ${n1}($n2) [$a $b]
  }
}
# <Internal Documentation>
# This alows to access "protected flags" by a standard tcl variable
# This means that you can access a flag/param defined as "protected flag" (see LIB_GE_flag_sample)
# by
# $lib_linked_var(LINKED_VAR_PROC@PROPERTY)
#
# e.g. $lib_linked_var(LIB_GE_flag_sample@return_safety_pos)
#
# The function has not to be explicitly! This is a BlackBox function
#
# <Internal Example>
#
#
#
#____________________________________________________________________________________________
proc LIB_GE_snapshot {arg1 {arg2 ""}} {
  eval global [uplevel #0 info vars]
  global lib_ge_snapshot_reset_list

  if {$arg1 == "CREATE"} {

    foreach var $arg2 {

      if {[array names $var] != ""} {
        foreach n [array names $var] {
          lappend snap_list "${var}($n) [subst $\{${var}($n)\}]"

        }
      } else {
        if {[info exists $var]} {
          lappend snap_list "$var [subst $\{$var\}]"
        }
      }

    }

    return $snap_list

  } elseif {$arg1 == "LOAD" || $arg1 == "LOAD_PERMANENT" || $arg1 == "UNLOAD"} {

    if {[info exists lib_ge_snapshot_reset_list] && $lib_ge_snapshot_reset_list != ""} {

      foreach a $lib_ge_snapshot_reset_list {
        if {1} $a
      }
       unset lib_ge_snapshot_reset_list
    }

    if {$arg1 == "LOAD" || $arg1 == "LOAD_PERMANENT"} {
      foreach var $arg2 {
        foreach {name value} $var {break}
        if {$arg1 != "LOAD_PERMANENT"} {
          if {![info exists $name]} {
            global [lindex [split $name "("] 0]
            lappend lib_ge_snapshot_reset_list "unset $name"
          } else {
            lappend lib_ge_snapshot_reset_list "set $name [subst $\{$name\}]"
          }
        }
        set $name $value
      }
    }
  } else {
    #WRONG ARGUMENT PASSED TO PROC

  }
}
# <Documentation>
# This procedure stores and reuses a snapshot of the values of a given set of global variables
# at a given point of time.
# This means you can store some defined variables in a given event and reload them later on in a differnet event.
#
# The procedure can be used in four different ways:
# CREATE:
# LIB_GE_snapshot CREATE {list of variables to store}
# Stores a list of global variables and values. LOAD:
# LIB_GE_snapshot LOAD {snapshot list created by LIB_GE_snapshot CREATE}
# load the snapshot defined in the list. This means the captured global variables
# are set to the value at the point of time when the snapshot was created.
# This can later be undone by calling LIB_GE_snapshot UNLOAD.
# UNLOAD:
# LIB_GE_snapshot UNLOAD
# Unload the currently loaded snapshot. This means the global variables affected by the loaded snapshot are reset
# to the state before the snapshot was loaded. If no snapshot is currently loaded, this call has no effect.
# LOAD_PERMANENT:
# LIB_GE_snapshot LOAD_PERMANENT {snapshot list created by LIB_GE_snapshot CREATE}
# Same as the LOAD option. The only difference is that a snapshot loaded with LOAD_PERMANENT is not registered
# for unload. This means LIB_GE_snapshot UNLOAD has no effect if the snapshot was loaded permanent
# <Arguments>
# arg1
#    Task to do. Valid arguments are:
#    CREATE - Creates a snapshot. Define the variables to be considered for the snapshot in arg2.
#    LOAD   - Loads the variables of a given snapshot. Define the snapshot in arg2.
#    UNLOAD - Unloads an active snapshot and resets to the state that was active before. No arg2 needed.
#    LOAD_PERMANENT - The same as LOAD but the variables cannot be unloaded later on.
# arg2
#    Additional arguments as described in arg1.
# <Returnvalue>
# None.
# <Example>
# name: Create a snapshot
# code: set snapshot(1) [LIB_GE_snapshot CREATE "mom_tool_name mom_pos mom_out_angle_pos(0) [info vars mom_sys*]"]
# desc: This stores the mom_tool_name, the entire array of mom_pos, the array element 0 of mom_out_angle_pos, and
# all the global variables matching the pattern mom_sys* in the variable snapshot(1).
# <Example>
# name: Load a snapshot
# code: LIB_GE_snapshot LOAD $snapshot(1)
# desc: This sets the values for the global variables in $snapshot(1) (created by LIB_GE_snapshot CREATE) to the values
# at the point of time when the variable snapshot was created.
# <Example>
# name: Unload a snapshot
# code: LIB_GE_snapshot UNLOAD
# desc: Undo the modifications of the global variables done by LIB_GE_snapshot LOAD
#____________________________________________________________________________________________
proc LIB_GE_convert_list_to_body {code special_syntax} {

  set aaa ""
  foreach ccc $code {
    if {$special_syntax == "short_template_syntax"} {
      if {$ccc != "" && [regexp {^[\w]*$} $ccc] == 1 && [info command $ccc] == ""} {
        set ccc "MOM_do_template $ccc"
      }
    }
    set aaa "$aaa\n$ccc"
  }
  return $aaa

}
# <Internal Documentation>
# This will return the proper proc body from a list containing the proc body
# (e.g. list created by LIB_CONF_prop_custom_proc_body)
#
# arguments:
#   code: list containing the lines of proc body
#   special_syntax: can be used to manipulate the list contents befor writing it to
#     proc body
#
#
# <Internal Example>
#
# INTERNAL USE
#
#____________________________________________________________________________________________
proc LIB_GE_init_open_documentation {} {
  global lib_document
  if {[info exists lib_document]} {

    set is_url [regexp {(https?)://(www\d?|[a-zA-Z0-9]+)?\.[a-zA-Z0-9-]+(\:|\.)([a-zA-Z0-9.]+|(\d+)?)([/?:].*)?} $lib_document]

    if {!$is_url && (![file exists $lib_document] || ![string match "*.pdf" $lib_document])} {
      MOM_output_to_listing_device "The documentation path \"$lib_document\" is not a valid url or pdf file path "
      return
    }

    uplevel #0 {
      proc LIB_GE_open_documentation {} {
        global lib_document
        eval exec [auto_execok start] [list $lib_document]
      }
    }

  }
}
# <Internal Documentation>
#
# This has to be called in LIB_GE_initialize_custom_level
#
# It will initialize LIB_GE_open_documentation if the lib_document
#   is installed in service layer
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_GE_init_unit_handling {} {

  global mom_sys_home_pos mom_sys_home_pos_metric mom_sys_home_pos_inch
  global mom_kin_max_arc_radius mom_kin_max_arc_radius_inch mom_kin_max_arc_radius_metric
  global mom_kin_min_arc_radius mom_kin_min_arc_radius_inch mom_kin_min_arc_radius_metric
  global mom_kin_min_arc_length mom_kin_min_arc_length_inch mom_kin_min_arc_length_metric
  global mom_kin_machine_resolution mom_kin_machine_resolution_inch mom_kin_machine_resolution_metric
  global lib_ge_unit_var_list

  set lib_ge_unit_var_list [list mom_kin_max_arc_radius mom_kin_min_arc_radius mom_kin_min_arc_length mom_kin_machine_resolution]

  for {set i 0} {$i <= 2} {incr i} {
    if {[info exists mom_sys_home_pos($i)]} {
      LIB_GE_set mom_sys_home_pos_inch($i)   $mom_sys_home_pos($i)
      LIB_GE_set mom_sys_home_pos_metric($i) $mom_sys_home_pos($i)
    } else {
      LIB_GE_set mom_sys_home_pos($i) $mom_sys_home_pos_metric($i)
    }
  }

  # Save mom_sys_home_pos and metric inch value before custom level
  global lib_ge_save_unit_var lib_ge_save_home_pos lib_ge_save_home_pos_metric lib_ge_save_home_pos_inch
  VMOV 3 mom_sys_home_pos lib_ge_save_home_pos
  VMOV 3 mom_sys_home_pos_metric lib_ge_save_home_pos_metric
  VMOV 3 mom_sys_home_pos_inch lib_ge_save_home_pos_inch

  foreach unit_var $lib_ge_unit_var_list {
    if {[info exists $unit_var]} {
      LIB_GE_set ${unit_var}_inch   [set $unit_var]
      LIB_GE_set ${unit_var}_metric [set $unit_var]
    } else {
      LIB_GE_set $unit_var [set ${unit_var}_metric]
    }
    set lib_ge_save_unit_var($unit_var) [set $unit_var]
    set lib_ge_save_unit_var(${unit_var}_metric) [set ${unit_var}_metric]
    set lib_ge_save_unit_var(${unit_var}_inch) [set ${unit_var}_inch]
  }
}
# <Internal Documentation>
#
# This has to be called in LIB_GE_initialize_custom_level
#
# It will initialize mom_sys and mom_kin variables which have
# metric or inch unit.
#
# All mom variables which have metric or inch unit should not be initialized in PC library
# until this command be called at beginning of customer level. It help us to identify if
# customer setup default value of them in service layer. If yes, both of metric and inch
#   default value are set to customer's value.
#   <Jan 08 2019>
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_GE_generate_chain_selection_condition_vars {number_of_conditions} {

  global lib_ge_chain_condition
  global lib_ge_chain_selection
  global lib_ge_chain_selection_priority

  for {set i 0} {$i < $number_of_conditions} {incr i} {

    if {![info exists lib_ge_chain_selection($i)]} {
      set lib_ge_chain_selection($i) ""
    }

    for {set ii 0} {$ii < [array size lib_ge_chain_selection_priority]} {incr ii} {
      if {![info exists lib_ge_chain_condition($i,$lib_ge_chain_selection_priority($ii))]} {
        set lib_ge_chain_condition($i,$lib_ge_chain_selection_priority($ii)) ""
      }
    }
  }

}
# <Documentation>
# This function initializes the variables used to display chain selection conditions in the UI.
# A selection condition is added by default for each chain (without explicitly calling this function).
# <Arguments>
# number_of_conditions
#   The total amount of chain selection conditions.
# <Returnvalue>
# None.
# <Example>
# LIB_GE_generate_chain_selection_condition_vars 4
#____________________________________________________________________________________________
proc LIB_GE_macro_arr {n1 n2 m} {
  global lib_ge_macro_arr

  if {![regexp "DEFINE_MACROS" [info level -1]]} {lappend lib_ge_macro_arr $n2}
}
# <Internal Documentation>
#
# Collect a list of macros which are modified from the customer
#
# <Internal Example>
#
#
#____________________________________________________________________________________________
proc LIB_GE_args procname {

  set res ""
  foreach a [info args $procname] {
    if [info default $procname $a default] {
      lappend a $default
    }
    lappend res $a
  }
  set res

}
# <Internal Documentation>
#
# Signature of a proc: arguments with defaults
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_load_smk_data {} {

  uplevel #0 {
    if {[array exists mom_sys_kim_model_data]} {
      foreach var_name [array name mom_sys_kim_model_data] {
        set mom_${var_name} $mom_sys_kim_model_data(${var_name})
      }
    }

    # install home position
    if {[info exists mom_sys_kim_model_data(sys_home_pos(0))]} {
      if {[info exists mom_sys_mtb_units] && [string equal "Inch" $mom_sys_mtb_units]} {
        array set mom_sys_home_pos_inch [array get mom_sys_home_pos]
        set mom_sys_home_pos_metric(0) [expr $mom_sys_home_pos_inch(0) * 25.4]
        set mom_sys_home_pos_metric(1) [expr $mom_sys_home_pos_inch(1) * 25.4]
        set mom_sys_home_pos_metric(2) [expr $mom_sys_home_pos_inch(2) * 25.4]
      } else {
        array set mom_sys_home_pos_metric [array get mom_sys_home_pos]
        set mom_sys_home_pos_inch(0) [expr $mom_sys_home_pos_metric(0) / 25.4]
        set mom_sys_home_pos_inch(1) [expr $mom_sys_home_pos_metric(1) / 25.4]
        set mom_sys_home_pos_inch(2) [expr $mom_sys_home_pos_metric(2) / 25.4]
      }
      unset mom_sys_home_pos
    }
  }

}
# <Internal Documentation>
#
# This has to be called at end of mtb layer
#   This proc is used to convert SMK data to related mom variable.
#
#
#____________________________________________________________________________________________

# lib_pretreatment.tcl

proc LIB_Shell_environment_handling {} {

  global lib_ge_env lib_ge_slash lib_ge_installed_machines

  set lib_ge_env(post_pool_dir)     [LIB_Shell_format_path_names [MOM_ask_env_var "UGII_POST_POOL_DIR_NG"]]
  set lib_ge_env(cam_post_dir)    [LIB_Shell_format_path_names [MOM_ask_env_var "UGII_CAM_POST_DIR"]]
  set lib_ge_env(tmp_dir)                 [LIB_Shell_format_path_names [MOM_ask_env_var "UGII_TMP_DIR"]]
  if {$lib_ge_env(tmp_dir) == ""} {set lib_ge_env(tmp_dir) $::lib_ge_temppath}

  if {[string match [string tolower [file tail [file dirname [info script]]]] "libraries"]} {
    set lib_ge_installed_machines [file dirname [info script]]
  } else {
    set lib_ge_installed_machines [info script]
  }

  set lib_ge_env(installed_machines_dir)  [LIB_Shell_format_path_names [file dirname $lib_ge_installed_machines]]
  # Needed is searchpath activ, therefore info script is wrong
  if {[file exists [LIB_Shell_format_path_names "$lib_ge_env(tmp_dir)${lib_ge_slash}pretreatment_script.tcl"]]} {source [LIB_Shell_format_path_names "$lib_ge_env(tmp_dir)${lib_ge_slash}pretreatment_script.tcl"]}

  set lib_ge_env(installed_machines_dir,recursively) ""
  lappend lib_ge_env(installed_machines_dir,recursively) $lib_ge_env(installed_machines_dir)

  set current_dir [pwd]
  if {![catch {cd [lindex $lib_ge_env(installed_machines_dir,recursively) 0]}]} {
    if {![catch {set dir [string tolower [glob *]]}]} {
      foreach e {libraries controller bin} {
        set index [lsearch -exact $dir $e]
        if {$index > -1} {
          set directory [lindex $dir $index]
          set directory [string toupper [string index $directory 0]][string range $directory 1 end]
          lappend lib_ge_env(installed_machines_dir,recursively) [LIB_Shell_format_path_names "[lindex $lib_ge_env(installed_machines_dir,recursively) 0]$lib_ge_slash$directory"]
        }
      }
    }
  }
  cd $current_dir

  if {![regexp -nocase -- {\w+} $lib_ge_env(post_pool_dir)]} {set lib_ge_env(post_pool_dir) $lib_ge_env(installed_machines_dir)}

  set lib_ge_env(version_bit)       [MOM_ask_env_var "UGII_VERSION_BIT"]
  set lib_ge_env(base_dir)          [MOM_ask_env_var "UGII_BASE_DIR"]

  set lib_ge_env(compatible_base_release_version) [MOM_ask_env_var "NX_COMPATIBLE_BASE_RELEASE_VERSION"]
  set lib_ge_env(major_version)       [MOM_ask_env_var "UGII_MAJOR_VERSION"]
  set lib_ge_env(minor_version)         [MOM_ask_env_var "UGII_MINOR_VERSION"]
  set lib_ge_env(subminor_version)        [MOM_ask_env_var "UGII_SUBMINOR_VERSION"]

  if {![info exists lib_ge_dll_version]} {global lib_ge_dll_version}
  if {$lib_ge_env(minor_version) > 0} {
    set lib_ge_dll_version "nx$lib_ge_env(major_version)$lib_ge_env(minor_version)"
  } else {
    set lib_ge_dll_version "nx$lib_ge_env(major_version)"
  }
  if {[llength $lib_ge_env(compatible_base_release_version)] > 0} {set lib_ge_dll_version "nx$lib_ge_env(compatible_base_release_version)"}

  regsub -all "/" $lib_ge_env(base_dir) "\\" lib_ge_env(base_dir)

}
# <Internal Documentation>
#
# Handling for the default environment variables
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_abort {message} {

  MOM_output_to_listing_device $message
  MOM_log_message $message

  MOM_abort $message

}
# <Internal Documentation>
#
# Abort postrun
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_main {} {

  global lib_ge_env lib_ge_slash
  global lib_cycle_path sourcefile

  LIB_Shell_environment_handling

  lappend ::lib_ge_monitored_files [LIB_Shell_format_path_names [info script]]

  if {[info commands LIB_GE_source] == ""} {
    set lib_cycle_path 0
    set searchpath $lib_ge_env(installed_machines_dir,recursively)
    lappend searchpath $lib_ge_env(post_pool_dir)
    foreach path $searchpath {
      if {$lib_cycle_path} {break}
      foreach ext {.tcl .tbc .pcf} {
        set sourcefile [LIB_Shell_format_path_names "$path${lib_ge_slash}lib_sourcing$ext"]
        if {[file exists $sourcefile]} {
          if {[string match ".tbc" $ext]} {
            LIB_Shell_abort "ByteCode Loader is not available, cannot process lib_sourcing$ext"
          }
          uplevel #0 {

            set err ""
            if {$tcl_version >= 8.6 && [catch {source -encoding utf-8 $sourcefile} err]} {
              if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $::errorInfo"}
              LIB_Shell_abort "File lib_sourcing $err not loadable"
            }
            if {$tcl_version < 8.6 && [catch {source $sourcefile} err]} {
              if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $::errorInfo"}
              LIB_Shell_abort "File lib_sourcing $err not loadable"
            }
            if {[string length $err] > 0} {
              set lib_ge_debug(lib_sourcing) "$sourcefile"
              lappend lib_ge_monitored_files "$sourcefile"
              lappend lib_ge_log_message "\n--> $sourcefile loaded"
              set lib_cycle_path 1 ; break
            }

          }
        }
      }
    }
    if {!$lib_cycle_path} {
      LIB_Shell_abort "File lib_sourcing not found"
    }
  }

  LIB_Shell_init

}
# <Internal Documentation>
#
# Handling for the main shell
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_defined_post_environment {} {

  global lib_ge_env lib_ge_slash lib_pp_source_file

  #____________________________________________________________________________________________
  #
  # NX Post, load files
  #____________________________________________________________________________________________
  #

  # There are different ways to source each files
  #
  # e.g. Befor LIB_GE_source call
  # lappend lib_pp_source_file "machine,UGII_CAM_POST_DIR"
  #
  # e.g. After LIB_GE_source call
  # LIB_GE_source "Test" "C:/Temp/;d:/tmp/"
  #
  # e.g. To define a searchpath
  # LIB_GE_source "" "C:/Temp/;UGII_CAM_POST_DIR"
  # Allowed is the direct path and/or variable

  # This is the call the PB post LIB_GE files
  # ** internal funktion / Don't remove this line **

  if {[file exists "$lib_ge_env(tmp_dir)${lib_ge_slash}pt_source_list_[pid].tcl"]} {
    LIB_GE_source pt_source_list_[pid] "$lib_ge_env(tmp_dir)${lib_ge_slash}" ".tcl" 0 0 "RUNTIME"
    LIB_GE_source lib_pretreatment_post
  } else {
    lappend lib_pp_source_file "ugpost_base" "lib_msg" "lib_file_handling" "lib_standard_post_func" "lib_document" "lib_pretreatment_post"
    LIB_GE_source
  }
}
# <Internal Documentation>
#
# Handling for the default environment variables
#
# <Internal Example>
#
#____________________________________________________________________________________________

#lib_pretreatment_post.tcl

proc PT_start_of_program {} {

  global lib_ge_pretreatment mom_kin_machine_type env lib_ge_slash
  global mom_output_file_basename pt_pp_source_file lib_ge_env lib_pt

  if {![info exists lib_ge_pretreatment]} {
    set lib_ge_pretreatment ""
  }

  if {[llength [info commands LIB_PT_start_of_program]]} {LIB_PT_start_of_program}

  if {[info exists lib_pt(pretreatment,controls)] && $lib_pt(pretreatment,controls) == 1} {
    set notclean  "MOM_initial_move MOM_first_move PT_initial_move PT_first_move"

    foreach lib_pt(global) [concat [info command MOM_*_move] [info command PT_*_move] [info command MOM_before_*]] {

      if {[info commands $lib_pt(global)] != "" && [info commands $lib_pt(global)_resolving] == "" && [lsearch -exact $notclean $lib_pt(global)] <0} {

        rename $lib_pt(global) $lib_pt(global)_resolving

        uplevel #0 {
          proc $lib_pt(global) {args} {
            # Cleanup all events in runtime
            # MOM_skip_handler_to_event end_of_path is to slow
            MOM_abort_event
          }
        }
      }
    }

    MOM_disable_address G_motion X Y Z fourth_axis fifth_axis

  } elseif {![info exists lib_pt(pretreatment,controls)]} {

    set lib_pt(pretreatment,controls) 0

  }

  if {![info exists mom_kin_machine_type]} {

    MOM_output_to_listing_device "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    MOM_output_to_listing_device "!!!!!!!      --> NO REAL KINEMATIC DEFINED <--       !!!!!!!"
    MOM_output_to_listing_device "!!!!!!!   THIS IS NOT A SELF-SUFFICIENT PROCESSORS   !!!!!!!"
    MOM_output_to_listing_device "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"

    set ::mom_kin_4th_axis_ang_offset               "0.0"
    set ::mom_kin_4th_axis_center_offset(0)         "0.0"
    set ::mom_kin_4th_axis_center_offset(1)         "0.0"
    set ::mom_kin_4th_axis_center_offset(2)         "0.0"
    set ::mom_kin_4th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set ::mom_kin_4th_axis_incr_switch              "OFF"
    set ::mom_kin_4th_axis_leader                   "B"
    set ::mom_kin_4th_axis_limit_action             "Warning"
    set ::mom_kin_4th_axis_max_limit                "360"
    set ::mom_kin_4th_axis_min_incr                 "0.001"
    set ::mom_kin_4th_axis_min_limit                "0"
    set ::mom_kin_4th_axis_plane                    "ZX"
    set ::mom_kin_4th_axis_point(0)                 "0.0"
    set ::mom_kin_4th_axis_point(1)                 "0.0"
    set ::mom_kin_4th_axis_point(2)                 "0.0"
    set ::mom_kin_4th_axis_rotation                 "standard"
    set ::mom_kin_4th_axis_type                     "Head"
    set ::mom_kin_4th_axis_vector(0)                "0"
    set ::mom_kin_4th_axis_vector(1)                "1"
    set ::mom_kin_4th_axis_vector(2)                "0"
    set ::mom_kin_4th_axis_zero                     "0.0"
    set ::mom_kin_5th_axis_ang_offset               "0.0"
    set ::mom_kin_5th_axis_center_offset(0)         "0.0"
    set ::mom_kin_5th_axis_center_offset(1)         "0.0"
    set ::mom_kin_5th_axis_center_offset(2)         "0.0"
    set ::mom_kin_5th_axis_direction                "MAGNITUDE_DETERMINES_DIRECTION"
    set ::mom_kin_5th_axis_incr_switch              "OFF"
    set ::mom_kin_5th_axis_leader                   "C"
    set ::mom_kin_5th_axis_limit_action             "Warning"
    set ::mom_kin_5th_axis_max_limit                "360"
    set ::mom_kin_5th_axis_min_incr                 "0.001"
    set ::mom_kin_5th_axis_min_limit                "0"
    set ::mom_kin_5th_axis_plane                    "XY"
    set ::mom_kin_5th_axis_point(0)                 "0.0"
    set ::mom_kin_5th_axis_point(1)                 "0.0"
    set ::mom_kin_5th_axis_point(2)                 "0.0"
    set ::mom_kin_5th_axis_rotation                 "standard"
    set ::mom_kin_5th_axis_type                     "Table"
    set ::mom_kin_5th_axis_vector(0)                "0"
    set ::mom_kin_5th_axis_vector(1)                "0"
    set ::mom_kin_5th_axis_vector(2)                "1"
    set ::mom_kin_5th_axis_zero                     "0.0"
    set ::mom_kin_arc_output_mode                   "FULL_CIRCLE"
    set ::mom_kin_arc_valid_plane                   "ANY"
    set ::mom_kin_clamp_time                        "2.0"
    set ::mom_kin_cycle_plane_change_to_lower       "0"
    set ::mom_kin_flush_time                        "2.0"
    set ::mom_kin_linearization_flag                "1"
    set ::mom_kin_linearization_tol                 "0.01"
    set ::mom_kin_machine_resolution                "0.001"
    set ::mom_kin_machine_type                      "5_axis_head_table"
    set ::mom_kin_machine_zero_offset(0)            "0.0"
    set ::mom_kin_machine_zero_offset(1)            "0.0"
    set ::mom_kin_machine_zero_offset(2)            "0.0"
    set ::mom_kin_max_arc_radius                    "99999.999"
    set ::mom_kin_max_dpm                           "1000000"
    set ::mom_kin_max_fpr                           "1000"
    set ::mom_kin_max_frn                           "1000"
    set ::mom_kin_min_arc_length                    "0.20"
    set ::mom_kin_min_arc_radius                    "0.001"
    set ::mom_kin_min_dpm                           "0.0"
    set ::mom_kin_min_fpm                           "0.1"
    set ::mom_kin_min_fpr                           "0.1"
    set ::mom_kin_min_frn                           "0.01"
    set ::mom_kin_output_unit                       "MM"
    set ::mom_kin_pivot_gauge_offset                "0.0"
    set ::mom_kin_pivot_guage_offset                ""
    set ::mom_kin_post_data_unit                    "MM"
    set ::mom_kin_rapid_feed_rate                   "10000"
    set ::mom_kin_retract_distance                  "500"
    set ::mom_kin_rotary_axis_method                "PREVIOUS"
    set ::mom_kin_spindle_axis(0)                   "0.0"
    set ::mom_kin_spindle_axis(1)                   "0.0"
    set ::mom_kin_spindle_axis(2)                   "1.0"
    set ::mom_kin_tool_change_time                  "12.0"
    set ::mom_kin_x_axis_limit                      "1000"
    set ::mom_kin_y_axis_limit                      "1000"
    set ::mom_kin_z_axis_limit                      "1000"

  } elseif {$mom_output_file_basename != "pretreatment_[pid]"} {
    MOM_output_to_listing_device "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    MOM_output_to_listing_device "!!!!!!!       --> PRETREATMENT POST TEST <--         !!!!!!!"
    MOM_output_to_listing_device "!!!!!!!    sourced post file:                        !!!!!!!"
    MOM_output_to_listing_device "!!!!!!!"
    MOM_output_to_listing_device "!!!!!!!    $pt_pp_source_file"
    MOM_output_to_listing_device "!!!!!!!"
    MOM_output_to_listing_device "!!!!!!! delete $lib_ge_env(tmp_dir)${lib_ge_slash}pt_source_list_[pid].tcl "
    MOM_output_to_listing_device "!!!!!!!    to test pure pretreatment '$mom_output_file_basename' "
    MOM_output_to_listing_device "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  }

  # Workaround for Bug 1889
  MOM_reload_kinematics
  # from move is ouputted as initial/first move
  if {[llength [info commands MOM_enable_from_move_fix]] && $::mom_sys_enable_from_without_tool_change == 1} {
    MOM_enable_from_move_fix
  }
  # delete the pretreatment transferfile here
  if {[LIB_Shell_file_exists $lib_ge_pretreatment 1]} {
    catch {MOM_remove_file $lib_ge_pretreatment}
  }

  # disable output of debug_buffer (Output for QA team)
  # (all output generated by a postprocesser, regardless of main or pt postprocessor run, is put to
  # an internal NX variable which is used to compare the output (for QA-Team)
  # With the Keyword '#PRETREATMENT_OUTPUT_START' we tell NX to not put this intermediate output from Pretreatment to this debug_buffer)
  # This will be canceled by the keyword '#PRETREATMENT_OUTPUT_END' (see MOM_end_of_program)
  MOM_suppress once N
  MOM_output_literal "#PRETREATMENT_OUTPUT_START    \[" JEPT
}
# <Internal Documentation>
#
# Here is the procedure MOM_start_of_program loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_start_of_program at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_start_of_path {} {

  global flag type subtype lib_pt
  global mom_operation_type mom_template_type
  global mom_kin_is_turbo_output
  global mom_kin_iks_usage cycle_tap tag
  global pt_save_orig_turbo
  global mom_from_status
  global mom_current_motion
  global hole_making_operation

  if {[llength [info commands LIB_PT_start_of_path]]} {LIB_PT_start_of_path}

  set mom_current_motion ""

  PT_save_pre_start_of_path_vars

  set cycle_tap ""
  set flag(lib_pt_tool_axis_change) 0
  set flag(lib_pt_tool_path_motion) 0

  # ask the operation type from the current operation
  LIB_ask_operation_type

  MOM_force once G_motion fourth_axis fifth_axis X Y Z

  # set as an default the turbo mode to an deactive state
  if {![info exists flag(kin_is_turbo_output)] } {
    set flag(kin_is_turbo_output) ""
  }

  set mom_kin_is_turbo_output "FALSE"
  set hole_making_operation 0

  # analyze object types and subtypes based on ..\UGOPEN\uf_object_types.h
  # and set the turbo mode option it is possible by toggle
  if {![info exists flag(lib_spf_no_turbo_mode)] || !$flag(lib_spf_no_turbo_mode)} {
    if {$type == 100} {
      switch -- $subtype {
        1    {set mom_kin_is_turbo_output "FALSE" ; # mach_instanced_oper_subtype       }
        2    {set mom_kin_is_turbo_output "FALSE" ; # mach_orphan_oper_subtype          }
        10   {set mom_kin_is_turbo_output "FALSE" ; # mach_oldopr_subtype               }
        11   {set mom_kin_is_turbo_output "FALSE" ; # mach_mill_post_cmnds_subtype      }
        13   {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_post_cmnds_subtype     }
        17   {set mom_kin_is_turbo_output "FALSE" ; # mach_wed_post_cmnds_subtype       }
        110  {set mom_kin_is_turbo_output "TRUE"  ; # mach_pocket_subtype               }
        210  {set mom_kin_is_turbo_output "TRUE"  ; # mach_surface_contour_subtype      }
        211  {set mom_kin_is_turbo_output "TRUE"  ; # mach_vasc_subtype                 }
        220  {set mom_kin_is_turbo_output "TRUE"  ; # mach_gssm_main_op_subtype         }
        221  {set mom_kin_is_turbo_output "TRUE"  ; # mach_gssm_sub_op_subtype          }
        222  {set mom_kin_is_turbo_output "TRUE"  ; # mach_gssm_grip_subtype            }
        230  {set mom_kin_is_turbo_output "TRUE"  ; # mach_param_line_subtype           }
        240  {set mom_kin_is_turbo_output "TRUE"  ; # mach_zig_zag_surf_subtype         }
        250  {set mom_kin_is_turbo_output "TRUE"  ; # mach_rough_to_depth_subtype       }
        260  {set mom_kin_is_turbo_output "TRUE"  ; # mach_cavity_milling_subtype       }
        261  {set mom_kin_is_turbo_output "TRUE"  ; # mach_face_milling_subtype         }
        262  {set mom_kin_is_turbo_output "TRUE"  ; # mach_volumn_milling_subtype       }
        263  {set mom_kin_is_turbo_output "TRUE"  ; # mach_zlevel_milling_subtype       }
        264  {set mom_kin_is_turbo_output "FALSE" ; # mach_fb_hole_milling_subtype      }
        265  {set mom_kin_is_turbo_output "FALSE" ; # mach_plunge_milling_subtype       }
        266  {set mom_kin_is_turbo_output "TRUE"  ; # mach_vazl_milling_subtype         }
        310  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_rough_subtype          }
        320  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_finish_subtype         }
        330  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_groove_subtype         }
        340  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_thread_subtype         }
        350  {set mom_kin_is_turbo_output "FALSE" ; set hole_making_operation 1; # mach_drill_subtype                }
        360  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_face_subtype           }
        450  {set mom_kin_is_turbo_output "FALSE" ; set hole_making_operation 1; # mach_point_to_point_subtype       }
        460  {set mom_kin_is_turbo_output "TRUE"  ; # mach_seq_curve_mill_subtype       }
        461  {set mom_kin_is_turbo_output "TRUE"  ; # mach_seq_curve_lathe_subtype      }
        510  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_rough_subtype           }
        520  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_finish_subtype          }
        530  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_teachmode_subtype       }
        540  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_thread_subtype          }
        550  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_cdrill_subtype          }
        560  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_auxiliary_subtype       }
        600  {set mom_kin_is_turbo_output "FALSE" ; set hole_making_operation 1; # mach_hole_making_subtype          }
        700  {set mom_kin_is_turbo_output "FALSE" ; # mach_wedm_subtype                 }
        800  {
          # mach_mill_ud_subtype
          if {[LIB_GE_is_volumill_op reset] || [LIB_GE_is_imachining_op]} {
            set mom_kin_is_turbo_output "TRUE"
          } else {
            set mom_kin_is_turbo_output "FALSE"
          }
        }
        900  {set mom_kin_is_turbo_output "FALSE" ; # mach_gmc_subtype                  }
        1000 {set mom_kin_is_turbo_output "FALSE" ; # mach_probing_subtype              }
        1010 {set mom_kin_is_turbo_output "FALSE" ; # mach_mill_probing_subtype         }
        1020 {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_probing_subtype         }
        1030 {set mom_kin_is_turbo_output "FALSE" ; # mach_mill_tool_probing_subtype    }
        1040 {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_tool_probing_subtype    }
        1100 {
          # mach_mill_mc_subtype
          if {$mom_template_type == "Imported"} {
            set mom_kin_is_turbo_output "TRUE"
          } else {
            set mom_kin_is_turbo_output "FALSE"
          }
        }
        1200 {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_mc_subtype             }
        1300 {set mom_kin_is_turbo_output "FALSE" ; # mach_wedm_mc_subtype              }
        1400 {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_ud_subtype             }
        1500 {set mom_kin_is_turbo_output "FALSE" ; # mach_wedm_ud_subtype              }
        1600 {set mom_kin_is_turbo_output "FALSE" ; # mach_mass_edit_subtype            }
        1700 {set mom_kin_is_turbo_output "FALSE" ; # mach_thread_milling_subtype       }
        1800 {set mom_kin_is_turbo_output "FALSE" ; # insp_tolerance_subtype            }
        1900 {set mom_kin_is_turbo_output "FALSE" ; # insp_path_subtype                 }
        2000 {set mom_kin_is_turbo_output "FALSE" ; # insp_output_subtype               }
        2100 {set mom_kin_is_turbo_output "FALSE" ; # insp_misc_subtype                 }
        2200 {set mom_kin_is_turbo_output "FALSE" ; # insp_align_subtype                }
        2300 {set mom_kin_is_turbo_output "FALSE" ; # insp_sensor_subtype               }
        2400 {set mom_kin_is_turbo_output "FALSE" ; # insp_construct_subtype            }
        2500 {set mom_kin_is_turbo_output "FALSE" ; # insp_bounding_feature_subtype     }
        2600 {set mom_kin_is_turbo_output "FALSE" ; # insp_feature_subtype              }
        2700 {set mom_kin_is_turbo_output "FALSE" ; # mach_cylinder_milling_subtype     }
        2800 {set mom_kin_is_turbo_output "FALSE" ; # mach_canned_cycle_subtype         }
        2900 {set mom_kin_is_turbo_output "FALSE" ; # mach_laser_teachmode_subtype      }
        3000 {set mom_kin_is_turbo_output "FALSE" ; set hole_making_operation 1; # mach_hole_drilling_subtype        }
        3100 {set mom_kin_is_turbo_output "FALSE" ; # mach_groove_milling_subtype       }
        3200 {set mom_kin_is_turbo_output "FALSE" ; # mach_chamfer_milling_subtype      }
        3300 {set mom_kin_is_turbo_output "FALSE" ; # mach_radial_groove_milling_subtype}
        3400 {set mom_kin_is_turbo_output "FALSE" ; # mach_planar_additive_subtype      }
        3500 {set mom_kin_is_turbo_output "FALSE" ; # mach_generic_feature_subtype      }
        3600 {set mom_kin_is_turbo_output "FALSE" ; # mach_device_gmc_subtype           }
        3800 {set mom_kin_is_turbo_output "TRUE"  ; # TP Framework Operations   }
        default {set mom_kin_is_turbo_output "FALSE"}
      }
    }
  }

  set flag(check_cycle_combine) 0
  set ::lib_cycle_move_number 0
  #flag used to check if operation should combine drilling cycles
  if {[string match "*table*" $::mom_kin_machine_type] && [CONF_SPF_cycle combine_rapid_arc_motion] == "Yes" && $hole_making_operation == 1 } {
    set flag(check_cycle_combine) 1
    if {![string compare "TRUE" [MOM_validate_machine_model]]} {
      MOM_reload_iks_parameters NONE
      MOM_reload_kinematics
    }
  }

  if {[info exists mom_from_status] && $mom_from_status == 1} {
    set pt_save_orig_turbo $mom_kin_is_turbo_output
    set mom_kin_is_turbo_output "FALSE"
  }

  if {[info exists mom_kin_is_turbo_output] && $flag(kin_is_turbo_output) != $mom_kin_is_turbo_output} {
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
    set flag(kin_is_turbo_output) $mom_kin_is_turbo_output
  }

    global mom_merged_path_group_operation_name_list oper_tag_list_of_merged_group
    if {[info exists mom_merged_path_group_operation_name_list]} {
        set mom_merged_path_group_operation_name_list ""
    set oper_tag_list_of_merged_group ""
    }
   #NX1953 add preferred angle support
   LIB_SPF_set_preferred_solution

   if {[info exists ::mom_pattern_csys_matrix]} {
    set ::pt_is_pattern_instance($tag) 1
  } else {
    set ::pt_is_pattern_instance($tag) 0
   }
}
# <Internal Documentation>
#
# Here is the procedure MOM_start_of_path loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_start_of_path at the shell level
#
# If you dosen't like the turbo mode, so need to be set the variable
# flag(lib_spf_no_turbo_mode) at the customer level to 1
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_first_tool {} {

  if {[llength [info commands LIB_PT_first_tool]]} {LIB_PT_first_tool}

  LIB_write_pretreatment "mom_tool_change_type"
  set ::flag(check_tool_change) 1

}
# <Internal Documentation>
#
# Here is the procedure MOM_first_tool loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_first_tool at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_tool_change {} {

  if {[llength [info commands LIB_PT_tool_change]]} {LIB_PT_tool_change}

  LIB_write_pretreatment "mom_tool_change_type"
  set ::flag(check_tool_change) 1

}
# <Internal Documentation>
#
# Here is the procedure MOM_tool_change loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_tool_change at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_msys {} {
  global pt_flag
  global lib_flag

  if {[llength [info commands LIB_PT_msys]]} {LIB_PT_msys}

  set pt_flag(mom_msys_done) 1

}
# <Internal Documentation>
#
# Here is the procedure MOM_msys loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_msys at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_initial_move {} {

  global pt_flag init_tool_axis mom_tool_axis

  if {[llength [info commands LIB_PT_initial_move]]} {LIB_PT_initial_move}

  if {$pt_flag(mom_msys_done) == 0} {MOM_msys}

  # Bug at the block handling from NX
  # Without the fix we got:
  # e.g.  C X71.919 Y149.29 Z433.03 4th0.0 5th0.0(SQUARE BRACKET)
  # Therefore: extra characters after close-brace
  # Now with this fix
  # e.g.  lappend lib_pt($tag) [list C X71.919 Y149.29 Z433.03 4th0.0 5th0.0]
  MOM_force once N ; MOM_enable_address N

  if {[EQ_is_zero $::mom_programmed_feed_rate]} {
    LIB_do_template RAPID
  } else {
    LIB_do_template LINEAR
  }
  array set init_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  LIB_write_pretreatment "mom_out_angle_pos init_tool_axis"

}
# <Internal Documentation>
#
# Here is the procedure MOM_initial_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_initial_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_first_move {} {

  global pt_flag tag init_tool_axis mom_tool_axis

  if {[llength [info commands LIB_PT_first_move]]} {LIB_PT_first_move}

  if {$pt_flag(mom_msys_done) == 0} {MOM_msys}

  # Bug at the block handling from NX
  # Without the fix we got:
  # e.g.  C X71.919 Y149.29 Z433.03 4th0.0 5th0.0(SQUARE BRACKET)
  # Therefore: extra characters after close-brace
  # Now with this fix
  # e.g.  lappend lib_pt($tag) [list C X71.919 Y149.29 Z433.03 4th0.0 5th0.0]
  MOM_force once N ; MOM_enable_address N

  # <Feb-10-2021 xinrong> Need to treat first move as initial move for pattern instances, in order to prevent axis_mode from false simultaneous in LIB_analyze_op_type
  if {[info exists ::pt_is_pattern_instance($tag)] && $::pt_is_pattern_instance($tag) == 1} {
    if {[EQ_is_zero $::mom_programmed_feed_rate]} {
      LIB_do_template RAPID
    } else {
      LIB_do_template LINEAR
    }
  } else {
    LIB_do_template INITIAL
  }
  array set init_tool_axis "0 $mom_tool_axis(0) 1 $mom_tool_axis(1) 2 $mom_tool_axis(2)"
  LIB_write_pretreatment "mom_out_angle_pos init_tool_axis"

}
# <Internal Documentation>
#
# Here is the procedure MOM_first_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_first_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_from_move {} {

  global pt_flag

  if {[llength [info commands LIB_PT_from_move]]} {LIB_PT_from_move}

  if {$pt_flag(mom_msys_done) == 0} {MOM_msys}

  # Bug at the block handling from NX
  # Without the fix we got:
  # e.g.  C X71.919 Y149.29 Z433.03 4th0.0 5th0.0(SQUARE BRACKET)
  # Therefore: extra characters after close-brace
  # Now with this fix
  # e.g.  lappend lib_pt($tag) [list C X71.919 Y149.29 Z433.03 4th0.0 5th0.0]
  MOM_force once N ; MOM_enable_address N

  LIB_do_template RAPID
  LIB_write_pretreatment "mom_out_angle_pos"

}
# <Internal Documentation>
#
# Here is the procedure MOM_first_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_first_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_before_motion {} {

  global flag tool_axis
  global mom_tool_axis
  global cutting_tool_axes
  global mom_motion_event mom_kin_is_turbo_output
  global mom_from_status
  global pt_save_orig_turbo
  global hole_making_operation mom_motion_type

  if {[llength [info commands LIB_PT_before_motion]]} {LIB_PT_before_motion}


  if {![info exists flag(lib_pt_tool_path_motion)] || !$flag(lib_pt_tool_path_motion)} {
    set cutting_tool_axes ""
    set flag(lib_pt_tool_path_motion) 1
  }

  if {$cutting_tool_axes == ""} {
    lappend cutting_tool_axes [array get mom_tool_axis]
  }

  if {[info exists mom_motion_event] && $mom_motion_event != "rapid_move" && [info exists mom_tool_axis] && \
      !($hole_making_operation ==1 && ($mom_motion_type == "RAPID" || $mom_motion_type == "TRAVERSAL"))} {
    array set check_axis [lindex $cutting_tool_axes end]
    if {[VEC3_is_equal mom_tool_axis check_axis] != 1} {
      lappend cutting_tool_axes [array get mom_tool_axis]
    }
  }

  if {[info exists mom_from_status] && $mom_from_status == 1 && [info exist mom_motion_event] && $mom_motion_event != "from_move" && $mom_motion_event != "rapid_move" && $pt_save_orig_turbo == "TRUE"} {

    set pt_save_orig_turbo ""
    set mom_kin_is_turbo_output "TRUE"

    if {[info exists mom_kin_is_turbo_output] && $flag(kin_is_turbo_output) != $mom_kin_is_turbo_output} {
      MOM_reload_kinematics_variable mom_kin_is_turbo_output
      set flag(kin_is_turbo_output) $mom_kin_is_turbo_output
    }
  }


}
# <Internal Documentation>
#
# Here is the procedure MOM_initial_move loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_initial_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_rapid_move {} {

  if {[llength [info commands LIB_PT_rapid_move]]} {LIB_PT_rapid_move}

  LIB_do_template RAPID
  global flag
  if {[info exists flag(check_cycle_combine)] && $flag(check_cycle_combine) == 1 && \
    [info exists flag(cycle_skip_rapid)] && $flag(cycle_skip_rapid) != -1}  {
    global mom_spindle_axis mom_pos lib_cycle_spindle_axis lib_prev_cycle_retract_pos
    if {[VEC3_is_equal mom_spindle_axis lib_cycle_spindle_axis] && [VEC3_is_equal mom_pos lib_prev_cycle_retract_pos]} {
      set flag(cycle_skip_rapid) 1
    } else {
      set flag(cycle_skip_rapid) -1
    }
  }
}
# <Internal Documentation>
#
# Here is the procedure MOM_rapid_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_rapid_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_linear_move {} {
  global hole_making_operation mom_motion_type
  if {[llength [info commands LIB_PT_linear_move]]} {LIB_PT_linear_move}

  if {$hole_making_operation ==1 && ($mom_motion_type == "RAPID" || $mom_motion_type == "TRAVERSAL")} {
    LIB_do_template RAPID
  } else {
    LIB_do_template LINEAR
  }

}
# <Internal Documentation>
#
# Here is the procedure MOM_linear_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_linear_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_circular_move {} {

  if {[llength [info commands LIB_PT_circular_move]]} {LIB_PT_circular_move}

  LIB_do_template CIRCULAR

}
# <Internal Documentation>
#
# Here is the procedure MOM_circular_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_circular_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_helix_move {} {

  if {[llength [info commands LIB_PT_helix_move]]} {LIB_PT_helix_move}

  LIB_do_template HELICAL

}
# <Internal Documentation>
#
# Here is the procedure MOM_helical_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_helical_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_nurbs_move {} {

  if {[llength [info commands LIB_PT_nurbs_move]]} {LIB_PT_nurbs_move}

  LIB_do_template NURBS

}
# <Internal Documentation>
#
# Here is the procedure MOM_nurbs_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_nurbs_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_cutcom_on {} {
  global pt_flag
  global lib_flag

  LIB_write_pretreatment "mom_cutcom_status"

}
# <Internal Documentation>
#
# Here is the procedure MOM_msys loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_msys at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_move {} {

  if {[llength [info commands LIB_PT_bore_move]]} {LIB_PT_bore_move}

  LIB_do_template BORE

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_back_move {} {

  if {[llength [info commands LIB_PT_bore_back_move]]} {LIB_PT_bore_back_move}

  LIB_do_template BORE_BACK

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_back_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_back_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_drag_move {} {

  if {[llength [info commands LIB_PT_bore_drag_move]]} {LIB_PT_bore_drag_move}

  LIB_do_template BORE_DRAG

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_drag_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_drag_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_dwell_move {} {

  if {[llength [info commands LIB_PT_bore_dwell_move]]} {LIB_PT_bore_dwell_move}

  LIB_do_template BORE_DWELL

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_dwell_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_dwell_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_manual_move {} {

  if {[llength [info commands LIB_PT_bore_manual_move]]} {LIB_PT_bore_manual_move}

  LIB_do_template BORE_MANUAL

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_manual_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_manual_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_manual_dwell_move {} {

  if {[llength [info commands LIB_PT_bore_manual_dwell_move]]} {LIB_PT_bore_manual_dwell_move}

  LIB_do_template BORE_MANUAL_DWELL

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_manual_dwell_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_manual_dwell_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_bore_no_drag_move {} {

  if {[llength [info commands LIB_PT_bore_no_drag_move]]} {LIB_PT_bore_no_drag_move}

  LIB_do_template BORE_NO_DRAG

}
# <Internal Documentation>
#
# Here is the procedure MOM_bore_no_drag_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_bore_no_drag_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_move {} {

  if {[llength [info commands LIB_PT_drill_move]]} {LIB_PT_drill_move}

  LIB_do_template DRILL

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_mill_hole_move {} {

  if {[llength [info commands LIB_PT_mill_hole_move]]} {LIB_PT_mill_hole_move}

  LIB_do_template POCKET4

}
# <Internal Documentation>
# Here is the procedure MOM_mill_hole_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_mill_hole_move at the shell level
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_break_chip_move {} {

  if {[llength [info commands LIB_PT_drill_break_chip_move]]} {LIB_PT_drill_break_chip_move}

  LIB_do_template DRILL_BREAK_CHIP

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_break_chip_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_break_chip_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_counter_sink_move {} {

  if {[llength [info commands LIB_PT_drill_counter_sink_move]]} {LIB_PT_drill_counter_sink_move}

  LIB_do_template DRILL_COUNTER_SINK

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_counter_sink_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_counter_sink_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_csink_dwell_move {} {

  if {[llength [info commands LIB_PT_drill_csink_dwell_move]]} {LIB_PT_drill_csink_dwell_move}

  LIB_do_template DRILL_CSINK_DWELL

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_csink_dwell_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_csink_dwell_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_deep_move {} {

  if {[llength [info commands LIB_PT_drill_deep_move]]} {LIB_PT_drill_deep_move}

  LIB_do_template DRILL_DEEP

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_deep_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_deep_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_dwell_move {} {

  if {[llength [info commands LIB_PT_drill_dwell_move]]} {LIB_PT_drill_dwell_move}

  LIB_do_template DRILL_DWELL

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_dwell_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_dwell_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_drill_text_move {} {

  if {[llength [info commands LIB_PT_drill_text_move]]} {LIB_PT_drill_text_move}

  LIB_do_template DRILL_TEXT

}
# <Internal Documentation>
#
# Here is the procedure MOM_drill_text_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_drill_text_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_tap_move {} {

  global cycle_tap

  if {[llength [info commands LIB_PT_tap_move]]} {LIB_PT_tap_move}

  LIB_do_template TAP

  set cycle_tap "YES"

}
# <Internal Documentation>
#
# Here is the procedure MOM_tap_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_tap_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_tap_float_move {} {

  global cycle_tap

  if {[llength [info commands LIB_PT_tap_float_move]]} {LIB_PT_tap_float_move}

  LIB_do_template TAP

  set cycle_tap "YES"

}
# <Internal Documentation>
#
# Here is the procedure MOM_tap_float_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_tap_float_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_tap_break_chip_move {} {

  global cycle_tap

  if {[llength [info commands LIB_PT_tap_break_chip_move]]} {LIB_PT_tap_break_chip_move}

  LIB_do_template TAP

  set cycle_tap "YES"

}
# <Internal Documentation>
#
# Here is the procedure MOM_tap_break_chip_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_tap_break_chip_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_tap_deep_move {} {

  global cycle_tap

  if {[llength [info commands LIB_PT_tap_deep_move]]} {LIB_PT_tap_deep_move}

  LIB_do_template TAP

  set cycle_tap "YES"

}
# <Internal Documentation>
#
# Here is the procedure MOM_tap_deep_move loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_tap_deep_move at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_end_of_path {} {

  global mom_kin_is_turbo_output lib_pt
  global tool_name_list mom_tool_name
  global tool_number_list mom_tool_number
  global operation_list mom_operation_name
  global tag_list tag mom_csys_matrix csys_is_default csys_is_offset
  global set_pt_kin pt_flag flag
  global out_angle_pos_last

  if {$pt_flag(mom_msys_done) == 0} {MOM_msys}

  if {[info exists mom_csys_matrix] && [LIB_SPF_is_matrix_equal [LIB_SPF_matrix_to_list "mom_csys_matrix" "11"] "1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0" "0.0001" "11"] == 1} {
    set csys_is_default 1
  } else {
    set csys_is_default 0
  }

  if {[info exists mom_csys_matrix] && [LIB_SPF_is_matrix_equal [LIB_SPF_matrix_to_list "mom_csys_matrix" "8"] "1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0" "0.0001" "8"] == 1} {
    set csys_is_offset 1
  } else {
    set csys_is_offset 0
  }

  if {[llength [info commands LIB_PT_end_of_path]]} {LIB_PT_end_of_path}

  if {[info exists lib_pt(pretreatment,controls)] && !$lib_pt(pretreatment,controls)} {
    # added different informations to lists
    lappend tool_name_list $mom_tool_name
    lappend tool_number_list $mom_tool_number
    if {$::mom_operation_name != $::mom_path_name} {
      lappend operation_list $::mom_path_name
    } else {
      lappend operation_list $::mom_operation_name
    }
    lappend tag_list $tag
  }

  # Get tool pitch info for to_ini output
  global mom_isv_tool_count mom_tool_pitch mom_isv_tool_name thread_tool_pitch
  if {[info exists mom_tool_pitch]} {
    for {set i 0} {$i <$mom_isv_tool_count} {incr i} {
      if {$mom_isv_tool_name($i) == $mom_tool_name} {
        set thread_tool_pitch($i) $mom_tool_pitch
        break
      }
    }
  }

  set tmp_turbo $mom_kin_is_turbo_output
  set mom_kin_is_turbo_output "FALSE"

  #########################################
  if {[info exists lib_pt(pretreatment,controls)] && !$lib_pt(pretreatment,controls)} {
    LIB_GE_copy_var_range pt_kin mom_kin

    uplevel #0 {
      set kin_list [info vars pt_kin*]

      set set_pt_kin ""

      foreach v $kin_list {

        if {[array get $v] == ""} {
          append set_pt_kin "set ::$v \"[subst $$v]\";"
        } else {
          append set_pt_kin "array set ::$v \"[array get $v]\";"
        }
      }
    }
  }
  ##########################################

  set mom_kin_is_turbo_output $tmp_turbo

  set out_angle_pos_last(0) [MOM_ask_address_value fourth_axis]
  set out_angle_pos_last(1) [MOM_ask_address_value fifth_axis]

  # make an output for the transferfile from the variable
  LIB_write_pretreatment "mom_toolpath_cutting_time mom_operation_type mom_kin_is_turbo_output csys_is_default csys_is_offset set_pt_kin mom_tool_axis mom_flip_a_axis mom_tool_holder_angle_for_cutting cutting_tool_axes mom_machine_mode out_angle_pos_last"
  LIB_write_pretreatment "mom_tool_name mom_tool_number mom_tool_description mom_oper_tool mom_optimized_group_operation_name_list mom_merged_path_group_operation_name_list cycle_tap oper_tag_list_of_merged_group"
  LIB_write_pretreatment "mom_blank_cylinder_feature_vector mom_blank_cylinder_diameter mom_blank_cylinder_height mom_blank_cylinder_center mom_blank_block_length mom_blank_block_width mom_blank_block_height mom_blank_block_center mom_blank_block_feature_matrix"

  if {[info exist ::cutting_tool_axes]} {
    set ::pt_cutting_tool_axes($tag) $::cutting_tool_axes
  }

  if {!$flag(check_tool_change)} {
    set ::mom_tool_change_type 0
    LIB_write_pretreatment "mom_tool_change_type"
  }
  set flag(check_tool_change) 0
  set pt_flag(mom_msys_done) 0

  global lib_cycle_combine prev_cycle_param flag lib_cycle_skip_rapid
  if {[array exists lib_cycle_combine]} {
    LIB_write_pretreatment "lib_cycle_combine"
    LIB_write_pretreatment "lib_cycle_skip_rapid"

    array unset lib_cycle_combine
    array unset lib_cycle_skip_rapid
    unset prev_cycle_param
    unset flag(cycle_skip_rapid)
  }

  if {[llength [info commands CONF_CTRL_moves]] && [CONF_CTRL_moves reset_rotary_axis_end_of_path] == "ON"} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

}
# <Internal Documentation>
#
# Here is the procedure MOM_end_of_path loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_end_of_path at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_start_of_merged_path {} {

  global mom_operation_name mom_merged_path_group_operation_name_list oper_tag_list_of_merged_group mom_operation_id

  if {![info exists oper_tag_list_of_merged_group]} {
    lappend oper_tag_list_of_merged_group $mom_operation_id
  } else {
    set index [lsearch -exact $oper_tag_list_of_merged_group $mom_operation_id]
    if {$index == -1} {
      lappend oper_tag_list_of_merged_group $mom_operation_id
    }
  }

  if {![info exists mom_merged_path_group_operation_name_list]} {
    lappend mom_merged_path_group_operation_name_list $mom_operation_name
    incr number_of_opers_in_merged_group
  } else {
    set index [lsearch -exact $mom_merged_path_group_operation_name_list $mom_operation_name]
    if {$index == -1} {
      lappend mom_merged_path_group_operation_name_list $mom_operation_name
      incr number_of_opers_in_merged_group
    }
  }
  global flag type cycle_tap

  if {[llength [info commands LIB_PT_start_of_merged_path]]} {LIB_PT_start_of_merged_path}

  if {![CONF_SPF_pt lib_spf_new_pretreatment]} {
    PT_save_pre_start_of_path_vars
  } else {
    PT_save_pre_start_of_path_vars_advance
  }

  set cycle_tap ""
  set flag(lib_pt_tool_axis_change) 0
  set flag(lib_pt_tool_path_motion) 0

  global subtype
  global mom_template_type
  global mom_kin_is_turbo_output

  # Need set turbo at start_of_merged_path for each merged path operation


  # ask the operation type from the current operation
  LIB_ask_operation_type

  MOM_force once G_motion fourth_axis fifth_axis X Y Z

  # set as an default the turbo mode to an deactive state
  if {![info exists flag(kin_is_turbo_output)] } {
    set flag(kin_is_turbo_output) ""
  }

  set mom_kin_is_turbo_output "FALSE"

  # analyze object types and subtypes based on ..\UGOPEN\uf_object_types.h
  # and set the turbo mode option it is possible by toggle
  if {![info exists flag(lib_spf_no_turbo_mode)] || !$flag(lib_spf_no_turbo_mode)} {
    if {$type == 100} {
      switch -- $subtype {
        1    {set mom_kin_is_turbo_output "FALSE" ; # mach_instanced_oper_subtype       }
        2    {set mom_kin_is_turbo_output "FALSE" ; # mach_orphan_oper_subtype          }
        10   {set mom_kin_is_turbo_output "FALSE" ; # mach_oldopr_subtype               }
        11   {set mom_kin_is_turbo_output "FALSE" ; # mach_mill_post_cmnds_subtype      }
        13   {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_post_cmnds_subtype     }
        17   {set mom_kin_is_turbo_output "FALSE" ; # mach_wed_post_cmnds_subtype       }
        110  {set mom_kin_is_turbo_output "TRUE"  ; # mach_pocket_subtype               }
        210  {set mom_kin_is_turbo_output "TRUE"  ; # mach_surface_contour_subtype      }
        211  {set mom_kin_is_turbo_output "TRUE"  ; # mach_vasc_subtype                 }
        220  {set mom_kin_is_turbo_output "TRUE"  ; # mach_gssm_main_op_subtype         }
        221  {set mom_kin_is_turbo_output "TRUE"  ; # mach_gssm_sub_op_subtype          }
        222  {set mom_kin_is_turbo_output "TRUE"  ; # mach_gssm_grip_subtype            }
        230  {set mom_kin_is_turbo_output "TRUE"  ; # mach_param_line_subtype           }
        240  {set mom_kin_is_turbo_output "TRUE"  ; # mach_zig_zag_surf_subtype         }
        250  {set mom_kin_is_turbo_output "TRUE"  ; # mach_rough_to_depth_subtype       }
        260  {set mom_kin_is_turbo_output "TRUE"  ; # mach_cavity_milling_subtype       }
        261  {set mom_kin_is_turbo_output "TRUE"  ; # mach_face_milling_subtype         }
        262  {set mom_kin_is_turbo_output "TRUE"  ; # mach_volumn_milling_subtype       }
        263  {set mom_kin_is_turbo_output "TRUE"  ; # mach_zlevel_milling_subtype       }
        264  {set mom_kin_is_turbo_output "FALSE" ; # mach_fb_hole_milling_subtype      }
        265  {set mom_kin_is_turbo_output "FALSE" ; # mach_plunge_milling_subtype       }
        266  {set mom_kin_is_turbo_output "TRUE"  ; # mach_vazl_milling_subtype         }
        310  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_rough_subtype          }
        320  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_finish_subtype         }
        330  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_groove_subtype         }
        340  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_thread_subtype         }
        350  {set mom_kin_is_turbo_output "FALSE" ; # mach_drill_subtype                }
        360  {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_face_subtype           }
        450  {set mom_kin_is_turbo_output "FALSE" ; # mach_point_to_point_subtype       }
        460  {set mom_kin_is_turbo_output "TRUE"  ; # mach_seq_curve_mill_subtype       }
        461  {set mom_kin_is_turbo_output "TRUE"  ; # mach_seq_curve_lathe_subtype      }
        510  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_rough_subtype           }
        520  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_finish_subtype          }
        530  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_teachmode_subtype       }
        540  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_thread_subtype          }
        550  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_cdrill_subtype          }
        560  {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_auxiliary_subtype       }
        600  {set mom_kin_is_turbo_output "FALSE" ; # mach_hole_making_subtype          }
        700  {set mom_kin_is_turbo_output "FALSE" ; # mach_wedm_subtype                 }
        800  {
          # mach_mill_ud_subtype
          if {[LIB_GE_is_volumill_op reset] || [LIB_GE_is_imachining_op]} {
            set mom_kin_is_turbo_output "TRUE"
          } else {
            set mom_kin_is_turbo_output "FALSE"
          }
        }
        900  {set mom_kin_is_turbo_output "FALSE" ; # mach_gmc_subtype                  }
        1000 {set mom_kin_is_turbo_output "FALSE" ; # mach_probing_subtype              }
        1010 {set mom_kin_is_turbo_output "FALSE" ; # mach_mill_probing_subtype         }
        1020 {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_probing_subtype         }
        1030 {set mom_kin_is_turbo_output "FALSE" ; # mach_mill_tool_probing_subtype    }
        1040 {set mom_kin_is_turbo_output "FALSE" ; # mach_turn_tool_probing_subtype    }
        1100 {
          # mach_mill_mc_subtype
          if {$mom_template_type == "Imported"} {
            set mom_kin_is_turbo_output "TRUE"
          } else {
            set mom_kin_is_turbo_output "FALSE"
          }
        }
        1200 {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_mc_subtype             }
        1300 {set mom_kin_is_turbo_output "FALSE" ; # mach_wedm_mc_subtype              }
        1400 {set mom_kin_is_turbo_output "FALSE" ; # mach_lathe_ud_subtype             }
        1500 {set mom_kin_is_turbo_output "FALSE" ; # mach_wedm_ud_subtype              }
        1600 {set mom_kin_is_turbo_output "FALSE" ; # mach_mass_edit_subtype            }
        1700 {set mom_kin_is_turbo_output "FALSE" ; # mach_thread_milling_subtype       }
        1800 {set mom_kin_is_turbo_output "FALSE" ; # insp_tolerance_subtype            }
        1900 {set mom_kin_is_turbo_output "FALSE" ; # insp_path_subtype                 }
        2000 {set mom_kin_is_turbo_output "FALSE" ; # insp_output_subtype               }
        2100 {set mom_kin_is_turbo_output "FALSE" ; # insp_misc_subtype                 }
        2200 {set mom_kin_is_turbo_output "FALSE" ; # insp_align_subtype                }
        2300 {set mom_kin_is_turbo_output "FALSE" ; # insp_sensor_subtype               }
        2400 {set mom_kin_is_turbo_output "FALSE" ; # insp_construct_subtype            }
        2500 {set mom_kin_is_turbo_output "FALSE" ; # insp_bounding_feature_subtype     }
        2600 {set mom_kin_is_turbo_output "FALSE" ; # insp_feature_subtype              }
        2700 {set mom_kin_is_turbo_output "FALSE" ; # mach_cylinder_milling_subtype     }
        2800 {set mom_kin_is_turbo_output "FALSE" ; # mach_canned_cycle_subtype         }
        2900 {set mom_kin_is_turbo_output "FALSE" ; # mach_laser_teachmode_subtype      }
        3000 {set mom_kin_is_turbo_output "FALSE" ; # mach_hole_drilling_subtype        }
        3100 {set mom_kin_is_turbo_output "FALSE" ; # mach_groove_milling_subtype       }
        3200 {set mom_kin_is_turbo_output "FALSE" ; # mach_chamfer_milling_subtype      }
        3300 {set mom_kin_is_turbo_output "FALSE" ; # mach_radial_groove_milling_subtype}
        3400 {set mom_kin_is_turbo_output "FALSE" ; # mach_planar_additive_subtype      }
        3500 {set mom_kin_is_turbo_output "FALSE" ; # mach_generic_feature_subtype      }
        3600 {set mom_kin_is_turbo_output "FALSE" ; # mach_device_gmc_subtype           }
        default {set mom_kin_is_turbo_output "FALSE"}
      }
    }
  }
  if {[info exists mom_kin_is_turbo_output] && $flag(kin_is_turbo_output) != $mom_kin_is_turbo_output} {
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
    set flag(kin_is_turbo_output) $mom_kin_is_turbo_output
  }
}
# <Internal Documentation>
#
# When the procedure MOM_start_of_merged_path is loaded
# during pretreatment, PT_start_of_merged_path is executed.
#
# <Internal Example>
#
#____________________________________________________________________________________________

if {[info proc MOM_start_of_merged_path] == "MOM_start_of_merged_path"} {
  set PT_start_of_merged_path "PT_start_of_merged_path"
} else {
  set PT_start_of_merged_path MOM_start_of_merged_path
}

proc PT_end_of_merged_path {} {
  global mom_operation_name
  global flag pt_flag

  if {[llength [info commands LIB_PT_end_of_merged_path]]} {LIB_PT_end_of_merged_path}
  # Use pt_flag($mom_operation_name) as marker for whether the following pretreatment lists have already been recorded for the current operation,
  # since in merge path each operation may have many layers, only need write to pretreatment once
  if {![info exists pt_flag($mom_operation_name)]} {set pt_flag($mom_operation_name) 0}
  if {$pt_flag($mom_operation_name) == 0} {
    if {!$flag(check_tool_change)} {
      set ::mom_tool_change_type 0
    }
    LIB_write_pretreatment "mom_tool_change_type"
    set flag(check_tool_change) 0

    LIB_write_pretreatment "mom_toolpath_cutting_time"
    LIB_write_pretreatment "mom_tool_name"
    LIB_write_pretreatment "mom_tool_number"
    LIB_write_pretreatment "mom_tool_description"
    LIB_write_pretreatment "mom_operation_type"
    LIB_write_pretreatment "mom_kin_is_turbo_output"
    LIB_write_pretreatment "mom_operation_name"

    set pt_flag($mom_operation_name) 1
  }

}
# <Internal Documentation>
#
# When the procedure MOM_end_of_merged_path is loaded
# during pretreatment, PT_end_of_merged_path is executed.
#
# <Internal Example>
#
#____________________________________________________________________________________________

if {[info proc MOM_end_of_merged_path] == "MOM_end_of_merged_path"} {
  set PT_end_of_merged_path "PT_end_of_merged_path"
} else {
  set PT_end_of_merged_path MOM_end_of_merged_path
}

proc PT_end_of_group {} {

  if {[llength [info commands LIB_PT_end_of_group]]} {LIB_PT_end_of_group}

}
# <Internal Documentation>
#
# Here is the procedure MOM_end_of_group loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_end_of_group at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_end_of_program {} {

  global flag lib_ge_slash lib_ge_env
  global mom_sys_leader lib_pt
  global mom_output_file_full_name
  global mom_output_file_basename
  global lib_ge_debug

  # Workaround, if inside NX8.5 TCL 8.4 as a preview active
  set workaround 0
  if {[string match "85" "$lib_ge_env(major_version)$lib_ge_env(minor_version)"] && $::tcl_version >= 8.4} {
    LIB_subst_pretreatment $mom_output_file_full_name 1 ; set workaround 1
  }

  set mom_sys_leader(N) "set error \["
  MOM_force once N ; MOM_enable_address N

  if {[llength [info commands LIB_PT_end_of_program]]} {LIB_PT_end_of_program}

  if {[info exists lib_pt(pretreatment,controls)] && !$lib_pt(pretreatment,controls)} {
    if {[info exist ::mom_operation_name_list]} {
      set ::operation_list_delta [LIB_SPF_list_non_common_elements $::operation_list $::mom_operation_name_list]
    } else {
      set ::operation_list_delta ""
    }
    # Make an output for the transferfile from the variable
    LIB_write_pretreatment "tag_list" 3
    LIB_write_pretreatment "tool_name_list tool_number_list operation_list tag_list operation_list_delta" 2
    LIB_write_pretreatment "thread_tool_pitch" 2
  }

  # reactivate output of debug_buffer (Output for QA team)
  MOM_suppress once N
  MOM_output_literal "#PRETREATMENT_OUTPUT_END    \[" JEPT
  # Now close the current output file
  MOM_close_output_file $mom_output_file_full_name

  if {$workaround} {
    LIB_subst_pretreatment $mom_output_file_full_name 0
  }
  # Now, the output file is read again.
  # However, it is now structured so that the information is provided as a tcl command.
  # This is necessary because we have no access to the output of the turbo mode.
  # This analysis is only possible if we read the file now.
  LIB_GE_source [file rootname [file tail $mom_output_file_full_name]] [LIB_GE_format_path_names [file dirname $mom_output_file_full_name] 1] [file extension $mom_output_file_full_name] 0 1
  # Is the debug is active, the file is written to the temporary directory
  set debug_input [LIB_GE_format_path_names [file join $lib_ge_env(tmp_dir) $mom_output_file_basename]_input.debug]
  if {$lib_ge_debug(on) != 0} {
    set error [file copy -force $mom_output_file_full_name $debug_input]
  } else {
    if {[LIB_Shell_file_exists $debug_input 1]} {
      catch {MOM_remove_file $debug_input]}
    }
  }
  if {[LIB_Shell_file_exists $mom_output_file_full_name 1]} {catch {MOM_remove_file $mom_output_file_full_name}}

  LIB_output_pretreatment

  # Is the debug is active, the file is written to the temporary directory
  set debug_output [LIB_GE_format_path_names [file join $lib_ge_env(tmp_dir) $mom_output_file_basename]_output.debug]
  if {$lib_ge_debug(on) != 0} {
    set error [file copy -force $mom_output_file_full_name $debug_output]
  } else {
    if {[LIB_Shell_file_exists $debug_output 1]} {
      catch {MOM_remove_file $debug_output]}
    }
  }

  # MOM_log_message "Pretreatment run completed\n"

}
# <Internal Documentation>
#
# Here is the procedure MOM_end_of_program loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_end_of_program at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_start_of_group {} {

  if {[llength [info commands LIB_PT_start_of_group]]} {LIB_PT_start_of_group}

}
# <Internal Documentation>
#
# Here is the procedure MOM_start_of_group loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_start_of_group at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_pattern_set_csys_start {} {

  if {[llength [info commands LIB_PT_pattern_set_csys_start]]} {LIB_PT_pattern_set_csys_start}
  if {$::mom_process_pattern_index !=0} {
    MOM_skip_handler_to_event pattern_set_csys_end
  }
}
# <Internal Documentation>
#
# Here is the procedure MOM_pattern_set_csys_start loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_pattern_set_csys_start at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_pattern_set_csys_end {} {

  if {[llength [info commands LIB_PT_pattern_set_csys_end]]} {LIB_PT_pattern_set_csys_end}
}
# <Internal Documentation>
#
# Here is the procedure MOM_pattern_set_csys_end loaded
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_pattern_set_csys_end at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_line_leader {args} {

}
# <Internal Documentation>
#
# Just disable this command. If a line leader is defined, this will cause wrong
# output of pretreatment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_seq_off {args} {

}
# <Internal Documentation>
#
# Just disable this command. If a seq is turned off, this will cause wrong
# output of pretreatment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_load_definition_file {args} {

}
# <Internal Documentation>
#
# Just disable this command. If a def file overloads block_templates, this may cause wrong
# output of pretreatment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_address_format {args} {

}
# <Internal Documentation>
#
# Just disable this command. If MOM_set_address_format is calle dwith an address not defined in pretreatment, this will cause
# an error in pretreatment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_reset_sequence {args} {

}
# <Internal Documentation>
#
# Just disable this command. If MOM_reset_sequence changes the frequency of seq output, this will cause
# an error in pretreatment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_force_block {args} {

}
# <Internal Documentation>
#
# Just disable this command. MOM_force_block may cause
# an error in pretreatment if it is called for a block not defined in pretreatment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_start_of_subop_path {} {

  if {[llength [info commands LIB_PT_start_of_subop_path]]} {LIB_PT_start_of_subop_path}

}
# <Internal Documentation>
#
# Here is the procedure MOM_start_of_subop_path loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_start_of_subop_path at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_start_of_transition_path {} {

  global flag type subtype lib_pt
  global mom_operation_type
  global mom_kin_is_turbo_output
  global mom_kin_iks_usage cycle_tap tag

  if {[llength [info commands LIB_PT_start_of_transition_path]]} {LIB_PT_start_of_transition_path}

  PT_save_pre_start_of_path_vars

  set cycle_tap ""
  set flag(lib_pt_tool_axis_change) 0
  set flag(lib_pt_tool_path_motion) 0

  # ask the operation type from the current operation
  LIB_ask_operation_type

  MOM_force once G_motion fourth_axis fifth_axis X Y Z
  set mom_kin_is_turbo_output "FALSE"

  # set as an default the turbo mode to an deactive state
  if {![info exists flag(kin_is_turbo_output)] } {
    set flag(kin_is_turbo_output) ""
  }

  if {[info exists mom_kin_is_turbo_output] && $flag(kin_is_turbo_output) != $mom_kin_is_turbo_output} {
    MOM_reload_kinematics_variable mom_kin_is_turbo_output
    set flag(kin_is_turbo_output) $mom_kin_is_turbo_output
  }
}
# <Internal Documentation>
#
# Here is the procedure MOM_start_of_transition_path loaded
# Transition path is a generic motion operaton
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_start_of_transition_path at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_end_of_transition_path {} {

  global mom_kin_is_turbo_output lib_pt
  global tool_name_list mom_tool_name
  global tool_number_list mom_tool_number
  global operation_list mom_operation_name
  global tag_list tag mom_csys_matrix csys_is_default csys_is_offset
  global set_pt_kin pt_flag flag
  global out_angle_pos_last

  if {$pt_flag(mom_msys_done) == 0} {MOM_msys}

  if {[info exists mom_csys_matrix] && [LIB_SPF_is_matrix_equal [LIB_SPF_matrix_to_list "mom_csys_matrix" "11"] "1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0" "0.0001" "11"] == 1} {
    set csys_is_default 1
  } else {
    set csys_is_default 0
  }

  if {[info exists mom_csys_matrix] && [LIB_SPF_is_matrix_equal [LIB_SPF_matrix_to_list "mom_csys_matrix" "8"] "1.0 0.0 0.0 0.0 1.0 0.0 0.0 0.0 1.0" "0.0001" "8"] == 1} {
    set csys_is_offset 1
  } else {
    set csys_is_offset 0
  }

  if {[llength [info commands LIB_PT_end_of_transition_path]]} {LIB_PT_end_of_transition_path}

  if {[info exists lib_pt(pretreatment,controls)] && !$lib_pt(pretreatment,controls)} {
    # added different informations to lists
    lappend tool_name_list $mom_tool_name
    lappend tool_number_list $mom_tool_number
    if {$::mom_operation_name != $::mom_path_name} {
      lappend operation_list $::mom_path_name
    } else {
      lappend operation_list $::mom_operation_name
    }
    lappend tag_list $tag
  }

  set tmp_turbo $mom_kin_is_turbo_output
  set mom_kin_is_turbo_output "FALSE"

  #########################################
  if {[info exists lib_pt(pretreatment,controls)] && !$lib_pt(pretreatment,controls)} {
    LIB_GE_copy_var_range pt_kin mom_kin

    uplevel #0 {
      set kin_list [info vars pt_kin*]

      set set_pt_kin ""

      foreach v $kin_list {

        if {[array get $v] == ""} {
          append set_pt_kin "set ::$v \"[subst $$v]\";"
        } else {
          append set_pt_kin "array set ::$v \"[array get $v]\";"
        }
      }
    }
  }
  ##########################################

  set mom_kin_is_turbo_output $tmp_turbo

  set out_angle_pos_last(0) [MOM_ask_address_value fourth_axis]
  set out_angle_pos_last(1) [MOM_ask_address_value fifth_axis]

  # make an output for the transferfile from the variable
  LIB_write_pretreatment "mom_toolpath_cutting_time mom_operation_type mom_kin_is_turbo_output csys_is_default csys_is_offset set_pt_kin mom_tool_axis mom_flip_a_axis mom_tool_holder_angle_for_cutting cutting_tool_axes mom_machine_mode out_angle_pos_last"
  LIB_write_pretreatment "mom_tool_name mom_tool_number mom_tool_description mom_oper_tool mom_optimized_group_operation_name_list cycle_tap"
  LIB_write_pretreatment "mom_blank_cylinder_diameter mom_blank_cylinder_height mom_blank_cylinder_center mom_blank_block_length mom_blank_block_width mom_blank_block_height mom_blank_block_center mom_blank_block_feature_matrix"

  if {[info exist ::cutting_tool_axes]} {
    set ::pt_cutting_tool_axes($tag) $::cutting_tool_axes
  }

  if {!$flag(check_tool_change)} {
    set ::mom_tool_change_type 0
    LIB_write_pretreatment "mom_tool_change_type"
  }
  set flag(check_tool_change) 0
  set pt_flag(mom_msys_done) 0

}
# <Internal Documentation>
#
# Here is the procedure MOM_end_of_transition_path loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_end_of_transition_path at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_zero {} {

  if {[llength [info commands LIB_PT_zero]]} {LIB_PT_zero}

}
# <Internal Documentation>
#
# Here is the procedure MOM_zero loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_zero at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc PT_sync {} {

  if {[llength [info commands LIB_PT_sync]]} {LIB_PT_sync}

}
# <Internal Documentation>
#
# Here is the procedure MOM_sync loaded
# Is there a movement then a template is called
#
# Is an entry point required so it is possible with a procedure
# LIB_PT_sync at the shell level
#
# <Internal Example>
#
#____________________________________________________________________________________________

# lib_sourcing.tcl

proc LIB_Shell_search_file_recursively {pathname filename {value ""}} {

  global lib_ge_env lib_ge_slash

  upvar $value returnvalue

  set filename [LIB_Shell_format_path_names $pathname$lib_ge_slash$filename]
  if {[LIB_Shell_file_exists $filename 1]} {
    if {![string length $value]} {
      return $filename
    } else {
      set returnvalue $filename
      return 1
    }
  }

  set searchpath "$lib_ge_env(installed_machines_dir,recursively)"
  lappend searchpath $lib_ge_env(post_pool_dir)

  foreach pathnames $searchpath {
    set filenames [LIB_Shell_format_path_names $pathnames$lib_ge_slash[file tail $filename]]
    if {[LIB_Shell_file_exists $filenames 1]} {
      if {![string length $value]} {
        return $filenames
      } else {
        set returnvalue $filenames
        return 1
      }
    }
  }
  return 0
}
# <Internal Documentation>
#
# Handling for the default environment variables
#
# <Internal Example>
#
#____________________________________________________________________________________________
if {[info commands LIB_Shell_environment_handling] != ""} {
  proc LIB_Shell_environment_handling {} {

    global lib_ge_env lib_ge_slash lib_ge_installed_machines

    # Language file and OS specific values
    if {![info exists lib_ge_slash]} {
      global lib_ge_slash
      if {[string match "*windows*" $::tcl_platform(platform)]} {set lib_ge_slash "\\"} else {set lib_ge_slash "/"}
    }

    if {![info exists lib_ge_env]} {global lib_ge_env}

    set lib_ge_env(post_pool_dir)     [MOM_ask_env_var "UGII_POST_POOL_DIR_NG"]
    set lib_ge_env(cam_resource_dir)  [MOM_ask_env_var "UGII_CAM_RESOURCE_DIR"]
    set lib_ge_env(cam_post_dir)    [MOM_ask_env_var "UGII_CAM_POST_DIR"]
    set lib_ge_env(tmp_dir)                 [MOM_ask_env_var "UGII_TMP_DIR"]
    if {$lib_ge_env(tmp_dir) == ""} {set lib_ge_env(tmp_dir) $::lib_ge_temppath}

    set lib_ge_installed_machines   [info script]

    regsub -all "/" $lib_ge_env(post_pool_dir) "\\" lib_ge_env(post_pool_dir)
    regsub -all "/" $lib_ge_env(cam_post_dir) "\\" lib_ge_env(cam_post_dir)
    regsub -all "/" [LIB_Shell_format_path_names [file dirname $lib_ge_installed_machines]]$lib_ge_slash "\\" lib_ge_env(installed_machines_dir)

    if {![regexp -nocase -- {\w+} $lib_ge_env(post_pool_dir)]} {set lib_ge_env(post_pool_dir) $lib_ge_env(installed_machines_dir)}

    LIB_Shell_path_init $lib_ge_env(installed_machines_dir)
    LIB_Shell_path_init $lib_ge_env(cam_post_dir)
    if {$lib_ge_env(installed_machines_dir) != $lib_ge_env(post_pool_dir)} {
      LIB_Shell_path_init $lib_ge_env(post_pool_dir)
    }

    set lib_ge_env(version_bit)       [MOM_ask_env_var "UGII_VERSION_BIT"]
    set lib_ge_env(base_dir)          [MOM_ask_env_var "UGII_BASE_DIR"]

    set lib_ge_env(compatible_base_release_version) [MOM_ask_env_var "NX_COMPATIBLE_BASE_RELEASE_VERSION"]
    set lib_ge_env(major_version)       [MOM_ask_env_var "UGII_MAJOR_VERSION"]
    set lib_ge_env(minor_version)         [MOM_ask_env_var "UGII_MINOR_VERSION"]
    set lib_ge_env(subminor_version)        [MOM_ask_env_var "UGII_SUBMINOR_VERSION"]

    if {![info exists lib_ge_dll_version]} {global lib_ge_dll_version}
    if {$lib_ge_env(minor_version) > 0} {
      set lib_ge_dll_version "nx$lib_ge_env(major_version)$lib_ge_env(minor_version)"
    } else {
      set lib_ge_dll_version "nx$lib_ge_env(major_version)"
    }
    if {[llength $lib_ge_env(compatible_base_release_version)] > 0} {set lib_ge_dll_version "nx$lib_ge_env(compatible_base_release_version)"}

    regsub -all "/" $lib_ge_env(base_dir) "\\" lib_ge_env(base_dir)
  }
}

if {[info commands LIB_Shell_main] != ""} {
  proc LIB_Shell_main {} {

    global lib_ge_env lib_ge_slash
    global lib_cycle_path sourcefile

    LIB_Shell_environment_handling

    if {[info commands LIB_GE_source] == ""} {
      set lib_cycle_path 0
      set searchpath "$lib_ge_env(installed_machines_dir,recursively)"
      lappend searchpath $lib_ge_env(post_pool_dir)
      foreach path $searchpath {
        if {$lib_cycle_path} {break}
        foreach name {library lib_sourcing} {
          foreach ext {.tcl .pce .pcf .tbc} {
            set sourcefile [LIB_Shell_format_path_names "${path}${lib_ge_slash}$name$ext"]
            if {[LIB_Shell_file_exists $sourcefile]} {
              if {![string match "library.tbc" "$name$ext"] && [string match ".tbc" $ext]} {
                LIB_Shell_abort "ByteCode Loader is not available, cannot process $name$ext"
              }
              uplevel #0 {

                set err ""
                if {$tcl_version >= 8.6 && [catch {source -encoding utf-8 $sourcefile} err]} {
                  if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $::errorInfo"}
                  LIB_Shell_abort "File [file tail $sourcefile] $err not loadable"
                }
                if {$tcl_version < 8.6 && [catch {source $sourcefile} err]} {
                  if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $::errorInfo"}
                  LIB_Shell_abort "File [file tail $sourcefile] $err not loadable"
                }
                if {[string length $err] > 0} {
                  set lib_ge_debug(lib_sourcing) "$sourcefile"
                  lappend lib_ge_monitored_files "$sourcefile"
                  lappend lib_ge_log_message "\n--> $sourcefile loaded"
                  set lib_cycle_path 1 ; break
                }

              }
            }
          }
        }
      }
      if {!$lib_cycle_path} {
        LIB_Shell_abort "File lib_sourcing not found"
      }
    }
    LIB_Shell_init
  }
}

#___________________________________________________________________________________________
# <Internal Documentation>
#
# Search directories recursively
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_abort {message} {

  MOM_output_to_listing_device $message
  MOM_log_message $message

  MOM_abort $message

}
# <Internal Documentation>
#
# Abort postrun
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_special_queries {} {

  global lib_ge_env lib_shell lib_ge_env_init lib_ge_dll_version lib_ge_slash

  # Workaround if the function not work correctly
  MOM_set_env_var POST_LIB_TEST "POST_LIB_TEST"
  if {[string length [MOM_ask_env_var "POST_LIB_TEST"]] == 0} {
    set ::lib_ge_execute_extension "_nx85_64bit_84"
    LIB_Shell_load_user_function "lib_execute" "JEDLL_NG_Execute"
    if {[info commands JEDLL_SET_VARIABLE] != ""} {
      set error [JEDLL_SET_VARIABLE UGII_LIB_POST_CURRENT_MASCH_DIR $lib_ge_env(installed_machines_dir)]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      set error [JEDLL_SET_VARIABLE POST_LIB_CURRENT_MACH_DIR $lib_ge_env(installed_machines_dir)]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      set error [JEDLL_SET_VARIABLE POST_LIB_CURRENT_CTRL_DIR $lib_shell(controller)]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      set error [JEDLL_SET_VARIABLE POST_LIB_CURRENT_BIN_DIR $lib_shell(bin)]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      set error [JEDLL_SET_VARIABLE POST_LIB_CURRENT_LIB_DIR $lib_shell(libraries)]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      set error [JEDLL_SET_VARIABLE POST_LIB_CURRENT_BMP_DIR $lib_shell(bitmaps)]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      if {"$lib_ge_env(major_version)$lib_ge_env(minor_version)$lib_ge_env(subminor_version)" > "901"} {
        set error [JEDLL_SET_VARIABLE POST_SYS_CYCL_VERS ""]
        if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
      } else {
        # SYS_CYCLE Drill_Tap_Breakchip, SYS_CYCLE Drill_Tap_Deep, SYS_CYCLE Drill_Tap_Float not available
        set error [JEDLL_SET_VARIABLE POST_SYS_CYCL_VERS "_NX85"]
        if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
        if {[LIB_Shell_file_pathname "ctrl_s840d_base" ".cdl" 1] != "" && [LIB_Shell_file_pathname "ctrl_s840d_base_cycle_NX85" ".cdl" 1] == "" || \
            [LIB_Shell_file_pathname "ctrl_s828d_base" ".cdl" 1] != "" && [LIB_Shell_file_pathname "ctrl_s828d_base_cycle_NX85" ".cdl" 1] == ""} {
          if {[regexp -nocase -- "Libraries" [LIB_Shell_file_pathname "ctrl_s840d_base" ".cdl" 1]] || \
                  [regexp -nocase -- "Libraries" [LIB_Shell_file_pathname "ctrl_s828d_base" ".cdl" 1]]} {
              LIB_Shell_abort "\n The postprocessor can not be executed because the function:\n\n\
                SYS_CYCLE Drill_Tap_Breakchip,\n\
                SYS_CYCLE Drill_Tap_Deep and\n\
                SYS_CYCLE Drill_Tap_Float\n\n\
                are not yet supported in the ctrl_s8**d_base.cdl before NX9.0.2.\n\n\
                \n Please comment this manuel, or make ctrl_s8**d_base_cycle_NX85.cdl available."
          }
        }
      }
    }
    # Check if the variable is now set
    if {[string length [MOM_ask_env_var "POST_LIB_CURRENT_MACH_DIR"]] == 0} {
      MOM_output_to_listing_device "Unfortunately, the current version of NX can not be supported."
    }
  }
}

proc LIB_Shell_load_ugpost_base {} {

  global lib_flag lib_ge_env lib_ge_slash
  global lib_cycle_path sourcefile lib_ge_debug

  if {!$lib_flag(load_ugpost_base)} {return}

  if {[info commands LIB_GE_source] == ""} {
    set lib_cycle_path 0
    set searchpath "$lib_ge_env(installed_machines_dir,recursively)"
    lappend searchpath $lib_ge_env(cam_post_dir)
    lappend searchpath $lib_ge_env(post_pool_dir)
    foreach path $searchpath {
      if {$lib_cycle_path} {break}
      foreach ext {.tbc .tcl} {
        set sourcefile [LIB_Shell_format_path_names "${path}${lib_ge_slash}ugpost_base$ext"]
        if {[LIB_Shell_file_exists $sourcefile]} {
          uplevel #0 {

            set err ""
            if {$tcl_version >= 8.6 && [catch {source -encoding utf-8 $sourcefile} err]} {
              if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $errorInfo"}
              LIB_Shell_abort "File lib_general $err not loadable"
            }
            if {$tcl_version < 8.6 && [catch {source $sourcefile} err]} {
              if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $errorInfo"}
              LIB_Shell_abort "File lib_general $err not loadable"
            }
            if {[string length $err] > 0} {
              set lib_ge_debug(lib_general) "$sourcefile"
              lappend lib_ge_monitored_files "$sourcefile"
              lappend lib_ge_log_message "\n--> $sourcefile loaded"
              lappend lib_ge_debug(sourced) $sourcefile
              catch {unset mom_sys_leader}
              set lib_cycle_path 1 ; break
            }

          }
        }
      }
    }
    if {!$lib_cycle_path} {
      LIB_Shell_abort "File ugpost_base not found"
    }
  }
}
# <Internal Documentation>
#
# Load ugpost_base
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_init {} {

  global lib_ge_user_function lib_ge_execute_extension
  global lib_ge_dll_version lib_ge_nx_platform lib_ge_env
  global lib_pp_source_file lib_ge_slash lib_shell
  global lib_load_user_function
  global errorCode errorInfo

  if {$lib_shell(load_library) && [info commands LIB_Shell_init_custom] != ""} {LIB_Shell_init_custom}
  if {$lib_shell(load_library) && [info commands LIB_Shell_load] != ""} {LIB_Shell_load}

  LIB_Shell_path_init $lib_ge_env(installed_machines_dir)
  if {![LIB_Shell_directory_exists "$lib_ge_env(installed_machines_dir)\\Bin"]} {
    set lib_shell(quick_source) 0
  }
  # In special cases, the customer's environment UGII_CAM_POST_DIR can be initialized if here an subdirectory or an dummy defined
  if {$::lib_shell(quick_source,cam_post_dir) != ""} {
    LIB_Shell_path_init $lib_ge_env(cam_post_dir) $::lib_shell(quick_source,cam_post_dir)
  }
  if {![string match $lib_ge_env(post_pool_dir) $lib_ge_env(installed_machines_dir)]} {
    LIB_Shell_path_init $lib_ge_env(post_pool_dir) $::lib_shell(quick_source,post_pool_dir)
    LIB_Shell_path_init $lib_ge_env(cam_post_dir) $::lib_shell(quick_source,cam_post_dir)
  }

  LIB_Shell_load_package tdom
  if {[llength [info commands LIB_Shell_init_packag_custom]]} {LIB_Shell_init_packag_custom}
  LIB_Shell_load_bytecode

  if {![info exists lib_ge_env(installed_machines_dir,recursively)]} {
    set lib_ge_env(installed_machines_dir,recursively) $lib_ge_env(installed_machines_dir)
  }

  set lib_ge_user_function ""
  set lib_ge_execute_extension "_32bit"
  if {$lib_ge_nx_platform == 64} {set lib_ge_execute_extension "_64bit"}

  # Available as basic functions from NX9, but optionally possible via lib_load_user_function
  if {$lib_ge_env(major_version) < 9 || [info exists lib_load_user_function] && $lib_load_user_function} {
    # Workaround, if inside NX8.5 TCL 8.4 as a preview active
    if {[string match "85" "$lib_ge_env(major_version)$lib_ge_env(minor_version)"] && $::tcl_version >= 8.4} {
      append lib_ge_execute_extension "_84"
    }
    LIB_Shell_load_user_function "lib_execute_$lib_ge_dll_version" "JEDLL_NG_Execute"
  }

  LIB_Shell_load_loader

  LIB_Shell_exchange_env

  LIB_Shell_load_ugpost_base

  LIB_Shell_load_general

  LIB_Shell_load_xml_handling

  LIB_Shell_defined_post_environment

  if {![info exists lib_shell(version)] || $lib_shell(version) < 2} {
    if {$lib_shell(load_library)} {
      set lib_pp_source_file [LIB_GE_cleanup_list [list "lib_general" "lib_msg" "lib_file_handling" "lib_standard_post_func" "lib_document"] $lib_pp_source_file 1]
    }
  }

  if {[info commands LIB_GE_cleanup_list] != ""} {
    set lib_pp_source_file [LIB_GE_cleanup_list $lib_pp_source_file]
  } else {
    if {[info exists errorCode] && [string length $errorCode] > 0} {
      MOM_log_message "$errorCode"
    }
    if {[info exists errorInfo] && [string length $errorInfo] > 0} {
      MOM_log_message "$errorInfo"
    }
    LIB_Shell_abort "Cannot run current post-processor, one or more files could not be loaded"
  }

  LIB_GE_source

  LIB_GE_layer_editor

}
# <Internal Documentation>
#
# Handling for the default environment variables
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_source {} {

  global lib_ge_installed_machines lib_xml_node_idx
  global lib_pp_source_file lib_pp_source_folder
  global lib_shell lib_xml node

  set sourcefile [LIB_Shell_format_path_names "[file rootname $lib_ge_installed_machines].psc"]
  if {![LIB_Shell_file_exists $sourcefile]} {return}

  if {[info commands LIB_XML_to_list] != ""} {
    if {[info exists lib_shell(package,tdom)]} {
      LIB_XML_tdom_load $sourcefile

      if {[info exists lib_xml(tdom)]} {
        foreach sublist $lib_xml(tdom) {
          switch -nocase -- [lindex $sublist 0] {
            "Configuration" {
                    foreach {name value} [lindex $sublist 1] {
                      LIB_Shell_external_status_variable $name $value
                    }
                    if {[info exists lib_shell(version)] && $lib_shell(version) > 1} {
                      set lib_pp_source_file ""
                    }
                  }
            "Variable"    {
                    foreach {name target} [lindex $sublist 1] {
                      LIB_Shell_external_source_variable $name $target
                    }
                  }
            "SubFolder" -
            "Subfolder"   {
                    foreach {name} [lindex $sublist 1] {
                      LIB_Shell_external_source_subfolder $name
                    }
                  }
            "Filename" -
            "Scripts"   {
                    LIB_Shell_external_source_files [lindex $sublist 1]
                  }
            "DefinedEvents" {
                    LIB_Shell_external_def_files [lindex $sublist 1]
                  }
            "CustomerDialogs" {
                    LIB_Shell_external_cdl_files [lindex $sublist 1]
                  }
            "Functions"   {
                    # Implementation currently still without reaction
                  }
          }
        }
      }

    } else {

      set xmllist [LIB_XML_to_list $sourcefile]

      # Read out all environment which are to be created
      set node [LIB_XML_get_node $xmllist Environment]

      set lib_xml_node_idx 0
      while {$lib_xml_node_idx > -1} {
        set namelist [LIB_XML_get_nodes $node Variable]
        set name [lindex [lindex $namelist 1] [expr [lsearch -exact [lindex $namelist 1] "Name"]+1]]
        set target [lindex [lindex $namelist 1] [expr [lsearch -exact [lindex $namelist 1] "Target"]+1]]
        LIB_Shell_external_source_variable $name $target
      }

      # Read out all environment which are to be created
      set value [LIB_XML_get_value $xmllist "Version"]
      if {[llength $value]} {
        LIB_Shell_external_status_variable "Version" $value
          if {[info exists lib_shell(version)] && $lib_shell(version) > 1} {
            set lib_pp_source_file ""
          }
      }

      # Read out all folder which are to be analysed
      set node [LIB_XML_get_node $xmllist Sourcing]
      set node [LIB_XML_get_node $node Sequence]

      set lib_xml_node_idx 0
      while {$lib_xml_node_idx > -1} {
        set namelist [LIB_XML_get_nodes $node SubFolder]
        set name [lindex [lindex $namelist 1] [expr [lsearch -exact [lindex $namelist 1] "Folder"]+1]]
        LIB_Shell_external_source_subfolder $name
      }

      # Read out all filenames which are to be sourced
      set node [LIB_XML_get_node $xmllist Sourcing]
      set node [LIB_XML_get_node $node Sequence]

      set lib_xml_node_idx 0
      while {$lib_xml_node_idx > -1} {
        LIB_Shell_external_source_files
      }
    }

  } else {
    # The current post-processor can not run, because not all files were loaded
    # This is also the case, if utility.pce not available
    return
  }

}
# <Internal Documentation>
#
# Read the sourcingfiles from an XML file
#
# <Internal Example>
#
# <?xml version="1.0" encoding="utf-8"?>
# <Configuration>
#   <Copyright>Copyright © 2012-2018 Siemens Industry Software GmbH & Co. KG</Copyright>
#   <Version>1.0</Version>
#   <Controller>Siemens 840D</Controller>
#   <MachineName>MyMachine</MachineName>
#   <Environment>
#     <Variable Name="UGII_CAM_LIBRARY_INSTALLED_MACHINES_DEF_DIR" Target="D:\Temp\post_mit_kim"></Variable>
#   </Environment>
#   <Sourcing>
#     <Sequence>
#       <SubFolder Folder="Bin" />
#       <SubFolder Folder="Controller" />
#       <SubFolder Folder="Libraries" />
#       <Filename Name="ctrl_s840d_base" Processing="true" />
#       <Filename Name="post_mit_kim_mtb" Processing="true" />
#       <Filename Name="oem_my_oem" Processing="true" />
#       <Filename Name="mach_my_machine" Processing="true" />
#       <Filename Name="post_mit_kim_service" Processing="true" />
#       <Filename Name="post_mit_kim_test" Processing="true" />
# <Filename Name="shop_doc" Processing="true" Folder="UGII_CAM_SHOP_DOC_DIR" Extension=".TCL" />
#     </Sequence>
#   </Sourcing>
#   <Metadata>
#     <Comment>
#       <Changes>Uwe Roosz</Changes>
#       <Date>2014/05/15 12:00:00</Date>
#       <Content>Auto-generated by aPB</Content>
#     </Comment>
#     <Customer>
#       <Company></Company>
#       <Address></Address>
#       <Contact></Contact>
#       <Phone></Phone>
#       <Fax></Fax>
#       <Mail></Mail>
#     </Customer>
#   </Metadata>
# </Configuration>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_status_variable {name value} {

  global lib_shell

  if {[string length $name] > 0} {
    set lib_shell([string tolower $name]) $value
  }
}
# <Internal Documentation>
#
# Internal function to handle loading environment variables
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_source_variable {name target} {

  if {[string length $name] > 0} {
    if {[info commands MOM_set_env_var] != ""} {
      set error [MOM_set_env_var $name $target]
    } elseif {[info commands JEDLL_SET_VARIABLE] != ""} {
      set error [JEDLL_SET_VARIABLE $name $target]
      if {$error!=0} {MOM_log_message "ERROR JEDLL_SET_VARIABLE $::errorInfo $::error"}
    } else {
      MOM_log_message "Not possible to set environment variable"
    }
  }
}
# <Internal Documentation>
#
# Internal function to handle loading environment variables
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_source_subfolder {name} {

  if {[string length $name] > 0} {
    LIB_Shell_path_init $name
  }
}
# <Internal Documentation>
#
# Internal function to handle loading sub folder
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_source_files {{list ""} {action 0}} {

  global lib_pp_source_file lib_shell node lib_xml_node_idx

  array set external "Name {} Processing {} Folder {} Extension {}"
  if {!$action && [llength $list] < 1} {

    if {![info exists lib_shell(version)] || $lib_shell(version) < 2} {
      array set external [lindex [LIB_XML_get_nodes $node Filename] 1]
    } else {
      set nodes [LIB_XML_get_nodes $node [list Layer Filename]]
      switch -- [lindex $nodes 0] {
        "Layer"
        {

          if {[string match "Name" [lindex [lindex $nodes 1] 0]]} {
            foreach {variable value} [lindex $nodes 1] {
              switch -- $variable {
                "SubFolder"
                {
                  if {[string match "Bin" $value] || [string match "Controller" $value] || [string match "Libraries" $value]} {
                    continue
                  }
                  set value [LIB_GE_search_pathname $value]
                  if {![LIB_Shell_file_exists $value]} {
                    set value [file join $::lib_ge_env(installed_machines_dir) $value]
                    set value [LIB_GE_search_pathname $value]
                  }

                  LIB_Shell_external_source_subfolder $value
                }
              }
            }
          }

          foreach e {Scripts DefinedEvents CustomerDialogs Functions} {
            set nodes [LIB_XML_get_node $nodes $e]
            switch -- [lindex $nodes 0] {
              "Scripts"
              {
                foreach files [lindex $nodes 2] {
                  LIB_Shell_external_source_files [lindex $files 1] 1
                }
                return
              }
              "DefinedEvents"
              {
                foreach files [lindex $nodes 2] {
                  LIB_Shell_external_def_files [lindex $files 1]
                }
                return
              }
              "CustomerDialogs"
              {
                foreach files [lindex $nodes 2] {
                  LIB_Shell_external_cdl_files [lindex $files 1]
                }
                return
              }
              "Functions"
              {
                # Implementation currently still without reaction
              }
            }
          }
        }
        "Filename"
        {
          array set external [lindex $nodes 1]
        }
      }
    }
  } else {
    array set external $list
  }

  if {[string match -nocase "TRUE" $external(Processing)] || ![string length $external(Processing)]} {
    if {[string length $external(Folder)] && [string length $external(Name)]} {
      if {[string length $external(Extension)]} {
        lappend lib_pp_source_file "$external(Name)@[LIB_GE_format_path_names [LIB_GE_search_pathname $external(Folder)] 1 2]@$external(Extension)"
      } else {
        lappend lib_pp_source_file "$external(Name)@[LIB_GE_format_path_names [LIB_GE_search_pathname $external(Folder)] 1 2]"
      }
    } elseif {[string length $external(Name)]} {
      if {[string length $external(Extension)]} {
        lappend lib_pp_source_file "$external(Name)@@$external(Extension)"
      } else {
        lappend lib_pp_source_file "$external(Name)"
      }
    }
  }
}
# <Internal Documentation>
#
# Internal function to handle loading files
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_def_files {{list ""}} {

  global lib_pp_source_file node

  array set external "Name {} Processing {} Include {} Folder {} Extension {}"
  if {[llength $list] < 1} {
    array set external [lindex [LIB_XML_get_nodes $node Filename] 1]
  } else {
    array set external $list
  }

  if {[string length $external(Extension)] <= 0} {set external(Extension) ".def"}

  if {[string match -nocase "FALSE" $external(Include)] && ([string match -nocase "TRUE" $external(Processing)] || ![string length $external(Processing)])} {
    if {[string length $external(Folder)] && [string length $external(Name)]} {
      if {[string length $external(Extension)]} {
        lappend lib_pp_source_file "$external(Name)@[LIB_GE_format_path_names [LIB_GE_search_pathname $external(Folder)] 1 2]@$external(Extension)"
      }
    } elseif {[string length $external(Name)]} {
      if {[string length $external(Extension)]} {
        lappend lib_pp_source_file "$external(Name)@@$external(Extension)"
      }
    }
  }
}
# <Internal Documentation>
#
# Internal function to handle loading def files
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_external_cdl_files {{list ""}} {

  global lib_pp_source_file node

  array set external "Name {} Processing {} Include {} Folder {} Extension {}"
  if {[llength $list] < 1} {
    array set external [lindex [LIB_XML_get_nodes $node Filename] 1]
  } else {
    array set external $list
  }

  if {[string length $external(Extension)] <= 0} {set external(Extension) ".cdl"}

  if {[string match -nocase "FALSE" $external(Include)] && ([string match -nocase "TRUE" $external(Processing)] || ![string length $external(Processing)])} {
    if {[string length $external(Folder)] && [string length $external(Name)]} {
      if {[string length $external(Extension)]} {
        lappend lib_pp_source_file "$external(Name)@[LIB_GE_format_path_names [LIB_GE_search_pathname $external(Folder)] 1 2]@$external(Extension)"
      }
    } elseif {[string length $external(Name)]} {
      if {[string length $external(Extension)]} {
        lappend lib_pp_source_file "$external(Name)@@$external(Extension)"
      }
    }
  }
}
# <Internal Documentation>
#
# Internal function to handle loading def files
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_file_exists {check {realtime 0} {reset 0}} {

  global lib_shell

  # TCL has an bug in the commands "file exists"
  # this requires at version 8.4 many times during execution
  if {$::tcl_version != 8.4} {
    return [file exists $check]
  }

  # Replaces the following functionality ; # return [file exists $check]

  set lib_shell(path)     [LIB_Shell_format_path_names [file dirname $check]]
  set lib_shell(file)     [file rootname [file tail $check]]
  set lib_shell(extension)  [file extension $check]

  if {![string length $lib_shell(path)] || ![string length $lib_shell(file)] || ![string length $lib_shell(extension)]} {return 0}
  binary scan $lib_shell(path) H* pathbin

  # Query at loop, updated information is needed
  if {$realtime || [string match $pathbin [lindex [array get lib_shell check] 1]]} {
    return [file exists $check]
  }

  if {$reset && [llength [array get lib_shell $pathbin]]} {unset lib_shell($pathbin)}
  if {![llength [array get lib_shell $pathbin]]} {
    set lib_shell($pathbin) [string tolower [LIB_Shell_file_glob $lib_shell(path)]]
    if {$lib_shell($pathbin) == 0} {
      return 0
    }
  }

  set lib_shell(check) $pathbin

  if {[llength [array get lib_shell $pathbin]]} {
    if {[lsearch -exact [string tolower $lib_shell($pathbin)] [string tolower "$lib_shell(file)$lib_shell(extension)"]] > -1} {
      return 1
    }
  }
  return 0

}
# <Internal Documentation>
#
# Workaround to handle 'file exists' in a faster way
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_directory_exists {check {realtime 0}} {

  global lib_shell

  # Replaces the following functionality ; # return [file isdirectory "$check"]
  if {$realtime == 2} {
    return [file isdirectory $check]
  }

  set check [LIB_Shell_format_path_names $check]
  if {![regexp -nocase -- {^\\{2}|^\/|^[A-Z]:\\} $check]} {return 0}
  binary scan $check H* pathbin

  if {!$realtime && [info exists lib_shell($pathbin,unavailable)]} {
    return 0
  } elseif {$realtime || ![info exists lib_shell($pathbin)]} {
    set current_path [pwd]

    if {$realtime && [info exists lib_shell($pathbin)]} {unset lib_shell($pathbin)}
    if {[catch {cd $check}]} {
      if {[string length $pathbin] > 0} {
        lappend lib_shell($pathbin,unavailable) 1
      }
      return 0
    }
    cd $current_path
    lappend lib_shell($pathbin) 1
    return 1
  } elseif {[info exists lib_shell($pathbin)]} {
    return 1
  }
  return 0
}
# <Internal Documentation>
#
# Workaround to handle 'file isdirectory' in an faster way
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_file_glob {path {argument "file"}} {

  global tcl_version lib_ge_platform

  if {$lib_ge_platform} {
    # Glob leaves TCL crash is some reson, depending on the file name (special characters)
    if {$::lib_shell(quick_source,globstyle) || [regexp -nocase -- {^[\\]{2}|^[/]{2}} $path]} {
      # Reaction with unc directories
      if {$tcl_version <= 8.3} {set initialdir [pwd] ; cd $path}
      switch -- $argument {
        f - file    {
                if {$tcl_version > 8.3} {
                       return [glob -nocomplain -directory [file nativename $path] -tails -types f *{tcl,tbc,pce,pcf,dll,exe,psc,cdl,def}]
                } else {
                  set returnvalue [glob -nocomplain *{tcl,tbc,pce,pcf,dll,exe,psc,cdl,def}]
                }
              }
        p - path    {
                if {$tcl_version > 8.3} {
                       return [glob -nocomplain -directory [file nativename $path] -types d *]
                } else {
                  set value [glob -nocomplain *] ; set returnvalue ""
                  foreach e $value {if {[LIB_Shell_directory_exists [file join $path $e]]} {lappend returnvalue [LIB_Shell_format_path_names [file join $path $e]]}}
                }
              }
        r - pathrecursively {
                set dirs "" ; lappend dirs [file join $path] ; set initial $dirs ; set initialdir "" ; lappend initialdir [pwd]
                while {[llength $dirs]} {
                  set name [lindex $dirs 0]
                  if {$tcl_version > 8.3} {
                        set dirs [concat [glob -nocomplain -directory [lindex $dirs 0] -type d *] [lrange $dirs 1 end]]
                  } else {
                    cd [lindex $dirs 0] ; if {[catch {glob *}]} {lappend directories [lindex $dirs 0] ; set dirs [concat [lrange $dirs 1 end]] ; continue} else {set all [glob *]}
                    foreach e $all {if {[LIB_Shell_directory_exists [file join [lindex $dirs 0] $e]]} {lappend dirs [file join [lindex $dirs 0] $e]}}
                    set dirs [concat [lrange $dirs 1 end]]
                  }
                  lappend directories [LIB_Shell_format_path_names $name]
                }
                cd [lindex $initialdir 0]
                return $directories
              }
        c - content     {
                if {$tcl_version > 8.3} {
                       return [glob -nocomplain -directory $path -tails -types f *]
                } else {
                  set returnvalue [glob -nocomplain *]
                }
              }
      }
      if {$tcl_version <= 8.3} {cd $initialdir ; return $returnvalue}
    } else {
      # Reaction with directories
      switch -- $argument {
        f - file    {return [LIB_Shell_files_from_dir $path "/a-d" "*.tcl *.tbc *.pce *.pcf *.dll *.exe *.psc *.cdl *.def"]}
        p - path    {return [LIB_Shell_files_from_dir $path "/ad"]}
        r - pathrecursively {return [LIB_Shell_files_from_dir $path "/ad" "/s"]}
        c - content     {return [LIB_Shell_files_from_dir $path "" "*"]}
      }
    }
  } else {
      if {$tcl_version <= 8.3} {set initialdir [pwd] ; cd $path}
      switch -- $argument {

        f - file  {
                if {$tcl_version > 8.3} {
                       return [glob -nocomplain -directory $path -tails -types f *{tcl,tbc,pce,pcf,dll,exe,psc,cdl,def}]
                } else {
                  set returnvalue [glob -nocomplain *{tcl,tbc,pce,pcf,dll,exe,psc,cdl,def}]
                }
              }

        p - path    {
                if {$tcl_version > 8.3} {
                       return [glob -nocomplain -directory $path -tails -types d *]
                } else {
                  set value [glob -nocomplain *] ; set returnvalue ""
                  foreach e $value {if {[LIB_Shell_directory_exists [file join $path $e]]} {lappend returnvalue [LIB_Shell_format_path_names [file join $path $e]]}}
                }
              }

        r - pathrecursively {
                set dirs "" ; lappend dirs [file join $path] ; set initial $dirs ; set initialdir "" ; lappend initialdir [pwd]
                while {[llength $dirs]} {
                  set name [lindex $dirs 0]
                  if {$tcl_version > 8.3} {
                        set dirs [concat [glob -nocomplain -directory [lindex $dirs 0] -type d *] [lrange $dirs 1 end]]
                  } else {
                    cd [lindex $dirs 0] ; if {[catch {glob *}]} {lappend directories [lindex $dirs 0] ; set dirs [concat [lrange $dirs 1 end]] ; continue} else {set all [glob *]}
                    foreach e $all {if {[LIB_Shell_directory_exists [file join [lindex $dirs 0] $e]]} {lappend dirs [file join [lindex $dirs 0] $e]}}
                    set dirs [concat [lrange $dirs 1 end]]
                  }
                  lappend directories [LIB_Shell_format_path_names $name]
                }
                cd [lindex $initialdir 0]
                return $directories
              }

        c - content  {
                if {$tcl_version > 8.3} {
                       return [glob -nocomplain -directory $path -tails -types f *]
                } else {
                  set returnvalue [glob -nocomplain *]
                }
              }
    }
  }
}
# <Internal Documentation>
#
# Search glob directories
#
# Argument (1):
# path to search
#
# Argument (2):
# f = file
# p = path
# c = all
#
# <Internal Example>
#
# set content [LIB_Shell_file_glob "D:/Temp/Test"]
# returns e.g.: Test Functions Librarys
#____________________________________________________________________________________________
proc LIB_Shell_file_delete {filename} {

  if {[catch {file delete -force $filename}]} {
    MOM_log_message "Can't delete file '$filename'"
    return 0
  } else {
    return 1
  }

}
# <Internal Documentation>
#
# Delete a file and watch if it's possible
# It's also return true, if the file not exist
#
# <Internal Example>
#
# set content [LIB_Shell_file_delete "D:/Temp/Test.txt"]
# returns e.g.: Test Functions Librarys
#____________________________________________________________________________________________
proc LIB_Shell_holding_stack {obj {loops 300} {wait 100} {abort 1}} {

  if {[regexp -nocase -- {^[\\]{2}|^[A-Z][:][\\|\/]} $obj]} {set file 1} else {set file 0}
  if {$loops < 0} {set loops [expr abs($loops)] ; set negate 1} else {set negate 0}
  for { set n 1 } { $n <= $loops } { incr n } {
    if {!$negate && !$file && [info exists $obj]} {
      return
    } elseif {!$negate && $file && [file exists $obj]} {
      return
    } elseif {$negate && !$file && ![info exists $obj]} {
      return
    } elseif {$negate && $file && ![file exists $obj]} {
      return
    }
    after $wait
  }

  if {$abort} {
    LIB_Shell_abort "Timeout at LIB_Shell_holding_stack '$obj'"
  }
}
proc LIB_Shell_list_to_file {list filename {action w+}} {

  catch {MOM_remove_file $filename}
  set fileid [open $filename $action]
  foreach e $list {
    puts $fileid $e
  }
  flush $fileid
  close $fileid

}
proc LIB_Shell_path_init {folder {authorized "bin controller libraries"}} {

  global lib_shell lib_ge_slash

  set folder [LIB_Shell_format_path_names $folder]

  if {[llength $authorized] > 0} {
    set dirs [LIB_Shell_file_glob $folder p]
    set dirs [linsert $dirs 0 $folder]
  } else {
    set dirs [list $folder]
  }

  for { set n 0 } { $n <= [llength $dirs] } { incr n } {
    set name [lindex $dirs $n]
    set pathname [LIB_Shell_format_path_names $name]

    if {[llength $authorized] > 0 && $n > 0} {
      regsub -all (?q)$folder$lib_ge_slash $pathname "" pathnames
      set last [file tail $pathnames]
      if {[llength [file split $pathnames]] > 1} {continue}
      set continue 1
      foreach e $authorized {
        if {[string match -nocase $e $last]} {
          set continue 0
        }
      }
      if {[string length $last] > 0 && $continue} {continue}
    }

    if {$n > 0 && [lsearch -exact [string tolower $authorized] [string tolower [file tail $pathname]]] < 0} {continue}
    binary scan $pathname H* pathbin
    if {![llength [array get lib_shell $pathbin]] || [string length $lib_shell($pathbin)] <= 1} {
      set content [LIB_Shell_file_glob $pathname]
      if {$content != 0} {
        set lib_shell($pathbin) $content
        set lib_shell(collection) [join [lappend lib_shell(collection) $content]]
        foreach e $lib_shell($pathbin) {
          binary scan $e H* e
          if {![info exists lib_shell($e)]} {set lib_shell($e) $pathname}
        }
      }
    }
  }

}
# <Internal Documentation>
#
# Search directories recursively
#
# <Internal Example>
#
# set directories [LIB_Shell_path_init "D:/Temp/Test"]
# returns: D:/Temp/Test D:/Temp/Test/Functions D:/Temp/Test/Librarys D:/Temp/Test/Librarys/Test
#____________________________________________________________________________________________
proc LIB_Shell_file_pathname {filename {extension ".pce .pcf .tbc .tcl"} {logsuppress 0}} {

  global lib_shell lib_ge_slash

  foreach ext $extension {
    set name "$filename$ext"
    binary scan $name H* file
    binary scan [string tolower $name] H* lowerfile
    if {[llength [array get lib_shell $file]]} {
      return [LIB_Shell_format_path_names "$lib_shell($file)$lib_ge_slash$name"]
    } elseif {[llength [array get lib_shell $lowerfile]]} {
      return [LIB_Shell_format_path_names "$lib_shell($lowerfile)$lib_ge_slash$name"]
    } elseif {[lsearch -exact [string tolower $lib_shell(collection)] [string tolower $name]] > -1} {
      set index [lindex $lib_shell(collection) [lsearch -exact [string tolower $lib_shell(collection)] [string tolower $name]]]
      binary scan $index H* index
      if {[info exists lib_shell($index)]} {
        return [LIB_Shell_format_path_names "$lib_shell($index)$lib_ge_slash$name"]
      }
    }
  }

  if {!$logsuppress} {
    LIB_Shell_abort "File not found '$filename$ext' on the file system to source"
  }

}
# <Internal Documentation>
#
# Search location
#
# <Internal Example>
#
# set location [LIB_Shell_file_pathname "lib_general"]
#____________________________________________________________________________________________
proc LIB_Shell_replace_special_characters {text {special 0}} {

  if {[llength [info commands CONF_GE_msg]] && ![CONF_GE_msg replace_special_character]} {
    uplevel #0 {
      proc LIB_Shell_replace_special_characters {text {special 0}} {
        return $text
      }
    }
  }

  if {$special == 1} {
    regsub -all {1º} $text "1"        text
    regsub -all {2º} $text "2"        text
    regsub -all {3º} $text "3"        text
    regsub -all {ä}  $text "ae"       text
    regsub -all {Ä}  $text "AE"       text
    regsub -all {ö}  $text "oe"       text
    regsub -all {Ö}  $text "OE"       text
    regsub -all {ü}  $text "ue"       text
    regsub -all {Ü}  $text "UE"       text
    regsub -all {Ø}  $text "D"        text
    regsub -all {ø}  $text "D"        text
    regsub -all {°}  $text "D"        text
    regsub -all {ß}  $text "ss"       text
    regsub -all {\t} $text "    "      text
    regsub -all {à}  $text "a"        text
    regsub -all {À}  $text "A"        text
    regsub -all {â}  $text "a"        text
    regsub -all {Â}  $text "A"        text
    regsub -all {ô}  $text "o"        text
    regsub -all {Ô}  $text "O"        text
    regsub -all {ç}  $text "c"        text
    regsub -all {Ç}  $text "C"        text
    regsub -all {é}  $text "e"        text
    regsub -all {É}  $text "E"        text
    regsub -all {è}  $text "e"        text
    regsub -all {È}  $text "E"        text
    regsub -all {ê}  $text "e"        text
    regsub -all {Ê}  $text "E"        text
    regsub -all {ï}  $text "i"        text
    regsub -all {Ï}  $text "I"        text
    regsub -all {ù}  $text "u"        text
    regsub -all {Ù}  $text "U"        text
    regsub -all {\"}  $text "Inch"     text
    regsub -all {\$}  $text "Dollar"   text
  } elseif {$special == 2} {
    regsub -all "¡" $text "\\&iexcl;"  text
    regsub -all "¢" $text "\\&cent;"   text
    regsub -all "£" $text "\\&pound;"  text
    regsub -all "¤" $text "\\&curren;" text
    regsub -all "¥" $text "\\&yen;"    text
    regsub -all "¦" $text "\\&brvbar;" text
    regsub -all "§" $text "\\&sect;"   text
    regsub -all "¨" $text "\\&uml;"    text
    regsub -all "©" $text "\\&copy;"   text
    regsub -all "ª" $text "\\&ordf;"   text
    regsub -all "«" $text "\\&laquo;"  text
    regsub -all "¬" $text "\\&not;"    text
    regsub -all "­" $text "\\&shy;"    text
    regsub -all "®" $text "\\&reg;"    text
    regsub -all "¯" $text "\\&macr;"   text
    regsub -all "°" $text "\\&deg;"    text
    regsub -all "±" $text "\\&plusmn;" text
    regsub -all "²" $text "\\&sup2;"   text
    regsub -all "³" $text "\\&sup3;"   text
    regsub -all "´" $text "\\&acute;"  text
    regsub -all "µ" $text "\\&micro;"  text
    regsub -all "¶" $text "\\&para;"   text
    regsub -all "·" $text "\\&middot;" text
    regsub -all "¸" $text "\\&cedil;"  text
    regsub -all "¹" $text "\\&sup1;"   text
    regsub -all "º" $text "\\&ordm;"   text
    regsub -all "»" $text "\\&raquo;"  text
    regsub -all "¼" $text "\\&frac14;" text
    regsub -all "½" $text "\\&frac12;" text
    regsub -all "¾" $text "\\&frac34;" text
    regsub -all "¿" $text "\\&iquest;" text
    regsub -all "À" $text "\\&Agrave;" text
    regsub -all "Á" $text "\\&Aacute;" text
    regsub -all "Â" $text "\\&Acirc;"  text
    regsub -all "Ã" $text "\\&Atilde;" text
    regsub -all "Ä" $text "\\&Auml;"   text
    regsub -all "Å" $text "\\&Aring;"  text
    regsub -all "Æ" $text "\\&AElig;"  text
    regsub -all "Ç" $text "\\&Ccedil;" text
    regsub -all "È" $text "\\&Egrave;" text
    regsub -all "É" $text "\\&Eacute;" text
    regsub -all "Ê" $text "\\&Ecirc;"  text
    regsub -all "Ë" $text "\\&Euml;"   text
    regsub -all "Ì" $text "\\&Igrave;" text
    regsub -all "Í" $text "\\&Iacute;" text
    regsub -all "Î" $text "\\&Icirc;"  text
    regsub -all "Ï" $text "\\&Iuml;"   text
    regsub -all "Ð" $text "\\&ETH;"    text
    regsub -all "Ñ" $text "\\&Ntilde;" text
    regsub -all "Ò" $text "\\&Ograve;" text
    regsub -all "Ó" $text "\\&Oacute;" text
    regsub -all "Ô" $text "\\&Ocirc;"  text
    regsub -all "Õ" $text "\\&Otilde;" text
    regsub -all "Ö" $text "\\&Ouml;"   text
    regsub -all "×" $text "\\&times;"  text
    regsub -all "Ø" $text "\\&Oslash;" text
    regsub -all "Ù" $text "\\&Ugrave;" text
    regsub -all "Ú" $text "\\&Uacute;" text
    regsub -all "Û" $text "\\&Ucirc;"  text
    regsub -all "Ü" $text "\\&Uuml;"   text
    regsub -all "Ý" $text "\\&Yacute;" text
    regsub -all "Þ" $text "\\&THORN;"  text
    regsub -all "ß" $text "\\&szlig;"  text
    regsub -all "à" $text "\\&agrave;" text
    regsub -all "á" $text "\\&aacute;" text
    regsub -all "â" $text "\\&acirc;"  text
    regsub -all "ã" $text "\\&atilde;" text
    regsub -all "ä" $text "\\&auml;"   text
    regsub -all "å" $text "\\&aring;"  text
    regsub -all "æ" $text "\\&aelig;"  text
    regsub -all "ç" $text "\\&ccedil;" text
    regsub -all "è" $text "\\&egrave;" text
    regsub -all "é" $text "\\&eacute;" text
    regsub -all "ê" $text "\\&ecirc;"  text
    regsub -all "ë" $text "\\&euml;"   text
    regsub -all "ì" $text "\\&igrave;" text
    regsub -all "í" $text "\\&iacute;" text
    regsub -all "î" $text "\\&icirc;"  text
    regsub -all "ï" $text "\\&iuml;"   text
    regsub -all "ð" $text "\\&eth;"    text
    regsub -all "ñ" $text "\\&ntilde;" text
    regsub -all "ò" $text "\\&ograve;" text
    regsub -all "ó" $text "\\&oacute;" text
    regsub -all "ô" $text "\\&ocirc;"  text
    regsub -all "õ" $text "\\&otilde;" text
    regsub -all "ö" $text "\\&ouml;"   text
    regsub -all "÷" $text "\\&divide;" text
    regsub -all "ø" $text "\\&oslash;" text
    regsub -all "ù" $text "\\&ugrave;" text
    regsub -all "ú" $text "\\&uacute;" text
    regsub -all "û" $text "\\&ucirc;"  text
    regsub -all "ü" $text "\\&uuml;"   text
    regsub -all "ý" $text "\\&yacute;" text
    regsub -all "þ" $text "\\&thorn;"  text
    regsub -all "ÿ" $text "\\&yuml;"   text
  } elseif {$special == 3} {
    regsub -all "ô" $text "Ã´"    text
    regsub -all "š" $text "Å¡"    text
    regsub -all "¤" $text "Â¤"    text
    regsub -all "ö" $text "Ã¶"    text
    regsub -all "Þ" $text "Å¢"    text
    regsub -all "¦" $text "Â¦"    text
    regsub -all "÷" $text "Ã·"    text
    regsub -all "þ" $text "Å£"    text
    regsub -all "§" $text "Â§"    text
    regsub -all "ú" $text "Ãº"    text
    regsub -all "¨" $text "Â¨"    text
    regsub -all "ü" $text "Ã¼"    text
    regsub -all "©" $text "Â©"    text
    regsub -all "ý" $text "Ã½"    text
    regsub -all "Ù" $text "Å®"    text
    regsub -all "«" $text "Â«"    text
    regsub -all "Ã" $text "Ä‚"    text
    regsub -all "ù" $text "Å¯"    text
    regsub -all "¬" $text "Â¬"    text
    regsub -all "ã" $text "Äƒ"    text
    regsub -all "Û" $text "Å°"    text
    regsub -all "¥" $text "Ä„"    text
    regsub -all "û" $text "Å±"    text
    regsub -all "®" $text "Â®"    text
    regsub -all "¹" $text "Ä..."  text
    regsub -all "°" $text "Â°"    text
    regsub -all "Æ" $text "Ä†"    text
    regsub -all "Ÿ" $text "Åº"    text
    regsub -all "±" $text "Â±"    text
    regsub -all "æ" $text "Ä‡"    text
    regsub -all "¯" $text "Å»"    text
    regsub -all "´" $text "Â´"    text
    regsub -all "È" $text "ÄŒ"    text
    regsub -all "¿" $text "Å¼"    text
    regsub -all "µ" $text "Âµ"    text
    regsub -all "è" $text "Ä?"    text
    regsub -all "Ž" $text "Å½"    text
    regsub -all "¶" $text "Â¶"    text
    regsub -all "Ï" $text "ÄŽ"    text
    regsub -all "ž" $text "Å¾"    text
    regsub -all "·" $text "Â·"    text
    regsub -all "ï" $text "Ä?"    text
    regsub -all "¡" $text "Ë‡"    text
    regsub -all "¸" $text "Â¸"    text
    regsub -all "Ð" $text "Ä?"    text
    regsub -all "¢" $text "Ë~"    text
    regsub -all "»" $text "Â»"    text
    regsub -all "ð" $text "Ä‘"    text
    regsub -all "ÿ" $text "Ë™"    text
    regsub -all "Á" $text "Ã?"    text
    regsub -all "Ê" $text "Ä~"    text
    regsub -all "²" $text "Ë›"    text
    regsub -all "Â" $text "Ã‚"    text
    regsub -all "ê" $text "Ä™"    text
    regsub -all "½" $text "Ë?"    text
    regsub -all "Ä" $text "Ã„"    text
    regsub -all "Ì" $text "Äš"    text
    regsub -all "–" $text "â€“"   text
    regsub -all "Ç" $text "Ã‡"    text
    regsub -all "ì" $text "Ä›"    text
    regsub -all "—" $text "â€”"   text
    regsub -all "É" $text "Ã‰"    text
    regsub -all "Å" $text "Ä¹"    text
    regsub -all "‘" $text "â€~"   text
    regsub -all "Ë" $text "Ã‹"    text
    regsub -all "å" $text "Äº"    text
    regsub -all "’" $text "â€™"   text
    regsub -all "Í" $text "Ã?"    text
    regsub -all "¼" $text "Ä½"    text
    regsub -all "‚" $text "â€š"   text
    regsub -all "Î" $text "ÃŽ"    text
    regsub -all "¾" $text "Ä¾"    text
    regsub -all "“" $text "â€œ"   text
    regsub -all "Ó" $text "Ã“"    text
    regsub -all "£" $text "Å?"    text
    regsub -all "”" $text "â€?"   text
    regsub -all "Ô" $text "Ã”"    text
    regsub -all "³" $text "Å‚"    text
    regsub -all "„" $text "â€ž"   text
    regsub -all "Ö" $text "Ã–"    text
    regsub -all "Ñ" $text "Åƒ"    text
    regsub -all "†" $text "â€"    text
    regsub -all "×" $text "Ã—"    text
    regsub -all "ñ" $text "Å„"    text
    regsub -all "‡" $text "â€¡"   text
    regsub -all "Ú" $text "Ãš"    text
    regsub -all "Ò" $text "Å‡"    text
    regsub -all "•" $text "â€¢"   text
    regsub -all "Ü" $text "Ãœ"    text
    regsub -all "ò" $text "Åˆ"    text
    regsub -all "Ý" $text "Ã?"    text
    regsub -all "Õ" $text "Å?"    text
    regsub -all "‰" $text "â€°"   text
    regsub -all "ß" $text "ÃŸ"    text
    regsub -all "õ" $text "Å‘"    text
    regsub -all "‹" $text "â€¹"   text
    regsub -all "á" $text "Ã¡"    text
    regsub -all "À" $text "Å”"    text
    regsub -all "›" $text "â€º"   text
    regsub -all "â" $text "Ã¢"    text
    regsub -all "à" $text "Å•"    text
    regsub -all "€" $text "â‚¬"   text
    regsub -all "ä" $text "Ã¤"    text
    regsub -all "Ø" $text "Å ~"   text
    regsub -all "™" $text "â„¢"   text
    regsub -all "ç" $text "Ã§"    text
    regsub -all "ø" $text "Å™"    text
    regsub -all "é" $text "Ã©"    text
    regsub -all "Œ" $text "Åš"    text
    regsub -all "ë" $text "Ã«"    text
    regsub -all "œ" $text "Å›"    text
    regsub -all "í" $text "Ã-"    text
    regsub -all "ª" $text "Åž"    text
    regsub -all "î" $text "Ã®"    text
    regsub -all "º" $text "ÅŸ"    text
    regsub -all "ó" $text "Ã³"    text
    regsub -all "Š" $text "Å"     text
  } elseif {$special == 4} {
    regsub -all {ä}  $text "ae"    text
    regsub -all {Ä}  $text "AE"    text
    regsub -all {ö}  $text "oe"    text
    regsub -all {Ö}  $text "OE"    text
    regsub -all {ü}  $text "ue"    text
    regsub -all {Ü}  $text "UE"    text
    regsub -all {ß}  $text "ss"    text
    regsub -all {à}  $text "a"     text
    regsub -all {À}  $text "A"     text
    regsub -all {â}  $text "a"     text
    regsub -all {Â}  $text "A"     text
    regsub -all {ô}  $text "o"     text
    regsub -all {Ô}  $text "O"     text
    regsub -all {ç}  $text "c"     text
    regsub -all {Ç}  $text "C"     text
    regsub -all {é}  $text "e"     text
    regsub -all {É}  $text "E"     text
    regsub -all {è}  $text "e"     text
    regsub -all {È}  $text "E"     text
    regsub -all {ê}  $text "e"     text
    regsub -all {Ê}  $text "E"     text
    regsub -all {ï}  $text "i"     text
    regsub -all {Ï}  $text "I"     text
    regsub -all {ù}  $text "u"     text
    regsub -all {Ù}  $text "U"     text
  } elseif {$special == 5} {
    regsub -all {ä}  $text "ae"      text
    regsub -all {&}  $text "\\&amp;"    text
    regsub -all {§}  $text "\\&sect;"   text
    regsub -all {‰}  $text "\\&permil;" text
    regsub -all {¯}  $text "\\&macr;"   text
    regsub -all {–}  $text "\\&ndash;"  text
    regsub -all {—}  $text "\\&mdash;"  text
    regsub -all {¦}  $text "\\&brvbar;" text
    regsub -all {†}  $text "\\&dagger;" text
    regsub -all {‡}  $text "\\&Dagger;" text
    regsub -all {←}  $text "\\&larr;"   text
    regsub -all {→}  $text "\\&rarr;"   text
    regsub -all {↑}  $text "\\&uarr;"   text
    regsub -all {↓}  $text "\\&darr;"   text
    regsub -all {↔}  $text "\\&harr;"   text
    regsub -all {◊}  $text "\\&loz;"    text
    regsub -all {•}  $text "\\&bull;"   text
    regsub -all {¡}  $text "\\&iexcl;"  text
    regsub -all {¿}  $text "\\&iquest;" text
    regsub -all {♥}  $text "\\&hearts;" text
    regsub -all {♠}  $text "\\&spades;" text
    regsub -all {♣}  $text "\\&clubs;"  text
    regsub -all {♦}  $text "\\&diams;"  text
    regsub -all {€}  $text "\\&euro;"   text
    regsub -all {£}  $text "\\&pound;"  text
    regsub -all {¥}  $text "\\&yen;"    text
    regsub -all {¢}  $text "\\&cent;"   text
    regsub -all {„}  $text "\\&quot;"   text
    regsub -all {‘}  $text "\\&lsquo;"  text
    regsub -all {’}  $text "\\&rsquo;"  text
    regsub -all {‚}  $text "\\&sbquo;"  text
    regsub -all {“}  $text "\\&ldquo;"  text
    regsub -all {”}  $text "\\&rdquo;"  text
    regsub -all {„}  $text "\\&bdquo;"  text
    regsub -all {‹}  $text "\\&lsaquo;" text
    regsub -all {›}  $text "\\&rsaquo;" text
    regsub -all {«}  $text "\\&laquo;"  text
    regsub -all {»}  $text "\\&raquo;"  text
    regsub -all {<}  $text "\\&lt;"     text
    regsub -all {>}  $text "\\&gt;"     text
    regsub -all {±}  $text "\\&plusmn;" text
    regsub -all {×}  $text "\\&times;"  text
    regsub -all {÷}  $text "\\&divide;" text
    regsub -all {≤}  $text "\\&le;"     text
    regsub -all {≥}  $text "\\&ge;"     text
    regsub -all {≈}  $text "\\&asymp;"  text
    regsub -all {≠}  $text "\\&ne;"     text
    regsub -all {¼}  $text "\\&frac14;" text
    regsub -all {½}  $text "\\&frac12;" text
    regsub -all {¾}  $text "\\&frac34;" text
    regsub -all {¹}  $text "\\&sup1;"   text
    regsub -all {²}  $text "\\&sup2;"   text
    regsub -all {³}  $text "\\&sup3;"   text
    regsub -all {√}  $text "\\&radic;"  text
    regsub -all {∫}  $text "\\&int;"    text
    regsub -all {∞}  $text "\\&infin;"  text
    regsub -all {∂}  $text "\\&part;"   text
    regsub -all {∩}  $text "\\&cap;"    text
    regsub -all {©}  $text "\\&copy;"   text
    regsub -all {®}  $text "\\&reg;"    text
    regsub -all {™}  $text "\\&trade;"  text
    regsub -all {ˆ}  $text "\\&circ;"   text
    regsub -all {˜}  $text "\\&tilde;"  text
    regsub -all {¸}  $text "\\&cedil;"  text
    regsub -all {À}  $text "\\&Agrave;" text
    regsub -all {à}  $text "\\&agrave;" text
    regsub -all {Á}  $text "\\&Aacute;" text
    regsub -all {Â}  $text "\\&Acirc;"  text
    regsub -all {Ã}  $text "\\&Atilde;" text
    regsub -all {Ä}  $text "\\&Auml;"   text
    regsub -all {Å}  $text "\\&Aring;"  text
    regsub -all {Æ}  $text "\\&AElig;"  text
    regsub -all {Ç}  $text "\\&Ccedil;" text
    regsub -all {Þ}  $text "\\&THORN;"  text
    regsub -all {Ð}  $text "\\&ETH;"    text
    regsub -all {þ}  $text "\\&thorn;"  text
    regsub -all {ð}  $text "\\&eth;"    text
    regsub -all {Ø}  $text "\\&Oslash;" text
    regsub -all {Œ}  $text "\\&OElig;"  text
    regsub -all {œ}  $text "\\&oelig;"  text
    regsub -all {Š}  $text "\\&Scaron;" text
    regsub -all {š}  $text "\\&scaron;" text
  } elseif {$special == 6} {
    # May not always be required in doublequoted strings, just try
    regsub -all {%}  $text "%%"     text
    # May not always be required in doublequoted strings, but it won't hurt
    regsub -all {\^}  $text "\^\^"  text
    regsub -all {&}  $text "\^\\\&" text
    regsub -all {<}  $text "\^<"    text
    regsub -all {>}  $text "\^>"    text
    regsub -all {\|}  $text "\^|"   text
    # Required only in the FOR /F subject (i.e. between the parenthesis), unless backq is used
    regsub -all {\'}  $text "\^'"   text
    # Required only in the FOR /F subject (i.e. between the parenthesis), if backq is used
    regsub -all {\`}  $text "\^`"   text
    # Required only in the FOR /F subject (i.e. between the parenthesis), even in doublequoted strings
    regsub -all {,}  $text "\^,"    text
    regsub -all {;}  $text "\^;"    text
    regsub -all {=}  $text "\^="    text
    regsub -all {\(}  $text "\^("   text
    regsub -all {\)}  $text "\^)"   text
    # Required only when delayed variable expansion is active
    regsub -all {!}  $text "\^\^"   text
    # Required only inside the search pattern of FIND
    regsub -all {\"}  $text "\"\""  text
  } elseif {$special == 7} {
    # Required only inside the regex pattern of FINDSTR
    regsub -all {\\} $text "\\\\\\" text
    regsub -all {[}  $text "\\\["   text
    regsub -all {]}  $text "\\\]"   text
    regsub -all {\"}  $text "\\\""  text
    regsub -all {.}  $text "\\\."   text
    regsub -all {*}  $text "\\\*"   text
    regsub -all {?}  $text "\\\?"   text
  } elseif {$special == 8} {
    #this is nx internal conversion for MOM__part_attributes (mom_mcsname_attach_opr)
    regsub -all {Ä}  $text "Ã„"        text
    regsub -all {Ö}  $text "Ã–"        text
    regsub -all {Ü}  $text "Ãœ"       text
    regsub -all {ß}  $text "ÃŸ"       text
    regsub -all {Ø}  $text "Ã˜"         text
    regsub -all {À}  $text "Ã€"        text
    regsub -all {Â}  $text "Ã‚"        text
    regsub -all {Ô}  $text "Ã”"        text
    regsub -all {Ç}  $text "Ã‡"        text
    regsub -all {É}  $text "Ã‰"        text
    regsub -all {È}  $text "Ãˆ"         text
    regsub -all {Ê}  $text "ÃŠ"         text
    regsub -all {Ï}  $text "Ã"         text
    regsub -all {Ù}  $text "Ã™"        text
  }

  return $text

}
# <Internal Documentation>
#
# This procedure can be called whenever a textoutput need to be checked for special characters.
#
# The options are:
# 0 = direct output (default)
# 1 = replace special characters to international spelling. Considers diameter, degree, inch and dollar sign.
# 2 = replace special characters to html
# 3 = replace UTF-8 to Unicode
# 4 = replace special characters to international spelling. No conversion of diameter, degree, inch and dollar sign.
# 5 = replace special characters to xml
# 6 = replace special characters to batch
# 7 = replace special characters to batch (for regex pattern of FINDSTR)
# 8 = replace special characters to MOM__part_attributes
#
# <Internal Example>
# set text [LIB_Shell_replace_special_characters $text]
#____________________________________________________________________________________________
proc LIB_Shell_reload_functions {} {

  uplevel #0 {

    #____________________________________________________________________________________________
    #
    # Procs used to detect equality between scalars of real data type.
    #
    # global mom_system_tolerance
    # EQ_is_equal(s, t)  (abs(s-t) <= mom_system_tolerance) Return true if scalars are equal
    # EQ_is_ge(s, t)     (s > t - mom_system_tolerance)     Return true if s is greater than
    #                                         or equal to t
    # EQ_is_gt(s, t)     (s > t + mom_system_tolerance)     Return true if s is greater than t
    # EQ_is_le(s, t)     (s < t + mom_system_tolerance)     Return true if s is less than or
    #                                         equal to t
    # EQ_is_lt(s, t)     (s < t - mom_system_tolerance)     Return true if s is less than t
    # EQ_is_zero(s)      (abs(s) < mom_system_tolerance)    Return true if scalar is zero
    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # Procs used to detect equality between scalars of real data type.
    # Return true if scalars are equal
    #
    # <Internal Example>
    # EQ_is_equal 12.0 12.0
    #____________________________________________________________________________________________
    proc EQ_is_equal [list s t [list tol $mom_system_tolerance]] {
    #@.pce@
      if {[string trim $s] == "" || [string trim $t] == ""} {return 0}
      expr {abs($s - $t) <= $tol}
    }

    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # Procs used to detect equality between scalars of real data type.
    # Return true if s is greater than or equal to t
    #
    # <Internal Example>
    # EQ_is_ge 12.0 12.0
    #____________________________________________________________________________________________
    proc EQ_is_ge [list s t [list tol $mom_system_tolerance]] {
    #@.pce@
      if {[string trim $s] == "" || [string trim $t] == ""} {return 0}
      expr {$s > ($t - $tol)}
    }

    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # Procs used to detect equality between scalars of real data type.
    # Return true if s is greater than t
    #
    # <Internal Example>
    # EQ_is_gt 12.0 14.0
    #____________________________________________________________________________________________
    proc EQ_is_gt [list s t [list tol $mom_system_tolerance]] {
    #@.pce@
      if {[string trim $s] == "" || [string trim $t] == ""} {return 0}
      expr {$s > ($t + $tol)}
    }

    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # Procs used to detect equality between scalars of real data type.
    # Return true if s is less than or equal to t
    #
    # <Internal Example>
    # EQ_is_le 12.0 14.0
    #____________________________________________________________________________________________
    proc EQ_is_le [list s t [list tol $mom_system_tolerance]] {
    #@.pce@
      if {[string trim $s] == "" || [string trim $t] == ""} {return 0}
      expr {$s < ($t + $tol)}
    }

    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # Procs used to detect equality between scalars of real data type.
    # Return true if s is less than t
    #
    # <Internal Example>
    # EQ_is_lt 12.0 14.0
    #____________________________________________________________________________________________
    proc EQ_is_lt [list s t [list tol $mom_system_tolerance]] {
    #@.pce@
      if {[string trim $s] == "" || [string trim $t] == ""} {return 0}
      expr {$s < ($t - $tol)}
    }

    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # Procs used to detect equality between scalars of real data type.
    # Return true if scalar is zero
    #
    # <Internal Example>
    # EQ_is_zero 0.0
    #____________________________________________________________________________________________
    proc EQ_is_zero [list s [list tol $mom_system_tolerance]] {
    #@.pce@
      if {[string trim $s] == ""} {return 0}
      expr {abs($s) <= $tol}
    }

    #____________________________________________________________________________________________
# <Internal Documentation>
    #
    # MOM_output_text differ from MOM_output_literal in the NX-Core!!
    # so we have to change this proc when we are in simulation
    #
    # PR#9360571 : remove mom_post_in_smulation check, change MOM_output_text for both of post and
    # simulation
    #
    # <Internal Example>
    # >> This function is a black box  <<
    #____________________________________________________________________________________________


    if {![llength [info commands PC_MOM_output_text]]} {
      rename MOM_output_text PC_MOM_output_text

      proc MOM_output_text {arg} {
      #@.pce@
        set seq_status  [MOM_set_seq_off]
        set output  [MOM_output_literal $arg]
        if {[string match "on" $seq_status]} {
          MOM_set_seq_on
        }
        return $output
      }
    }

  }
}

# lib_standard_post_func.tcl

proc LIB_SPF_abort_postrun {text {once 0} {output 1}} {

  global lib_ge_debug lib_spf tcl_version mom_output_file_full_name

  if {[llength [info commands MOM_set_turbo_mode]]} {MOM_set_turbo_mode "FALSE"}

  if {$mom_output_file_full_name != "" && [file exists $mom_output_file_full_name]} {
    MOM_close_output_file $mom_output_file_full_name
    if {![info exists lib_ge_debug(active)] || !$lib_ge_debug(active)} {
      file delete -force $mom_output_file_full_name
    }
    MOM_open_output_file [file nativename $mom_output_file_full_name]
  }

  if {![info exists lib_spf(abort_postrun,message)]} {
    if {$output} {MOM_output_to_listing_device "\n\t$text\n\n\t[LIB_GE_MSG "!!! Postprocessing was canceled !!!"]\n\n"}
  }

  LIB_GE_command_buffer_edit_redefine LIB_GE_listing_info LISTING_INFO ""

  if {![llength [info commands MOM_abort_program]] && (![info exists lib_ge_debug(active)] || $lib_ge_debug(active))} {
    LIB_GE_error_message "LIB_SPF_abort_postrun is called, but the debug mode is activated" "Therefore no better abort handling is possible" "ERROR"
    error "LIB_SPF_abort_postrun is called, but the debug mode is activated. Therefore no better abort handling is possible."
  }

  proc MOM__halt {} {
    global lib_spf mom_output_file_full_name
    if {[LIB_Shell_file_exists $mom_output_file_full_name 1] && ![string equal -nocase $lib_spf(initial,output_file_full_name) $lib_spf(value,output_file_full_name)] || \
        [string match ".STAY" [file extension $mom_output_file_full_name]]} {
      MOM_close_output_file $mom_output_file_full_name
      MOM_remove_file $mom_output_file_full_name
    }
  }

  if {$once > 0} {set lib_spf(abort_postrun,message) 1}

  set lib_spf(global,text) $text

  set notclean [lsort "\
    MOM_abort MOM_abort_event MOM_add_to_address_buffer MOM_add_to_block_buffer MOM_add_to_line_buffer \
    MOM_ask_address_value MOM_ask_definition_element MOM_ask_env_var MOM_ask_event_type MOM_ask_ess_exp_value \
    MOM_ask_init_junction_xform MOM_ask_machine_zero_junction_name MOM_ask_oper_csys MOM_ask_syslog_name \
    MOM_cancel_suppress_force_once_per_event MOM_check_out_license MOM_close_output_file MOM_convert_point \
    MOM_disable_address MOM_display_message MOM_enable_address MOM_force MOM_force_block MOM__util_do_heading\
    MOM_has_definition_element MOM_incremental MOM_load_definition_file MOM_load_lathe_thread_cycle_params \
    MOM_log_message MOM_on_event_error MOM_on_parse_error MOM_open_output_file MOM__boot MOM__halt \
    MOM__util_print MOM__util_print_line_context MOM_output_to_listing_device \
    MOM_abort_program MOM__dispatch MOM__part_attributes MOM_post_oper_path MOM_reload_kinematics MOM_reload_variable \
    MOM_reset_sequence MOM_run_postprocess MOM_run_user_function MOM_set_address_expression MOM_set_address_format \
    MOM_set_attribute MOM_set_debug_mode MOM_set_env_var MOM_set_feedrate MOM_set_line_leader MOM_set_seq_off \
    MOM_set_seq_on MOM_set_turbo_before_motion MOM_set_turbo_blocks MOM_set_turbo_mode MOM_set_turbo_pos_output \
    MOM_set_turbo_rapid MOM_skip_handler_to_event MOM_suppress MOM_abort_operation MOM_unload_library \
    MOM_end_of_program MOM_before_output MOM_remove_file MOM_string_toupper \
  "]

  if {![info exists lib_ge_debug(commands)]} {set lib_ge_debug(commands) [lsort [info command MOM_*]]}
  foreach lib_spf(global) $lib_ge_debug(commands) {
    if {[info commands $lib_spf(global)] != "" && [info commands $lib_spf(global)_resolving] == "" && [lsearch -exact $notclean $lib_spf(global)] < 0} {

      rename $lib_spf(global) $lib_spf(global)_resolving

      uplevel #0 {
        proc $lib_spf(global) {args} {
          # Cleanup all events in runtime
          MOM_abort_event
        }
      }
    }
  }

  uplevel #0 {
    proc LIB_SPF_abort {} {
    #@.pce@
      catch {
        # Cleanup the listing output
        set id [open $::mom_output_file_full_name w+]
        close $id
        MOM_log_message "\t[LIB_GE_string_range_toupper $::lib_spf(global,text) 0 0]\n\n"
        MOM_output_to_listing_device "\t[LIB_GE_string_range_toupper $::lib_spf(global,text) 0 0]\n\n"
        LIB_GE_cleanup_file $::mom_output_file_full_name
      }
    }
  }

  if {[llength [info commands MOM_abort_program]]} {MOM_abort_program}

}
# <Documentation>
# This procedure aborts the postprocessing of a toolpath or program.
# It has the same effect as MOM_abort but is faster, clears messages, and does cleanup handling.
# <Arguments>
# text
#   Message that is displayed when postprocessing is aborted.
# once
#   Reserved argument.
# output
#   Writes Postprocessing was canceled to the listing window provided that this argument is not set to 0.
# <Returnvalue>
# None.
# <Example>
# LIB_SPF_abort_postrun "The post will now be interrupted"
#____________________________________________________________________________________________
proc LIB_SPF_pt_additional_variables {} {

  # LIB_SPF_pretreatment_add_var MOM_start_of_path mom_msys_matrix 0
  # LIB_SPF_pretreatment_add_var MOM_header_ude mom_header_program_name 2

  set pt_additional_variables_procs [info proc LIB_SPF_pt_additional_variables_*]

  foreach element $pt_additional_variables_procs {
      $element
  }

}
# <Internal Documentation>
#
# Entrypoint to define additional variables which should be stored in pretreatment
#
# Copy this proc to the needed post file and call
# LIB_SPF_pretreatment_add_var in this proc to add return variables from pretreatment
#
# <Internal Example>
# Sample code as comment in proc body
#____________________________________________________________________________________________
proc LIB_SPF_pt_exists {variable {sequence 0} {path_name ""}} {

  return [LIB_SPF_get_pretreatment $variable $sequence $path_name]

}
# <Documentation>
# This procedure checks whether a pretreatment variable exists or not.
# Use this procedure before using LIB_SPF_get_pretreatment.
# <Arguments>
# variable
#   Name of the pretreatment variable to check.
# sequence
#   Operation sequence to check for the variable. Valid options are:
# 0 - Read value of current operation.
# last - Read value in the last operation.
# first - Read value in the first operation.
# next - Read value in the next operation.
# +/- x - Read x operations before or after the current operation.
# path_name
#   Reads the value in a given path_name instead of a specifc sequence. In this case set sequence to 0.
#
# <Returnvalue>
# 1 - Variable exists.
# 0 - Variable does not exist.
#
# <Example>
# if {[LIB_SPF_pt_exists mom_path_name 1]} {
# MOM_output_literal "next oper = [LIB_SPF_get_pretreatment mom_path_name 1]"
# } else {
# MOM_output_literal "no next oper"
# }
#____________________________________________________________________________________________
proc LIB_SPF_pt_exists_not_empty {variable {sequence 0} {path_name ""}} {
  if {![LIB_SPF_pt_exists $variable $sequence $path_name] } {
    return 0
  } elseif {[LIB_SPF_get_pretreatment $variable $sequence $path_name] == ""} {
    return 0
  } else {
    return 1
  }
}
# <Documentation>
# This procedure checks whether a pretreatment variable exists and is not empty. Use this procedure before using LIB_SPF_get_pretreatment.
# <Arguments>
# variable
#   Name of the pretreatment variable to be checked.
# sequence
#   Operation sequence to check for the variable. Valid options are:
# 0 - Read value of current operation.
# last - Read value in the very last operation.
# first - Read value in the very first operation.
# next - Read value in the next operation.
# +/- x - Read x operations before or after the current operation.
# path_name
#   Reads the value in a given path_name instead of a specifc sequence. In this case set sequence to 0.
#
# <Returnvalue>
# 1 - Variable exists and is not empty.
# 0 - Variable does not exist or is empty.
#
# <Example>
# if {[LIB_SPF_pt_exists_not_empty "mom_out_angle_pos,0" 1]} {
# set nxt_out_angle_pos(0) [LIB_SPF_get_pretreatment "mom_out_angle_pos,0" 1]
# set nxt_out_angle_pos(1) [LIB_SPF_get_pretreatment "mom_out_angle_pos,1" 1]
# } else {
# set nxt_out_angle_pos(0) 0.0
# set nxt_out_angle_pos(1) 0.0
# }
#____________________________________________________________________________________________
proc LIB_SPF_get_pretreatment_eventbased {event variable {sequence 0} {path_name ""}} {

  set returnvalue [LIB_SPF_get_pretreatment $event,$variable $sequence $path_name]
  if {![string length $returnvalue]} {
    set returnvalue [LIB_SPF_get_pretreatment $variable $sequence $path_name]
  }
  return $returnvalue

}
# <Documentation>
# This procedure reads variables that have been collected in the pretreatment postprocessor for a specified event.
# Use the procedure LIB_SPF_pretreatment_add_var to tell the pretreatment postprocessor which variables should be collected.
# If a desired variable does not exist, an empty string is returned.
#
# Note: This procedure can only access information that is available after the first MOM_start_of_path event.
# Use LIB_PT_get_header_var instead to access variables that precede the first MOM_start_of_path, such as variables coming from a UDE header.
#
# <Arguments>
# event
#   Name of the event that contains the variable.
#   Sometimes the same variable name is used by different procedures (for example mom_command_status),
#   so this procedure only considers the variable set in a specific event.
# variable
#   Name of the variable to read.
# sequence
#   Operation sequence to read. Default = 0 means that the value of the current operation is read.
#   Valid options are:
#     0 - Read value of current operation.
#     last - Read value in the last operation.
#     first - Read value in the first operation.
#     next - Read value in the next operation.
#     +/- x - Read x operations before or after the current operation.
# path_name
#   Reads the value in a given path_name instead of a specific sequence. In this case set sequence to 0.
# <Returnvalue>
# value of the requested variable or empty string if value is not present.
# <Example>
# name: get command_status of specific UDE for next operation
# code: set command_status [LIB_SPF_get_pretreatment_eventbased MOM_customer_ude mom_command_status next]
# desc: Gets the command_status of the UDE MOM_customer_ude of the next operation.
#      Important: In order to access the variable, you must first tell the pretreatment postprocessor to read the variable of the specified event with:
#      LIB_SPF_pretreatment_add_var mom_command_status MOM_customer_ude
#____________________________________________________________________________________________
proc LIB_SPF_get_pretreatment {variable {sequence 0} {path_name ""} {pathnamesequence 0}} {


  global mom_path_name
  global lib_flag lib_pretreatment
  global mom_operation_name_list lib_spf
  global mom_operation_info mom_cutter_info mom_csys_matrix
  global mom_nxt_event_data

    set local_debug_oper_name_list 0

    if {$lib_spf(sort_pt_operation_name_list) && [info exists lib_pretreatment]} {
      if {![info exists lib_pretreatment(operation_list__original)]} {
        set lib_pretreatment(operation_list__original) $lib_pretreatment(operation_list)
        set lib_pretreatment(tag_list__original) $lib_pretreatment(tag_list)
        set lib_pretreatment(tool_name_list__original) $lib_pretreatment(tool_name_list)
        set lib_pretreatment(tool_number_list__original) $lib_pretreatment(tool_number_list)
      }
      # set this imediately to 0 to avoid nested calls ending in a loop
      set lib_spf(sort_pt_operation_name_list) 0
      #create a temporary list
      set tmp_operation_name_list $mom_operation_name_list

      if {$local_debug_oper_name_list} {MOM_output_to_listing_device "ORIG tmp_operation_name_list = $tmp_operation_name_list"}

      foreach op $lib_pretreatment(operation_list) {
        #Check if one of the elements of lib_pretreatment(operation_list) is an optimized group
        if {$local_debug_oper_name_list} {MOM_output_to_listing_device "op = $op"}

        if {[LIB_SPF_pt_exists mom_optimized_group_operation_name_list 0 $op] && [LIB_SPF_get_pretreatment mom_optimized_group_operation_name_list 0 $op] != ""} {
          # if it is an optimized group
          # search tmp_operation_name_list for the names of the group members and replace them with the name
          # of the optimized group
          if {$local_debug_oper_name_list} {MOM_output_to_listing_device "op = $op , group = [LIB_SPF_get_pretreatment mom_optimized_group_operation_name_list 0 $op]"}

          set tmp_operation_name_list [string map [list [LIB_SPF_get_pretreatment mom_optimized_group_operation_name_list 0 $op] $op] $tmp_operation_name_list]

        } elseif {[LIB_SPF_pt_exists mom_merged_path_group_operation_name_list 0 $op] && [LIB_SPF_get_pretreatment mom_merged_path_group_operation_name_list 0 $op] != ""} {
          # if it is an additive merged path group
          # search tmp_operation_name_list for the names of the group members and replace them with the name
          # of the merged path group

          if {$local_debug_oper_name_list} {MOM_output_to_listing_device "op = $op , group = [LIB_SPF_get_pretreatment mom_merged_path_group_operation_name_list 0 $op]"}
          set index [lsearch -exact $tmp_operation_name_list [lindex [LIB_SPF_get_pretreatment mom_merged_path_group_operation_name_list 0 $op] 0]]
          if {$index != -1} {
            set tmp_operation_name_list [lreplace $tmp_operation_name_list $index $index $op]
          }

        }

        # for further treatment use tmp_operation_name_list instead of mom_operationname_list
      }

      if {$local_debug_oper_name_list} {MOM_output_to_listing_device "tmp_operation_name_list = $tmp_operation_name_list"}

      set lib_pretreatment(operation_list) ""
      set lib_pretreatment(tag_list) ""
      set lib_pretreatment(tool_name_list) ""
      set lib_pretreatment(tool_number_list) ""

      if {[info exists lib_spf(nx_version)] && $lib_spf(nx_version) < 1000} {
        #in NX9 there is a problem with special characters in the operation names.
        #therefore we just abort here in this case
        set wrong_names ""
        foreach oper $tmp_operation_name_list {
          if {![regexp -nocase {^[0-9A-Z_\-.]+$} $oper]} {
            lappend wrong_names $oper
          }
        }
        if {$wrong_names != ""} {
          LIB_GE_abort_message "Remove special characters from operation name 'INS->$wrong_names<-'" "Please verify"
        }
      }

      foreach name $tmp_operation_name_list {
        set current_index [lsearch -exact $lib_pretreatment(operation_list__original) $name]

        lappend lib_pretreatment(operation_list) [lindex $lib_pretreatment(operation_list__original) $current_index]
        lappend lib_pretreatment(tag_list) [lindex $lib_pretreatment(tag_list__original) $current_index]
        lappend lib_pretreatment(tool_name_list) [lindex $lib_pretreatment(tool_name_list__original) $current_index]
        lappend lib_pretreatment(tool_number_list) [lindex $lib_pretreatment(tool_number_list__original) $current_index]
      }

      set lib_spf(sort_pt_operation_name_list) 0

    }


  # arrays require a comma as delimiter and not a bracketing
  regsub -all "\\\(" $variable "," variable
  regsub -all "\\\)" $variable "" variable

  if {[info exists lib_flag(lib_spf_pretreatment)] && ![CONF_SPF_pt lib_spf_pretreatment]} {
    return "NOT_Activated"
  }

  if {![regexp -nocase -- {\w+} $variable]} {LIB_GE_abort_message "Entry for INS->LIB_SPF_get_pretreatment<- with argument 'INS->variable<-' needs a value" "Please verify"}

  if {[info exists lib_pretreatment(operation_list)]} {
    if {$path_name == ""} {
      set order [lsearch -exact $lib_pretreatment(operation_list) $mom_path_name]
    } else {
      set order [lsearch -exact $lib_pretreatment(operation_list) $path_name]
      if {$pathnamesequence == 0} {
        set sequence 0
      } else {
        set sequence $pathnamesequence
      }
    }
  }

  if {$sequence != 0} {
    switch -- $sequence {
      "last"  {set order end}
      "next"  {incr order}
      "first" {set order 0}
      default {
        if {![regexp -- {[0-9]} $sequence]} {LIB_GE_abort_message "Entry for INS->LIB_SPF_get_pretreatment<- with argument 'INS->sequence<-' needs a number as value" "Please verify"}
        if {[regexp -- {^[0-9\.]+} $sequence]} {set sequence "+$sequence"}
        set order [expr $order$sequence]
      }
    }
  }

  if {[info exists lib_pretreatment(tag_list)]} {
    set tag [lindex $lib_pretreatment(tag_list) $order]
  }

  if {![info exists variable]} {LIB_GE_abort_message "There is no variable available at INS->LIB_SPF_get_pretreatment<-" "Please verify"}

  if { $lib_flag(optimized_mode)} {
    set path_name [lindex $lib_pretreatment(operation_list) $order]
    set variable_exists 0
    switch -- [string trim $variable] {
      "operation_list" -
      "tag_list" -
      "tool_name_list" -
      "tool_number_list" {
        if {[info exists lib_pretreatment($variable)]} {
          set returnvalue $lib_pretreatment($variable)
          set variable_exists 1
        } else {
          LIB_GE_abort_message "There is no variable available at INS->LIB_SPF_get_pretreatment<- for INS->$variable<-" "Please verify"
        }
      }
      "mom_path_name" {
        set returnvalue $path_name
        set variable_exists 1
      }
      "tag" {
        if {[info exists mom_operation_info($path_name,operation_id)]} {
          set returnvalue $mom_operation_info($path_name,operation_id)
          set variable_exists 1
        }
      }
      "mom_tool_description" {
        if {[info exists mom_operation_info($path_name,tool_name)]} {
          set cutter_name $mom_operation_info($path_name,tool_name)
          if {[info exists mom_cutter_info($cutter_name,cutter_description)]} {
            set returnvalue $mom_cutter_info($cutter_name,cutter_description)
            set variable_exists 1
          }
        }
      }
      "mom_tool_axis,0" -
      "mom_tool_axis,1" -
      "mom_tool_axis,2" {
        set vars [split $variable ","]
        if {[info exists lib_pretreatment($path_name,[lindex $vars 0],[lindex $vars 1])]} {
          set returnvalue $lib_pretreatment($path_name,[lindex $vars 0],[lindex $vars 1])
          set variable_exists 1
        } elseif {[MOM_ask_oper_event_data $path_name last mom_tool_axis] == 1} {
          for {set i 0} {$i < 3} {incr i} {
            set lib_pretreatment($path_name,mom_tool_axis,$i) $mom_nxt_event_data(mom_tool_axis,$i)
          }
          set returnvalue $lib_pretreatment($path_name,[lindex $vars 0],[lindex $vars 1])
          set variable_exists 1
        }
      }
      "mom_operation_type" {
        if {[info exists mom_operation_info($path_name,template_subtype)]} {
          set returnvalue $mom_operation_info($path_name,template_subtype)
        }
        set variable_exists 1
      }
      default {
        regsub {^mom_} $variable "" trimmed_name
        if {[info exists mom_operation_info($path_name,tool_name)]} {
          set cutter_name $mom_operation_info($path_name,tool_name)
        }
        if {[info exists mom_operation_info($path_name,$trimmed_name)]} {
          set returnvalue $mom_operation_info($path_name,$trimmed_name)
          set variable_exists 1
        } elseif {[info exists cutter_name] && [info exists mom_cutter_info($cutter_name,$trimmed_name)]} {
          set returnvalue $mom_cutter_info($cutter_name,$trimmed_name)
          set variable_exists 1
        } else {
          set returnvalue ""
        }

        # Analysis of values from the old pretreatment
        if {[string match "" $returnvalue]} {
          set variable_exists 0

          if {[info exists tag] && [info exists variable] && [info exists lib_pretreatment($tag,$variable)]} {
            set returnvalue $lib_pretreatment($tag,$variable)
            set variable_exists 1
          } elseif {[info exists variable] && [info exists lib_pretreatment($variable)]} {
            set returnvalue $lib_pretreatment($variable)
            set variable_exists 1
          } else {
            #LIB_GE_abort_message "Unable to find a variable at INS->$mom_path_name<-" "Check INS->LIB_SPF_get_pretreatment $variable<-"
            set returnvalue ""
          }
        }
      }
    }
  } else {
    switch -- [string trim $variable] {
      "operation_list" -
      "operation_list__original" -
      "tag_list" -
      "tag_list__original" -
      "tool_name_list" -
      "tool_name_list__original" -
      "tool_number_list" -
      "tool_number_list__original"  {
        if {[info exists lib_pretreatment($variable)]} {
          set returnvalue $lib_pretreatment($variable)
        } else {
          LIB_GE_abort_message "There is no variable available at INS->LIB_SPF_get_pretreatment<- for INS->$variable<-" "Please verify"
        }
      }
      default     {

        set variable_exists 0

        if {[info exists tag] && [info exists variable] && [info exists lib_pretreatment($tag,$variable)]} {
          set returnvalue $lib_pretreatment($tag,$variable)
          set variable_exists 1
        } elseif {[info exists variable] && [info exists lib_pretreatment($variable)]} {
          set returnvalue $lib_pretreatment($variable)
          set variable_exists 1
        } else {
          #LIB_GE_abort_message "Unable to find a variable at INS->$mom_path_name<-" "Check INS->LIB_SPF_get_pretreatment $variable<-"
          set returnvalue ""
        }

      }
    }
  }

  # The case, if abort postrun
  if {![info exists returnvalue]} {set returnvalue ""}
  if {0 && ![string length [string trim $returnvalue]] && [lindex [info level -1] 0] != "LIB_SPF_pt_exists"} {MOM_log_message "No value at LIB_SPF_get_pretreatment for '$variable' found"}

  if {[lindex [info level -1] 0] == "LIB_SPF_pt_exists"} {
    return $variable_exists
  } else {
    return $returnvalue
  }

}
# <Documentation>
# This procedure reads variables that have been collected in the pretreatment postprocessor.
# Use the procedure LIB_SPF_pretreatment_add_var to tell the pretreatment postprocessor which variables should be collected.
# If a desired variable does not exist, an empty string is returned.
#
# Note: This procedure can only access information that is available after the first MOM_start_of_path event,
# such as variables coming from an UDE header.
# Use LIB_PT_get_header_var instead to access variables that precede the first MOM_start_of_path.
#
# <Arguments>
# variable
#   Name of the variable to read.
#   The following variables are always accessible:
#     axis_mode, mom_kin_is_turbo_output, mom_operation_type, mom_path_name, mom_tool_name, mom_tool_number, mom_tool_description,
#     tag, type, subtype, number, mom_toolpath_cutting_time, mom_tool_change_type, mom_machine_mode, limit,4th,max, limit,4th,min,
#     limit,5th,max, limit,5th,min, limit,x,max, limit,x,min, limit,y,max, limit,y,min, limit,z,max, limit,z,min,
#     csys_is_default, op_with_no_move, mom_out_angle_pos (value of intial / first move) and out_angle_pos_last (value of last move).
#   The following variable lists are always accessible (do not use sequence and path_name parameters):
#     operation_list, tag_list, tool_name_list, and tool_number_list.
#   All other variables must beidentified with the procedure LIB_SPF_pretreatment_add_var.
# sequence
#   Operation sequence to read.
#   Valid options are:
#     0 - Read value of current operation.
#     last - Read value in the last operation.
#     first - Read value in the first operation.
#     next - Read value in the next operation.
#     +/- x - Read x operations before or after the current operation.
# path_name
#   Reads the value in a given path_name instead of a specifc sequence. In this case, set sequence to 0.
# pathnamesequence (based on given the path_name)
#   Operation sequence to read based on the given path name.
#   In this case, set sequence to 0.
#   (Unfortunately, this is necessary in order not to negatively influence previous implementations.)
#   Valid options are:
#     0 - Read value of current operation.
#     last - Read value in the last operation.
#     first - Read value in the first operation.
#     next - Read value in the next operation.
#     +/- x - Read x operations before or after the current operation.
# <Example>
# set device_description [LIB_SPF_get_pretreatment mom_device_description]
# or
# set device_description [LIB_SPF_get_pretreatment mom_device_description -1]
# or
# set device_description [LIB_SPF_get_pretreatment mom_device_description 0 $::path_name]
# or
# set device_description [LIB_SPF_get_pretreatment mom_device_description 0 $::path_name -1]
#____________________________________________________________________________________________
proc LIB_SPF_get_pretreatment_next_occurrence {variable {event ""}} {

  set i 1

  if {$event != ""} {
    set search_var $event,$variable
  } else {
    set search_var $variable
  }

  set next_occurrence 0

  while {[LIB_SPF_pt_exists mom_path_name $i]} {
    if {[LIB_SPF_pt_exists $search_var $i]} {
      set  next_occurrence $i
      break
    }
    incr i
  }
  return $next_occurrence
}
# <Documentation>
# This procedure returns the sequence index of next operation containing a defined pretreatment variable
# This could be helpful e.g. to find next operation with specific UDE attached
# Note: This procedure can only access information that is available after the first MOM_start_of_path
#
# <Arguments>
# variable
#   Variable to be searched for
# event
#   Optional argument. Event name for which the pretreatment variable was stored
#
# <Returnvalue>
# Integer - 0 : no next occurence of variable , > 0 offset from current operation (nth operation after current operation)
#
# <Example>
# proc LIB_SPF_pt_additional_variables_test {} {
#  LIB_SPF_pretreatment_add_var MOM_tool_change mom_cutter_libref
# }
# LIB_GE_command_buffer_edit_append MOM_start_of_path_LIB MOM_start_of_path_LIB_ENTRY_start {
#   set next_cutter_libref_occ [LIB_SPF_get_pretreatment_next_occurrence mom_cutter_libref]
#   if {$next_cutter_libref_occ != 0} {
#     MOM_output_literal ">> Next cutter_libref : [LIB_SPF_get_pretreatment mom_cutter_libref $next_cutter_libref_occ] (Pathname: [LIB_SPF_get_pretreatment mom_path_name $next_cutter_libref_occ])"
#   } else {
#     MOM_output_literal ">> No yext cutter_libref"
#   }
# } TestOutputCutterLibref
#
# or
#
# proc LIB_SPF_pt_additional_variables_test {} {
#  LIB_SPF_pretreatment_add_var MOM_my_ude mom_my_ude_var
# }
# LIB_GE_command_buffer_edit_append MOM_start_of_path_LIB MOM_start_of_path_LIB_ENTRY_start {
#   set next_ude_occ [LIB_SPF_get_pretreatment_next_occurrence mom_my_ude_var MOM_my_ude]
#   if {$next_ude_occ != 0} {
#     MOM_output_literal ">> Next UDE var : [LIB_SPF_get_pretreatment_eventbased MOM_my_ude mom_my_ude_var $next_ude_occ] (Pathname: [LIB_SPF_get_pretreatment mom_path_name $next_ude_occ])"
#   } else {
#     MOM_output_literal ">> No next UDE var"
#   }
# } TestOutputUDE
#____________________________________________________________________________________________
proc LIB_SPF_store_mom_vars {} {

  global lib_spf_mom_list
  set lib_spf_mom_list [lsort [info globals "mom_*"]]

  foreach var $lib_spf_mom_list {
    global $var lib_spf_stored_$var
    if {[array exist $var]} {
      array set lib_spf_stored_$var [array get $var]
    } else {
      set lib_spf_stored_$var [set $var]
    }
  }
}
# <Documentation>
# This procedure creates a backup of all current MOM variables in memory. The variables can be
# restored later on with LIB_SPF_restore_mom_vars.
# The reason for this procedure is that some actions, like  the procedure MOM_cycle_objects,
# lose some MOM variables due to the parallel postprocessing run.
# <Returnvalue>
# None.
# <Example>
# LIB_SPF_store_mom_vars
#____________________________________________________________________________________________
proc LIB_SPF_restore_mom_vars {} {

  global lib_spf_mom_list

  if {![info exists lib_spf_mom_list]} return

  foreach var $lib_spf_mom_list {
    global $var lib_spf_stored_$var
    if {[array exist lib_spf_stored_$var]} {
      array set $var [array get lib_spf_stored_$var]
      array unset lib_spf_stored_$var
    } else {
      set $var [set lib_spf_stored_$var]
      unset lib_spf_stored_$var
    }
  }
  unset lib_spf_mom_list
}
# <Documentation>
# This procedure corresponds to the procedure LIB_SPF_store_mom_vars. It restores the backup state
# created with LIB_SPF_store_mom_vars.
# The previous execution of LIB_SPF_store_mom_vars is necessary in order to restore the variables.
# <Returnvalue>
# None.
# <Example>
#  LIB_SPF_restore_mom_vars
#____________________________________________________________________________________________
proc LIB_SPF_is_vector {value} {

  set value [string trim $value]

  if {[regexp -linestop -lineanchor {([-+0-9\.]+)[\s]+([-+0-9\.]+)[\s]+([-+0-9\.]+)} $value]} {
    return 1
  } else {
    return 0
  }

}
# <Documentation>
# This procedure checks whether a value is a vector, point, or another value.
# <Arguments>
# value
#   Value to be checked.
# <Returnvalue>
# 1 - Value is a vector or point.
# 0 - Value is not a vector or point.
# <Example>
# name: Example with a vector
# code: set value "0 0 1"
#      set result [LIB_SPF_is_vector $value]
# desc: result = 1
# <Example>
# name: Example with a point
# code: set value "123.222 555.666 -111.999"
#      set result [LIB_SPF_is_vector $value]
# desc: result = 1
# <Example>
# name: Example with a non vector/non point
# code: set value "1.23"
#      set result [LIB_SPF_is_vector $value]
# desc: result = 0
#____________________________________________________________________________________________
proc LIB_SPF_is_vector_equal {Value1 {Value2 ""} {Tolerance "0.00001"}} {

  global lib_ge_log_message

  if {$Value2 == ""} {set Value2 $Value1}

  set error [JEDLL_VEC3_UNITIZE $Value1 $Tolerance magnitude vector]
  if {$error!=0} {lappend lib_ge_log_message "Command JEDLL_VEC3_UNITIZE $::errorInfo"}
  set Value1 $jedll_vec3_unitize(vector)
  set error [JEDLL_VEC3_UNITIZE $Value2 $Tolerance magnitude vector]
  if {$error!=0} {lappend lib_ge_log_message "Command JEDLL_VEC3_UNITIZE $::errorInfo"}
  set Value2 $jedll_vec3_unitize(vector)

  if {![LIB_SPF_is_vector $Value1] || \
      ![LIB_SPF_is_vector $Value2]} {
    return 0
  }

  set count 0
  for { set n 0 } { $n <= 2 } { incr n } {
    set Value2_small [expr [lindex $Value2 $n]-$Tolerance]
    set Value2_big [expr [lindex $Value2 $n]+$Tolerance]

    if {[lindex $Value1 $n] > $Value2_small && [lindex $Value1 $n] < $Value2_big} {
      incr count
    } else {
      return 0
    }
  }

  return 1
}
# <Internal Documentation>
# This function compares two vectors and examines if they have the same direction within a
# specified tolerance.
# <Internal Arguments>
# Value1
#   First vector as string list
# Value2
#   Second vector as string list
# Tolerance
#   Tolerance to detect equality within
# <Internal Returnvalue>
# 1 if vectors have the same direction
# 0 if not
#
# <Internal Example>
# set Result [LIB_SPF_is_vector_equal $Value1 $Value2 $Tolerance]
# Value1 "-0.9999999999999999 0.0000000000000000 0.0000000000000000"
# Value2 "1.0000000000000000 0.0000000002447645 0.0000000000000000"
#____________________________________________________________________________________________
proc LIB_SPF_is_matrix_equal {Value1 Value2 {Tolerance "0.00001"} {Elements 8}} {

  for { set n 0 } { $n <= $Elements } { incr n } {
    if {![EQ_is_equal [lindex $Value1 $n] [lindex $Value2 $n] $Tolerance]} {
      return 0
    }
  }

  return 1
}
# <Documentation>
# This procedure compares two matrixes and determines if they are equal within a specified tolerance.
# <Arguments>
# Value1
#   First matrix as string list
# Value2
#   Second matrix as string list
# Tolerance
#   Tolerance between the values used to detect equality.
# Elements
#   Number of matrix elements to compare. By default, a nine dimensional matrix has the elements 0-8 (zero based index).
# <Returnvalue>
# 1 - Matrices are equal.
# 0 - Matrices are not equal.
#
# <Example>
# name: Example 1
# code: set Value1 "-0.9 0.0 0.0 -0.9 0.0 0.0 -0.9 0.0 0.0 -0.9 0.0 0.0"
#      set Value2 "1.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0"
#      set Result [LIB_SPF_is_matrix_equal $Value1 $Value2]
# desc: result = 0
# <Example>
# name: Example 2
# code: set Value1 "0.99999 -0.00001 0.0 1.0 0.0 0.0 1.0 0.0 0.0"
#      set Value2 "1.0 0.0 0.0 1.0 0.0 0.0 1.0 0.0 0.0"
#      set Result [LIB_SPF_is_matrix_equal $Value1 $Value2]
# desc: result = 1
#____________________________________________________________________________________________
proc LIB_SPF_is_floating {value} {

  if {[LIB_SPF_is_number $value] && [regexp -nocase -- {[0-9]+\.[0-9]+} $value]} {
    if {[regexp -nocase -- {[0-9]+\.[^1-9]*$} $value]} {
      return 2
    } else {
      return 1
    }
  } else {
    return 0
  }

}
# <Documentation>
# This procedure checks whether a value is a floating number or not.
# This procedure also indicates if a value is noted with decimals but is equal to an integer value.
# <Arguments>
# value
#   Value to be checked.
# <Returnvalue>
# 0 - Not a floating number (for example, 1 or text)
# 1 - Floating number (for example, 1.234)
# 2 - Integer value followed by a decimal and zeros (for example, 1.000)
# <Example>
# name: Example with a floating number
# code: set result [LIB_SPF_is_floating -1.123]
# desc: result = 1
# <Example>
# name: Example with an integer followed by decimals
# code: set result [LIB_SPF_is_floating 2.000]
# desc: result = 1
# <Example>
# name: Example with an integer
# code: set value -3
#      set result [LIB_SPF_is_floating -3]
# desc: result = 0
#____________________________________________________________________________________________
proc LIB_SPF_is_integer {value {mode check_data_type}} {

  if {$::tcl_version >= 8.4} {
    if {$mode == "check_data_type"} {
      return [string is integer -strict $value]
    } elseif {$mode == "check_value"} {
      return [string is integer -strict [string trimright $value "."]]
    }
  } else {
    if {$mode == "check_data_type"} {
      set f %i
    } elseif {$mode == "check_value"} {
      set f %.0f
    }
  }

  if {[LIB_SPF_is_number $value] && ![catch {set test_number [format $f $value]}] && $test_number == $value} {
    return 1
  } else {
    return 0
  }

}
# <Documentation>
# This procedure detects if a given string represents an integer value or not.
# <Arguments>
# value
#   Value to be checked.
# mode
#   Check if the data type should be considered.
# Valid options are:
# check_data_type - Checks if string is an integer value.
# check_value - Checks first if string is a number and then if the number is equal to an integer value.
# <Returnvalue>
# 0 - Not an integer.
# 1 - Integer.
# <Example>
# name: Example with an integer
# code: set string 12
#      result [LIB_SPF_is_integer $string]
# desc: result = 1
# <Example>
# name: Example with an integer value followed by dot (default mode check_data_type)
# code: set string "12."
#      result [LIB_SPF_is_integer $string]
# desc: result = 0
# <Example>
# name: Example with an integer value followed by dot (optional mode check_value)
# code: set string 12.
#      result [LIB_SPF_is_integer $string check_value]
# desc: result = 1
#____________________________________________________________________________________________
proc LIB_SPF_is_number {value {compared "mathematically"}} {

  if {[string length [string trim $value]] == 0 || $compared == "mathematically" && [catch {set test_number [format %.3f [expr $value]]}]} {
    return 0
  } elseif {$compared == "character" && ![regexp {^(\+|\-+)?(\d+)?.?(\d+)?$} $value]} {
    return 0
  } else {
    return 1
  }

}
# <Documentation>
# This procedure checks if a given string represents a number in a valid TCL format.
# Note: Exponential notation is also considered as a valid number if checked mathematically (default).
# <Arguments>
# value
#   Value to be checked.
# compared
#   Type of check
# mathematically - Check number for valid TCL mathematical format.
# character - Check  number in normal decimal notation (regexp).
# <Returnvalue>
# 0 - String is a number.
# 1 - String is not a number.
# <Example>
# name: Example with a floating value
# code: set result [LIB_SPF_is_number 1.234]
# desc: result = 1
# <Example>
# name: Example with a floating value in exponential notation (default mode mathematically)
# code: set result [LIB_SPF_is_number 1.56819e-015]
# desc: result = 1
# <Example>
# name: Example with a floating value in exponential notation (optional mode character)
# code: set result [LIB_SPF_is_number 1.56819e-015]
# desc: result = 0
#____________________________________________________________________________________________
proc LIB_SPF_is_no_decimal {value} {

  return [regexp {^[^0-9]+$} $value]

}
# <Documentation>
# This procedure verifies that a given string does not contain numbers.
# <Arguments>
# value
#   Value to be checked.
# <Returnvalue>
# 0 - Contains a number.
# 1 - Does not contain any numbers.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_is_no_decimal "check this string"]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [LIB_SPF_is_no_decimal "check me 123"]
# desc: result = 0
# <Example>
# name: Example 3
# code: set result [LIB_SPF_is_no_decimal "1.234"]
# desc: result = 0
#____________________________________________________________________________________________
proc LIB_SPF_is_empty {value} {

  if {[string length [string trim $value]] > 0} {
    return 0
  } else {
    return 1
  }

}
# <Documentation>
# This procedure checks if a given string is empty (blanks are trimmed out before the check).
# <Arguments>
# value
#   String to be checked.
# <Returnvalue>
# 0 - String is not empty.
# 1 - String is empty.
# <Example>
# name: Example 1
# code: set string ""
#       set result [LIB_SPF_is_empty $string]
# desc: result = 1
# <Example>
# name: Example 2
# code: set string "  "
#      set result [LIB_SPF_is_empty $string]
# desc: result = 1
# <Example>
# name: Example 3
# code: set string "any text"
#      set result [LIB_SPF_is_empty $string]
# desc: result = 0
#____________________________________________________________________________________________
proc LIB_SPF_is_part_of_string {string part {case 0}} {

  switch -- $case {
    0 {return [regsub -nocase -- $part $string "" dummy]}
    1 {return [regsub -- $part $string "" dummy]}
  }

}
# <Documentation>
# This procedure checks if one string is a part of another string.
# <Arguments>
# string
#   String to be searched in.
# part
#   String to be searched for within the other string.
# case
#   Determines whether or not to check the case of the text when comparing strings.
# 1 - Check is case sensitive.
# 0 - Check is not case sensitive.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_is_part_of_string "Test for a string" string]
# desc: result = 1
# <Example>
# name: Example 1
# code: set result [LIB_SPF_is_part_of_string "Test for a string" STRING]
# desc: result = 1
# <Example>
# name: Example 1
# code: set result [LIB_SPF_is_part_of_string "Test for a string" STRING 1]
# desc: result = 0
#____________________________________________________________________________________________
proc LIB_SPF_is_divisible {value {divider 2}} {

  if {$value % $divider == 0} {
    # even
    return 1
  } else {
    # uneven
    return 0
  }

}
# <Documentation>
# This procedure checks if a given input value can be evenly divided. (2 is the default divider).
# The check is true if the divided resulting value is an integer value.
# <Arguments>
# value
#   Number to be checked.
# divider
#   Divider to be applied.
# <Returnvalue>
# 1 - Division result is an integer value
# 0 - Division result is not an integer (result is a decimal value)
# <Example>
# name: Example 1
# code: set result [LIB_SPF_is_divisible 20]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [LIB_SPF_is_divisible 21]
# desc: result = 0
# <Example>
# name: Example 3 with optional divider 3
# code: set result [LIB_SPF_is_divisible 9 3]
# desc: result = 1
#____________________________________________________________________________________________
proc LIB_SPF_array_to_vector {variable {elements "0 1 2"}} {

  upvar $variable response

  if {![info exists response] || ![array exists response]} {
    global $variable
    set response $variable

    set returnvalue ""
    for { set n 0 } { $n < [llength $elements] } { incr n } {
      lappend returnvalue [subst $[subst $response]($n)]
    }
    return $returnvalue
  }

  set returnvalue ""
  for { set n 0 } { $n < [llength $elements] } { incr n } {
    lappend returnvalue $response($n)
  }
  return $returnvalue
}
# <Documentation>
# This procedure converts a three dimensional array into a list. It is the corresponding
# procedure to LIB_SPF_vector_to_array.
# <Arguments>
# variable
#   Name of the array to be converted.
# elements
#   The array elements to be included in the list.
# <Returnvalue>
# String list.
# <Example>
# name: Example 1
# code: set MSYS_Origin [LIB_SPF_array_to_vector "mom_msys_origin"]
# desc: Creates a list from the variable array mom_sys_origin. The list corresponds to the result from the command: set MSYS_Origin "$mom_msys_origin(0) $mom_msys_origin(1) $mom_msys_origin(2)"
#____________________________________________________________________________________________
proc LIB_SPF_vector_to_array {delist variable {elements "0 1 2"}} {

  global $variable

  for { set n 0 } { $n < [llength $elements] } { incr n } {
    LIB_GE_set $variable\([lindex $elements $n]\) [lindex $delist $n]
  }
}
# <Documentation>
# This procedure converts a string list into a three-dimensional array.
# It is the procedure that corresponds to LIB_SPF_array_to_vector.
# <Arguments>
# delist
#   Defined string list to be be converted.
# variable
#   Name of the array to be created.
# elements
#   The array elements to be read from the list.
# <Returnvalue>
# None. The array is set directly.
# <Example>
# name: Example 1
# code: LIB_SPF_vector_to_array "$MSYS_Origin" "mom_msys_origin"
# desc: Creates the array mom_sys_origin and fills it with the values from MSYS_Origin.
#      This corresponds to:
#      set mom_msys_origin(0) "[lindex $MSYS_Origin 0]"
#      set mom_msys_origin(1) "[lindex $MSYS_Origin 1]"
#      set mom_msys_origin(2) "[lindex $MSYS_Origin 2]"
#____________________________________________________________________________________________
proc LIB_SPF_matrix_to_list {variable {elements 8}} {

  global $variable

  for { set n 0 } { $n <= $elements } { incr n } {
    append result [subst $$variable\($n\)]
    if {$n < $elements} {append result " "}
  }

  return $result
}
# <Documentation>
# This procedure converts a dimensional matrix into a list.
# <Arguments>
# variable
#   Name of the matrix to be converted.
# elements
#   Number of elements in the matrix to be converted. By default, a nine dimensional matrix has the elements 0-8 (zero based index).
# <Returnvalue>
# String list.
# <Example>
# name: Example 1
# code: set CSYS_matrix [LIB_SPF_matrix_to_list mom_csys_matrix 11]
# desc: Creates a list from the twelve dimensional matrix mom_csys_matrix.
#____________________________________________________________________________________________
proc LIB_SPF_list_reverse {list} {

  set res {}
  set i [llength $list]
  while {$i} {lappend res [lindex $list [incr i -1]]}
  set res

}
# <Documentation>
# This procedure reverses the order of a list.
# <Arguments>
# list
#   String list to be reversed.
# <Returnvalue>
# Reversed string list.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_list_reverse [list "first element" "second element" "some other text" 1 2 3 4 5]]
# desc: result = 5 4 3 2 1 "some other text" "second element" "first element"
# <Example>
# name: Example 2
# code: set result [LIB_SPF_list_reverse [list "" "" "" 1 2 3 4 5 "" "" 6 7 ""]]
# desc: result = {} 7 6 {} {} 5 4 3 2 1 {} {} {}
#      Note: Empty elements are conserved in the list.
#____________________________________________________________________________________________
proc LIB_SPF_lprepend {listVar args} {

  upvar 1 $listVar l
  lappend l
  set l [concat $args $l[set l {}]]
}
# <Documentation>
# This procedure puts the values at the start of the list.
# <Arguments>
# var
#   String list to be extend.
# args
#   String list to be added to the beginning at the list.
# <Returnvalue>
# Extend string list.
# <Example>
# name: Example 1
# code: set result "initial"
# code: set result [LIB_SPF_lprepend result "extend"]
# desc: result = extend initial
#____________________________________________________________________________________________
proc LIB_SPF_ltreatment {list processing {prepend ""} {append ""} {check 1}} {

  if {[string length $prepend]} {set list [concat [LIB_SPF_lprepend list $prepend]]}
  if {[string length $append]} {set list [concat [lappend list $append]]}
  set processing [split [string trim "$processing" "|"] "|"]
  foreach {control element} $processing {
    if {$check && ![llength [info commands [lindex $element 0]]]} {continue}
    switch -- $control {
      append - end {
        lappend list $element

      }
      prepend - start - beginning {
        LIB_SPF_lprepend list $element
      }
      default {
        if {[regexp -- {[0-9]+} $control]} {set list [linsert $list $control $element]}
      }
    }

  }
  return $list
}
# <Documentation>
# This procedure handles lists and combines these
# <Arguments>
# list
#   String list to be extend.
# processing
#   String list to be processing, purpose of use and procedure separated by a pipe sign.
#   Options: append / start and prepend / end or a number for the index to be inserted
# prepend
#   String list to be prepend.
# append
#   String list to be append.
# check
#   Option to check whether it is a command with 0=No/1=Yes
# <Returnvalue>
# Extend string list.
# <Example>
# name: Example 1
# code: set processing "prepend|LIB_CTRL_linear_move_turbo start|append|LIB_CTRL_linear_move_turbo end"
# code: set list [LIB_SPF_ltreatment [CONF_Turbo_Templates linear_template_turbo] $processing "MOM_linear_move_turbo_LIB"]
# desc: result = {LIB_CTRL_linear_move_turbo start} MOM_linear_move_turbo_LIB linear_template_turbo {LIB_CTRL_linear_move_turbo end}
#____________________________________________________________________________________________
proc LIB_SPF_list_trim_left {list} {

  for { set n 0 } { $n < [llength $list] } { incr n } {
    if {![string match "" [string trim [lindex $list $n]]]} {break}
  }
  return [lrange $list $n end]

}
# <Documentation>
# This procedure trims empty elements at the beginning of a list.
# <Arguments>
# list
#   String list to be left trimmed.
# <Returnvalue>
# Trimmed string list.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_list_trim_left [list "" "" "" 1 2 3 4 5 "" "" 6 7 ""]]
# desc: result = 1 2 3 4 5 {} {} 6 7 {}
#      Only empty elements at the beginning of the list are trimmed.
#____________________________________________________________________________________________
proc LIB_SPF_list_trim_right {list} {

  set list [LIB_SPF_list_reverse $list]
  for { set n 0 } { $n < [llength $list] } { incr n } {
    if {![string match "" [string trim [lindex $list $n]]]} {break}
  }
  set list [lrange $list $n end]
  return [LIB_SPF_list_reverse $list]

}
# <Documentation>
# This procedure trims empty elements at the end of a list.
# <Arguments>
# list
#   String list to be right trimmed.
# <Returnvalue>
# Trimmed string list.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_list_trim_right [list "" "" "" 1 2 3 4 5 "" "" 6 7 ""]]
# desc: result = {} {} {} 1 2 3 4 5 {} {} 6 7
#      Only empty elements at the end of the list are trimmed.
#____________________________________________________________________________________________
proc LIB_SPF_list_trim {list} {

  set list [LIB_SPF_list_trim_left $list]
  return [LIB_SPF_list_trim_right $list]

}
# <Documentation>
# This procedure trims empty elements at the beginning and the end of a list.
# <Arguments>
# list
#   String list to be trimmed on both sides.
# <Returnvalue>
# Trimmed string list.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_list_trim [list "" "" "" 1 2 3 4 5 "" "" 6 7 ""]]
# desc: result = 1 2 3 4 5 {} {} 6 7
#      Empty elements at both sides of the list are trimmed.
#____________________________________________________________________________________________
proc LIB_SPF_list_trim_elements {list} {

  while {[regsub -all "\{ " $list "\{" list]} {}
  while {[regsub -all " \}" $list "\}" list]} {}
  return $list

}
# <Documentation>
# This procedure trims each element within a list.
# <Arguments>
# list
#   String list to be trimmed on both sides.
# <Returnvalue>
# Trimmed string list.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_list_trim_elements [list "" "" "" " 1 " 2 "3 " 4 " 5" "" "" 6 7 ""]]
# desc: result = {} {} {} 1 2 3 4 5 {} {} 6 7 {}
# Each element of the list is trimmed on both sides.
# Note: Empty elements are conserved.
#____________________________________________________________________________________________
proc LIB_SPF_list_non_common_elements {list1 list2} {

  if {[llength $list2] > [llength $list1]} {
    set result_list $list2
    set pattern_list $list1
  } else {
    set result_list $list1
    set pattern_list $list2
  }

  foreach pattern $pattern_list {
    set ind [lsearch -exact $result_list $pattern]

    if {$ind > -1} {
      set result_list [lreplace $result_list $ind $ind]
    } else {
      lappend result_list $pattern
    }
  }
  return $result_list
}
# <Documentation>
# This procedure returns a list of elements that are not common in two given lists.
# <Arguments>
# list1
#   First list.
# list2
#   Second list.
# <Returnvalue>
# List of non-common list elements.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_list_non_common_elements "a b c d" "a b d"]
# desc: result = c
# <Example>
# name: Example 2
# code: set result [LIB_SPF_list_non_common_elements "a b c d" "a b d  1 2 3"]
# desc: result = c 1 2 3
#____________________________________________________________________________________________
proc LIB_SPF_divide_list {list spliter exclusion seperator trailer} {

  regsub -all $spliter $list "${spliter}@" list
  set list [split $list "@"]
  set newlist ""
  foreach e $list {
    set e [string trim $e]
    if {![regexp -nocase -- $exclusion $e]} {
      regsub -all $seperator $e "@$seperator" e
      regsub -all $trailer $e "@$trailer" e
      set e [split $e "@"]
    }
    lappend newlist $e
  }
  if {[string length $newlist] > 0} {return $newlist} else {return $list}

}
# <Internal Documentation>
#
# Trim all elements in a list
# Inputvalue:
# CYCL DEF 200 DRILLING ~ Q200=2. ;SETUP CLEARANCE ~ Q201=-2.5 ;DEPTH ~ Q206=251. ;FEED RATE FOR PLUNGING
# Outputvalue:
# {CYCL DEF 200 DRILLING ~} {Q200=2. {;SETUP CLEARANCE } ~} {{Q201=-2.5 } {;DEPTH } ~} {{Q206=251. } {;FEED RATE FOR PLUNGING } ~}
#
# <Internal Example>
# [LIB_SPF_divide_list $list "~" "CYCL" ";" "~"]
#
#____________________________________________________________________________________________
proc LIB_SPF_list_to_table {in {padding 0} {firstelement 0} {leader ""} {as_list 0}} {

  set out [lrange $in 0 [expr $firstelement - 1]]
  set in [lrange $in $firstelement end]

  set result {}
  array set lengths {}
  # Determine the longest element in each column
  foreach line $in {
    set colnum 1
    foreach column $line {
      set length [string length $column]
      if {[info exist lengths($colnum)]} {
        if {$lengths($colnum) < $length} {
          set lengths($colnum) $length
        }
      } else {
        set lengths($colnum) $length
      }
      incr colnum
    }
  }

  if {$firstelement} {
    foreach e $out {
      append result $e
      append result "\n"
    }
  }

  # Format the output
  foreach line $in {
    set colnum 1
    set maxcol [llength $line]
    append result $leader
    foreach column $line {
      if {$colnum < $maxcol} {
        append result [
        format %-*s [
        expr {$lengths($colnum) + 1 + $padding}] $column]
      } else {
        append result $column
      }
      incr colnum
    }
    append result "\n"
  }
  if {$as_list} {set result [split $result "\n"]}
  return $result

}

# <Documentation>
# This procedure formats a string list into a table form. Every column of the table is aligned to the longest element of
# the respective column.
# <Arguments>
# in
#   String list to be formatted.
# padding
#   Padding between each column.
# firstelement
#   Number of the first line to be considered for the alignment. Corresponds to the index of the string list.
# leader
#   Character(s) to be put at the beginning of every line.
# as_list
#   Determines how
# 0 - Returns a string with line breaks.
# 1 - Returns a string list.
# <Returnvalue>
#   Formatted string with line breaks or. a formatted string list.
# <Example>
# name: Coordinate list (string with line breaks)
# code: set result [LIB_SPF_list_to_table [list "X1" "X10 Y1" "X100 Y10" "X1000 Y10 Z100"]]
# desc: The result is the following string:
#       X1
#       X10   Y1
#       X100  Y10
#       X1000 Y10 Z100
# <Example>
# name: Operation list (string list)
# code:  foreach e [LIB_SPF_get_pretreatment operation_list] {
#           lappend oplist "( Operation $e )"
#       }
#       set result [LIB_SPF_list_to_table $oplist 2 0 \; 1]
#       foreach e $result {
#           MOM_output_literal $e
#       }
# desc: The result is the output of an operation list into the NC code output file, such as:
#      N100 ;(   Operation   PLANAR_PROFILE        )
#      N110 ;(   Operation   PLANAR_PROFILE_COPY   )
#      N120 ;(   Operation   CONTUR_PROFILE        )
#____________________________________________________________________________________________
proc LIB_SPF_list_to_output {list {list_output "0 end"} {list_text "end end"}} {

  set list_output_start [lindex $list_output 0]
  set list_output_end [lindex $list_output 1]
  set list_text_start [lindex $list_text 0]
  set list_text_end [lindex $list_text 1]

  if {[LIB_SPF_is_no_decimal $list_output_end]} {set list_output_end 999}
  if {[LIB_SPF_is_no_decimal $list_text_end]} {set list_text_end 999}

  for { set n 0 } { $n <= [llength $list] } { incr n } {
    if {$n >= $list_output_start && $n <= $list_output_end} {
      MOM_output_literal [lindex $list $n]
    } elseif {$n >= $list_text_start && $n <= $list_text_end} {
      MOM_output_text [lindex $list $n]
    } else {
      MOM_output_to_listing_device [lindex $list $n]
    }
  }

}
# <Internal Documentation>
#
# Output the content of a list line by line to the nc-code
#
# <Internal Example>
# LIB_SPF_list_to_output [list "1" "2" "3"] "0 0" "1 end"
#____________________________________________________________________________________________
proc LIB_SPF_extract_string {string leading_blanks text trailed_blanks} {

  upvar 1 $leading_blanks ResultVariable_1
  upvar 1 $text ResultVariable_2
  upvar 1 $trailed_blanks ResultVariable_3

  set leading_blanks "" ; set text "" ; set trailed_blanks ""
  regexp -- {(^ *)(.+?)( *$)} $a string leading_blanks text trailed_blanks

  set ResultVariable_1 $leading_blanks
  set ResultVariable_2 $text
  set ResultVariable_3 $trailed_blanks

}
# <Internal Documentation>
#
# Extract from a string the leading and trailed blanks and the text
#
# e.g.
# " This is a Text   "
#
# leading_blanks  " "
# text      "This is a Text"
# trailed_blanks  "   "
#
# <Internal Example>
# set error [LIB_SPF_extract_string $string leading_blanks text trailed_blanks]
# Returnvariables are leading_blanks text trailed_blanks
# !!! Attention at defined dollar signs !!!
#____________________________________________________________________________________________
proc LIB_SPF_eliminate_zero {value {decimal_places 4} {splitter ""} {leading_zeros 1}} {

  global tcl_version tcl_precision

  # Fix for TCL8.6 -> expected floating-point number but got "000008" (looks like invalid octal number)
  if {[info tclversion] >= 8.6 && [regexp {(^[-+]?)([0]{1,})([0-9]?)([0-9\.]+$)} $value all a b c d]} {
    if {[string length $b] == 1} {
      if {!$leading_zeros} {set b ""}
      set c "$b$c"
    }
    if {$leading_zeros && $d < 1 && [string match "" $c]} {
      set c "0"
    }
    set value "$a$c$d"
  }

  if {$decimal_places >= 0} {
    set form "%.${decimal_places}f"
    set w0 [format "$form" $value]
  } else {
    set w0 [format "%.${tcl_precision}f" $value]
  }
  set w [string trimleft $w0 "0"]
  if {[regexp "\\." $w0]} {set w [string trimright $w "0"]}
  if {$splitter == ""} {set w2 [string trimright $w "."]} else {set w2 $w}
  if {$w2 == "." || $w2 == ""} {set w2 0}
  if {$leading_zeros && [string range $w2 0 0] == "."} {
    set w2 "0$w2"
  } elseif {$leading_zeros && [string range $w2 0 1] == "-."} {
    set w2 "-0[string range $w2 1 end]"
  }
  if {[LIB_GE_string_equal $w2 "-0"]} {set w2 0}
  if {$decimal_places != "" && $decimal_places < 0 && [LIB_SPF_is_integer $w2]} {append w2 "."}
  if {$splitter != "" && [string match 0 $w2]} {set w2 "0."}

  return $w2

}
# <Documentation>
# This procedure formats a decimal number into a specified string format
# and rounds it to the desired number of decimals.
# It also removes zeros beyond the last significant digit of the formatted value.
# <Arguments>
# value
#   Value to be formatted.
# decimal_places
#   Number of decimals to be output.
# splitter
#   If set to . a value of zero is returned as 0.
# <Returnvalue>
# Formated number as string value.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_eliminate_zero "12.3456789"]
# desc: result = 12.3457
# <Example>
# name: Example 2
# code: set result [LIB_SPF_eliminate_zero "12.3456789" 3]
# desc: result = 12.346
# <Example>
# name: Example 3
# code: set result [LIB_SPF_eliminate_zero "0.0034" 0 .]
# desc: result = 0.
# <Example>
# name: Example 4
# code: set result [LIB_SPF_eliminate_zero "0.340" 4 "" 0]
# desc: result = .34
#____________________________________________________________________________________________
proc LIB_SPF_eliminate_zero_inline {line {word_separator 0} {max_decimal_place 3} {iterationen 25}} {

  global mom_sys_control_out

  set commandcheck(LIB_SPF_eliminate_zero_inline_ENTRY) [llength [info commands LIB_SPF_eliminate_zero_inline_ENTRY]]

  if {$commandcheck(LIB_SPF_eliminate_zero_inline_ENTRY)} {LIB_SPF_eliminate_zero_inline_ENTRY "start" $line}

  if {[regexp -nocase -- \\$mom_sys_control_out $line]} {return $line}
  set check 0 ; set linebackup $line ; set splitter ""

  regsub -all -- "-0," $line "0," line
  regsub -all -- ", " $line "," line
  while {[regsub -all -- "(?q),,)" $line ",)" line]} {}
  regsub -all -- "(?q),)" $line ")" line

  set regexp "\(\[-+\]?\\\d+\\\.\\\d\{1,\}\[eE\]+\[-+\\\d\]+|\[-+\]?\\\d+\\\.\\\d\{[expr $max_decimal_place +1],\}\[-+eE\\\d\]*|\[-+\]?\\\d+\\\.\\\d0+\(?=\\\}\)|\[-+\]?\\\d+\\\.0?\(?=\\\.\\\}\)|\[-+\]?\\\d+\\\.0+\(?!\\\d\)\)"

  if {$word_separator} {
    set splitter "output"
  }
  while {[regexp -indices -- $regexp $line dummy ind]} {
    incr check

    # store start and end index of match
    foreach {s_ind e_ind} $ind {}

    # extract the value from line
    set value [string range $line $s_ind $e_ind]

    # replace exactly the section that was found before
    set line [string replace $line $s_ind $e_ind [LIB_SPF_eliminate_zero $value $max_decimal_place $splitter]]

    if {$check > $iterationen} {return $linebackup} ; # To prevent infinite loops
  }

  if {![regexp {;} $line]} {
    regsub -all "\\. " $line " " line
  } else {
    set newline ""
    foreach e $line {
      if {![regexp {[\{\}]} $e]} {
        if {![regexp {~} $e]} {regsub -all "\\. " $e " " e}
        lappend newline $e
      } elseif {[regexp {[\{\}]} $e]} {
        set newsub ""
        foreach x $e {
          if {![regexp {;} $x]} {
                  regsub -all "\\. " $x " " x
            lappend newsub $x
                } else {
                  lappend newsub $x
                }
        }
        lappend newline $newsub
      }
    }
    if {[string length $newline] > 0} {set line $newline}
  }
  set line [string trimright $line "\\."]

  if {[llength [info commands LIB_CTRL_modify_inline]] && $word_separator} {
    set line [LIB_CTRL_modify_inline $line $word_separator $max_decimal_place]
  }
  if {[llength [info commands LIB_CTRL_cleanup_inline]]} {
    set line [LIB_CTRL_cleanup_inline $line]
  }

  if {$commandcheck(LIB_SPF_eliminate_zero_inline_ENTRY)} {LIB_SPF_eliminate_zero_inline_ENTRY "end" $line}

  return $line

}
# <Documentation>
# This procedure does the same task as LIB_SPF_eliminate_zero but applies on every decimal
# expression within a line/string list.
# <Arguments>
# line
#   String (list) that contains decimal values.
# word_separator
#   Reserved for internal use.
# max_decimal_place
#   Number of decimals to be output.
# iterationen
#   Reserved for internal use.
# <Returnvalue>
# Formated number as string value.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_eliminate_zero_inline "CYCL DEF 200 Q200=2. Q201=-2.5 Q206=251. Q202=2.5 Q210=0.0 Q203=0.0 Q204=5. Q211=0.0"]
# desc: Formats all decimal values within the string:
# Before: CYCL DEF 200 Q200=2. Q201=-2.5 Q206=251. Q202=2.5 Q210=0.0 Q203=0.0 Q204=5. Q211=0.0
# After:  CYCL DEF 200 Q200=2 Q201=-2.5 Q206=251 Q202=2.5 Q210=0 Q203=0 Q204=5 Q211=0
#____________________________________________________________________________________________
proc MOM_catch_warning {{warning_info ""} {mode 0}} {

  global lib_spf listing_info
  global mom_warning_info mom_path_name

  if {$warning_info == ""} {
    LIB_SPF_rotary_axis_limit
    set warning_info $mom_warning_info
  }

  # do this to avoid warnings without message in case of LIB_SPF_convert_point
  if {$warning_info == ""} {return}


  if {![info exists mom_path_name] || $mom_path_name == ""} {
    set mom_path_name [LIB_GE_MSG "Selected operation"]
  }

  if {[array names listing_info] == ""} {
    LIB_GE_listing_format
  }

  if {[regexp -nocase -- "MISSING EVENT HANDLER" $warning_info] || [regexp "EREIGNIS-BEHANDLUNGSROUTINE" $warning_info]} {return}

  set info_orig ""
  regexp -nocase -- {(WARNING:)(.+)} $warning_info all warning information
  if {[info exists warning]} {set warning [string trim $warning]}
  if {[info exists information]} {
    set information [string trim $information]
    set info_orig $information
  } else {
    set information $warning_info
    set info_orig $information
  }

  if {[lsearch -exact $lib_spf(warningoutputcache,path) $mom_path_name] < 0} {set lib_spf(warningoutputcache) ""}

  #Bug2043, eliminate empty elements from list
  CONF_SPF_warning set no_warningoutput [lsearch -all -inline -not -exact [CONF_SPF_warning no_warningoutput] {}]

  if {[lsearch -exact [CONF_SPF_warning no_warningoutput] $warning_info] < 0 && [lsearch -exact [CONF_SPF_warning no_warningoutput] $info_orig] < 0} {
    if {[lsearch -exact $lib_spf(warningoutputcache) $warning_info] < 0 && [LIB_SPF_catch_warning_by_type] != "CONTINUE"} {
      incr lib_spf(warningcount)
      lappend lib_spf(warningoutputcache) $warning_info
      set references [lsearch -exact $lib_spf(entire,warningoutputcache) $warning_info]

      if {$mode == 1} {
        if {$references < 0} {
          if {[info exists lib_spf(warningoutputcache,count)]} {lappend lib_spf(warningoutput) $listing_info(line,1)}
          lappend lib_spf(warningoutput) [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG "GENERAL WARNING"]]]
          lappend lib_spf(warningoutput) $listing_info(line,8)
          if {!$::lib_flag(omit_translation)} {
            foreach e $warning_info {
              foreach i $e {
                lappend lib_spf(warningoutput) [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG $i]]]
              }
              lappend lib_spf(warningoutput) $listing_info(line,8)

            }
            set lib_spf(warningoutputcache,count) 1
          }
        }
        lappend lib_spf(entire,warningoutputcache) $warning_info
      } elseif {[lsearch -exact $lib_spf(warningoutputcache,path) $mom_path_name] < 0} {
        if {[info exists lib_spf(warningoutputcache,count)]} {lappend lib_spf(warningoutput) $listing_info(line,1)}
        set breakpoint 0
        foreach e [CONF_SPF_warning abort_based_warning] {
          # Now ignores upper and lower case when comparing
          if {[info exists information] && [string toupper $e] == [string toupper $information]} {
            set breakpoint 1
          }
        }
        if {$breakpoint} {
          lappend lib_spf(warningoutput) [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG "ERROR at operation: INS->$mom_path_name<-"]]]
        } else {
          lappend lib_spf(warningoutput) [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG "WARNING at operation: INS->$mom_path_name<-"]]]
        }
        lappend lib_spf(warningoutput) $listing_info(line,8)
        lappend lib_spf(warningoutputcache,path) $mom_path_name
        set lib_spf(warningoutputcache,count) 1
      }

      if {[info exists warning] && [info exists information]} {
        lappend lib_spf(warningoutput) [list SpecialOutput $mom_path_name "$information"]
        regsub -all "(?q) " $information "_" information
        set lib_spf(warningoutput,$mom_path_name,$information) 1
      } else {
        if {$references < 0} {
          lappend lib_spf(warningoutput) [list SpecialOutput $mom_path_name "$warning_info"]
          lappend lib_spf(warningoutput) $listing_info(line,1)
          regsub -all "(?q) " $warning_info "_" warning_info
          set lib_spf(warningoutput,$mom_path_name,$warning_info) 1
        }
      }
    } else {
      if {![info exists mom_path_name]} {set mom_path_name ""}
      if {![info exists warning_info]} {set warning_info ""}
      regsub -all "(?q) " $warning_info "_" warning_info
      regsub -all "(?q)\;" $warning_info "_" warning_info
      if {![info exists information]} {set information ""}
      regsub -all "(?q) " $information "_" information
      regsub -all "(?q)\;" $information ":" information

      set info_exists_info 0
      set info_exists_warninfo 0
      catch {set info_exists_info [info exists lib_spf(warningoutput,$mom_path_name,$information)]}
      catch {set info_exists_warninfo [info exists lib_spf(warningoutput,$mom_path_name,$warning_info)]}
      if {$info_exists_info} {
        incr lib_spf(warningoutput,$mom_path_name,$information)
      } elseif {$info_exists_warninfo} {
        incr lib_spf(warningoutput,$mom_path_name,$warning_info)
      }
    }

    if {[info exists info_orig] && ([lsearch -exact [CONF_SPF_warning abort_based_warning] $warning_info] >= 0 || [lsearch -exact [CONF_SPF_warning abort_based_warning] $info_orig] >= 0)} {
      # To abort the current event
      # - Whoever handles this condition MUST unset it to avoid any lingering effect!
      LIB_SPF_add_warning " - [LIB_GE_MSG "Postprocessing aborted!"]" 0 add
      MOM_abort $information
    }
    # mom_motion_type is only available if turbo off or advanced turbo
    if {([info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE") || ([info exists ::mom_kin_is_turbo_output] && $::mom_kin_is_turbo_output == "FALSE")} {
      if {[info exists info_orig] && ([lsearch -exact [CONF_SPF_warning abort_based_warning_cutting] $warning_info] >= 0 || [lsearch -exact [CONF_SPF_warning abort_based_warning_cutting] $info_orig] >= 0) && \
        [info exists ::mom_motion_type] && ($::mom_motion_type == "CUT" || $::mom_motion_type == "FIRSTCUT" || $::mom_motion_type == "STEPOVER" )} {
        # To abort the current event
        # - Whoever handles this condition MUST unset it to avoid any lingering effect!
        LIB_SPF_add_warning " - [LIB_GE_MSG "Postprocessing aborted!"]" 0 add
        MOM_abort $information
      }
    }
  }
}
# <Internal Documentation>
#
# Warnings will be captured in the list variable std_warnings and will be
# output into the listing of the header of the listing window
# ignored - if listed in list variabel
#
# <Internal Example>
# called from Manufacturing Output Manager
#
# >> The arguments are black box toggles <<
#     These are therefore not described
#____________________________________________________________________________________________
proc LIB_SPF_catch_warning_output {} {

  eval global [uplevel #0 info vars]
  global lib_spf_warning_dialog_box

  if {[info exists mom_run_number] && ![info exists mom_postprocessing_mode]} {return}

  if {[info exists mom_sys_warning_output] && $mom_sys_warning_output == "ON"} {
    set lib_spf(id,warning_file_full_name) [LIB_FH_open_file $lib_spf(value,warning_file_full_name) w]
  }

  if {[CONF_SPF_warning outputmessage] == 2 && [info exists mom_post_in_simulation] && ($mom_post_in_simulation == "CSE" || $mom_post_in_simulation == "MTD") || \
      [info exists mom_output_file_full_name] && $mom_output_file_full_name == "" && [info exists mom_post_in_simulation] && $mom_post_in_simulation == "SYN"} {
    set post_in_simulation 1
  } else {
    set post_in_simulation 0
  }

  if {[CONF_SPF_warning outputwarning] && $lib_spf(warningcount) > 0} {

    set frozenstate $lib_spf(warningcount)
    if {![info exists mom_postprocessing_mode]} {
      if {[CONF_SPF_warning outputmessage] == 1 || ([CONF_SPF_warning outputmessage] == 2 && !$post_in_simulation)} {
        # if output file name != mom_output_file_full_name, final file will only be created in MOM__halt. Therefore file will only be created after closing dialog box (Bug#1920)
        set lib_spf_warning_dialog_box "LIB_GE_error_message \{[LIB_GE_MSG "Number of warnings: INS->$frozenstate<-"]\} \"\" WARNING 1 [CONF_SPF_warning outputmessage]"
        if {$mom_output_file_full_name == ""} {
          eval $lib_spf_warning_dialog_box
        }
      }

      set lib_spf(warningoutput) [linsert $lib_spf(warningoutput) 0 $listing_info(line,1)]
      set lib_spf(warningoutput) [linsert $lib_spf(warningoutput) 0 [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG "Number of warnings: INS->$frozenstate<-"]]]]
    } else {
      if {[CONF_SPF_warning outputmessage] == 1 || ([CONF_SPF_warning outputmessage] == 2 && !$post_in_simulation)} {
        # if output file name != mom_output_file_full_name, final file will only be created in MOM__halt. Therefore file will only be created after closing dialog box (Bug#1920)
        set lib_spf_warning_dialog_box "LIB_GE_error_message \{[LIB_GE_MSG "Number of warnings channel INS->$mom_channel_id: $frozenstate<-"]\} \"\" WARNING 1 [CONF_SPF_warning outputmessage]"
        if {$mom_output_file_full_name == ""} {
          eval $lib_spf_warning_dialog_box
        }
      }

      set lib_spf(warningoutput) [linsert $lib_spf(warningoutput) 0 $listing_info(line,1)]
      set lib_spf(warningoutput) [linsert $lib_spf(warningoutput) 0 [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG "Number of warnings channel INS->$mom_channel_id: $frozenstate<-"]]]]
    }
    set lib_spf(warningoutput) [linsert $lib_spf(warningoutput) 0 $listing_info(line,1)]
    set lib_spf(warningoutput) [linsert $lib_spf(warningoutput) 0 ""]
    catch {
      foreach e $lib_spf(warningoutput) {

        if {[regexp -nocase -- "SpecialOutput" [lindex $e 0]]} {
          set command [lindex $e 1]
          regsub -all "(?q) " $command "_" command
          set search [string trim [lindex $e 2]]
          regsub -all "(?q) " [lindex $e 2] "_" search
          if {[info exists search]} {regsub -all "(?q)\;" $search ":" search ; regsub -all "(?q)\." $search "_" search ; regsub -all "(?q)\'" $search "_" search}
          if {[info exists search] && ![info exists lib_spf(warningoutput,$command,$search)]} {
            set e [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_string_range_toupper [lindex $e 2] 0 0] ""]]
          } else {
            set e [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_string_range_toupper [lindex $e 2] 0 0] "$lib_spf(warningoutput,[lindex $e 1],$search)"]]
          }
        }

        set modified 0
        if {[regexp -nocase -- {(SUBST->([^<]+)<-)} $e all search command]} {
          set command [subst $command]
          regsub -- (?q)$search $e "$command" e
          set modified 1
        }
        if {[regexp -nocase -- {(INS->([^<]+)<-)} $e all search command]} {
          regsub -- (?q)$search $e "$command" e
          set modified 1
        }
        if {$modified} {
          set e [LIB_DC_format_string $listing_info(line,11) [list [string trim [string trim $e "|"]]]]
        }

        if {[string length $lib_spf(id,warning_file_full_name)] == 0} {
          MOM_output_to_listing_device $e
        } else {
          puts $lib_spf(id,warning_file_full_name) $e
        }
      }
    }
    if {[string length $lib_spf(id,warning_file_full_name)] > 0} {
      MOM_output_to_listing_device $listing_info(line,1)
      MOM_output_to_listing_device [LIB_DC_format_string $listing_info(line,11) [list [LIB_GE_MSG "Check INS->$lib_spf(value,warning_file_full_name)<- for any Errors/Warnings during postprocessing"]]]
      MOM_output_to_listing_device $listing_info(line,1)
    }

    MOM_output_to_listing_device ""
    MOM_output_to_listing_device ""
  }

  if {[string length $lib_spf(id,warning_file_full_name)] > 0} {
    LIB_FH_close_file $lib_spf(id,warning_file_full_name)
  }
}
# <Internal Documentation>
#
# Output all warnings if exists, controlled over flag lib_spf(outputwarning)
# It's called from MOM_end_of_program
#
# <Internal Example>
# set error [LIB_SPF_catch_warning_output]
#____________________________________________________________________________________________
proc LIB_SPF_add_warning {text {mode 0} {function ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_spf

  switch -- $function {
    "add"
    {
      if {![LIB_SPF_is_part_of_string [lindex [lindex $lib_spf(warningoutput) end] end] $text]} {
        set replacestring [concat [lrange [lindex $lib_spf(warningoutput) end] 0 [expr [llength $lib_spf(warningoutput)]-2]] [list [lindex [lindex $lib_spf(warningoutput) end] end]$text]]
        set varstring_old [lindex [lindex $lib_spf(warningoutput) end] end]
        regsub -all "(?q) " $varstring_old "_" varstring_old
        if {[info exists lib_spf(warningoutput,$::mom_path_name,$varstring_old)]} {
          set varstring "[lindex [lindex $lib_spf(warningoutput) end] end]$text"
          regsub -all "(?q) " $varstring "_" varstring
          if {[info exists lib_spf(warningoutput,$::mom_path_name,$varstring)] && $lib_spf(warningoutput,$::mom_path_name,$varstring) == $lib_spf(warningoutput,$::mom_path_name,$varstring_old)} {return}
          set lib_spf(warningoutput,$::mom_path_name,$varstring) $lib_spf(warningoutput,$::mom_path_name,$varstring_old)
        }
        set lib_spf(warningoutput) [lreplace [K $lib_spf(warningoutput) [set list {}]] end end $replacestring]
      }
    }
    "direct"
    {
      MOM_catch_warning $text $mode
    }
    default
    {
      MOM_catch_warning [LIB_GE_MSG $text] $mode
    }
  }
}
# <Documentation>
# This procedure adds a warning message to the postprocess Information window.
# The name of the operation where the warning occurs is automatically added to the displayed information.
# The configuration object CONF_SPF_warning sets how warnings are being handled.
# <Arguments>
# text
#   Warning to be issued.
# mode
#   Reserved. Do not use.
# function
#   Reserved. Do not use.
# <Returnvalue>
# None.
# <Example>
# LIB_SPF_add_warning "Operation with no moves"
#____________________________________________________________________________________________
proc LIB_SPF_catch_warning_by_type {} {

  global lib_spf

  if {[CONF_SPF_warning catch_warning_by_type]} {
    if {$lib_spf(opertype) == 100 && ($lib_spf(opersubtype) == 1100 || $lib_spf(opersubtype) == 1200 || $lib_spf(opersubtype) == 1300)} {
      return "CONTINUE"
    }
  }

  return "OK"

}

# <Documentation>
# This procedure is evaluated from the postprocessor when warning messages issued with LIB_SPF_add_warning
# are being output and the configuration object CONF_SPF_warning catch_warning_by_type is set to 1.
# In this case, the warning is omitted, given that the current operation type is listed in this
# procedure.
# All existing operation types are defined in the file ..UGOPEN\uf_object_types.h.
# By default, warning messages are omitted for mill, lathe and wedm control operations.
# Here is the definition in uf_object_types.h:
# UF_machining_operation_type 100
#  UF_mach_mill_mc_subtype  1100
#  UF_mach_lathe_mc_subtype 1200
#  UF_mach_wedm_mc_subtype  1300
# <Returnvalue>
# CONTINUE - Warning should be omitted.
# OK -Warning should be output.
# <Example>
# name: Source code of the standard
# code: proc LIB_SPF_catch_warning_by_type {} {
# global lib_spf
# if {[CONF_SPF_warning catch_warning_by_type]} {
#   if {$lib_spf(opertype) == 100 && ($lib_spf(opersubtype) == 1100 || $lib_spf(opersubtype) == 1200 || $lib_spf(opersubtype) == 1300)} {
#     return "CONTINUE"
#   }
# }
# return "OK"
#}
# desc: This standard code omits warning messages for control operations.
#____________________________________________________________________________________________
proc LIB_SPF_ask_type_subtype {} {

  global lib_spf
  global mom_path_name
  global mom_operation_id mom_operation_type_enum mom_operation_type

  if {[info exists mom_operation_id] && [info exists mom_operation_type_enum]} {
    set lib_spf(opertag) $mom_operation_id
    set lib_spf(opertype) 100
    set lib_spf(opersubtype) $mom_operation_type_enum
  } elseif {[info exists mom_operation_id] && [info exists mom_operation_type] && $mom_operation_type != ""} {
    set lib_spf(opertag) $mom_operation_id
    set lib_spf(opertype) 100
    set lib_spf(opersubtype) $mom_operation_type
  } elseif {[llength [info commands JEDLL_GET_TYPE_SUBTYPE]]} {
    set error [LIB_GE_ask_type_subtype $mom_path_name lib_spf(opertag) lib_spf(opertype) lib_spf(opersubtype)]
  } else {
    LIB_GE_abort_message "Unknown ID at 'INS->$mom_path_name<-'" "Please verify"
  }

}
# <Documentation>
# This procedures gets the type and subtype of the current operation.
# The procedure is automatically called in MOM_start_of_path and is only documented here for your reference.
# The supported types correspond to the definitions in the file ...\UGOPEN\uf_object_types.h.
# <Returnvalue>
# Three standard variables are being set:
# - lib_spf(opertag)
# - lib_spf(opertype)
# - lib_spf(opersubtype)
# <Example>
# No example needed. Procedure is automatically called at the start of every operation path.
#____________________________________________________________________________________________
proc LIB_SPF_ask_operation_type {{path_name ""}} {
  global mom_operation_type mom_operation_id mom_path_name mom_tool_path_type mom_operation_type_enum
  global mom_operation_info

  if {[array exist mom_operation_info] && [info exists mom_operation_info($path_name,operation_type)]} {
    set tmp_operation_id $mom_operation_info($path_name,operation_type)
  }

  if {$path_name != "" && ![info exists tmp_operation_id]} {
    set returnvalue "0"
    return $returnvalue
  }

  if {[info exists mom_tool_path_type] && $mom_tool_path_type == "variable_axis"} {
    set returnvalue "lincir_5"
  } else {
    set returnvalue "lincir_3"
  }

  if {![info exists tmp_operation_id]} {
    if {![string compare "Hole Making" $mom_operation_type] || \
      ![string compare "Point to Point" $mom_operation_type] || \
      ![string compare "Drilling" $mom_operation_type] } {

      set returnvalue "point_3_2"
    }

    if {![string compare "Cylinder Milling" $mom_operation_type] || \
      ![string compare "Thread Milling" $mom_operation_type] || \
      ![string compare "Chamfer Milling" $mom_operation_type] || \
      ![string compare "Generic Feature Operation" $mom_operation_type] || \
      ![string compare "Radial Groove Milling" $mom_operation_type] } {

      set returnvalue "lincir_3_2"
    }

    if {$mom_operation_type_enum == 1000 || \
      $mom_operation_type_enum == 1020 || \
      $mom_operation_type_enum == 1030 || \
      $mom_operation_type_enum == 1040 } {

      set returnvalue "probe_3_2"
    }

  } else {
    # current operation type numbers   --  type "100"
    switch -- $tmp_operation_id {
      1    {set returnvalue "other"     ; # Obsolete          }
      2    {set returnvalue "other"     ; # Used for imported CLSF      }
      10   {set returnvalue "other"     ; # Obsolete          }
      110  {set returnvalue "lincir_3"    ; # Planar mill profile / pocket operation  }
      210  {set returnvalue "lincir_3"    ; # Fixed axis surface contouring   }
      211  {set returnvalue "lincir_5"    ; # Variable axis surface contouring    }
      260  {set returnvalue "lincir_3"    ; # Cavity Milling        }
      261  {set returnvalue "lincir_3"    ; # Face Milling        }
      262  {set returnvalue "lincir_3"    ; # Volume Milling        }
      263  {set returnvalue "lincir_3"    ; # Z-Level Milling       }
      264  {set returnvalue "point_3_2"   ; # Feature based hole milling      }
      265  {set returnvalue "lincir_3"  ; # Plunge milling        }
      266  {set returnvalue "TRUE"      ; # Variable axis Z-Level     }
      510  {set returnvalue "other"     ; # Rough Turning       }
      520  {set returnvalue "other"     ; # Finish Turning        }
      530  {set returnvalue "other"     ; # Turn Teachmode        }
      540  {set returnvalue "other"     ; # Thread Turning        }
      550  {set returnvalue "other"     ; # Centerline Drilling       }
      560  {set returnvalue "other"     ; # Turn auxiliary        }
      600  {set returnvalue "point_3_2"   ; # Hole making         }
      700  {set returnvalue "other"     ; # Wire EDM          }
      800  {set returnvalue "lincir_5"  ; # User defined milling      }
      900  {set returnvalue "lincir_5"  ; # Generic motion        }
      1000 {set returnvalue "probe_3_2"   ; # Probing of mill parts     }
      1010 {set returnvalue "other"     ; # Unused          }
      1020 {set returnvalue "probe_3_2"   ; # Probing of turned parts     }
      1030 {set returnvalue "probe_3_2"   ; # Probing using a milling tool    }
      1040 {set returnvalue "probe_3_2"   ; # Probing using a turing tool     }
      1050 {set returnvalue "other"     ; # Robot related generic motion    }
      1100 {set returnvalue "other"     ; # Mill machine control      }
      1200 {set returnvalue "other"     ; # Lathe machine control     }
      1300 {set returnvalue "other"     ; # Wire EDM machine control      }
      1400 {set returnvalue "other"     ; # Lathe user defined        }
      1500 {set returnvalue "other"     ; # Wire EDM user defined     }
      1600 {set returnvalue "other"     ; # Operation for mass editing      }
      1700 {set returnvalue "other"     ; # Thread milling        }
      1800 {set returnvalue "other"     ; # insp_tolerance_subtype                }
      1900 {set returnvalue "other"     ; # insp_path_subtype                     }
      2000 {set returnvalue "other"     ; # insp_output_subtype                   }
      2100 {set returnvalue "other"     ; # insp_misc_subtype                     }
      2200 {set returnvalue "other"     ; # insp_align_subtype        }
      2300 {set returnvalue "other"     ; # insp_sensor_subtype       }
      2400 {set returnvalue "other"     ; # insp_construct_subtype      }
      2500 {set returnvalue "other"     ; # insp_bounding_feature_subtype   }
      2600 {set returnvalue "other"     ; # insp_feature_subtype      }
      2700 {set returnvalue "point_3_2"   ; # Hole milling        }
      2800 {set returnvalue "point_3_2"   ; # mach_canned_cycle_subtype     }
      2900 {set returnvalue "other"     ; # Laser teach mode        }
      3000 {set returnvalue "point_3_2"   ; # mach_hole_drilling_subtype      }
      3100 {set returnvalue "other"     ; # Grove milling       }
      3200 {set returnvalue "other"     ; # Chamfer Milling operation     }
      3300 {set returnvalue "other"     ; # Radial Groove Milling Operation   }
      3400 {set returnvalue "other"     ; # mach_planar_additive_subtype    }
      3500 {set returnvalue "other"     ; # Generic (machining) Feature Operation }
      3600 {set returnvalue "lincir_5"  ; # mach_device_gmc_subtype     }
    }

    # obsolete operation type numbers   --  type "107"
    switch -- $tmp_operation_id {
      11   {set returnvalue "other"     ; # mach_mill_post_cmnds_subtype    }
      13   {set returnvalue "other"     ; # mach_lathe_post_cmnds_subtype   }
      17   {set returnvalue "other"     ; # mach_wed_post_cmnds_subtype     }
      220  {set returnvalue "lincir_5"    ; # mach_gssm_main_op_subtype     }
      221  {set returnvalue "lincir_5"    ; # mach_gssm_sub_op_subtype      }
      222  {set returnvalue "lincir_5"    ; # mach_gssm_grip_subtype      }
      230  {set returnvalue "lincir_5"    ; # mach_param_line_subtype     }
      240  {set returnvalue "lincir_5"    ; # mach_zig_zag_surf_subtype     }
      250  {set returnvalue "lincir_3"    ; # mach_rough_to_depth_subtype     }
      310  {set returnvalue "other"     ; # mach_lathe_rough_subtype      }
      320  {set returnvalue "other"     ; # mach_lathe_finish_subtype     }
      330  {set returnvalue "other"     ; # mach_lathe_groove_subtype     }
      340  {set returnvalue "other"     ; # mach_lathe_thread_subtype     }
      350  {set returnvalue "point_3_2"   ; # mach_drill_subtype        }
      360  {set returnvalue "other"     ; # mach_lathe_face_subtype     }
      450  {set returnvalue "point_3_2"   ; # mach_point_to_point_subtype     }
      460  {set returnvalue "lincir_5"    ; # mach_seq_curve_mill_subtype     }
      461  {set returnvalue "lincir_5"    ; # mach_seq_curve_lathe_subtype    }
    }
    if {([info exists mom_tool_path_type] && $mom_tool_path_type == "variable_axis") && [string match "lincir_3*" $returnvalue]} {
      set returnvalue "lincir_5"
    }
  }
  return $returnvalue
}
# <Documentation>
# This procedure examine the operation which is given by the argument or
# if there is no argument then the current operation is used.
#
# If the array mom_operation_info does not exists (first available in 12.0.2 and there is an argument
# then the returnvalue is "0"
#
# Return values:
# lincir_5  --> 5axis simultanous         (SIMULTANOUS)
# lincir_3_2  --> 3axis constant with tool axis change    (POSITIONING)
# lincir_3  --> 3axis constant without tool axis change   (CONSTANT)
# point_3_2 --> point operation with tool axis change     (POSITIONING)
# point_3   --> point operation without tool axis change    (CONSTANT)
# probe_3_2 --> probing operation with tool axis change   (POSITIONING)
# probe_3   --> probing operation without tool axis change    (CONSTANT)
#
#
# <Example>
# set type [LIB_SPF_ask_operation_type]  --> type .. "return value"
#____________________________________________________________________________________________
proc LIB_SPF_read_tool_attribute {attribute default {ind 0} {cutter_libref 0} {path_name ""}} {

  global lib_spf
  global mom_cutter_libref mom_lib_attr_value
  global lib_attr_value lib_attr_db_alias_list
  global mom_tool_ug_type mom_tool_ug_subtype

  if {$cutter_libref == 0} {
    set cutter_libref $mom_cutter_libref
  }

  if {[info exists lib_attr_value($cutter_libref,$attribute)]} {
    return $lib_attr_value($cutter_libref,$attribute)
  }

  #to speed up query all defined variables
  if {![info exists mom_tool_ug_type]} {
    set ugt [LIB_SPF_get_pretreatment mom_tool_ug_type 0 $path_name]
    if {$ugt == ""} {
      MOM_log_message "LIB_SPF_read_tool_attribute: mom_tool_ug_type is empty from pretreatment. Did you miss to add the variable to LIB_SPF_pt_additional_variables..."
    }
  } else {
    set ugt [format %.0f $mom_tool_ug_type]
  }
  if {![info exists mom_tool_ug_subtype]} {
    set ugst [LIB_SPF_get_pretreatment mom_tool_ug_subtype 0 $path_name]
    if {$ugst == ""} {
      MOM_log_message "LIB_SPF_read_tool_attribute: mom_tool_ug_subtype is empty from pretreatment. Did you miss to add the variable to LIB_SPF_pt_additional_variables..."
    }
  } else {
    set ugst [format %.0f $mom_tool_ug_subtype]
  }

  if {[info exists lib_attr_db_alias_list($ugt,$ugst)]} {
    set attr_db_alias_list $lib_attr_db_alias_list($ugt,$ugst)
  } else {
    if {[info exists lib_attr_db_alias_list(all_tools)]} {
      set attr_db_alias_list $lib_attr_db_alias_list(all_tools)
    } else {
      set attr_db_alias_list $attribute
    }
  }
  if {[lsearch $attr_db_alias_list $attribute] <0 } {lappend attr_db_alias_list $attribute}

  set query_attributes 0
  foreach dbalias $attr_db_alias_list {
    set dbalias [lindex [split $dbalias ";"] 0]
    lappend temp_attr_str $dbalias
    if {![info exists lib_attr_value($cutter_libref,$dbalias)]} {
      set query_attributes 1
    }
  }

  set query_single_attribute 0
  if {$query_attributes == 1} {
    if {[llength $temp_attr_str] > 1} {

      set error_tdb 1
      set error_tdb [catch {eval "MOM_ask_library_attributes LIBRARY_TOOL $cutter_libref $temp_attr_str"}]

      if {$error_tdb == 0} {
        foreach dbalias $temp_attr_str {
          set lib_attr_value($cutter_libref,$dbalias) [string trim $mom_lib_attr_value($dbalias)]
        }
      } else {
        set query_single_attribute 1
      }

    } else {
      set query_single_attribute 1
    }
  }

  if {$query_single_attribute == 1} {

    foreach dbalias $attr_db_alias_list {
      set dbalias [lindex [split $dbalias ";"] 0]

      if {![info exists lib_attr_value($cutter_libref,$dbalias)]} {

        set error_tdb 1
        set error_tdb [catch {eval "MOM_ask_library_attributes LIBRARY_TOOL $cutter_libref $dbalias"}]

        if {$error_tdb == 0} {
          set lib_attr_value($cutter_libref,$dbalias) [string trim $mom_lib_attr_value($dbalias)]
        } else {
          if {$ind == 1} {
            incr lib_spf(warningcount) 1
            lappend lib_spf(warningoutput) [LIB_GE_MSG "INS->$dbalias<- not available for tool INS->$cutter_libref<-"]
          }
        }

      }
    }

  }

  if {[info exists lib_attr_value($cutter_libref,$attribute)]} {
    return $lib_attr_value($cutter_libref,$attribute)
  } else {
    return $default
  }

}
# <Documentation>
# This procedure reads tool attribute data from the active tool library.
# Internally the standard MOM command MOM_ask_library_attributes is used, but the command is enriched with
# error handling.
#
# Starting from Post Configurator Library Release 4.3.4 and up once queried attributes are
# internally stored in an array to reduce the MOM_ask_library_attributes command in order to
# seed up database access.
# Also multiple attributes are queried at once per function call. For this it is necessary to
# define all attributes upfront which you want to access from the database, using the array
# lib_attr_db_alias_list.
#
# define attributes which should be queried for all tools with
# lib_attr_db_alias_list(all_tools)
# define attributes which should only be queried for a specific tool with
# lib_attr_db_alias_list(ug_tooltype,ug_subtype)
#
# <Arguments>
# attribute
#   Attribute to be read from the tool database.
# default
#   Value that is returned if reading the attribute fails.
# ind
#   Indicator whether a warning should be issued if reading the attribute fails.
# 1 - Issue warning.
# 0 - No warning.
# cutter_libref
#   Cutter libref to be read from. If not specified, the procedure reads from the active tool.
# <Returnvalue>
# If the read is successful, the attribute value is returned, or else
# the default value is returned.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_read_tool_attribute ATTRIBUTE "The ATTRIBUTE has no value"]
# desc: results the attribute 'ATTRIBUTE' from the current tool. If no value is present in the
#       tool database, 'The ATTRIBUTE has no value' will be returned.
# <Example>
# name: Time optimized example, reading several attributes at once
# code: global lib_attr_db_alias_list
#       set lib_attr_db_alias_list(all_tools) [list Descr Coolant]
#       set result [LIB_SPF_read_tool_attribute Coolant "-"]
# desc: results the attribute 'Coolant' from the current tool. If no value is present in the
#       tool database, '-' will be returned. When LIB_SPF_read_tool_attribute Descr is used,
#       the function returns the attribute which has been read before right away withouth
#       need to use MOM_ask_library_attributes again.
# <Example>
# name: Time optimized example, reading specific attributes related to tool type
# code: global lib_attr_db_alias_list
#       set lib_attr_db_alias_list(all_tools) Descr Coolant
#       set lib_attr_db_alias_list(2,8) "Pitch;this is the Tool Pitch"
#       set result [LIB_SPF_read_tool_attribute Pitch "-"]
# desc: results the attribute 'Pitch' from the current tool. Only when the mom_tool_ug_type is 2 and
#       mom_tool_ug_subtype is 8 it will be queried, else we return the default value '-'.
#       When LIB_SPF_read_tool_attribute Descr and Coolant is used, the function returns the attributes
#       that have been read before right away withouth need to use MOM_ask_library_attributes again.
#____________________________________________________________________________________________
proc LIB_SPF_read_part_attribute {attribute default {ind 0} {clear 0}} {

  global lib_spf

  #PR9248493: With 12.0.1 MP1 Attributes now in uppercase
  if {$lib_spf(nx_version) >= 1202} {
    set attribute [string toupper $attribute]
  }

  set error_part 1
  set error_part [catch {set attribute [subst \$::mom_attr_PART_$attribute]}]
  if {$clear && [info exists ::mom_attr_PART_$attribute]} {unset ::mom_attr_PART_$attribute}

  if {$error_part == 0} {
    return $attribute

  } else {
    if {$ind == 1} {
      incr lib_spf(warningcount) 1
      lappend lib_spf(warningoutput) [LIB_GE_MSG "Part attribute INS->$attribute<- unknown"]
    }
    return $default
  }

}
# <Documentation>
# This procedure reads part attribute data from the active part.
# The procedure has error handling.
# <Arguments>
# attribute
#   Attribute to be read.
# default
#   Value that is returned if reading the attribute fails.
# ind
#   Indicator whether a warning should be issued if reading the attribute fails.
# 1 - Issue warning.
# 0 - No warning.
# clear
#   Unset the variable if it exists.
# <Returnvalue>
# If the read is successful, the attribute value is returned, or else
# the default value is returned.
# <Example>
# set result [LIB_SPF_read_part_attribute ATTRIBUTE "The ATTRIBUTE has no value"]
#____________________________________________________________________________________________
proc LIB_SPF_read_oper_attribute {attribute default {ind 0} {clear 0}} {

  global lib_spf

  #PR9248493: With 12.0.1 MP1 Attributes now in uppercase
  if {$lib_spf(nx_version) >= 1202} {
    set attribute [string toupper $attribute]
  }

  set error_part 1
  set error_part [catch {set attribute_result [subst \$::mom_attr_OPER_$attribute]}]
  if {$clear && [info exists ::mom_attr_OPER_$attribute]} {unset ::mom_attr_OPER_$attribute}

  if {$error_part == 0} {
    return $attribute_result

  } else {
    if {$ind == 1} {
      incr lib_spf(warningcount) 1
      lappend lib_spf(warningoutput) [LIB_GE_MSG "Operation attribute INS->$attribute<- unknown"]
    }
    return $default
  }

}
# <Documentation>
# This procedure reads operation attribute data from the current operation.
# The procedure has error handling.
# <Arguments>
# attribute
#   Attribute to be read.
# default
#   Value that is returned if reading the attribute fails.
# ind
#   Indicator whether a warning should be issued if reading the attribute fails. Valid options are:
# 1 - Issue warning.
# 0 - No warning.
# clear
#   Unset the variable if it exists.
# <Returnvalue>
# If the read is successful, the attribute value is returned, or else the default value is returned.
# <Example>
# set result [LIB_SPF_read_oper_attribute ATTRIBUTE "The ATTRIBUTE has no value"]
#____________________________________________________________________________________________
proc LIB_SPF_read_programview_attribute {attribute default {ind 0} {clear 0}} {

  global lib_spf

  #PR9248493: With 12.0.1 MP1 Attributes now in uppercase
  if {$lib_spf(nx_version) >= 1202} {
    set attribute [string toupper $attribute]
  }

  global mom_attr_PROGRAMVIEW_$attribute

  set error_part 1
  set error_part [catch {set attribute [subst \$mom_attr_PROGRAMVIEW_$attribute]}]
  if {$clear && [info exists mom_attr_PROGRAMVIEW_$attribute]} {unset mom_attr_PROGRAMVIEW_$attribute}

  if {$error_part == 0} {
    return $attribute

  } else {
    if {$ind == 1} {
      incr lib_spf(warningcount) 1
      lappend lib_spf(warningoutput) [LIB_GE_MSG "Programview attribute INS->$attribute<- unknown"]
    }
    return $default
  }

}

# <Documentation>
# This procedure reads programview attribute data.
# The procedure has error handling.
# <Arguments>
# attribute
#   Attribute to be read.
# default
#   Value that is returned if reading the attribute fails.
# ind
#   Indicator whether a warning should be issued if reading the attribute fails.
# 1 - Issue warning.
# 0 - No warning.
# clear
#   Unset the variable if it exists.
# <Returnvalue>
# If the read is successful, the attribute value is returned, or else
# the default value is returned.
# <Example>
# set result [LIB_SPF_read_programview_attribute ATTRIBUTE "The ATTRIBUTE has no value"]
#____________________________________________________________________________________________
proc LIB_SPF_extract_udecode {ude {name ""}} {

  upvar 1 $name resultvariable

  regexp -nocase -- {(^[0-9]+)[_-](.*)} $ude all udecode udename
  if {![info exist udecode]} {set udecode $ude}
  if {![info exist udename] || ![regexp -nocase -- {^[0-9]|[A-Z]+} [string trim $udename]]} {set udename ""}

  set resultvariable $udename

  return $udecode

}
# <Documentation>
# This procedure returns the option number of a variable of a user-defined event (UDE), provided that the options start with
# a number (an ID) and are followed by - or _.
# This helps you create language independent UDEs as the ID is used and not the name after the - or _
# <Arguments>
# ude
#   Variable of a UDE to be analyzed.
# name
#   Variable name for which the variable value after the language code is returned.
# <Returnvalue>
# Returns the option number. If no option number exists, returns the whole string instead.
# <Example>
# name: Example 1
# code: set ude "99-Test"
#      set result [LIB_SPF_extract_udecode $ude name]
# desc: The value of the variable result is 99 and the variable $name is Test.
#____________________________________________________________________________________________
proc EQ_is_equal {s t {tol 0}} {
  if {$tol == 0} {set tol $::mom_system_tolerance}
  if {[LIB_SPF_is_empty $s] || [LIB_SPF_is_empty $t]} {return 0}
  expr {abs($s - $t) <= $tol}
}
# <Documentation>
# This procedure checks if two given values are equal within a given tolerance.
# <Arguments>
# s
#   Value 1
# t
#   Value 2
# tol
#   Tolerance between the values is checked within the equality.
#   If the tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - values are equal.
# 0 - values are not equal.
# <Example>
# name: Example 1
# code: set result [EQ_is_equal 12.0 12.0 0.0001]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [EQ_is_equal 11.999 12.0 0.0001]
# desc: result = 0
# <Example>
# name: Example 3
# code: set result [EQ_is_equal 11.999 12.0 0.01]
# desc: result = 1
#____________________________________________________________________________________________
proc EQ_is_ge {s t {tol 0}} {
  if {$tol == 0} {set tol $::mom_system_tolerance}
  expr {$s > ($t - $tol)}
}
# <Documentation>
# This procedure checks if value 1 is greater or equal than value 2 within a given tolerance.
# <Arguments>
# s
#   Value 1
# t
#   Value 2
# tol
#   Tolerance between the values is checked.
#   If the tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - Value 1 is greater than or equal to value 2.
# 0 - Value 1 is not greater than or equal to value 2.
# <Example>
# name: Example 1
# code: set result [EQ_is_ge 12.0 12.0 0.0001]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [EQ_is_ge 11.999 12.0 0.0001]
# desc: result = 0
# <Example>
# name: Example 3
# code: set result [EQ_is_ge 12.0 11.999 0.0001]
# desc: result = 1
#____________________________________________________________________________________________
proc EQ_is_gt {s t {tol 0}} {
  if {$tol == 0} {set tol $::mom_system_tolerance}
  expr {$s > ($t + $tol)}
}
# <Documentation>
# This procedure checks if value 1 is greater than value 2 within a given tolerance.
# <Arguments>
# s
#   Value 1
# t
#   Value 2
# tol
#   Tolerance between the values  is checked.
#   If the tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - Value 1 is greater than value 2.
# 0 - Value 1 is not greater than value 2.
# <Example>
# name: Example 1
# code: set result [EQ_is_gt 12.0 12.0 0.0001]
# desc: result = 0
# <Example>
# name: Example 2
# code: set result [EQ_is_gt 11.999 12.0 0.0001]
# desc: result = 0
# <Example>
# name: Example 3
# code: set result [EQ_is_gt 12.0 11.999 0.0001]
# desc: result = 1
#____________________________________________________________________________________________
proc EQ_is_le {s t {tol 0}} {
  if {$tol == 0} {set tol $::mom_system_tolerance}
  expr {$s < ($t + $tol)}
}
# <Documentation>
# This procedure checks if value 1 is less than or equal to value 2 within a given tolerance.
# <Arguments>
# s
#   Value 1
# t
#   Value 2
# tol
#   Tolerance between the values  is checked.
#   If the tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - Value 1 is less than or equal to value 2.
# 0 - Value 1 is not less than or equal to value 2.
# <Example>
# name: Example 1
# code: set result [EQ_is_le 12.0 12.0 0.0001]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [EQ_is_le 11.999 12.0 0.0001]
# desc: result = 1
# <Example>
# name: Example 3
# code: set result [EQ_is_le 12.0 11.999 0.0001]
# desc: result = 0
#____________________________________________________________________________________________
proc EQ_is_lt {s t {tol 0}} {
  if {$tol == 0} {set tol $::mom_system_tolerance}
  expr {$s < ($t - $tol)}
}
# <Documentation>
# This procedure checks if value 1 is less than value 2 within a given tolerance.
# <Arguments>
# s
#   Value 1
# t
#   Value 2
# tol
#   Tolerance between the values is checked.
#   If the tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - Value 1 is less than value 2.
# 0 - Value 1 is not less than value 2.
# <Example>
# name: Example 1
# code: set result [EQ_is_lt 12.0 12.0 0.0001]
# desc: result = 0
# <Example>
# name: Example 2
# code: set result [EQ_is_lt 11.999 12.0 0.0001]
# desc: result = 1
# <Example>
# name: Example 3
# code: set result [EQ_is_lt 12.0 11.999 0.0001]
# desc: result = 0
#____________________________________________________________________________________________
proc EQ_is_zero {s {tol 0}} {
  if {$tol == 0} {set tol $::mom_system_tolerance}
  expr {abs($s) <= $tol}
}
# <Documentation>
# This procedure checks if a given value is zero within a given tolerance.
# <Arguments>
# s
#   Value
# tol
#   Tolerance between the value and zero  is checked.
#   If the tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - Value is zero.
# 0 - Value1 is not zero.
# <Example>
# name: Example 1
# code: set result [EQ_is_zero 0.0001 0.0001]
# desc: result = 1
# <Example>
# name: Example 2
# code: set result [EQ_is_zero 0.01 0.0001]
# desc: result = 0
# <Example>
# name: Example 3
# code: set result [EQ_is_zero 0 0.0001]
# desc: result = 1
#____________________________________________________________________________________________
proc VEC3_add {u v w} {
  upvar $u u1 ; upvar $v v1 ; upvar $w w1
  set w1(0) [expr {$u1(0) + $v1(0)}]
  set w1(1) [expr {$u1(1) + $v1(1)}]
  set w1(2) [expr {$u1(2) + $v1(2)}]
}
# <Documentation>
# This procedure performs a vector addition.
# Vector addition: VEC3_add(u,v,w) w = u + v
# <Arguments>
# u
#   Vector 1.
# v
#   Vector 2.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: array set vector2 "0 10.0 1 0.0 2 0.0"
#      VEC3_add mom_pos vector2 result
# desc: The variable result contains the current value of mom_pos + 10 in the X direction.
#____________________________________________________________________________________________
proc VEC3_cross {u v w} {
  upvar $u u1 ; upvar $v v1 ; upvar $w w1
  set w1(0) [expr {$u1(1) * $v1(2) - $u1(2) * $v1(1)}]
  set w1(1) [expr {$u1(2) * $v1(0) - $u1(0) * $v1(2)}]
  set w1(2) [expr {$u1(0) * $v1(1) - $u1(1) * $v1(0)}]
}
# <Documentation>
# This procedure calculates the vector cross product.
# Vector cross product: VEC3_cross(u,v,w) w = ( u X v )
# <Arguments>
# u
#   Vector 1.
# v
#   Vector 2.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: array set vector1 "0 10.0 1 20.0 2 0.0"
#      array set vector2 "0 -10.0 1 -20.0 2 0.0"
#      VEC3_cross vector1 vector2 result
# desc: result = cross product between vector1 and vector2.
#____________________________________________________________________________________________
proc VEC3_dot {u v} {
  upvar $u u1 ; upvar $v v1
  expr {$u1(0) * $v1(0) + $u1(1) * $v1(1) + $u1(2) * $v1(2)}
}
# <Documentation>
# This procedure calculates the vector dot product of normalized input vectors.
# Vector dot product: VEC3_dot(u,v) (u dot v)
# <Arguments>
# u
#   Normalized vector 1.
# v
#   Normalized vector 2.
# <Returnvalue>
# Resulting dot product.
# <Example>
# name: Example 1
# code: array set vector1 "0 1.0 1 0.0 2 0.0"
#      array set vector2 "0 0.0 1 1.0 2 0.0"
#      set result [VEC3_dot vector1 vector2]
# desc: result = dot product between vector1 and vector2.
#____________________________________________________________________________________________
proc VEC3_dot_A {u v} {
  upvar $u u1 ; upvar $v v1

  set mu [VEC3_mag u1]
  set mv [VEC3_mag v1]
  expr {($u1(0) * $v1(0) + $u1(1) * $v1(1) + $u1(2) * $v1(2)) / ($mu*$mv)}
}
# <Documentation>
# This procedure calculates the vector dot product. Input vectors do not need to be normalized.
# Vector dot product: VEC3_dot_A(u,v) (u dot v)
# <Arguments>
# u
#   Vector 1.
# v
#   Vector 2.
# <Returnvalue>
# Resulting dot product.
# <Example>
# name: Example 1
# code: array set vector1 "0 10.0 1 20.0 2 0.0"
#      array set vector2 "0 -10.0 1 -20.0 2 0.0"
#      set result [VEC3_dot_A vector1 vector2]
# desc: result = dot product between vector1 and vector2.
#____________________________________________________________________________________________
proc VEC3_init {x y z w} {
  upvar $x x1 ; upvar $y y1 ; upvar $z z1 ; upvar $w w1
  set w1(0) $x1 ; set w1(1) $y1 ; set w1(2) $z1
}
# <Documentation>
# This procedure initializes a vector from a coordinate value. This is useful to create a vector
# from given variables. Initialize a vector from coordinates (passed as variables):
# VEC3_init(x,y,z,w) w = (x, y, z)
# <Arguments>
# x
#   Variable that holds the X-value.
# y
#   Variable that holds the Y-value.
# z
#   Variable that holds the Z-value.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: VEC3_init x y z result
# desc: result = vector created from x, y, z coordinates.
#____________________________________________________________________________________________
proc VEC3_init_s {x y z w} {
  upvar $w w1
  set w1(0) $x ; set w1(1) $y ; set w1(2) $z
}
# <Documentation>
# This procedure initializes a vector from scalar values. This is useful to create a vector
# directly from given values. Initialize a vector from coordinates (passed as scalars):
# VEC3_init_s(x,y,z,w) w = (x, y, z)
# <Arguments>
# x
#   Variable that holds the X-scalar.
# y
#   Variable that holds the Y-scalar.
# z
#   Variable that holds the Z-scalar.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: VEC3_init_s 1 1 0 result
# desc: result = vector created from the passed scalar.
# <Example>
# name: Example 2
# code: VEC3_init_s x y z result
# desc: result = vector created from x, y, z coordinates.
#____________________________________________________________________________________________
proc VEC3_is_equal {u v {tol 0}} {
  upvar $u u1 ; upvar $v v1
  if {$tol == 0} {set tol $::mom_system_tolerance}
  expr {[EQ_is_equal $u1(0) $v1(0) $tol] && [EQ_is_equal $u1(1) $v1(1) $tol] && [EQ_is_equal $u1(2) $v1(2) $tol]}
}
# <Documentation>
# This procedure checks if two given vectors are equal within a given tolerance.
# Vector equality: VEC3_is_equal(u,v,tol) (||(u-v)|| < tol)
# <Arguments>
# u
#   Vector 1
# v
#   Vector 2
# tol
#   Tolerance between the vectors to be checked.
#   If tolerance is not specified, mom_system_tolerance is used instead.
# <Returnvalue>
# 1 - Vectors are equal.
# 0 - Vectors are not equal.
# <Example>
# name: Example 1
# code: set result [VEC3_is_equal mom_pos mom_prev_pos]
# desc: The variable result = 1 if both vectors are equal.
#____________________________________________________________________________________________
proc VEC3_is_zero {u} {
  upvar $u u1
  expr {[EQ_is_zero $u1(0)] && [EQ_is_zero $u1(1)] && [EQ_is_zero $u1(2)]}
}
# <Documentation>
# This procedure checks if a given vector is zero within the system tolerance.
# Vector equal to zero: VEC3_is_zero(u,tol) (|| u || < tol)
# <Arguments>
# u
#   Vector
# <Returnvalue>
# 1 - Vector is zero.
# 0 - Vector is not zero.
# <Example>
# name: Example 1
# code: set result [VEC3_is_zero mom_pos]
# desc: The variable result = 1 if the vector is zero.
#____________________________________________________________________________________________
proc VEC3_mag {u} {
  upvar $u u1
  expr {sqrt([VEC3_dot u1 u1])}
}
# <Documentation>
# This procedure determines the magnitude of a vector.
# Vector magnitude: VEC3_mag(u) ( || u || )
# <Arguments>
# u
#   Vector
# <Returnvalue>
# Vector magnitude.
# <Example>
# name: Example 1
# code: VEC3_init_s 10 15 0 myvector
# set result [VEC3_mag myvector]
# desc: result = magnitude of myvector = 18.028
#____________________________________________________________________________________________
proc VEC3_negate {u w} {
  upvar $u u1 ; upvar $w w1
  set w1(0) [expr {-$u1(0)}]
  set w1(1) [expr {-$u1(1)}]
  set w1(2) [expr {-$u1(2)}]
}
# <Documentation>
# This procedure negates a given vector.
# Vector negate: VEC3_negate(u,w) w = (-u)
# <Arguments>
# u
#   Vector to negate.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: VEC3_negate vector1 result
# desc: result = negated vector of vector1.
#____________________________________________________________________________________________
proc VEC3_scale {s u w} {
  upvar $s s1 ; upvar $u u1 ; upvar $w w1
  set w1(0) [expr {$s1 * $u1(0)}]
  set w1(1) [expr {$s1 * $u1(1)}]
  set w1(2) [expr {$s1 * $u1(2)}]
}
# <Documentation>
# This procedure scales a vector by a given value.
# Vector scale: VEC3_scale(s,u,w) w = (s*u)
# <Arguments>
# s
#   Scale value.
# u
#   Vector to be scaled.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: VEC3_scale scale vector1 result
# desc: result = scaled vector of vector1.
# <Example>
# name: Example 2
# code: set factor 2
#      VEC3_scale factor mom_pos result
# desc: The result contains the mom_pos values, scaled by factor 2.
#____________________________________________________________________________________________
proc VEC3_sub {u v w} {
  upvar $u u1 ; upvar $v v1 ; upvar $w w1
  set w1(0) [expr {$u1(0) - $v1(0)}]
  set w1(1) [expr {$u1(1) - $v1(1)}]
  set w1(2) [expr {$u1(2) - $v1(2)}]
}
# <Documentation>
# This procedure substracts one vector from another vector.
# Vector subtraction: VEC3_sub(u,v,w) w = u - v
# <Arguments>
# u
#   Base vector.
# v
#   Vector to be subtracted.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# name: Example 1
# code: VEC3_sub vector1 vector2 result
# desc: result = vector1 - vector2.
#____________________________________________________________________________________________
proc VEC3_unitize {u w} {
  upvar $u u1 ; upvar $w w1
  if {[VEC3_is_zero u1]} {
    set len 0.0
    set w1(0) 0.0
    set w1(1) 0.0
    set w1(2) 0.0
  } else {
    set len [VEC3_mag u1]
    set scale [expr {1.0/$len}]
    VEC3_scale scale u1 w1
  }
  return $len
}
# <Documentation>
# This procedure calculates the unit vector (or normalized vector) of a given vector in space.
# Vector unitization: VEC3_unitize(u,w) *len = || u ||
# <Arguments>
# u
#   Vector in space.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# The result is stored in the variable that has been defined with argument w.
# The procedure itself returns the length of the given input vector.
# <Example>
# name: Example 1
# code: set len [VEC3_unitize vector1 result]
# desc: The variable result is the unit vector of vector1. The varible len is
# the length of vector1.
#____________________________________________________________________________________________
proc VEC3_rotate_arbitary_axis {axis angle input_vector output_vector} {

  upvar $axis r; upvar $input_vector input ; upvar $output_vector output
  #set up matrix to rotate about an arbitrary axis

  VEC3_unitize r r

  set S [expr sin($angle)]
  set C [expr cos($angle)]
  set T [expr 1 - $C]

  set m(0) [expr $r(0)*$r(0)*$T + $C]
  set m(1) [expr $r(0)*$r(1)*$T - $r(2)*$S]
  set m(2) [expr $r(0)*$r(2)*$T + $r(1)*$S]

  set m(3) [expr $r(0)*$r(1)*$T + $r(2)*$S]
  set m(4) [expr $r(1)*$r(1)*$T + $C]
  set m(5) [expr $r(1)*$r(2)*$T - $r(0)*$S]

  set m(6) [expr $r(0)*$r(2)*$T - $r(1)*$S]
  set m(7) [expr $r(1)*$r(2)*$T + $r(0)*$S]
  set m(8) [expr $r(2)*$r(2)*$T + $C]

  MTX3_vec_multiply input m output
}
# <Documentation>
# This procedure rotates a vector around an arbitary axis.
# <Arguments>
# axis
#   Vector defining the rotation axis (is unitized in procedure).
# angle
#   Rotation angle in radians.
# input_vector
#   Vector to rotate.
# output_vector
#   Rotated vector (result).
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument output_vector.
#
# <Example>
# name: Example 1
# code: set rot_vec(0) 1 ; set rot_vec(1) 1 ;set rot_vec(2) 0
#      set ang [expr  65. * $DEG2RAD]
#      set point(0) 123.1 ; set point(1) 1.98 ; set point(2) 44.9
#      VEC3_rotate_arbitary_axis rot_vec $ang point new_point
# desc: The variable new_point contains the resulting vector when rotating point 65 degrees around the vector rot_vec.
#____________________________________________________________________________________________
proc VEC3_dist_point_line {_u _v _w} {
    upvar $_u u ; upvar $_v v ; upvar $_w w

    VEC3_sub w v s0
    VEC3_sub v u s1
    set ms2 [VEC3_mag s0]
    if {[EQ_is_zero $ms2]} {return 0.0}
    VEC3_cross s0 s1 x0
    expr {double([VEC3_mag x0])/$ms2}
}
# <Documentation>
# This procedure calculates the shortest distance between a given point and a line.
# It is the distance from the point perpendicular to the line.
# <Arguments>
# _u
#   Point in space
# _v
#   Point 1 on the line (could be the startpoint, but not necessary)
# _w
#   Point 2 on the line (could be the endpoint, but not necessary)
# <Returnvalue>
# Distance from the point perpendicular to the line.
# <Example>
# name: Example 1
# code: set result [VEC3_dist_point_line point linestart lineend]
# desc: result = distance from the point perpendicular to the line.
#____________________________________________________________________________________________
proc VEC3_angle_3points {_u _v _w} {
    upvar $_u u ; upvar $_v v ; upvar $_w w

    VEC3_sub u v L1
    VEC3_sub v w L2
    if {[EQ_is_zero [set len1 [VEC3_mag L1]]] || [EQ_is_zero [set len2 [VEC3_mag L2]]]} {return 0.0}
    set cosa [expr {[VEC3_dot L1 L2]/($len1*$len2)}]
  expr {(abs($cosa)>1.0) ? 0.0 : acos($cosa)}
}
# <Documentation>
# This procedure calculates the angle between three points.
# <Arguments>
# _u
#   Point 1
# _v
#   Intermediate point
# _w
#   Point 2
# <Returnvalue>
# Resulting angle in radians.
# <Example>
# name: Example 1
# code: set result [VEC3_angle_3points p0 p p1]
# desc: result = angle between p0-p-p1 in radians.
# <Example>
# name: Example 2
# code: VEC3_init_s 0 10 0 l1
#      VEC3_init_s 0 0 0 intermediate
#      VEC3_init_s 10 0 0 l2
#      set result [expr [VEC3_angle_3points l1 intermediate l2] * $RAD2DEG]
# desc: result = 90.0
#____________________________________________________________________________________________
proc VEC3_angle_between {vec1 vec2 {return_unit "deg"}} {
  global RAD2DEG
  global PI vres
  upvar $vec1 v1
  upvar $vec2 v2

  VEC3_unitize v1 v1_unit
  VEC3_unitize v2 v2_unit

  if {[VEC3_is_equal v1_unit v2_unit]} {return 0.0}

  VEC3_cross v1_unit v2_unit vres
  if {![EQ_is_zero $vres(2)]} {
    set direction $vres(2)
  } elseif {![EQ_is_zero $vres(1)]} {
    set direction $vres(1)
  } else {
    set direction $vres(0)
  }
  set angle_rad [expr acos([VEC3_dot v1_unit v2_unit])]
  if {$direction < 0} {
    set angle_rad [expr 2*$PI - $angle_rad]
  }
  set angle_deg [expr $angle_rad * 180./$PI]
  if {$return_unit == "deg"} {
    return $angle_deg
  } else {
    return $angle_rad
  }
}
# <Documentation>
# This procedure calculates the angle between two vectors. The input vectors do not need
# to be unitized.
# <Arguments>
# vec1
#   Vector 1
# vec2
#   Vector 2
# return_unit
#   deg - Return value in degrees.
#   rad - Return value in radians.
# <Returnvalue>
# Resulting angle in degrees or radians.
# <Example>
# name: Example 1
# code: set result [VEC3_angle_between vector1 vector2 deg]
# desc: result = angle in degrees.
# <Example>
# name: Example 2
# code: VEC3_init_s 10 0 0 l1
#      VEC3_init_s 0 10 0 l2
#      set result [VEC3_angle_between l1 l2]
# desc: result = 90.0
#____________________________________________________________________________________________
proc VEC3_is_parallel {u v} {
  upvar $u u1 ; upvar $v v1

  VEC3_cross u1 v1 w

  if {[EQ_is_zero [VEC3_mag w]]} {
    return 1
  } else {
    return 0
  }
}
# <Documentation>
# This procedure checks if two vectors are parallel or not.
# <Arguments>
# u
#   Vector 1
# v
#   Vector 2
# <Returnvalue>
# 1 - Vectors are parallel.
# 0 - Vectors are not parallel.
#
# <Example>
# set result [VEC3_cross vector1 vector2]
#____________________________________________________________________________________________
proc LIB_SPF_mcs_vector {input_vector output_vector} {

  upvar $input_vector u ; upvar $output_vector v
  global mom_machine_mode
  global mom_kin_machine_type

  if {$mom_machine_mode != "MILL"} {
    return
  }
  if {[string match "*3_axis*" $mom_kin_machine_type] || ![string match "*table*" $mom_kin_machine_type]} {
    VMOV 3 u v
  } else {
    global mom_kin_4th_axis_type mom_kin_5th_axis_type
    global mom_kin_4th_axis_vector mom_kin_5th_axis_vector
    global mom_out_angle_pos mom_pos DEG2RAD
    if {[info exists mom_kin_4th_axis_type] && [string match "Table" $mom_kin_4th_axis_type]} {
      set angle $mom_pos(3)*$DEG2RAD
      VEC3_rotate_arbitary_axis mom_kin_4th_axis_vector $angle u v
      VMOV 3 v w
    } else {
      VMOV 3 u w
    }
    if {[info exists mom_kin_5th_axis_type] && [string match "Table" $mom_kin_5th_axis_type]} {
      set angle $mom_pos(4)*$DEG2RAD
      VEC3_rotate_arbitary_axis mom_kin_5th_axis_vector $angle w v
    }
  }
}
# <Documentation>
# This procedure transforms a vector from the machine coordinate system to the work coordinate system.
# <Arguments>
# input_vector
#   Input vector in machine coordinate system.
# output_vector
#   Variable name where the transformed vector is stored.
# <Example>
# LIB_SPF_mcs_vector vector1 vector2
#____________________________________________________________________________________________
proc MTX3_init_x_y_z {u v w r} {
  upvar $u u1 ; upvar $v v1 ; upvar $w w1 ; upvar $r r1
  set status 0

  # Unitize the input vectors and proceed if neither vector is zero.

  if {[VEC3_unitize u1 xxxxx] && \
    [VEC3_unitize v1 yyyyy] && \
    [VEC3_unitize w1 zzzzz]} {

    #    Proceed if the input vectors are orthogonal

    if {[EQ_is_zero [VEC3_dot xxxxx yyyyy]] && \
      [EQ_is_zero [VEC3_dot xxxxx zzzzz]] && \
      [EQ_is_zero [VEC3_dot yyyyy zzzzz]]} {

      #        Cross the unitized input vectors and initialize the matrix
      #        Orthonormal test is stricter than EQ_ask_systol, so
      #        recalculate y and z.

      set status 1
      VEC3_cross xxxxx yyyyy zzzzz
      set len [VEC3_unitize zzzzz zzzzz]
      VEC3_cross zzzzz xxxxx yyyyy

      set r1(0) $xxxxx(0)
      set r1(1) $xxxxx(1)
      set r1(2) $xxxxx(2)
      set r1(3) $yyyyy(0)
      set r1(4) $yyyyy(1)
      set r1(5) $yyyyy(2)
      set r1(6) $zzzzz(0)
      set r1(7) $zzzzz(1)
      set r1(8) $zzzzz(2)

    }
  }
  return $status
}
# <Documentation>
# This procedure initializes a matrix from given x, y, and z vectors.
# Initialize matrix: MTX3_init_x_y_z (u, v, w, r) r = (u, v, w)
# <Arguments>
# u
#   Variable that holds the vector 1.
# v
#   Variable that holds the vector 2.
# w
#   Variable that holds the vector 3.
# r
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument r.
# <Example>
# name: Example 1
# code: MTX3_init_x_y_z vector1 vector2 vector3 result
# desc: The variable result contains a matrix created from vector1, vextor2, and vector3.
#____________________________________________________________________________________________
proc MTX3_is_equal {m n {count 9}} {
  upvar $m m1 ; upvar $n n1
  for {set ii 0} {$ii < $count} {incr ii} {
    if {![EQ_is_equal $m1($ii) $n1($ii)]} {return 0}
  }
  return 1
}
# <Documentation>
# This procedure determines if two matrices are equal within the system tolerance (mom_system_tolerance).
# Matrix equality: MTX3_is_equal(m,n,a) (m == n)
# <Arguments>
# m
#   Variable that holds the first matrix.
# n
#   Variable that holds the second matrix.
# count
#   Dimension of the matrices.
# <Returnvalue>
# 0 - Matrices are not equal.
# 1 - Matrices are equal.
# <Example>
# set result [MTX3_is_equal matrix1 matrix2]
# The variable result = 1 if the matrices are equal, or else result = 0.
#____________________________________________________________________________________________
proc MTX3_multiply {m n r} {
  upvar $m m1 ; upvar $n n1 ; upvar $r r1
  set r1(0) [expr ($m1(0) * $n1(0) + $m1(3) * $n1(1) + $m1(6) * $n1(2))]
  set r1(1) [expr ($m1(1) * $n1(0) + $m1(4) * $n1(1) + $m1(7) * $n1(2))]
  set r1(2) [expr ($m1(2) * $n1(0) + $m1(5) * $n1(1) + $m1(8) * $n1(2))]
  set r1(3) [expr ($m1(0) * $n1(3) + $m1(3) * $n1(4) + $m1(6) * $n1(5))]
  set r1(4) [expr ($m1(1) * $n1(3) + $m1(4) * $n1(4) + $m1(7) * $n1(5))]
  set r1(5) [expr ($m1(2) * $n1(3) + $m1(5) * $n1(4) + $m1(8) * $n1(5))]
  set r1(6) [expr ($m1(0) * $n1(6) + $m1(3) * $n1(7) + $m1(6) * $n1(8))]
  set r1(7) [expr ($m1(1) * $n1(6) + $m1(4) * $n1(7) + $m1(7) * $n1(8))]
  set r1(8) [expr ($m1(2) * $n1(6) + $m1(5) * $n1(7) + $m1(8) * $n1(8))]
}
# <Documentation>
# This procedure multiplies two matrices.
# Matrix multiplication: MTX3_multiply(m, n, r) r = ( m X n )
# <Arguments>
# m
#   Variable that holds the first matrix.
# v
#   Variable that holds the second matrix.
# r
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument r.
# <Example>
# MTX3_multiply matrix1 matrix2 result
# The variable result contains a new matrix created from multiplying matrix1 and matrix2.
#____________________________________________________________________________________________
proc MTX3_transpose {m r} {
  upvar $m m1 ; upvar $r r1
  set r1(0) $m1(0)
  set r1(1) $m1(3)
  set r1(2) $m1(6)
  set r1(3) $m1(1)
  set r1(4) $m1(4)
  set r1(5) $m1(7)
  set r1(6) $m1(2)
  set r1(7) $m1(5)
  set r1(8) $m1(8)
}
# <Documentation>
# This procedure transposes a matrix.
# Transpose matrix: MTX3_transpose(m, r) r = trns (m)
# <Arguments>
# m
#   Variable that holds the first matrix.
# r
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument r.
# <Example>
# MTX3_transpose matrix result
#____________________________________________________________________________________________
proc MTX3_scale {s r} {
  upvar $r r1
  for {set ii 0} {$ii < 9} {incr ii} {
    set r1($ii) [expr ($s * $r1($ii))]
  }
}
# <Documentation>
# This procedure scales a matrix with factor s.
# Scale a matrix: MTX3_scale(s,r) r = (s*(u))
# <Arguments>
# s
#   Scale factor.
# r
#   Name of the matrix to be transposed.
# <Returnvalue>
# None. The matrix defined with argument r is scaled and modified directly.
# <Example>
# MTX3_scale scale result
# The variable result contains the name of the matrix that has been changed.
#____________________________________________________________________________________________
proc MTX3_sub {m n r} {
  upvar $m m1 ; upvar $n n1 ; upvar $r r1
  for {set ii 0} {$ii < 9} {incr ii} {
    set r1($ii) [expr ($m1($ii) - $n1($ii))]
  }
}
# <Documentation>
# This procedure subtracts one matrix from another matrix.
# Matrix subtraction: MTX3_sub(m,n,r) r = (m - n)
# <Arguments>
# m
#   Base matrix.
# n
#   Matrix to be subtracted.
# r
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument r.
# <Example>
# MTX3_sub matrix1 matrix2 result
# The variable result contains a new matrix created from subtracting matrix2 from matrix1.
#____________________________________________________________________________________________
proc MTX3_add {m n r} {
  upvar $m m1 ; upvar $n n1 ; upvar $r r1
  for {set ii 0} {$ii < 9} {incr ii} {
    set r1($ii) [expr ($m1($ii) + $n1($ii))]
  }
}
# <Documentation>
# This procedure performs a matrix addition.
# Matrix addition: MTX3_add(m,n,r) r = (m + n)
# <Arguments>
# m
#   Variable that holds the first matrix.
# n
#   Variable that holds the second matrix.
# r
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument r.
# <Example>
# MTX3_add matrix1 matrix2 result
# The variable result contains a new matrix created from adding matrix2 to matrix1.
#____________________________________________________________________________________________
proc MTX3_vec_multiply {u m w} {
  upvar $u u1 ; upvar $m m1 ; upvar $w w1
  set w1(0) [expr ($u1(0) * $m1(0) + $u1(1) * $m1(1) + $u1(2) * $m1(2))]
  set w1(1) [expr ($u1(0) * $m1(3) + $u1(1) * $m1(4) + $u1(2) * $m1(5))]
  set w1(2) [expr ($u1(0) * $m1(6) + $u1(1) * $m1(7) + $u1(2) * $m1(8))]

}
# <Documentation>
# This procedure performs a vector/matrix multiplication.
# Vector/matrix multiplication: MTX3_vec_multiply(u, m, w) w = (u X m)
# <Arguments>
# u
#   Variable that holds the vector.
# m
#   Variable that holds the matrix.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# MTX3_vec_multiply vector1 matrix2 result
#____________________________________________________________________________________________
proc MTX3_x {m w} {
  upvar $m m1 ; upvar $w w1
  set w1(0) $m1(0)
  set w1(1) $m1(1)
  set w1(2) $m1(2)
}
# <Documentation>
# This procedure returns the first column vector (X-vector) of a matrix.
# First column vector of matrix: MTX3_x(m, w) w = (1st column)
# <Arguments>
# m
#   Variable that holds the matrix.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# MTX3_x matrix result
#____________________________________________________________________________________________
proc MTX3_y {m w} {
  upvar $m m1 ; upvar $w w1
  set w1(0) $m1(3)
  set w1(1) $m1(4)
  set w1(2) $m1(5)
}
# <Documentation>
# This procedure returns the second column vector (Y-vector) of a matrix.
# Second column vector of matrix: MTX3_y(m, w) w = (2nd column)
# <Arguments>
# m
#   Variable that holds the matrix.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# MTX3_y matrix result
#____________________________________________________________________________________________
proc MTX3_z {m w} {
  upvar $m m1 ; upvar $w w1
  set w1(0) $m1(6)
  set w1(1) $m1(7)
  set w1(2) $m1(8)
}
# <Documentation>
# This procedure returns the third column vector (Z-vector) of a matrix.
# Third column vector of matrix: MTX3_z(m, w) w = (3rd column)
# <Arguments>
# m
#   Variable that holds the matrix.
# w
#   Variable name where the result is stored.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument w.
# <Example>
# MTX3_z matrix result
#____________________________________________________________________________________________
proc VMOV {n p1 p2} {

  upvar $p1 v1 ; upvar $p2 v2

  for { set i 0 } { $i < $n } { incr i } {
    set v2($i) $v1($i)
  }
}
# <Documentation>
# This procedure copies a vector or matrix to another one.
# <Arguments>
# n
#   Number of elements to copy. Vectors have three elements. Matrices have nine elements.
# p1
#   Variable name of vector or matrix to copy.
# p2
#   Variable name of target vector or matrix.
# <Returnvalue>
# None. The result is stored in the variable that has been defined with argument p2.
# <Example>
# name: Copy vector
# code: VMOV 3 mom_pos memo_pos
# desc: This copies the values of the first three index positions of the array variable
# mom_pos (mom_pos(0), mom_pos(1), and mom_pos(2)) to the array variable memo_pos(0..2).
# <Example>
# name: Copy matrix
# code: VMOV 9 matrix1 matrix2
# desc: This copies matrix1 to matrix2.
#____________________________________________________________________________________________
proc hiset {v1} {
  upvar $v1 v2
  if {[info exists v2]} {return 1} else {return 0}
}
# <Documentation>
# This procedure checks if a variable is set or not.
# <Arguments>
# v1
#    Name of the variable to be checked.
# <Returnvalue>
# 0 - Variable is not set or does not exist.
# 1 - Variable is set.
# <Example>
# name: Example 1
# code: if {[hiset yy]} {puts $list_file "yy=$yy"}
# desc: Checks if yy is set and adds it to the list_file, when the variable has a value.
# <Example>
# name: Example 2
# code: set result [hiset yy]
# desc: The variable result = 1 if yy is set, or else result = 0.
#____________________________________________________________________________________________
proc isset {v1} {
  upvar $v1 v2
  if {[info exists v2]} {return y} else {return n}
}
# <Documentation>
# This procedure checks if a variable is set or not.
# <Arguments>
# v1
#    Name of the variable to be checked.
# <Returnvalue>
# n - if the variable is not set (does not exist)
# y - if the variable is set
# <Example>
# name: Example 1
# code: if {[hiset yy] == "y"} {puts $list_file "yy=$yy"}
# desc: Checks if yy is set and  adds it to the list_file, when the variable has a value.
# <Example>
# name: Example 2
# code: set result [hiset yy]
# desc: The variable result = y if yy is set, else result = n.
#____________________________________________________________________________________________
proc OUTPUT_adr {args} {

  set status 0
  foreach {v1 v2} $args {
    if {[MOM_ask_address_value $v1] != ""} {
      if {![EQ_is_equal [MOM_ask_address_value $v1] $v2]} {set status 1}
    }
  }
  return $status
}
# <Documentation>
# This procedure performs a preprocess modality check of NC code addresses before writing to the NC code output file.
#
#The procedure checks if the current value of an address is equal to a specified value.
# The address must be defined in the current postprocessor definition file (.def).
#
# You can check multiple addresses and values at one time. If at least one address value differs
# from the check value, the procedure returns 1, which means that the addresses must be output.
# <Arguments>
# args
#   Defined pairs of addresses and values to check. At least one pair of arguments must be defined.
# <Returnvalue>
# 1 - Addresses are not equal to the checked values and need to be output.
# 0 - Addresses are equal, no output required.
# <Example>
# if {[OUTPUT_adr fourth_axis $mom_out_angle_pos(0) fifth_axis $mom_out_angle_pos(1)]} {# do something}
#____________________________________________________________________________________________
proc LIB_SPF_rad_to_deg {angrad} {

  return [expr $angrad * $::RAD2DEG]

}
# <Documentation>
# This procedure converts an angular value in radians to an angular value in degrees.
# <Arguments>
# angrad
#    Angle in radians to be converted.
# <Returnvalue>
#    Angle in degrees.
# <Example>
# set result [LIB_SPF_rad_to_deg 0.5]
#____________________________________________________________________________________________
proc LIB_SPF_deg_to_rad {angdeg} {

  return [expr $angdeg * $::DEG2RAD]

}
# <Documentation>
# This procedure converts an angular value in degrees to an angular value in radians.
# <Arguments>
# angdeg
#    Angle in degrees to be converted.
# <Returnvalue>
#    Angle in radians.
# <Example>
# set result [LIB_SPF_deg_to_rad 180]
#____________________________________________________________________________________________
proc LIB_SPF_convert_decimal_to_binary {decimal} {

  if {![LIB_SPF_is_number $binary]} {
    LIB_GE_abort_message "Received value 'INS->$decimal<-' to function 'INS->LIB_SPF_convert_decimal_to_binary<-' is invalid" "Please verify"
  }

  set res {}
  while {$decimal>0} {
    set res [expr {$decimal%2}]$res
    set decimal [expr {$decimal/2}]
  }
  if {$res == {}} {set res 0}
  return $res
}
# <Documentation>
# This procedure converts decimal values to binary values.
# <Arguments>
# decimal
#    Decimal value to be converted.
# <Returnvalue>
# Converted binary value.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_convert_decimal_to_binary 27]
# desc: result = 1011
#____________________________________________________________________________________________
proc LIB_SPF_convert_string_to_hex {str} {

  binary scan $str H* hex
  return $hex

}
# <Documentation>
# This function converts a string to an hexadecimal value.
# <Arguments>
# str
#   String to be converted.
# <Returnvalue>
# Converted string value.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_convert_string_to_hex "Hello, world!"]
# desc: result = 48656c6c6f2c20776f726c6421
#____________________________________________________________________________________________
proc LIB_SPF_convert_hex_to_string {hex} {

  foreach c [split $hex ""] {
    if {![string is xdigit $c]} {
      return "#invalid $hex"
    }
  }
  binary format H* $hex

}
# <Documentation>
# This procedure converts an hexadecimal value to a string.
# <Arguments>
# hex
#   Hexadecimal value to be converted.
# <Returnvalue>
# Converted hexadecimal value.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_convert_hex_to_string 48656c6c6f2c20776f726c6421]
# desc: result = Hello, world!
#____________________________________________________________________________________________
proc LIB_SPF_convert_to_md5 {msg} {

  global lib_spf

  set lib_spf(md5body) {

    set msgLen [string length $msg]

    set padLen [expr {56 - $msgLen%64}]
    if {$msgLen % 64 > 56} {
      incr padLen 64
    }

    # pad even if no padding required
    if {$padLen == 0} {
      incr padLen 64
    }

    # append single 1b followed by 0b's
    append msg [binary format "a$padLen" \200]

    # RFC doesn't say whether to use little- or big-endian
    # code demonstrates little-endian
    # This step limits our input to size 2^32b or 2^24B
    append msg [binary format "i1i1" [expr {8*$msgLen}] 0]

    set A [expr 0x67452301]
    set B [expr 0xefcdab89]
    set C [expr 0x98badcfe]
    set D [expr 0x10325476]

    # process each 16-word block
    # RFC doesn't say whether to use little- or big-endian
    # code says little-endian
    binary scan $msg i* blocks

    foreach {X0 X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14 X15} $blocks {

      # Save A as AA, B as BB, C as CC, and D as DD.
      set AA $A
      set BB $B
      set CC $C
      set DD $D

      # Round 1.
      # Let [abcd k s i] denote the operation
      # a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s).
      # [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
      set A [expr {$B + [<<< [expr {$A + [F $B $C $D] + $X0  + $T01}]  7]}]
      set D [expr {$A + [<<< [expr {$D + [F $A $B $C] + $X1  + $T02}] 12]}]
      set C [expr {$D + [<<< [expr {$C + [F $D $A $B] + $X2  + $T03}] 17]}]
      set B [expr {$C + [<<< [expr {$B + [F $C $D $A] + $X3  + $T04}] 22]}]
      # [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
      set A [expr {$B + [<<< [expr {$A + [F $B $C $D] + $X4  + $T05}]  7]}]
      set D [expr {$A + [<<< [expr {$D + [F $A $B $C] + $X5  + $T06}] 12]}]
      set C [expr {$D + [<<< [expr {$C + [F $D $A $B] + $X6  + $T07}] 17]}]
      set B [expr {$C + [<<< [expr {$B + [F $C $D $A] + $X7  + $T08}] 22]}]
      # [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
      set A [expr {$B + [<<< [expr {$A + [F $B $C $D] + $X8  + $T09}]  7]}]
      set D [expr {$A + [<<< [expr {$D + [F $A $B $C] + $X9  + $T10}] 12]}]
      set C [expr {$D + [<<< [expr {$C + [F $D $A $B] + $X10 + $T11}] 17]}]
      set B [expr {$C + [<<< [expr {$B + [F $C $D $A] + $X11 + $T12}] 22]}]
      # [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]
      set A [expr {$B + [<<< [expr {$A + [F $B $C $D] + $X12 + $T13}]  7]}]
      set D [expr {$A + [<<< [expr {$D + [F $A $B $C] + $X13 + $T14}] 12]}]
      set C [expr {$D + [<<< [expr {$C + [F $D $A $B] + $X14 + $T15}] 17]}]
      set B [expr {$C + [<<< [expr {$B + [F $C $D $A] + $X15 + $T16}] 22]}]

      # Round 2.
      # Let [abcd k s i] denote the operation
      # a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s).
      # Do the following 16 operations.
      # [ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
      set A [expr {$B + [<<< [expr {$A + [G $B $C $D] + $X1  + $T17}]  5]}]
      set D [expr {$A + [<<< [expr {$D + [G $A $B $C] + $X6  + $T18}]  9]}]
      set C [expr {$D + [<<< [expr {$C + [G $D $A $B] + $X11 + $T19}] 14]}]
      set B [expr {$C + [<<< [expr {$B + [G $C $D $A] + $X0  + $T20}] 20]}]
      # [ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
      set A [expr {$B + [<<< [expr {$A + [G $B $C $D] + $X5  + $T21}]  5]}]
      set D [expr {$A + [<<< [expr {$D + [G $A $B $C] + $X10 + $T22}]  9]}]
      set C [expr {$D + [<<< [expr {$C + [G $D $A $B] + $X15 + $T23}] 14]}]
      set B [expr {$C + [<<< [expr {$B + [G $C $D $A] + $X4  + $T24}] 20]}]
      # [ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
      set A [expr {$B + [<<< [expr {$A + [G $B $C $D] + $X9  + $T25}]  5]}]
      set D [expr {$A + [<<< [expr {$D + [G $A $B $C] + $X14 + $T26}]  9]}]
      set C [expr {$D + [<<< [expr {$C + [G $D $A $B] + $X3  + $T27}] 14]}]
      set B [expr {$C + [<<< [expr {$B + [G $C $D $A] + $X8  + $T28}] 20]}]
      # [ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]
      set A [expr {$B + [<<< [expr {$A + [G $B $C $D] + $X13 + $T29}]  5]}]
      set D [expr {$A + [<<< [expr {$D + [G $A $B $C] + $X2  + $T30}]  9]}]
      set C [expr {$D + [<<< [expr {$C + [G $D $A $B] + $X7  + $T31}] 14]}]
      set B [expr {$C + [<<< [expr {$B + [G $C $D $A] + $X12 + $T32}] 20]}]

      # Round 3.
      # Let [abcd k s t] [sic] denote the operation
      # a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s).
      # Do the following 16 operations.
      # [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
      set A [expr {$B + [<<< [expr {$A + [H $B $C $D] + $X5  + $T33}]  4]}]
      set D [expr {$A + [<<< [expr {$D + [H $A $B $C] + $X8  + $T34}] 11]}]
      set C [expr {$D + [<<< [expr {$C + [H $D $A $B] + $X11 + $T35}] 16]}]
      set B [expr {$C + [<<< [expr {$B + [H $C $D $A] + $X14 + $T36}] 23]}]
      # [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
      set A [expr {$B + [<<< [expr {$A + [H $B $C $D] + $X1  + $T37}]  4]}]
      set D [expr {$A + [<<< [expr {$D + [H $A $B $C] + $X4  + $T38}] 11]}]
      set C [expr {$D + [<<< [expr {$C + [H $D $A $B] + $X7  + $T39}] 16]}]
      set B [expr {$C + [<<< [expr {$B + [H $C $D $A] + $X10 + $T40}] 23]}]
      # [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
      set A [expr {$B + [<<< [expr {$A + [H $B $C $D] + $X13 + $T41}]  4]}]
      set D [expr {$A + [<<< [expr {$D + [H $A $B $C] + $X0  + $T42}] 11]}]
      set C [expr {$D + [<<< [expr {$C + [H $D $A $B] + $X3  + $T43}] 16]}]
      set B [expr {$C + [<<< [expr {$B + [H $C $D $A] + $X6  + $T44}] 23]}]
      # [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]
      set A [expr {$B + [<<< [expr {$A + [H $B $C $D] + $X9  + $T45}]  4]}]
      set D [expr {$A + [<<< [expr {$D + [H $A $B $C] + $X12 + $T46}] 11]}]
      set C [expr {$D + [<<< [expr {$C + [H $D $A $B] + $X15 + $T47}] 16]}]
      set B [expr {$C + [<<< [expr {$B + [H $C $D $A] + $X2  + $T48}] 23]}]

      # Round 4.
      # Let [abcd k s t] [sic] denote the operation
      # a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s).
      # Do the following 16 operations.
      # [ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
      set A [expr {$B + [<<< [expr {$A + [I $B $C $D] + $X0  + $T49}]  6]}]
      set D [expr {$A + [<<< [expr {$D + [I $A $B $C] + $X7  + $T50}] 10]}]
      set C [expr {$D + [<<< [expr {$C + [I $D $A $B] + $X14 + $T51}] 15]}]
      set B [expr {$C + [<<< [expr {$B + [I $C $D $A] + $X5  + $T52}] 21]}]
      # [ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
      set A [expr {$B + [<<< [expr {$A + [I $B $C $D] + $X12 + $T53}]  6]}]
      set D [expr {$A + [<<< [expr {$D + [I $A $B $C] + $X3  + $T54}] 10]}]
      set C [expr {$D + [<<< [expr {$C + [I $D $A $B] + $X10 + $T55}] 15]}]
      set B [expr {$C + [<<< [expr {$B + [I $C $D $A] + $X1  + $T56}] 21]}]
      # [ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
      set A [expr {$B + [<<< [expr {$A + [I $B $C $D] + $X8  + $T57}]  6]}]
      set D [expr {$A + [<<< [expr {$D + [I $A $B $C] + $X15 + $T58}] 10]}]
      set C [expr {$D + [<<< [expr {$C + [I $D $A $B] + $X6  + $T59}] 15]}]
      set B [expr {$C + [<<< [expr {$B + [I $C $D $A] + $X13 + $T60}] 21]}]
      # [ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]
      set A [expr {$B + [<<< [expr {$A + [I $B $C $D] + $X4  + $T61}]  6]}]
      set D [expr {$A + [<<< [expr {$D + [I $A $B $C] + $X11 + $T62}] 10]}]
      set C [expr {$D + [<<< [expr {$C + [I $D $A $B] + $X2  + $T63}] 15]}]
      set B [expr {$C + [<<< [expr {$B + [I $C $D $A] + $X9  + $T64}] 21]}]

      incr A $AA
      incr B $BB
      incr C $CC
      incr D $DD
    }

    return [LIB_SPF_convert_md5_bytes $A][LIB_SPF_convert_md5_bytes $B][LIB_SPF_convert_md5_bytes $C][LIB_SPF_convert_md5_bytes $D]
  }

  proc LIB_SPF_convert_md5_byte0 {i} {expr {0xff & $i}}
  proc LIB_SPF_convert_md5_byte1 {i} {expr {(0xff00 & $i) >> 8}}
  proc LIB_SPF_convert_md5_byte2 {i} {expr {(0xff0000 & $i) >> 16}}
  proc LIB_SPF_convert_md5_byte3 {i} {expr {((0xff000000 & $i) >> 24) & 0xff}}

  proc LIB_SPF_convert_md5_bytes {i} {
    format %0.2x%0.2x%0.2x%0.2x [LIB_SPF_convert_md5_byte0 $i] [LIB_SPF_convert_md5_byte1 $i] [LIB_SPF_convert_md5_byte2 $i] [LIB_SPF_convert_md5_byte3 $i]
  }

  regsub -all -- {\[ *F +(\$.) +(\$.) +(\$.) *\]} $lib_spf(md5body) {((\1 \& \2) | ((~\1) \& \3))} lib_spf(md5body)
  regsub -all -- {\[ *G +(\$.) +(\$.) +(\$.) *\]} $lib_spf(md5body) {((\1 \& \3) | (\2 \& (~\3)))} lib_spf(md5body)
  regsub -all -- {\[ *H +(\$.) +(\$.) +(\$.) *\]} $lib_spf(md5body) {(\1 ^ \2 ^ \3)} lib_spf(md5body)
  regsub -all -- {\[ *I +(\$.) +(\$.) +(\$.) *\]} $lib_spf(md5body) {(\2 ^ (\1 | (~\3)))} lib_spf(md5body)

  regsub -all -- {\[ *<<< +\[ *expr +({[^\}]*})\] +([0-9]+) *\]} $lib_spf(md5body) {(([set x [expr \1]] << \2) |  (($x >> R\2) \& S\2))} lib_spf(md5body)

  set map {}
  foreach i {
    7 12 17 22
    5  9 14 20
    4 11 16 23
    6 10 15 21
  } {
    lappend map R$i [expr {32 - $i}] S$i [expr {0x7fffffff >> (31-$i)}]
  }

  foreach \
  tName {
    T01 T02 T03 T04 T05 T06 T07 T08 T09 T10
    T11 T12 T13 T14 T15 T16 T17 T18 T19 T20
    T21 T22 T23 T24 T25 T26 T27 T28 T29 T30
    T31 T32 T33 T34 T35 T36 T37 T38 T39 T40
    T41 T42 T43 T44 T45 T46 T47 T48 T49 T50
    T51 T52 T53 T54 T55 T56 T57 T58 T59 T60
  T61 T62 T63 T64 } \
  tVal {
    0xd76aa478 0xe8c7b756 0x242070db 0xc1bdceee
    0xf57c0faf 0x4787c62a 0xa8304613 0xfd469501
    0x698098d8 0x8b44f7af 0xffff5bb1 0x895cd7be
    0x6b901122 0xfd987193 0xa679438e 0x49b40821

    0xf61e2562 0xc040b340 0x265e5a51 0xe9b6c7aa
    0xd62f105d 0x2441453  0xd8a1e681 0xe7d3fbc8
    0x21e1cde6 0xc33707d6 0xf4d50d87 0x455a14ed
    0xa9e3e905 0xfcefa3f8 0x676f02d9 0x8d2a4c8a

    0xfffa3942 0x8771f681 0x6d9d6122 0xfde5380c
    0xa4beea44 0x4bdecfa9 0xf6bb4b60 0xbebfbc70
    0x289b7ec6 0xeaa127fa 0xd4ef3085 0x4881d05
    0xd9d4d039 0xe6db99e5 0x1fa27cf8 0xc4ac5665

    0xf4292244 0x432aff97 0xab9423a7 0xfc93a039
    0x655b59c3 0x8f0ccc92 0xffeff47d 0x85845dd1
    0x6fa87e4f 0xfe2ce6e0 0xa3014314 0x4e0811a1
    0xf7537e82 0xbd3af235 0x2ad7d2bb 0xeb86d391
  } {
    lappend map \$$tName $tVal
  }
  set lib_spf(md5body) [string map $map $lib_spf(md5body)]

  proc LIB_SPF_convert_md5 {msg} $lib_spf(md5body)

  unset lib_spf(md5body) tName tVal map

  LIB_SPF_convert_md5 $msg

}
# <Documentation>
# This procedure converts a string to an md5 value.
# <Arguments>
# msg
#   String to be converted.
# <Returnvalue>
# Converted md5 value.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_convert_to_md5 "Hello, world!"]
# desc: result = ed076287532e86365e841e92bfc50d8c
#____________________________________________________________________________________________
proc LIB_SPF_convert_point {option} {

  eval global [uplevel #0 info vars]

  global lib_spf_convert_kin_snapshot lib_spf_convert_point_snapshot mom_result mom_result1 prev_convert_mom_out_angle_pos

  if {$option == "reload" } {
    if {[info exists lib_spf_convert_point_snapshot]} {
      LIB_GE_snapshot LOAD_PERMANENT $lib_spf_convert_point_snapshot
      unset lib_spf_convert_point_snapshot
    }
  } else {

    set lib_spf_convert_point_snapshot [LIB_GE_snapshot CREATE "mom_out_angle_pos mom_pos mom_alt_pos mom_sys_leader mom_sys_trailer"]
    set lib_spf_convert_kin_snapshot [LIB_GE_snapshot CREATE "[info vars mom_kin*]"]

    set commandcheck(CONF_CTRL_setting) [llength [info commands CONF_CTRL_setting]]

    switch $option {
      "real"  {
        LIB_SPF_KINEMATICS_reload_pb_kin
        set mom_sys_leader(fourth_axis) $::lib_sav_sys_leader(fourth_axis)
        set mom_sys_leader(fifth_axis) $::lib_sav_sys_leader(fifth_axis)
      }
      "plane_no_reset" -
      "plane" {
        if {$commandcheck(CONF_CTRL_setting) && ([CONF_CTRL_setting plane_output_supported] == "NONE" || $lib_flag(tool_axis_zm) == 1)} {
          LIB_SPF_KINEMATICS_set_absolut_output_kin
        } else {
          LIB_SPF_KINEMATICS_set_plane_output_kin
        }
      }
      "simultanous" - "simultaneous"  {
        if {$commandcheck(CONF_CTRL_setting) && [CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
          LIB_SPF_KINEMATICS_set_absolut_output_kin
        } else {
          LIB_SPF_KINEMATICS_set_simultanous_kin
        }
        if {[llength [info commands LIB_CTRL_standard_path_between_rotary_motions_checking]]} {
          LIB_CTRL_standard_path_between_rotary_motions_checking "pos_to_sim"
        }
      }
    }

    if {$lib_ge_env(major_version) >= 9 && [llength [info commands MOM_convert_point]]} {

      # Calculate the Tool-axis as an combination of CSYS_ROTATION and the Lokal tool axis
      # in the block template the mom_init_pos is added to mom_out_angle_pos
      # for this case the mom_init_pos is subtraccted in this proc
      # we need mom_int_pos for NX8.5 in the template
      # works now also for non_orthogonal machines
      # mom_result1 contains the second solution

      if {[info exist mom_result]} {unset mom_result}
      if {[info exist mom_result1]} {unset mom_result1}
      if {[info exist ::mom_warning_info]} {unset ::mom_warning_info}
      MTX3_transpose oper_mcs_matrix tmp_mat
      MTX3_vec_multiply mom_tool_axis tmp_mat tmp_tool_axis

# Do this staff because of standard path between motion (COE,GB,HES)
#----------------
      uplevel #0 {
        trace add variable ::mom_warning_info write LIB_SPF_convert_point_TRACER
        proc LIB_SPF_convert_point_TRACER {args} {
          if {$::mom_warning_info == "WARNING: unable to determine valid rotary positions"} {
            set ::mom_warning_info ""
            set ::open_limits_for_convert_point 1
          }
        }
      }
#----------------

      MOM_convert_point mom_mcs_goto tmp_tool_axis

#----------------
      uplevel #0 {
        trace remove variable ::mom_warning_info write LIB_SPF_convert_point_TRACER
      }

      if {[info exists ::open_limits_for_convert_point]} {
        unset ::open_limits_for_convert_point
        if {[info exists ::restore_kin_5th_axis_min_limit]} {
          set ::mom_kin_5th_axis_min_limit $::restore_kin_5th_axis_min_limit
          set ::mom_kin_5th_axis_max_limit $::restore_kin_5th_axis_max_limit
          MOM_reload_kinematics
        }
        MOM_convert_point mom_mcs_goto tmp_tool_axis
      }
#-----------------

      if {![info exist mom_result]} {
        LIB_GE_abort_message "No Output from MOM_convert_point in operation $::mom_path_name"
      }
      foreach {mom_pos(0) mom_pos(1) mom_pos(2) mom_pos(3) mom_pos(4)} $mom_result {break}

      set tmp_pos(0) [lrange $mom_result 3 3]
      set tmp_pos(1) [lrange $mom_result 4 4]

      if {[info exists mom_kin_4th_axis_direction]} {
        set mom_out_angle_pos(0) [LIB_SPF_rotset $tmp_pos(0) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction\
                                      $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis)\
                                        $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit 1]

        set mom_out_angle_pos(0) [expr $mom_out_angle_pos(0) - $mom_init_pos(3)]
      }
      if {[info exists mom_kin_5th_axis_direction]} {
        set mom_out_angle_pos(1) [LIB_SPF_rotset $tmp_pos(1) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction\
                                            $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis)\
                                            $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit 1]
        set mom_out_angle_pos(1) [expr $mom_out_angle_pos(1) - $mom_init_pos(4)]
      }
      array set prev_convert_mom_out_angle_pos [array get mom_out_angle_pos]

      if {![string match "*no_reset" $option]} {
        LIB_GE_snapshot LOAD_PERMANENT $lib_spf_convert_kin_snapshot
        MOM_reload_kinematics
        unset lib_spf_convert_kin_snapshot
      }
    } else {
      LIB_GE_abort_message "command 'LIB_SPF_convert_point' does not exist in current NX release" "Possible reason : Property 'Use Standard Path between Rotary Motion' is set to 'On'"
    }

  }
}
# <Documentation>
# This procedure converts the current position (mom_pos and mom_alt_pos) into the desired kinematic system.
# Internally the mom_pos is stored in a list mom_result and mom_alt_pos in a list mom_result1.
# The lists (mom_result,mom_result1) are then converted to mom_pos and mom_alt_pos in the desired kinematic system.
# Further the mom_out_angle_pos is calculated with the limits in the defined configuration, taking into account the
# limit and mom_kin_(4)5th_axis_direction variables.
# <Arguments>
# option
# real - Use the real kinematics.
# plane - Use the plane kinematics (table-table and orthogonal).
# plane_no_reset - Use the plane kinematics will not be reset to the kinematics which was active when entering the proc
# simultaneous - Use the simultaneous kinematics (head-head and real machine axis).
# reload - Reload mom_pos, mom_alt_pos, mom_out_angle_pos, mom_sys_leader and mom_sys_trailer values that were active before the last convert_point.
# <Returnvalue>
# The converted values are written to the mom_pos(0..2), mom_alt_pos(0..2), and mom_out_angle_pos(0..1) array variables.
# <Example>
# name: Example 1
# code: LIB_SPF_convert_point simultaneous
#       ECHO mom_pos mom_alt_pos mom_out_angle_pos
#       LIB_SPF_convert_point reload
# desc: This example converts the current position to simultaneous, does a debug output of the converted values, and resets
# the values to the original state
#____________________________________________________________________________________________
proc LIB_SPF_convert_binary_to_decimal {binary} {

  if {![LIB_SPF_is_number $binary]} {
    LIB_GE_abort_message "Received value 'INS->$binary<-' to function 'INS->LIB_SPF_convert_binary_to_decimal<-' is invalid" "Please verify"
  }

  if {$binary == 0} {
    return 0
  } elseif {[string match -* $binary]} {
    set sign -
    set binary [string range $binary[set binary {}] 1 end]
  } else {
    set sign {}
  }
  set res 0
  for {set j 0} {$j < [string length $binary]} {incr j} {
    set bit [string index $binary $j]
    set res [expr {$res << 1}]
    set res [expr {$res | $bit}]
  }
  return $sign$res
}
# <Documentation>
# This procedure converts numbers in binary format to their corresponding decimal format.
# <Arguments>
# binary
#   Binary expression to convert.
# <Returnvalue>
# Converted number.
# <Example>
# name: Example with 11011
# code: set result [LIB_SPF_convert_binary_to_decimal 11011]
# desc: result = 27.
# The conversion is done in the following scheme:
# 111001 = 1*pow(2,4)+1*pow(2,3)+0*pow(2,2)+1*pow(2,1)+1*pow(2,0) = 27
# ------------------------
# bit4 bit3 bit2 bit1 bit0
#  16    8    4    2    1
#   1    1    0    1    1
# ------------------------
#  16  + 8  + 0  + 2  + 1 = 27
#____________________________________________________________________________________________
proc MOM_auxfun {{auxfun ""} {mess ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_auxfun_text mom_auxfun_text_defined mom_auxfun

  set commandcheck(MOM_auxfun_ENTRY) [llength [info commands MOM_auxfun_ENTRY]]

  LIB_GE_command_buffer MOM_auxfun_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_auxfun_ENTRY)} {MOM_auxfun_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$auxfun != ""} {set mom_auxfun $auxfun}
  if {$mess == ""} {
    if {[hiset mom_auxfun_text_defined] && $mom_auxfun_text_defined == 1} {
      LIB_GE_command_buffer MOM_auxfun_text
      LIB_GE_command_buffer {
        MOM_do_template auxfun BUFFER
      } @OUTPUT
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_auxfun_text" "output_1"
      } @MESSAGE
      LIB_GE_command_buffer_output
      set mom_auxfun_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_auxfun
      LIB_GE_command_buffer {
        MOM_do_template auxfun
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_auxfun_message
    LIB_GE_command_buffer {
      MOM_do_template auxfun BUFFER
    } @OUTPUT
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_1"
    } @MESSAGE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_auxfun_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_auxfun_ENTRY)} {MOM_auxfun_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Auxiliary command is activated.
# Possibility to usse also this procedure through an other one
#
# <Internal Example>
# MOM_auxfun 10 "this is a test"
# MOM_auxfun 99
#____________________________________________________________________________________________
proc MOM_delay {{delay ""} {mess ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_delay_mode mom_delay_value mom_delay_revs mom_delay_text_defined mom_delay_text
  global mom_spindle_rpm
  global lib_flag

  set commandcheck(MOM_delay_ENTRY) [llength [info commands MOM_delay_ENTRY]]

  LIB_GE_command_buffer MOM_delay_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_delay_ENTRY)} {MOM_delay_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![hiset lib_flag(delay_with_revolution_supported)]} {set lib_flag(delay_with_revolution_supported) 0}

  if {$delay != ""} {
    set mom_delay_value $delay
    set mom_delay_mode "SECONDS"
  }

  if {$mom_delay_mode == "REVOLUTIONS"} {
    if {![hiset mom_spindle_rpm] || $mom_spindle_rpm == 0} {
      set error [LIB_SPF_add_warning "Spindle Error - Spindle rpm is not set"]
      set mom_delay_value 0
    } else {
      if {$lib_flag(delay_with_revolution_supported) == 0} {
        set mom_delay_value [expr $mom_delay_revs * 60 / $mom_spindle_rpm]
      }
    }
  }

  if {$mess == ""} {
    if {[hiset mom_delay_text_defined] && $mom_delay_text_defined == 1 && [hiset mom_delay_text] && [string trim $mom_delay_text] != ""} {
      LIB_GE_command_buffer MOM_delay_text
      LIB_GE_command_buffer {
        if {$mom_delay_mode == "SECONDS" || [LIB_GE_catch_do_template delay_rev BUFFER]} {
          MOM_do_template delay BUFFER
        }
      } @OUTPUT
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_delay_text" "output_1"
      } @MESSAGE
      LIB_GE_command_buffer_output
      set mom_delay_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_delay
      LIB_GE_command_buffer {
        if {$mom_delay_mode == "SECONDS" || [LIB_GE_catch_do_template delay_rev]} {
          MOM_do_template delay
        }
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_delay_message
    LIB_GE_command_buffer {
      if {$mom_delay_mode == "SECONDS" || [LIB_GE_catch_do_template delay_rev]} {
        MOM_do_template delay BUFFER
      }
    } @OUTPUT
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_1"
    } @MESSAGE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_delay_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_delay_ENTRY)} {MOM_delay_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Delay command is activated.
# Possibility to usse also this procedure thru an other one (only with seconds mode)
#
# <Internal Example>
# MOM_delay 5 "this is a test"
# MOM_delay 3
#____________________________________________________________________________________________
proc MOM_opstop {{mess ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_opstop_ENTRY) [llength [info commands MOM_opstop_ENTRY]]

  LIB_GE_command_buffer MOM_opstop_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_ENTRY)} {MOM_opstop_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_opstop_LIB $mess

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opstop_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opstop_ENTRY)} {MOM_opstop_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Program Opstop command is activated.
# "option" corresponding to opstop text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_operator_message {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_operator_message
  global mom_operator_message_defined

  set commandcheck(MOM_operator_message_ENTRY) [llength [info commands MOM_operator_message_ENTRY]]

  LIB_GE_command_buffer MOM_operator_message_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_operator_message_ENTRY)} {MOM_operator_message_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![hiset mom_operator_message_defined] || $mom_operator_message_defined == 1} {

    LIB_GE_message "$mom_operator_message" "output_1" 0 "" 1

  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_operator_message_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_operator_message_ENTRY)} {MOM_operator_message_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is executed when the Text command is activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_text {} {

  global mom_user_defined_text

  set commandcheck(MOM_text_ENTRY) [llength [info commands MOM_text_ENTRY]]

  LIB_GE_command_buffer MOM_text_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_text_ENTRY)} {MOM_text_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

        if {[string length $mom_user_defined_text] > 0} {
          LIB_GE_message "$mom_user_defined_text" "output_1" 0 "" 1
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_text_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_text_ENTRY)} {MOM_text_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the Insert command is activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_insert {} {

  global mom_Instruction

  set commandcheck(MOM_insert_ENTRY) [llength [info commands MOM_insert_ENTRY]]

  LIB_GE_command_buffer MOM_insert_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_insert_ENTRY)} {MOM_insert_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

         MOM_output_literal "$mom_Instruction"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_insert_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_insert_ENTRY)} {MOM_insert_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the Insert command is activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_prefer_solution {} {
  global mom_prefer_output_min_defined mom_prefer_output_max_defined
  global mom_prefer_output_min mom_prefer_output_max
  global mom_prefer_axis
  global lib_flag

  if {![llength [info commands MOM_set_preferred_solution]]} {
    LIB_SPF_add_warning "Set Preferred Solution UDE only available after NX1953"
    return
  }

  if {![string compare $mom_prefer_axis $::mom_kin_4th_axis_leader]} {
    set axis 4th
  } elseif  {![string compare $mom_prefer_axis $::mom_kin_5th_axis_leader]} {
    set axis 5th
  } elseif {![string compare $mom_prefer_axis OFF]} {
    set axis Off
  } else {
    LIB_SPF_add_warning "Axis set wrong in UDE Preferred Solution, should be $::mom_kin_4th_axis_leader or $::mom_kin_5th_axis_leader"
    return
  }

  if {$axis != "Off"} {
    if {$mom_prefer_output_min_defined == 0} {
      set min [set ::mom_kin_${axis}_axis_min_limit]
    } else {
      set min $mom_prefer_output_min
    }
    if {$mom_prefer_output_max_defined == 0} {
      set max [set ::mom_kin_${axis}_axis_max_limit]
    } else {
      set max $mom_prefer_output_max
    }

    if {$lib_flag(in_operation) == 0} {
      CONF_SPF_setting set prefer_solution_axis $axis
      CONF_SPF_setting set prefer_solution_min $min
      CONF_SPF_setting set prefer_solution_max $max
    } else {
      MOM_set_preferred_solution $axis $min $max
      set lib_flag(preferred_solution) $axis
    }
    set lib_flag(preferred_solution_min) $min
    set lib_flag(preferred_solution_max) $max
  } else {
    MOM_set_preferred_solution OFF
    set lib_flag(preferred_solution) OFF
  }


}
# <Internal Documentation>
#
# This procedure is executed when Preferred Solution UDE is activated.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_prefun {{prefun ""} {mess ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_prefun_text mom_prefun_text_defined mom_prefun

  set commandcheck(MOM_prefun_ENTRY) [llength [info commands MOM_prefun_ENTRY]]

  LIB_GE_command_buffer MOM_prefun_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_prefun_ENTRY)} {MOM_prefun_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$prefun != ""} {set mom_prefun $prefun}

  if {$mess == ""} {
    if {[hiset mom_prefun_text_defined] && $mom_prefun_text_defined == 1} {
      LIB_GE_command_buffer MOM_prefun_text
      LIB_GE_command_buffer {
        MOM_do_template prefun BUFFER
      } @OUTPUT
      LIB_GE_command_buffer {
        LIB_GE_message "$mom_prefun_text" "output_1"
      } @MESSAGE
      LIB_GE_command_buffer_output
      set mom_prefun_text_defined 0
    } else {
      LIB_GE_command_buffer MOM_prefun
      LIB_GE_command_buffer {
        MOM_do_template prefun
      } @OUTPUT
      LIB_GE_command_buffer_output
    }
  } else {
    LIB_GE_command_buffer MOM_prefun_message
    LIB_GE_command_buffer {
      if {$mom_delay_mode == "SECONDS" || [LIB_GE_catch_do_template delay_rev]} {
        MOM_do_template prefun BUFFER
      }
    } @OUTPUT
    LIB_GE_command_buffer {
      LIB_GE_message "$mess" "output_1"
    } @MESSAGE
    LIB_GE_command_buffer_output
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_prefun_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_prefun_ENTRY)} {MOM_prefun_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Auxiliary command is activated.
# Possibility to usse also this procedure thru an other one
#
# <Internal Example>
# MOM_prefun 10 "this is a test"
# MOM_prefun 99
#____________________________________________________________________________________________
proc MOM_stop {{mess ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_stop_ENTRY) [llength [info commands MOM_stop_ENTRY]]

  LIB_GE_command_buffer MOM_stop_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_ENTRY)} {MOM_stop_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_stop_LIB $mess

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_stop_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_stop_ENTRY)} {MOM_stop_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Program Stop command is activated.
# "option" corresponding to stop text
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_opskip_on {} {

  global mom_sys_opskip_block_leader
  global mom_opskip_text mom_opskip_text_defined

  set commandcheck(MOM_opskip_on_ENTRY) [llength [info commands MOM_opskip_on_ENTRY]]

  LIB_GE_command_buffer MOM_opskip_on_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opskip_on_ENTRY)} {MOM_opskip_on_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

      if {[hiset mom_opskip_text_defined] && $mom_opskip_text_defined == 1} {
        LIB_GE_message $mom_opskip_text
      }

  MOM_set_line_leader always  $mom_sys_opskip_block_leader

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opskip_on_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opskip_on_ENTRY)} {MOM_opskip_on_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Optional skip command is activated.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_opskip_off {} {

  global mom_sys_opskip_block_leader
  global mom_opskip_text mom_opskip_text_defined

  set commandcheck(MOM_opskip_off_ENTRY) [llength [info commands MOM_opskip_off_ENTRY]]

  LIB_GE_command_buffer MOM_opskip_off_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_opskip_off_ENTRY)} {MOM_opskip_off_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

      MOM_set_line_leader off  $mom_sys_opskip_block_leader

      if {[hiset mom_opskip_text_defined] && $mom_opskip_text_defined == 1} {
        LIB_GE_message $mom_opskip_text
      }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_opskip_off_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_opskip_off_ENTRY)} {MOM_opskip_off_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# This procedure is executed when the Optional skip command is activated.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_coolant_on {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_coolant_mode mom_coolant_status
  global mom_coolant_text_defined mom_coolant_text

  set commandcheck(MOM_coolant_on_ENTRY) [llength [info commands MOM_coolant_on_ENTRY]]



  LIB_GE_command_buffer MOM_coolant_on_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_coolant_on_ENTRY)} {MOM_coolant_on_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_coolant_status != "OFF"} {set mom_coolant_status "ON"}
  #Fix coolant UDE set to ON, coolant code is not output issue
  if {$mom_coolant_status == "ON" && $mom_coolant_mode == ""} {set mom_coolant_mode "ON"}

  if {[info exists mom_coolant_text_defined] && $mom_coolant_text_defined == 1} {
    if {$mom_coolant_text == "AIR"} {
      if {$mom_coolant_mode == "ON"} {
        set mom_coolant_mode "AIR"
      } elseif {$mom_coolant_mode == "THRU"} {
        set mom_coolant_mode "AIRTHRU"
      }
    }
  }
  if {$mom_coolant_status == "ON" && $mom_coolant_mode != ""} {set mom_coolant_status $mom_coolant_mode}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_coolant_on_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_coolant_on_ENTRY)} {MOM_coolant_on_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is executed when the coolant_on command is activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_coolant_off {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_coolant_mode

  set commandcheck(MOM_coolant_off_ENTRY) [llength [info commands MOM_coolant_off_ENTRY]]

  LIB_GE_command_buffer MOM_coolant_off_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_coolant_off_ENTRY)} {MOM_coolant_off_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer MOM_coolant_off
  LIB_GE_command_buffer {
    CONF_CTRL_coolant set coolnt_auto 0
    set mom_coolant_mode "OFF"
    MOM_do_template coolant_off
  } @OUTPUT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_coolant_off_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_coolant_off_ENTRY)} {MOM_coolant_off_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is executed when the coolant_off command is activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_on_output_file_close {} {

}
# <Internal Documentation>
# This procedure is executed before the outputfile close
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_before_output {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_spf lib_ge_pb_empty_o_buffer lib_ge_line_length
  global mom_o_buffer lib_ge_line_info lib_ge lib_spf lib_flag

  set commandcheck(MOM_before_output_LIB_ENTRY) [llength [info commands MOM_before_output_LIB_ENTRY]]

  if {[CONF_GE_debug post_time] == 2 && $lib_spf(clock,exists) && [info exists lib_spf(clock,start)]} {
    if {$::lib_ge_tclversion > 8.3} {
      set lib_spf(clock,oper)   [format %.01f [clock clicks -milliseconds]]
    } else {
      set lib_spf(clock,oper)   [format %.01f [clock clicks]]
    }
    set lib_spf(clock,status) [format %.0f [expr $lib_spf(clock,oper)-$lib_spf(clock,start)]]
    if {[info exists lib_spf(clock,prev)]} {
      set lib_spf(clock,delta) [format %.0f [expr $lib_spf(clock,prev)-$lib_spf(clock,oper)]]
    } else {
      set lib_spf(clock,delta) 0
    }
    set mom_o_buffer "[LIB_GE_posttime_format $lib_spf(clock,status)] [LIB_GE_posttime_format $lib_spf(clock,delta)] $mom_o_buffer"
    set lib_spf(clock,prev) $lib_spf(clock,oper)
  }

  if {$commandcheck(MOM_before_output_LIB_ENTRY)} {MOM_before_output_LIB_ENTRY "start"}
  #---------------------------------------------------------------------------------

  set mom_o_buffer [string trimright $mom_o_buffer]

  if {[regexp {\mNEWLINE\M} [LIB_GE_string_toupper [string trim $mom_o_buffer]]]} {
    set mom_o_buffer " "
  }

  if {![info exists lib_ge(hidden_output)]} {
    MOM_output_to_listing_device "Cannot run current post-processor, one or more files could be overloaded"
    LIB_GE_abort_message "Cannot run current post-processor, one or more files could be overloaded" "Please check"
  }

  # Handling to ignore or restore the output
  switch -- $lib_ge(hidden_output) {
    "ignore_output" {
      set lib_ge(hidden_output,status) 1
      MOM_set_seq_off
      set mom_o_buffer ""
    }
    "ignore_and_buffer_output" {
      set lib_ge(hidden_output,status) 1
      MOM_set_seq_off
      LIB_GE_hidden_output_buffer $mom_o_buffer
      set mom_o_buffer ""
    }
    default {
      if {[info exists lib_ge(hidden_output,status)] && $lib_ge(hidden_output,status)} {
        if {[CONF_CTRL_setting sequence_number] == 1} {MOM_set_seq_on}
        set lib_ge(hidden_output,status) 0
      }
    }
  }

  if {[info exists lib_ge_pb_empty_o_buffer] && $lib_ge_pb_empty_o_buffer == 1} {
    #if in PB PB_CMD_LIB_ is set to supress standard output
    # we will flush mom_o_buffer
    set mom_o_buffer ""
  }

  if {[CONF_SPF_advanced_settings output_cleanup]} {
    if {![catch {set new_mom_o_buffer [LIB_SPF_eliminate_zero_inline $mom_o_buffer [CONF_SPF_advanced_settings word_separator] [CONF_SPF_advanced_settings max_decimal_place]]}]} {
      set mom_o_buffer $new_mom_o_buffer
    }
  }


  if {[string length $mom_o_buffer] > [CONF_SPF_file max_line_length]} {
    set tmp_mom_o_buffer_before_output $mom_o_buffer
    if {[regexp -- "\\[CONF_GE_msg message_dspa1]" $mom_o_buffer]} {
      set mom_o_buffer "[string range $mom_o_buffer 0 [expr [CONF_SPF_file max_line_length]-2]][CONF_GE_msg message_dspz1]"
    } else {
      set mom_o_buffer [string range $mom_o_buffer 0 [expr [CONF_SPF_file max_line_length]-1]]
    }

    lappend lib_ge_line_info [list \
    "The output line is longer than allowed (Max: [CONF_SPF_file max_line_length] / Current: [string length $mom_o_buffer]):" \
    "\tBefore: $tmp_mom_o_buffer_before_output" \
    "\tAfter: $mom_o_buffer" ]
  }

  #---------------------------------------------------------------------------------
  if {$commandcheck(MOM_before_output_LIB_ENTRY)} {MOM_before_output_LIB_ENTRY "end"}

  LIB_GE_output_comes_from_output

  set ::_output_array($::_counter) $mom_o_buffer
  set ::_output_tag_array($::_counter) [lindex $::_tag 0]
  incr ::_counter

}
# <Internal Documentation>
# This procedure is executed before output
#
# -> KEYWORDS <-
# NEWLINE = A new line in the outputcode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_conic {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_start_of_conic_LIB_ENTRY) [llength [info commands MOM_start_of_conic_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_conic_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_conic_LIB_ENTRY)} {MOM_start_of_conic_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_start_of_conic_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_conic_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_conic_LIB_ENTRY)} {MOM_start_of_conic_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the start_of_conic event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_conic {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_end_of_conic_LIB_ENTRY) [llength [info commands MOM_end_of_conic_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_conic_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_conic_LIB_ENTRY)} {MOM_end_of_conic_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_end_of_conic_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_conic_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_conic_LIB_ENTRY)} {MOM_end_of_conic_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_conic event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_region_marker {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_start_of_region_marker_LIB_ENTRY) [llength [info commands MOM_start_of_region_marker_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_region_marker_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_region_marker_LIB_ENTRY)} {MOM_start_of_region_marker_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_start_of_region_marker_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_region_marker_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_region_marker_LIB_ENTRY)} {MOM_start_of_region_marker_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the start_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_region_marker {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_end_of_region_marker_LIB_ENTRY) [llength [info commands MOM_end_of_region_marker_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_region_marker_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_region_marker_LIB_ENTRY)} {MOM_end_of_region_marker_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_end_of_region_marker_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_region_marker_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_region_marker_LIB_ENTRY)} {MOM_end_of_region_marker_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cut_wire {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_cut_wire_LIB_ENTRY) [llength [info commands MOM_cut_wire_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cut_wire_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cut_wire_LIB_ENTRY)} {MOM_cut_wire_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_cut_wire_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cut_wire_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cut_wire_LIB_ENTRY)} {MOM_cut_wire_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_flush {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_flush_LIB_ENTRY) [llength [info commands MOM_flush_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_flush_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_flush_LIB_ENTRY)} {MOM_flush_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_flush_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_flush_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_flush_LIB_ENTRY)} {MOM_flush_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_flush_tank {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_flush_tank_LIB_ENTRY) [llength [info commands MOM_flush_tank_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_flush_tank_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_flush_tank_LIB_ENTRY)} {MOM_flush_tank_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_flush_tank_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_flush_tank_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_flush_tank_LIB_ENTRY)} {MOM_flush_tank_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_power {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_power_LIB_ENTRY) [llength [info commands MOM_power_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_power_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_power_LIB_ENTRY)} {MOM_power_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_power_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_power_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_power_LIB_ENTRY)} {MOM_power_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_pprint {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_pprint_LIB_ENTRY) [llength [info commands MOM_pprint_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_pprint_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_pprint_LIB_ENTRY)} {MOM_pprint_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_pprint_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_pprint_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_pprint_LIB_ENTRY)} {MOM_pprint_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_modes {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_set_modes_LIB_ENTRY) [llength [info commands MOM_set_modes_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_modes_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_modes_LIB_ENTRY)} {MOM_set_modes_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_set_modes_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_modes_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_modes_LIB_ENTRY)} {MOM_set_modes_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_axis {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_set_axis_LIB_ENTRY) [llength [info commands MOM_set_axis_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_set_axis_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_axis_LIB_ENTRY)} {MOM_set_axis_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_set_axis_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_axis_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_axis_LIB_ENTRY)} {MOM_set_axis_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the MOM_set_axis event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_ball_center_output {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_ball_center_output_LIB_ENTRY) [llength [info commands MOM_ball_center_output_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_ball_center_output_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_ball_center_output_LIB_ENTRY)} {MOM_ball_center_output_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_ball_center_output_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_ball_center_output_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_ball_center_output_LIB_ENTRY)} {MOM_ball_center_output_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the MOM_ball_center_output event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_wire {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_thread_wire_LIB_ENTRY) [llength [info commands MOM_thread_wire_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_wire_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_wire_LIB_ENTRY)} {MOM_thread_wire_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_thread_wire_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_wire_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_wire_LIB_ENTRY)} {MOM_thread_wire_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tlset {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tlset_LIB_ENTRY) [llength [info commands MOM_tlset_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tlset_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tlset_LIB_ENTRY)} {MOM_tlset_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_tlset_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tlset_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tlset_LIB_ENTRY)} {MOM_tlset_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tool_preselect {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tool_preselect_LIB_ENTRY) [llength [info commands MOM_tool_preselect_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tool_preselect_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_preselect_LIB_ENTRY)} {MOM_tool_preselect_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_tool_preselect_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tool_preselect_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tool_preselect_LIB_ENTRY)} {MOM_tool_preselect_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_translate {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_translate_LIB_ENTRY) [llength [info commands MOM_translate_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_translate_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_translate_LIB_ENTRY)} {MOM_translate_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_translate_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_translate_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_translate_LIB_ENTRY)} {MOM_translate_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_wire_angles {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_wire_angles_LIB_ENTRY) [llength [info commands MOM_wire_angles_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_wire_angles_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_wire_angles_LIB_ENTRY)} {MOM_wire_angles_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_wire_angles_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_wire_angles_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_wire_angles_LIB_ENTRY)} {MOM_wire_angles_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_wire_cutcom {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_wire_cutcom_LIB_ENTRY) [llength [info commands MOM_wire_cutcom_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_wire_cutcom_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_wire_cutcom_LIB_ENTRY)} {MOM_wire_cutcom_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_wire_cutcom_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_wire_cutcom_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_wire_cutcom_LIB_ENTRY)} {MOM_wire_cutcom_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_wire_guides {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_wire_guides_LIB_ENTRY) [llength [info commands MOM_wire_guides_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_wire_guides_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_wire_guides_LIB_ENTRY)} {MOM_wire_guides_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_wire_guides_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_wire_guides_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_wire_guides_LIB_ENTRY)} {MOM_wire_guides_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end_of_region_marker event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_program {} {

  global lib_start_of_program_was_called lib_ge_env lib_ge_slash lib_fh_file_delete lib_spf
  global mom_event_handler_file_name mom_definition_file_name lib_flag mom_mcs_info lib_flag
  global mom_post_in_synchronization mom_post_in_simulation lib_definition lib_spf
  global mom_operation_info mom_cutter_info mom_nxt_event_data lib_pretreatment
  global mom_operation_name_with_optim_list lib_selected_group_name lib_ge_debug
  global mom_kin_output_unit mom_kin_machine_resolution

  if {[info command MOM_reload_kinematics_variable] != "MOM_reload_kinematics_variable"} {
    proc MOM_reload_kinematics_variable {args} {
      MOM_reload_kinematics
    }
  }

  set lib_start_of_program_was_called 1 ;# indicates that event eneration has started

  if {$::tcl_version > 8.3 && [llength [info commands LIB_Shell_reload_functions]]} {LIB_Shell_reload_functions}

  LIB_SPF_set_initial_properties

  LIB_SPF_reset_initial_globals

  if {[CONF_SPF_advanced_settings parse_def_file] == 1} {
    if {[catch {LIB_SPF_parse_definition_file_init [LIB_FH_file_to_list $mom_definition_file_name lib_spf(definitionfiles)]}]} {
      LIB_GE_abort_message "Analysis of the file '$mom_definition_file_name' is impossible" "(MOM_start_of_program)"
    }
  }

  catch {MOM_ask_mcs_info}
  LIB_SPF_get_machine_mcs_info
  LIB_SPF_ask_mcs_info
  LIB_SPF_mom_kin_vector_precision
  if {!$lib_spf(convert_unit)} {LIB_SPF_convert_unit_format}

  if {$::lib_ge_pretreatment_runtime} {PT_start_of_program ; return}


  # Can't cleanup outputfile at specific situations
  if {[info exists mom_post_in_synchronization] && $mom_post_in_synchronization || [info exists mom_post_in_simulation] && $mom_post_in_simulation != 0} {
    CONF_SPF_file set cleanup_post_output 0
  }

  LIB_SPF_output_cleanup

  LIB_SPF_display_listing

  LIB_SPF_op_tool_param_condition

  LIB_GE_impact_procs

  # Special call for e.g. XML definiton
  LIB_SPF_config_params

  set lib_ge_debug(active) [info exists ::mom_debug_assign_var]
  LIB_SPF_run_pretreatment

  # Monitor all files that are opened
  trace add execution MOM_open_output_file enter LIB_SPF_trace_open_output_file
  # Monitor all files that have been closed in order not to have to close them in the end
  trace add execution MOM_close_output_file enter LIB_SPF_trace_close_output_file
  LIB_SPF_output_setting

  LIB_SPF_subprogram_output_setting

  LIB_SPF_warning_setting

  LIB_GE_output_comes_from

  set digit 0
  regexp -- {\.([0-9]+)} [LIB_SPF_ask_format Coordinate] all digit
  set compare 0.[LIB_GE_string_append 0 [expr $digit -1]]1

  if {$digit > 0} {
    if {$compare < $mom_kin_machine_resolution} {
      if {$::lib_ge_env(major_version) < 12 || [info exists ::mom_output_file_basename] && $::mom_output_file_basename == "postprocess_preview"} {
        LIB_SPF_add_warning "Output may not be as expected - Machine Resolution should be minimum $compare[LIB_GE_string_tolower $::mom_kin_output_unit]"
      }
    }
  }

  # Alway activatie advanced turbo mode, Post Core will deside which event can be processed in turbo mode
  if {[CONF_CTRL_setting turbo_mode] == 3} {
    LIB_SPF_turbo_status "enable" "advanced"
  }

  LIB_SPF_init_adv_turbo_vars

  # generate the macro arrays
  if {[llength [info commands DEFINE_MACROS]]} {DEFINE_MACROS}

  if {[llength [info commands LIB_ISV_open_files]] && [CONF_SPF_file create_cse_ini_file] == 1} {
    # Call only for legacy, Bug 1464
    LIB_ISV_open_files
    LIB_GE_error_message "Procedure call for 'LIB_ISV_open_files' not longer supported, use 'LIB_SPF_ini_open_files' or better the Buffers" "Please change"
  }
  if {[llength [info commands LIB_SPF_ini_open_files]] && [CONF_SPF_file create_cse_ini_file] == 1} {
    LIB_SPF_ini_open_files
  }

  LIB_SPF_default_initial_setting

  if {![info exists lib_spf(chain_default_globals_setting)]} {
    LIB_GE_chain_set_default_globals mom_kin* mom_sys*
    set lib_spf(chain_default_globals_setting) 1
  }

  LIB_SPF_check_select_object
  # Only for customization for the controller level
  if {[llength [info commands MOM_start_of_program_include]]} {MOM_start_of_program_include}

  if {[llength [info commands MOM_start_of_program_LIB]]} {MOM_start_of_program_LIB}
}
# <Internal Documentation>
# This procedure is executed at start of program
#
# <Internal Example>
#
#____________________________________________________________________________________________

proc LIB_SPF_exists_address {address {supress_error 0}} {

  global lib_definition

  if {[llength [info commands MOM_has_definition_element]]} {
    return [MOM_has_definition_element ADDRESS $address]
  } elseif {[CONF_SPF_advanced_settings parse_def_file] == 0} {
    if {$supress_error} {return -1}
    LIB_GE_abort_message "In order to use '[info level [info level]]' command, 'CONF_SPF_advanced_settings parse_def_file' has to be activated"
  }

  if {[info exists lib_definition(ADDRESS)] && [lsearch -exact $lib_definition(ADDRESS) $address] >= 0} {
    return 1
  } else {
    return 0
  }
}
# <Documentation>
# This procedure checks whether the given address is defined in one of the currently sourced definition files.
# In order to use this procedure you have to activate the property [CONF_SPF_advanced_settings parse_def_file].
# <Arguments>
# address
#   Address to be checked.
# supress_error
#   Continue postprocessing on an error reading the definition file. Valid options are:
# 1 - Do not abort (returns -1 if file cannot be parsed).
# 0 - Abort.
# <Returnvalue>
# 0 - Address is not defined.
# 1 - Address is defined.
# -1 - Definition file cannot be parsed (only if option suppress_error is set).
# <Example>
# set result [LIB_SPF_exists_address M_spindle]
#____________________________________________________________________________________________
proc LIB_SPF_ask_address {address {parameter "ALL"} {supress_error 0}} {

  global lib_definition mom_result

  if {[llength [info commands MOM_ask_definition_element]]} {
    if {[MOM_ask_definition_element ADDRESS $address]} {
      if {$parameter == "ALL"} {
        # Bugfix, list is not valid separated with NX11.0.0
        regsub -all (\}\{) $mom_result "\} \{" mom_result
        return $mom_result
      } else {
        # Bugfix, list is not valid separated with NX11.0.0
        regsub -all (\}\{) $mom_result "\} \{" mom_result
        foreach e $mom_result {
          if {[string match [lindex $e 0] $parameter]} {
                  # Trim "MIN -99999.99900,ABORT", result -99999.99900
                  return [lindex [split [lindex $e 1] ","] 0]
          }
        }
      }
    }
    return FALSE
  } elseif {[CONF_SPF_advanced_settings parse_def_file] == 0} {
    if {$supress_error} {return -1}
    LIB_GE_abort_message "In order to use '[info level [info level]]' command, 'CONF_SPF_advanced_settings parse_def_file' has te be activated"
  }

  if {[info exists lib_definition(ADDRESS,$address)]} {
    if {$parameter == "ALL"} {
      return $lib_definition(ADDRESS,$address)
    } else {
      foreach e $lib_definition(ADDRESS,$address) {
        if {[string match [lindex $e 0] $parameter]} {
                return [lindex $e 1]
        }
      }
      return FALSE
    }
  } else {
    LIB_GE_error_message "File ADDRESS 'INS->$address<-' can not evaluated at LIB_SPF_ask_format" "Please check"
  }
}
# <Documentation>
# This procedure reads the definition elements of an address.
# In order to use this procedure, you have to activate the property [CONF_SPF_advanced_settings parse_def_file].
# <Arguments>
# address
#   Address to be read.
# parameter
#   Address definition element to be read.
#   Valid parameters are:
#   ALL         - reads all elements
#   FORMAT      - format to be used for the address
#   FORCE       - modality of the address
#   LEADER      - leader of the address
#   TRAILER     - trailer of the address
#   ZERO_FORMAT - format to be used when value is zero
#   Note: All other elements that may be defined for a specific address may be queried.
# supress_error
#   Continue postprocessing on an error reading the definition file. Valid options are:
# 1 - Do not abort (returns -1 if file cannot be parsed)
# 0 - Abort.
# <Returnvalue>
# FALSE - Address or element does not exist.
# -1    - Definition file cannot be parsed (only if option supress_error is set).
# Value - Query was successful.
# <Example>
# name: Example to read all elements
# code: set resultlist [LIB_SPF_ask_address M_spindle]
# desc: The variable resultlist contains something like: {FORMAT Digit_2} {FORCE off} {LEADER M} {ZERO_FORMAT Zero_int}
# <Example>
# name: Example to read a specific element
# code: set resultvalue [LIB_SPF_ask_address M_spindle LEADER]
# desc: resultvalue = M
#____________________________________________________________________________________________
proc LIB_SPF_exists_format {format {supress_error 0}} {

  global lib_definition

  if {[llength [info commands MOM_has_definition_element]]} {
    return [MOM_has_definition_element FORMAT $format]
  } elseif {[CONF_SPF_advanced_settings parse_def_file] == 0} {
    if {$supress_error} {return -1}
    LIB_GE_abort_message "In order to use '[info level [info level]]' command, 'CONF_SPF_advanced_settings parse_def_file' has te be activated"
  }

  if {[info exists lib_definition(FORMAT)] && [lsearch -exact $lib_definition(FORMAT) $format] >= 0} {
    return 1
  } else {
    return 0
  }
}
# <Documentation>
# This procedure checks if the given format name is defined in one of the currently sourced definition files.
# In order to use this procedure you have to activate the property [CONF_SPF_advanced_settings parse_def_file].
# <Arguments>
# format
#   Format which should be checked on its existence.
# supress_error
#   Continue postprocessing on an error reading the definition file. Valid options are:
# 1 - Do not abort (returns -1 if file cannot be parsed).
# 0 - Abort.
# <Returnvalue>
# 0 - Format is not defined.
# 1 - Format is defined.
# -1 - Definition file cannot be parsed (only if option suppress_error is set).
# <Example>
# set result [LIB_SPF_exists_format Coordinate]
#____________________________________________________________________________________________
proc LIB_SPF_ask_format {format {supress_error 0}} {

  global lib_definition mom_result

  if {[llength [info commands MOM_ask_definition_element]]} {
    if {[MOM_ask_definition_element FORMAT $format]} {
      return [lindex [lindex $mom_result 0] 1]
    }
    return FALSE
  } elseif {[CONF_SPF_advanced_settings parse_def_file] == 0} {
    if {$supress_error} {return -1}
    LIB_GE_abort_message "In order to use '[info level [info level]]' command, 'CONF_SPF_advanced_settings parse_def_file' has te be activated"
  }

  if {[info exists lib_definition(FORMAT,$format)]} {
    return $lib_definition(FORMAT,$format)
  } else {
    LIB_GE_error_message "File FORMAT 'INS->$format<-' can not evaluated at LIB_SPF_ask_format" "Please check"
  }
}
# <Documentation>
# This procedure reads the format definition of the given format name out of the currently sourced definition files.
# In order to use this procedure, you have to activate the property [CONF_SPF_advanced_settings parse_def_file].
# <Arguments>
# format
#   Format to be checked.
# supress_error
#   Continue postprocessing on an error reading the definition file. Valid options are:
# 1 - Do not abort (returns -1 if file cannot be parsed).
# 0 - Abort.
# <Returnvalue>
# FALSE - Format does not exist.
# -1 - Definition file cannot be parsed (only if option suppress_error is set).
# Value - Query was successful.
# <Example>
# set result [LIB_SPF_ask_format Coordinate]
# result = &__5.4_
#____________________________________________________________________________________________
proc LIB_SPF_exists_block_template {block_template {supress_error 0}} {

  global lib_ge_env lib_definition

  if {[llength [info commands MOM_has_definition_element]]} {
    return [MOM_has_definition_element BLOCK $block_template]
  } elseif {[CONF_SPF_advanced_settings parse_def_file] == 0} {
    if {$supress_error || $lib_ge_env(major_version) < 11} {return -1}
    LIB_GE_abort_message "In order to use '[info level [info level]]' command, 'CONF_SPF_advanced_settings parse_def_file' has te be activated"
  }

  if {[info exists lib_definition(BLOCK_TEMPLATE)] && [lsearch -exact $lib_definition(BLOCK_TEMPLATE) $block_template] >= 0} {
    return 1
  } else {
    return 0
  }

}
# <Documentation>
# This procedure checks if the given block template name is defined in one of the currently sourced definition files.
# In order to use this procedure you have to activate the property [CONF_SPF_advanced_settings parse_def_file].
# <Arguments>
# block_template
#   Block template to be checked for its existence.
# supress_error
#   Continue postprocessing on an error reading the definition file. Valid options are:
# 1 - Do not abort (returns -1 if file cannot be parsed).
# 0 - Abort.
# <Returnvalue>
# 0 - Block template is not defined.
# 1 - Block template is defined.
# -1 - Definition file cannot be parsed (only if option suppress_error is set).
# <Example>
# LIB_SPF_exists_block_template circular_move]
#____________________________________________________________________________________________
proc LIB_SPF_ask_block_template {block_template {parameter "ALL"} {supress_error 0}} {

  global lib_definition mom_result

  if {[llength [info commands MOM_ask_definition_element]]} {
    if {[MOM_ask_definition_element BLOCK $block_template]} {
      if {$parameter == "ALL"} {
        # Bugfix, list is not valid separated with NX11.0.0
        regsub -all (\}\{) $mom_result "\} \{" mom_result
        return $mom_result
      } else {
        # Bugfix, list is not valid separated with NX11.0.0
        regsub -all (\}\{) $mom_result "\} \{" mom_result
        foreach e $mom_result {
          if {[string match [lindex $e 0] $parameter]} {
                  # Trim "$mom_helix_turn_number,\opt", result $mom_helix_turn_number
                  return [lindex [split [lindex $e 1] ","] 0]
          }
        }
      }
    }
    return FALSE
  } elseif {[CONF_SPF_advanced_settings parse_def_file] == 0} {
    if {$supress_error} {return -1}
    LIB_GE_abort_message "In order to use '[info level [info level]]' command, 'CONF_SPF_advanced_settings parse_def_file' has te be activated"
  }

  if {[info exists lib_definition(BLOCK_TEMPLATE,$block_template)]} {
    if {$parameter == "ALL"} {
      set resultlist $lib_definition(BLOCK_TEMPLATE,$block_template)
      regsub -all "\\\[" $resultlist " \"" resultlist
      regsub -all "\\\]" $resultlist "\"" resultlist
      return $resultlist
    } else {
      foreach e $lib_definition(BLOCK_TEMPLATE,$block_template) {
        if {[string match [lindex [split $e \[\]] 0] $parameter]} {
                return [lindex [split $e \[\]] 1]
        }
      }
      return FALSE
    }
  } else {
    LIB_GE_error_message "File BLOCK_TEMPLATE 'INS->$block_template<-' can not evaluated at LIB_SPF_ask_block_template" "Please check"
  }
}
# <Documentation>
# This procedure reads the definition elements of a block template.
# In order to use this procedure, you have to activate the property [CONF_SPF_advanced_settings parse_def_file].
# <Arguments>
# block_template
#   Block template to be read.
# parameter
#   Address definition element to read.
#   Valid parameters are:
#   ALL    - Reads all elements (this is the default)
#  Address - Specific address.
# supress_error
#   Continue postprocessing on an error reading the definition file. Valid option are:
# 1 - Do not abort (returns -1 if file cannot be parsed).
# 0 - Abort.
# <Returnvalue>
# FALSE - Address or element does not exist.
# -1 - Definition file cannot be parsed (only if option suppress_error is set).
# Value - Query was successful.
# <Example>
# name: Read ALL addresses
# code: set result [LIB_SPF_ask_block_template "linear_move_turbo"]
# desc: result = {G_motion[^sys_linear_code]} {X[^POSX]} {Y[^POSY]} {Z[^POSZ]}...
# <Example>
# name: Read a specific address
# code: set result [LIB_SPF_ask_block_template "linear_move_turbo" "G_motion"]
# desc: result = {{G_motion} {^sys_linear_code}}
#____________________________________________________________________________________________
proc LIB_SPF_trace_open_output_file {filename op} {

  global lib_fh_file_ids

  set filename [lindex $filename 1]
  if {[lsearch -exact $lib_fh_file_ids $filename] < 0} {
    set lib_fh_file_ids [LIB_GE_linsert_index $lib_fh_file_ids 0 $filename]
  }

}
# <Internal Documentation>
# Add Filename based from MOM_open_output_file into the filehandling prozess
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_SPF_trace_close_output_file {filename op} {

  global lib_fh_file_ids lib_fh_trace_file

  set filename [lindex $filename 1]
  if {![info exists lib_fh_trace_file] || $lib_fh_trace_file || \
       [lsearch -exact $lib_fh_file_ids $filename] < 0 } {return}

  if {[llength [info commands LIB_GE_lremove]]} {
    set lib_fh_file_ids [LIB_GE_lremove $lib_fh_file_ids $filename]
  }

}
# <Internal Documentation>
# Remove Filename based from MOM_close_output_file into the filehandling prozess
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
#____________________________________________________________________________________________
proc LIB_SPF_program_header_comment {} {

  set commandcheck(LIB_SPF_program_header_comment_LIB_ENTRY) [llength [info commands LIB_SPF_program_header_comment_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_program_header_comment_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_program_header_comment_LIB_ENTRY)} {LIB_SPF_program_header_comment_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_msg output_header_comment]} {
    LIB_GE_command_buffer HEADER_COMMENT

    LIB_GE_command_buffer {LIB_GE_message [LIB_DC_format_string "<15< : <40<" [list [LIB_GE_MSG "Created by"] $::mom_logname]]} @CREATED_BY
    LIB_GE_command_buffer {LIB_GE_message [LIB_DC_format_string "<15< : <40<" [list [LIB_GE_MSG "Date"] "[LIB_GE_date] , [LIB_GE_time]"]]} @DATE
    LIB_GE_command_buffer {LIB_GE_message [LIB_DC_format_string "<15< : <40<" [list [LIB_GE_MSG "Partname"] [LIB_SPF_get_partnname]]]} @PARTNAME

    LIB_GE_command_buffer_output
  }

  LIB_GE_command_buffer LIB_SPF_program_header_comment_LIB_ENTRY_custom
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_program_header_comment_LIB_ENTRY)} {LIB_SPF_program_header_comment_LIB_ENTRY custom}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[llength [info commands LIB_SPF_program_header_comment_custom]]} {LIB_SPF_program_header_comment_custom}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_program_header_comment_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_program_header_comment_LIB_ENTRY)} {LIB_SPF_program_header_comment_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#   This is the definition of the standard program header
# to customize the output use LIB_SPF_program_header_comment_custom.
#
# If you would like to supress the default output,
# set the buffer please to nothing.
# e.g. LIB_GE_command_buffer_seq LIB_SPF_program_header_comment HEADER_COMMENT {}
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_sub_header_comment {} {

  set commandcheck(LIB_SPF_sub_header_comment_LIB_ENTRY) [llength [info commands LIB_SPF_sub_header_comment_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_sub_header_comment_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_header_comment_LIB_ENTRY)} {LIB_SPF_sub_header_comment_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_msg output_header_comment]} {
    LIB_GE_command_buffer HEADER_COMMENT

    LIB_GE_command_buffer {LIB_GE_message [LIB_DC_format_string "<15< : <40<" [list [LIB_GE_MSG "Created by"] $::mom_logname]]} @CREATED_BY
    LIB_GE_command_buffer {LIB_GE_message [LIB_DC_format_string "<15< : <40<" [list [LIB_GE_MSG "Date"] "[LIB_GE_date] , [LIB_GE_time]"]]} @DATE
    LIB_GE_command_buffer {LIB_GE_message [LIB_DC_format_string "<15< : <40<" [list [LIB_GE_MSG "Partname"] [LIB_SPF_get_partnname]]]} @PARTNAME

    LIB_GE_command_buffer_output
  }

  LIB_GE_command_buffer LIB_SPF_sub_header_comment_LIB_ENTRY_custom
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_header_comment_LIB_ENTRY)} {LIB_SPF_sub_header_comment_LIB_ENTRY custom}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[llength [info commands LIB_SPF_sub_header_comment_custom]]} {LIB_SPF_sub_header_comment_custom}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_sub_header_comment_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_header_comment_LIB_ENTRY)} {LIB_SPF_sub_header_comment_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#   This is the definition of the standard sub header
# to customize the output use LIB_SPF_sub_header_comment_custom.
#
# If you would like to supress the default output,
# set the buffer please to nothing.
# e.g. LIB_GE_command_buffer_seq LIB_SPF_sub_header_comment HEADER_COMMENT {}
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_config_params {} {

  global lib_flag
  global lib_parameter

  #XXX

  return

  set lib_flag_init_array [array get lib_flag]
  set lib_parameter_init_array [array get lib_parameter]

  set file_name "d:\\tmp\\flag_list.csv"

  set f_id [open $file_name w+]

  foreach {name value} $lib_flag_init_array {
    puts $f_id "lib_flag;$name;$value"
  }

  foreach {name value} $lib_parameter_init_array {
    puts $f_id "lib_parameter;$name;$value"
  }

  close $f_id

  after 250

  exec cmd /c start excel $file_name

  after 5000

  while {[LIB_Shell_file_exists $file_name 1]} {

    file copy -force $file_name ${file_name}_return

    catch {file delete $file_name}

    after 100

  }

  set super_list [LIB_FH_file_to_list ${file_name}_return]

  foreach var $super_list {
    set var [split $var ";"]

    set [lindex $var 0]([lindex $var 1]) [lindex $var 2]
  }
}
# <Internal Documentation>
# This is called in MOM_start_of_program
# it is a prototype for a tool to configure flags and parameters
# at runtime of NX
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_group {} {

  global lib_selected_group_name mom_group_name

  if {![info exists lib_selected_group_name] || $lib_selected_group_name == ""} {set lib_selected_group_name $mom_group_name}

  set commandcheck(MOM_start_of_group_LIB_ENTRY) [llength [info commands MOM_start_of_group_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_group_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_group_LIB_ENTRY)} {MOM_start_of_group_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$::lib_ge_pretreatment_runtime} {PT_start_of_group ; return}
  if {[llength [info commands LIB_SPF_sub_output_start]]} {LIB_SPF_sub_output_start}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_group_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_group_LIB_ENTRY)} {MOM_start_of_group_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at start of group
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_group {} {

  if {$::lib_ge_pretreatment_runtime} {PT_end_of_group ; return}

  set commandcheck(MOM_end_of_group_LIB_ENTRY) [llength [info commands MOM_end_of_group_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_group_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_group_LIB_ENTRY)} {MOM_end_of_group_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands LIB_SPF_sub_output_end]]} {LIB_SPF_sub_output_end}
  set ::lib_flag(pattern_output_sub)  0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_group_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_group_LIB_ENTRY)} {MOM_end_of_group_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at end of group
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_machine_mode {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_machine_mode_LIB_ENTRY) [llength [info commands MOM_machine_mode_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_machine_mode_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_mode_LIB_ENTRY)} {MOM_machine_mode_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #MOM_output_literal "----------------> [info level [info level]]"
  LIB_SPF_default_initial_setting "machine_mode"

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_mode_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_mode_LIB_ENTRY)} {MOM_machine_mode_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed to set the machine mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_path {} {

  if {$::lib_ge_pretreatment_runtime} {PT_start_of_path ; return}

  global lib_flag lib_spf lib_pretreatment lib_param lib_ge_env
  global lib_sav_kin_4th_axis_leader lib_sav_kin_5th_axis_leader
  global mom_sys_leader mom_sys_advanced_postprocessing mom_advanced_postprocessing_status
  global mom_operation_type

  set lib_flag(in_operation) 1
  set lib_flag(cycle_move_count) 0

  # If optimized groups are used than the mom_machine_mode is "DRILL" but we don't cover it
  # so it is redefined to MILL in Start_of_path
  # Do this in before mom_machine_mode is used
  if {$::mom_machine_mode == "DRILL"} {set ::mom_machine_mode "MILL"}

  # Workaround for NX core Bug (PR7333369). Pretreatment only returns information for first operation if
  # more than 1 object is selected for Simulation (multiple selection is only possible in Simulation)
  # This is the fallback for the check in MOM_start_of_program (if mom_operation_name_list does not exist)
  # From NX1953, simulation and post both support multiple operations as default, selected objects number in pretreatment and normal run are always the same.
  if {[info exists lib_ge_env(major_version)] && $lib_ge_env(major_version) < 1953 && $lib_flag(pretreatment_all_operation) == 0} {
    if {[CONF_SPF_pt lib_spf_pretreatment] && [string toupper $::mom_current_oper_is_last_oper_in_program] == "NO" && ![LIB_SPF_pt_exists tag 1] } {
      LIB_GE_abort_message "More than one object selected for Simulation" "Currently only single object selection supported"
    }
    set lib_flag(pretreatment_all_operation) 1
  }

  if {[LIB_SPF_get_pretreatment operation_list last] == $::mom_path_name} {
    set lib_flag(last_operation_in_program) 1
  }

  if {[llength [info commands LIB_CTRL_define_machining_operation_type_name]]} {
    LIB_CTRL_define_machining_operation_type_name
  }

  LIB_SPF_check_compatibility

  LIB_SPF_get_mcs_info

  LIB_GE_chain_activate_chain_globals default

  if {[llength [info commands LIB_CTRL_sys_leader_home]]} {LIB_CTRL_sys_leader_home}

  LIB_SPF_KINEMATICS_reload_real_mach_kin_from_pt

  LIB_SPF_KINEMATICS_turbo_setting

  LIB_SPF_ask_type_subtype
  LIB_GE_chain_activate_chain_globals [LIB_SPF_define_active_chain]

  LIB_SPF_ui_unit_convert

    #NX1953 add preferred angle support
    LIB_SPF_set_preferred_solution

  LIB_SPF_check_approach_motion_splitting_type

  # Set rotary axis plane
  LIB_SPF_set_rotary_axis_plane

  #PR9239197 Fix. Add get pretreatment of UDE lock axis. To handle the case: with Lock Axis defined. In PC settings,
  # option "Plane Output Supported" is set to "All" and "Set Polar Mode also for Linear Motions" set to "off",
  # lock axis may not work.
  set lib_flag(axis_locked) [LIB_SPF_get_pretreatment mom_lock_axis]
  if {($lib_flag(axis_locked) == "XAXIS" || $lib_flag(axis_locked) == "YAXIS" || $lib_flag(axis_locked) == "ZAXIS") && [CONF_CTRL_moves polar_allowed_moves] == "ALL"} {
    if {[CONF_CTRL_setting plane_output_supported] == "ALL"} {
      CONF_CTRL_setting set plane_output_supported "NO_ORTHOGONAL"
      set lib_flag(plane_output_supported_all) 1
    }
    if {[CONF_CTRL_moves polar_feedrate] == 0} {
      CONF_CTRL_moves set polar_feedrate 1
      set lib_flag(polar_feedrate_off) 1
    }
  }

  if {[llength [info commands LIB_CTRL_config_millturn]]} {LIB_CTRL_config_millturn}
  # set mom_sys_leader from mom_kin_(x)th_axis_leader
  set mom_sys_leader(fourth_axis) $::mom_kin_4th_axis_leader
  set mom_sys_leader(fifth_axis) $::mom_kin_5th_axis_leader

  LIB_SPF_KINEMATICS_save_initial

  set lib_param(cutting_tool_axis) [LIB_SPF_get_pretreatment cutting_tool_axes]

  set lib_flag(first_linear_move) 0
  set lib_flag(first_transmit_move) 0
  set lib_flag(first_plane_output) 0
  incr lib_flag(first_start_of_path) 1
  set ::lib_prev_programmed_feed_rate -939
  set ::lib_prev_motion_type          -939
  set ::lib_prev_feed_rate_dpm      -939
  set ::lib_prev_cycle_feed_rate      -939

  # If needed load "virtual" kinematics (inclined plane)
  LIB_SPF_KINEMATICS_current_setting
  # Set the tool change position if different with mom_sys_home_pos
  LIB_SPF_init_sys_tool_change_pos

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Start of Path"}

  if {![info exists lib_flag(pattern_output_sub)] || $lib_flag(pattern_output_sub) == 0} {
    LIB_SPF_operation_header_comment
  }
  if {[llength [info commands LIB_CTRL_parameter_call]]} {LIB_CTRL_parameter_call}
  if {$::tcl_version > 8.3 && [llength [info commands LIB_CTRL_structure_representation]] && [CONF_CTRL_setting op_representation_structured]} {LIB_CTRL_structure_representation}
  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message [list " " "Operation : INS->$::mom_operation_name<-" " "] 1}

  # In start of path, subprogram output is started under the following condition:
  # Subprogram output ON in PC and no pattern feature output is needed, open subprogram at start of path of every operation.
  if {([info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1) && \
  (![info exists ::mom_process_patterning_pattern_mcs] || $::mom_process_patterning_pattern_mcs == "No")} {
    LIB_GE_command_buffer LIB_SPF_sub_output_start
    LIB_GE_command_buffer {LIB_SPF_sub_output_operation_start} @SUB_OUTPUT_START
    LIB_GE_command_buffer_output
  }

  LIB_SPF_feed_turbo_status_set

  MOM_start_of_path_LIB

  # <NX1201 cam16012> new prereatment local csys
  # Revise coordinate system to G54 if a coordinate is set to local csys rotation
  if {[info exists lib_flag(first_start_of_path)] && $lib_flag(first_start_of_path) > 1 && \
    $lib_flag(local_namespace_output) == 1} {
    LIB_SPF_csys_rotation_revise_output
  }

  if {[CONF_CTRL_setting cutcom_off_alone] == 1 && [LIB_SPF_get_pretreatment mom_cutcom_status] != ""} {
    if {$lib_spf(nx_version) < 1202 || [string match "1847*" $lib_spf(nx_version)]} {
      # IR9254441: Event MOM_cutcom_off missed with Turbo Mode. Resolved by code changes made to the release NX12.0.2 MP4 and NX 1851
      LIB_SPF_turbo_status "disable"
    }
  }
  #PR9553209
  if {($::mom_sys_contour_feed_mode(ROTARY) == "FRN" || $::mom_sys_contour_feed_mode(LINEAR_ROTARY) == "FRN") && [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {
    LIB_SPF_turbo_status "disable"
  }
}
# <Internal Documentation>
#
# *MOM_lib_header (to generate standard output if UDE is not defined)
# --> call this in all UDE procs to keep the output sequence
# *load kinematics (PT)
# *operation comment
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_sync {} {

  if {$::lib_ge_pretreatment_runtime} {PT_sync ; return}

  set commandcheck(MOM_sync_ENTRY) [llength [info commands MOM_sync_ENTRY]]

  LIB_GE_command_buffer MOM_sync_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_ENTRY)} {MOM_sync_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_sync_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_sync_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_sync_ENTRY)} {MOM_sync_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the synch event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_define_active_chain {} {

  global lib_ge_active_chain
  global lib_ge_chain_selection_array
  global lib_ge_chain_selection_priority
  global lib_ge_chain_selection
  global lib_ge_chain_condition

  set lib_ge_active_chain ""

  set debug_chain_selection 0

  if {[info exists ::lib_ge_conf_chain_list] && [llength $::lib_ge_conf_chain_list] > 0} {
    if {![info exists lib_ge_chain_selection_array]} {
      #define lib_ge_chain_selection_array elements if they are nit yet defined
      #this array will be used to search the current chain
      set selections [lsort [array names lib_ge_chain_selection]]

      set prio_list ""

      foreach prio [lsort [array names lib_ge_chain_selection_priority]] {
        lappend prio_list $lib_ge_chain_selection_priority($prio)
      }

      foreach select $selections {

        set selection_array_element ""
        set omitted 0

        if {$lib_ge_chain_selection($select) != ""} {
          foreach prio $prio_list {
            if {$lib_ge_chain_condition($select,$prio) != ""} {
              while {$omitted > 0} {
                lappend selection_array_element ""
                incr omitted -1
              }
              lappend selection_array_element $lib_ge_chain_condition($select,$prio)
            } else {
              incr omitted
            }
          }

          set lib_ge_chain_selection_array([join $selection_array_element ","]) $lib_ge_chain_selection($select)

          if {$debug_chain_selection} {MOM_output_to_listing_device ">> lib_ge_chain_selection_array([join $selection_array_element ","]) $lib_ge_chain_selection($select)"}

          lappend selection_array_element_list [join $selection_array_element ","]
        }
      }
    }

    set prio_list [lsort [array names lib_ge_chain_selection_priority] ]
    set prio_list_length [llength $prio_list]

    set counter 1
    set array_name_list "\$::$lib_ge_chain_selection_priority([lindex $prio_list 0])"

    while {$counter < $prio_list_length} {
       set array_name_list [linsert $array_name_list 0 "[lindex $array_name_list 0],\$::$lib_ge_chain_selection_priority([lindex $prio_list $counter])"]
       incr counter
    }

    if {$debug_chain_selection} {MOM_output_to_listing_device "array_name_list = $array_name_list"}

    foreach array_name $array_name_list {

      if {$debug_chain_selection} {MOM_output_to_listing_device "   array_name = $array_name"}

      if {[info exists lib_ge_chain_selection_array([subst [subst $array_name]])]} {
        if {$debug_chain_selection} {MOM_output_to_listing_device "match : lib_ge_chain_selection_array([subst [subst $array_name]]) , value : $lib_ge_chain_selection_array([subst [subst $array_name]])"}

        set lib_ge_active_chain $lib_ge_chain_selection_array([subst [subst $array_name]])

        break
      }
    }

    set custom_active_chain [LIB_CONF_do_prop_custom_proc CONF_GE_chain custom_chain_selection]

    if {$debug_chain_selection} {MOM_output_to_listing_device "custom_active_chain = $custom_active_chain"}

    if {$custom_active_chain != ""} {
      set lib_ge_active_chain $custom_active_chain
    }

  }

  if {$debug_chain_selection} {MOM_output_to_listing_device "return value = $lib_ge_active_chain"}

  return $lib_ge_active_chain
}
# <Internal Documentation>
# This function is used to set the current active chain.
# The function is called in MOM_start_of_path
# The conditions to choose a certain chain a specifyied in lib_ge_chain_condition array.
# The easiest way to do this is to use POostConfigurator UI
# <Internal Arguments>
# None.
# <Returnvalue>
# None.
#____________________________________________________________________________________________
proc LIB_SPF_output_operation_description {} {

  global mom_operation_description

  if {![info exists mom_operation_description] || \
    [CONF_SPF_msg output_operation_description] == "off" || \
    ![string length [string trim $mom_operation_description]]} {return}

  switch -- [CONF_SPF_msg output_operation_description] {
    "comment" {
      set format output_1
    }
    "direct" {
      set format output_0
    }
  }

  LIB_GE_message $mom_operation_description $format

  unset mom_operation_description
}
# <Internal Documentation>
#   This is the output of the operation notes available from NX9+
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_output_operation_notes {} {

  global mom_operation_notes

  if {![info exists mom_operation_notes] || [CONF_SPF_msg output_operation_notes] == "off"} {return}

  switch -- [CONF_SPF_msg output_operation_notes] {
    "comment" {
      set format output_1
    }
    "direct" {
      set format output_0
    }
  }

  foreach n [lsort -dictionary [array names mom_operation_notes]] {
    LIB_GE_message $mom_operation_notes($n) $format
  }

  unset mom_operation_notes
}
# <Internal Documentation>
#   This is the output of the operation notes available from NX9+
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_operation_header_comment {} {

  set commandcheck(LIB_SPF_operation_header_comment_LIB_ENTRY) [llength [info commands LIB_SPF_operation_header_comment_LIB_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_operation_header_comment_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_operation_header_comment_LIB_ENTRY)} {LIB_SPF_operation_header_comment_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer HEADER_COMMENT

  LIB_GE_command_buffer {LIB_GE_message "NEWLINE" output_0} @NEWLINE1
  LIB_GE_command_buffer {LIB_GE_message "$::mom_path_name , [LIB_GE_MSG Tool] : $::mom_tool_name" output_2} @INFOLINE
  LIB_GE_command_buffer {LIB_SPF_output_operation_description} @OPDESCRIPTION
  LIB_GE_command_buffer {LIB_SPF_output_operation_notes} @OPNOTES
  LIB_GE_command_buffer {LIB_GE_message "NEWLINE" output_0} @NEWLINE2

  LIB_GE_command_buffer_output

  LIB_GE_command_buffer LIB_SPF_operation_header_comment_LIB_ENTRY_custom
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_operation_header_comment_LIB_ENTRY)} {LIB_SPF_operation_header_comment_LIB_ENTRY custom}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {[llength [info commands LIB_SPF_operation_header_comment_custom]]} {LIB_SPF_operation_header_comment_custom}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_operation_header_comment_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_operation_header_comment_LIB_ENTRY)} {LIB_SPF_operation_header_comment_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#   This is the definition of the standard operation header
# to customize the output use LIB_SPF_operation_header_comment_custom
#
# If you would like to supress the default output,
# set the buffer please to nothing.
# e.g. LIB_GE_command_buffer_seq LIB_SPF_operation_header_comment HEADER_COMMENT {}
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_subop_path {} {

  if {$::lib_ge_pretreatment_runtime} {PT_start_of_subop_path; return}

  set commandcheck(MOM_start_of_subop_path_ENTRY) [llength [info commands MOM_start_of_subop_path_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_ENTRY)} {MOM_start_of_subop_path_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_start_of_subop_path_LIB]]} {MOM_start_of_subop_path_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_subop_path_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_subop_path_ENTRY)} {MOM_start_of_subop_path_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed if a subop start activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_subop_path {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_end_of_subop_path_ENTRY) [llength [info commands MOM_end_of_subop_path_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_subop_path_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_ENTRY)} {MOM_end_of_subop_path_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_end_of_subop_path_LIB]]} {MOM_end_of_subop_path_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_subop_path_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_subop_path_ENTRY)} {MOM_end_of_subop_path_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed if a subop end activated
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_KINEMATICS_turbo_setting {} {

  LIB_SPF_advanced_turbo_setting [LIB_SPF_get_pretreatment mom_kin_is_turbo_output]
  LIB_SPF_turbo_setting_by_feedrate_mode
}
# <Internal Documentation>
# This proc is handling the setting of turbo mode
#
# <Internal Example>
# This automatically called in MOM_start_of_path (internal function)
#____________________________________________________________________________________________
proc LIB_SPF_advanced_turbo_setting {turbo_output} {
  global lib_flag mom_kin_is_turbo_output mom_post_in_simulation
  global mom_kin_arc_output_mode lib_cutcom_radius

  set advanced_turbo_output "FALSE"

  # reset advanced turbo mode
  if {$mom_post_in_simulation != 0 && $::lib_ge_env(major_version) < 12 || [CONF_CTRL_setting turbo_mode] == 0} {
    set mom_kin_is_turbo_output "FALSE"
    set advanced_turbo_output "FALSE"
  } else {
    if { [CONF_CTRL_setting turbo_mode] == 3 } {
      set advanced_turbo_output $turbo_output
    }

    set mom_kin_is_turbo_output $turbo_output
  }

  # mom_sys_advanced_turbo_output should be set by Post Core to indicate if the advanced is enable
  if {$advanced_turbo_output == "TRUE"} {
    set turbo_output [list enable advanced]
  } elseif {$mom_kin_is_turbo_output == "TRUE"} {
    set turbo_output [list enable]
  } else {
    set turbo_output [list disable]
  }

  if {[CONF_CTRL_setting turbo_mode] == 2 && $turbo_output == "enable"} {
    if { [CONF_CTRL_moves always_center_for_circle] == 0 && $mom_kin_arc_output_mode == "FULL_CIRCLE" } {
      set turbo_output [list enable advanced]
    }
  }

  set _do_it "LIB_SPF_turbo_status $turbo_output"
  eval $_do_it
  return $turbo_output
}
# <Internal Documentation>
# This proc is handling the setting of turbo mode
#
# <Internal Example>
# This automatically called in LIB_SPF_KINEMATICS_turbo_setting and advanced pretreatment MOM_start_of_path (internal function)
#____________________________________________________________________________________________
proc LIB_SPF_KINEMATICS_reload_real_mach_kin_from_pt {} {

  global mom_kin_output_unit mom_kin_min_fpr
  global lib_flag mom_kin_is_turbo_output mom_post_in_simulation

  eval [LIB_SPF_get_pretreatment set_pt_kin]

  if {[CONF_SPF_pt activate_reload_real_mach_kin_from_pt] == 1} {
    # By default we do no longer reload the kinematics from pretreatment.
    # In most cases this will be the same the kinematics loaded with LIB_SPF_KINEMATICS_reload_pb_kin
    # anyways. We only have to activate this is we are switching kineamtics in pretreatment by calling
    # LIB_SPF_PT_KINEMATICS_set_real_mach_kin in the pretreatment. Thats a real special case, and only for this
    # we have to activate this aption.
    #
    # If this is activated we migth get problem with INCH/METRIC Unit Conversion of mom_kin_* variables
    # (The values stored in PT are metric values)
    LIB_GE_copy_var_range mom_kin pt_kin

    if {$mom_kin_output_unit == "MM"} {
      set mom_kin_min_fpr "0.01"
    } else {
      set mom_kin_min_fpr "0.001"
    }
    MOM_reload_kinematics
  }

}
# <Internal Documentation>
# This proc reloads the kinematics for the current operation.
# The kinematics which will be reloaded was defined and stored in the Pretreatment
# postprocessor
#
# <Internal Example>
# This automatically called in MOM_start_of_path (internal function)
#____________________________________________________________________________________________
proc LIB_SPF_PT_KINEMATICS_set_real_mach_kin {kin_config} {

  global lib_ge_pretreatment_runtime
  global [uplevel #0 info vars mom_kin*]

  if {![info exists ::lib_ge_pretreatment_runtime] || $::lib_ge_pretreatment_runtime == 0} {return}

  switch -- $kin_config {
    "sample_case1"   {
      LIB_GE_abort_message "INS->LIB_PT_set_real_mach_kin<- called with invalid argument INS->\"$kin_config\"<-" "Please verify"
    }
    "sample_case2" {
      LIB_GE_abort_message "INS->LIB_PT_set_real_mach_kin<- called with invalid argument INS->\"$kin_config\"<-" "Please verify"
    }
    default  {
      if {[info commands $kin_config] == $kin_config} {
        $kin_config
      } else {
        LIB_GE_abort_message "INS->LIB_PT_set_real_mach_kin<- called with invalid argument INS->\"$kin_config\"<-" "Please verify"
      }
    }
  }

  MOM_reload_kinematics
}
# <Internal Documentation>
# This proc is only active in Pretreatment
# This is the only place to set the current "real" machine kinematics
# (Kinematics may change e.g. if an other attachment is loaded
# or if on a multifunction / multichannel machine the "working situation" is
# changing)
#
# argument: kin_config
# this is the name of the kinematics to be set
# if this is a PROC-name this proc will be called otherwise it is treated as
# argument for a switch structure
#
# <Internal Example>
#
# LIB_SPF_PT_KINEMATICS_set_real_mach_kin "kin_konfig1"
# LIB_SPF_PT_KINEMATICS_set_real_mach_kin "PROC_set_head_konfig_1"
#
#____________________________________________________________________________________________
proc MOM_first_tool {} {

  if {$::lib_ge_pretreatment_runtime} {PT_first_tool ; return}

  global mom_operation_is_interop

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "First Tool"}

  # <17013.16 Interop path> If tool path has tool change, previous transition path will do this event in advance.
  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 0} {
    return
  }

  MOM_first_tool_LIB

}
# <Internal Documentation>
# This procedure is executed at the first tool
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_check_probing_tool {} {

  global lib_flag
  global mom_tool_change_type
  global lib_sav_tool_change_type
  global mom_tool_number mom_tool_name

  if {[lsearch [CONF_CTRL_probe toolnr] $mom_tool_number] > -1 || \
    [lsearch [CONF_CTRL_probe toolname] $mom_tool_name] > -1} {
    if {[info exists mom_tool_change_type]} {
      set lib_sav_tool_change_type $mom_tool_change_type
    }
    set mom_tool_change_type [CONF_CTRL_probe tool_change_type]
    set lib_flag(ignore_spindle_rpm) 1
    MOM_disable_address M_spindle
  }
}
# <Internal Documentation>
# This procedure is executed before tool change to check if we have a probing tool and to set
# tool change type and other stuff
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tool_change {} {

  if {$::lib_ge_pretreatment_runtime} {PT_tool_change ; return}

  global mom_tool_change_type mom_manual_tool_change

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Tool Change"}
  LIB_SPF_execute_op_tool_param_condition "MOM_tool_change"
  LIB_SPF_check_probing_tool

  if {[info exists mom_tool_change_type]} {
    if {$mom_tool_change_type == "MANUAL"} {

      MOM_tool_change_LIB "MANUAL"

    } else {

      MOM_tool_change_LIB

    }
  } elseif {[info exists mom_manual_tool_change]} {
    if {![string compare $mom_manual_tool_change "TRUE"]} {

      MOM_tool_change_LIB "MANUAL"

    }
  }
}
# <Internal Documentation>
# This procedure is executed at tool change
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_device {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_first_device_ENTRY) [llength [info commands MOM_first_device_ENTRY]]

  LIB_GE_command_buffer MOM_first_device_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_device_ENTRY)} {MOM_first_device_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "First Device"}

  if {[llength [info commands MOM_first_device_LIB]]} {MOM_first_device_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_device_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_device_ENTRY)} {MOM_first_device_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is executed at the first device
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_device_change {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_device_change_ENTRY) [llength [info commands MOM_device_change_ENTRY]]

  LIB_GE_command_buffer MOM_device_change_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_device_change_ENTRY)} {MOM_device_change_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Device Change"}
  LIB_SPF_execute_op_tool_param_condition "MOM_device_change"

  if {[llength [info commands MOM_device_change_LIB]]} {MOM_device_change_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_device_change_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_device_change_ENTRY)} {MOM_device_change_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is executed at device change
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_csys {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  MOM_set_csys_LIB

}
# <Internal Documentation>
# This procedure is executed if csys is set
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_pattern_set_csys_start {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  # Something has gone really wrong when these vars are absent.
  if {![info exists ::mom_process_patterning_pattern_mcs] ||\
  ![info exists ::mom_process_patterning_subroutine_program] } {
    return
  }

  # Set control to output & call subroutine -
  # - Enables pattern subprogram output when both toggle options are checked with a Pattern Group on ONT,
  # - in addition, the mom_sys_post_output_subprogram_enabled must be ON to indicate that the post supports this functionality.

  global lib_flag
  if { [info exists ::mom_sys_post_output_subprogram_enabled] &&\
    $::mom_process_patterning_pattern_mcs == "Yes" &&\
  ($::mom_process_patterning_subroutine_program == "Yes" && $::mom_sys_post_output_subprogram_enabled == 1)} {
    set lib_flag(pattern_output_sub)  1
  } else {
    set lib_flag(pattern_output_sub)  0
  }

  if { $lib_flag(pattern_output_sub) && !$::mom_process_pattern_index == 0 } {

    LIB_GE_command_buffer SET_CSYS_START
    LIB_GE_command_buffer {
      LIB_SPF_get_mcs_info
    } @MCS_INFO
    LIB_GE_command_buffer {
      LIB_local_origin_call
    } @LOCAL_ORIGIN_CALL
    LIB_GE_command_buffer {
      LIB_ROTARY_positioning_init
    } @POSITIONING_INIT
    LIB_GE_command_buffer_output

  }

  global lib_spf

  # In set_csys_start, subprogram output are started under the following conditions:
  # 1. Subprogram output ON in PC and pattern mcs location is ON, open subprogram at start of path of only the first instance of pattern.
  # 2. Subprogram output ON in PC and pattern mcs location and subroutine output are both ON, open subprogram same as above.
  # 3. When posting a single operation rather than a pattern group, pattern_index doesn't exist, but its handling is equivalent to the first instance of pattern as above.
  if {([info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1) && \
    ([info exists ::mom_process_patterning_pattern_mcs] && $::mom_process_patterning_pattern_mcs == "Yes") && \
    (([info exists ::mom_process_pattern_index] && $::mom_process_pattern_index == 0) || ![info exists ::mom_process_pattern_index])} {
    LIB_GE_command_buffer LIB_SPF_sub_output_start
    LIB_GE_command_buffer {LIB_SPF_sub_output_operation_start} @SUB_OUTPUT_START
    LIB_GE_command_buffer_output
  }

}
# <Internal Documentation>
# This procedure is executed if pattern csys is set
# Below mom varialbes are available
#
# mom_pattern_csys_matrix : csys matrix used to output current pattern,reference to ?
# mom_pattern_instance_csys_matrix: curren instance pattern matrix reference to source pattern matrix
# mom_pattern_source_csys_matrix: source pattern feature matrix
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_pattern_set_csys_end {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_flag
  global lib_spf

  # In set_csys_end, subprogram output is ended under the following conditions:
  # 1. Subprogram output ON in PC and pattern mcs location and subroutine output are both ON, close subprogram at end of path of only the FIRST instance of pattern.
  # 2. When posting a single operation instead of a pattern group, lib_flag(pattern_output_sub) doesn't exist, but handling is the same as the first instance of pattern.
  if {[info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1} {
    if {([info exists lib_flag(pattern_output_sub)] && $lib_flag(pattern_output_sub) == 1 && [info exists ::mom_process_pattern_index] && $::mom_process_pattern_index == 0) ||\
    ![info exists lib_flag(pattern_output_sub)]} {
      LIB_GE_command_buffer LIB_SPF_sub_output
      LIB_GE_command_buffer {LIB_SPF_sub_output_operation_end} @SUB_OUTPUT_END
      LIB_GE_command_buffer {LIB_SPF_pattern_positioning_reset} @PATTERN_POSITIONING_RESET
      LIB_GE_command_buffer_output
    }
  } elseif { [info exists ::mom_process_patterning_pattern_mcs] && $::mom_process_patterning_pattern_mcs == "Yes" } {
    if { [info exists lib_flag(pattern_output_sub)] && $lib_flag(pattern_output_sub) == 1 && $::mom_process_pattern_index == 0 } {

      LIB_GE_command_buffer LIB_SPF_sub_output_end
      LIB_GE_command_buffer {LIB_SPF_sub_output_operation_end} @SUB_OUTPUT_END
      LIB_GE_command_buffer {LIB_SPF_end_of_extcall_program} @END_EXTCALL
      LIB_GE_command_buffer {LIB_SPF_pattern_positioning_reset} @POSITIONING_RESET
      LIB_GE_command_buffer_output
    }
  }

  # In set_csys_end, subprogram output is ended under the following conditions:
  # 1. Subprogram output OFF in PC, and pattern mcs location and subroutine output are both ON, close subprogram at set_csys_end of only the FIRST instance of pattern?
  #    Output call of external_subprogram at other instances of pattern.
  # 2. Subprogram output ON in PC, and pattern mcs location is ON, close subprogram at set_csys_end of only the LAST instance of pattern, do nothing at other instances.
  # 3. Subprogram output ON in PC, and pattern mcs location and subroutine output are both ON, close subprogram at set_csys_end of only the LAST instance of pattern,
  #   output call of external_subprogram at other instances of pattern.

  if { $lib_flag(pattern_output_sub) } {
    if {(![info exists lib_spf(subprogram_output)] || $lib_spf(subprogram_output) == 0)} {
      if { $::mom_process_pattern_index != 0 } {
        LIB_GE_command_buffer CALL_EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          MOM_do_template external_subprogram
        } @EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          LIB_SPF_pattern_positioning_reset
        } @POSITIONING_RESET
        LIB_GE_command_buffer_output
      }
      if { $::mom_process_pattern_index == [expr $::mom_process_pattern_count - 1] } {
        LIB_GE_command_buffer CALL_END_OF_PATH
        LIB_GE_command_buffer {
          MOM_end_of_path_LIB
        } @END_OF_PATH
        LIB_GE_command_buffer_output
      }
    } elseif {([info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1)} {
      if { ($::mom_process_pattern_index == [expr $::mom_process_pattern_count - 1]) } {
        LIB_GE_command_buffer CALL_EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          MOM_do_template external_subprogram
        } @EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          LIB_SPF_pattern_positioning_reset
        } @POSITIONING_RESET
        LIB_GE_command_buffer {
          MOM_end_of_path_LIB
        } @END_OF_PATH
        LIB_GE_command_buffer {
          LIB_SPF_sub_output_operation_end
        } @SUB_OUTPUT_OPERATION_END
        LIB_GE_command_buffer {
          LIB_SPF_end_of_extcall_program
        } @END_OF_EXTCALL_PROGRAM
        LIB_GE_command_buffer_output
      } elseif { $::mom_process_pattern_index != 0 } { #first instance is taken care of in end of path
        LIB_GE_command_buffer CALL_EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          MOM_do_template external_subprogram
        } @EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          LIB_SPF_pattern_positioning_reset
        } @POSITIONING_RESET
        LIB_GE_command_buffer_output
      }
    }
  } elseif {$::mom_process_patterning_pattern_mcs == "Yes"} {
    LIB_GE_command_buffer CALL_EXTERNAL_SUBPROGRAM
    LIB_GE_command_buffer {
      LIB_SPF_pattern_positioning_reset
    } @POSITIONING_RESET
    LIB_GE_command_buffer_output
    if {([info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1)} {
      if { ($::mom_process_pattern_index == [expr $::mom_process_pattern_count - 1]) } {
        LIB_GE_command_buffer CALL_EXTERNAL_SUBPROGRAM
        LIB_GE_command_buffer {
          LIB_SPF_sub_output_operation_end
        } @SUB_OUTPUT_OPERATION_END
        LIB_GE_command_buffer {
          LIB_SPF_end_of_extcall_program
        } @END_OF_EXTCALL_PROGRAM
        LIB_GE_command_buffer_output
      }
    }
  }

  # When both pattern mcs and subroutine output are checked on ONT, move MOM_end_of_path_LIB to outside of subroutine
  # can void extra tool retraction between pattern instances. And no special treatment for Heidenhain is needed anymore.
  # LIB_ROTARY_positioning_reset
}
# <Internal Documentation>
# This procedure is executed if pattern csys is set
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_pattern_positioning_reset {} {

  global lib_flag

  # To output plane rotary setting and cancelling, must change lib_flag
  set lib_flag(mode_current_status) "pos"

  LIB_GE_command_buffer PATTERN_POSITIONING_RESET
  LIB_GE_command_buffer {
    LIB_ROTARY_positioning_reset
  } @POSITIONING_RESET
  LIB_GE_command_buffer_output

  set lib_flag(tool_path_motion) 0
  set lib_flag(tool_axis_zm) 0

}
proc MOM_sequence_number {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_sequence_mode mom_sequence_number mom_sequence_increment mom_sequence_frequency mom_sequence_text
  global mom_seqnum

  if {![info exists mom_sequence_mode]} {set mom_sequence_mode "N"}
  switch -- $mom_sequence_mode {
    "OFF" {
      MOM_set_seq_off
    }
    "ON"  {
      MOM_set_seq_on
    }
    "N" {
      MOM_reset_sequence $mom_sequence_number $mom_sequence_increment $mom_sequence_frequency
      MOM_set_seq_on
    }
  }

}
# <Internal Documentation>
# This procedure is executed for the Sequence Number command.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_spindle_orient {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_spindle_orient_angle
  global mom_spindle_orient_angle_defined
  global mom_spindle_orient_ref_axis
  global operation_mcs_matrix
  global oper_mcs_matrix
  global mom_sys_spindle_orient_value

  set commandcheck(MOM_spindle_orient_ENTRY) [llength [info commands MOM_spindle_orient_ENTRY]]

  LIB_GE_command_buffer MOM_spindle_orient_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_spindle_orient_ENTRY)} {MOM_spindle_orient_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  MTX3_vec_multiply mom_spindle_orient_ref_axis operation_mcs_matrix spindle_orient_ref_axis
  set mom_sys_spindle_orient_value [LIB_SPF_spindle_orientation_angle spindle_orient_ref_axis $mom_spindle_orient_angle oper_mcs_matrix]

  LIB_SPF_spindle_direction
  LIB_CTRL_spindle_orient
  LIB_GE_command_buffer MOM_spindle_orient_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_spindle_orient_ENTRY)} {MOM_spindle_orient_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This procedure is executed at back contour sinking operation
# Initial tool insert tip is positioned to Machine coordinate X axis positive direction,
# which means the default value of initial offset angle is 0.
# Post writer can use UDE to customize offset angle
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_spindle_orientation_angle {spindle_orient_ref_axis input_angle rotate_matrix} {

  global mom_kin_4th_axis_vector mom_kin_5th_axis_vector
  global mom_prev_rot_ang_4th mom_prev_rot_ang_5th
  global mom_kin_4th_axis_zero mom_kin_5th_axis_zero
  global lib_sav_kin_machine_type
  global mom_tool_axis mom_out_angle_pos
  global lib_flag DEG2RAD RAD2DEG
  global pt_kin_4th_axis_direction pt_kin_5th_axis_direction
  global pt_kin_4th_axis_leader pt_kin_5th_axis_leader
  global pt_kin_4th_axis_min_limit pt_kin_5th_axis_min_limit
  global pt_kin_4th_axis_max_limit pt_kin_5th_axis_max_limit
  global mom_result1 mom_result
  global lib_sav_kin_4th_axis_vector lib_sav_kin_5th_axis_vector

  upvar $spindle_orient_ref_axis feature_ref_axis
  upvar $rotate_matrix matrix

  set v0 0.0; set v1 1.0
  VEC3_init v1 v0 v0 insert_ref_direction
  VEC3_init v0 v0 v1 insert_rotated_direction
  VEC3_init v0 v0 v0 intermediate_vector

  # <NX1201 cam16012> new prereatment local csys
  # Do not call convert_point with new pretreatment local csys
  if {$lib_flag(local_namespace_output) == 0} {
    LIB_SPF_convert_point "real"
  }

  # Values are taken direct from mom_result(1) because mom_init_pos is calculated in oper_mcs_matrix

  global mom_result1 mom_result
  set tmp_pos(0) [lrange $mom_result 3 3]
  set tmp_pos(1) [lrange $mom_result 4 4]
  set mom_out_angle_pos(0) [LIB_SPF_rotset $tmp_pos(0) $mom_prev_rot_ang_4th $pt_kin_4th_axis_direction $pt_kin_4th_axis_leader mom_sys_leader(fifth_axis) $pt_kin_4th_axis_min_limit $pt_kin_4th_axis_max_limit]
  if {[EQ_is_gt $mom_out_angle_pos(0) $pt_kin_4th_axis_max_limit] || [EQ_is_lt $mom_out_angle_pos(0) $pt_kin_4th_axis_min_limit]} {
    set tmp_pos(0) [lrange $mom_result1 3 3]
    set tmp_pos(1) [lrange $mom_result1 4 4]
    set mom_out_angle_pos(0) [LIB_SPF_rotset $tmp_pos(0) $mom_prev_rot_ang_4th $pt_kin_4th_axis_direction $pt_kin_4th_axis_leader mom_sys_leader(fifth_axis) $pt_kin_4th_axis_min_limit $pt_kin_4th_axis_max_limit]
    }
  set mom_out_angle_pos(1) [LIB_SPF_rotset $tmp_pos(1) $mom_prev_rot_ang_5th $pt_kin_5th_axis_direction $pt_kin_5th_axis_leader mom_sys_leader(fifth_axis) $pt_kin_5th_axis_min_limit $pt_kin_5th_axis_max_limit]
  set rot_angle(0) [expr ($mom_out_angle_pos(0) - $mom_kin_4th_axis_zero) * $DEG2RAD]
  set rot_angle(1) [expr ($mom_out_angle_pos(1) - $mom_kin_5th_axis_zero) * $DEG2RAD]

  # rot_angle depends from the setting of [CONF_S840D_cycle800 _DIR] or [CONF_ITNC530_PLANE seq]
  # in the moment we do not consider this
  #If {[CONF_S840D_cycle800 _DIR] == "-1"} {set rot_angle(0) [expr abs($rot_angle(0))* -1]}
  #if {[CONF_S840D_cycle800 _DIR] == "+1"} {set rot_angle(0) [expr abs($rot_angle(0))* +1]}
  #If {[CONF_ITNC530_PLANE seq] == "-"} {set rot_angle(0) [expr abs($rot_angle(0))* -1]}
  #if {[CONF_ITNC530_PLANE seq] == "+"} {set rot_angle(0) [expr abs($rot_angle(0))* +1]}
  switch $lib_sav_kin_machine_type {
    5_axis_dual_head {
      VEC3_rotate_arbitary_axis lib_sav_kin_5th_axis_vector $rot_angle(1) insert_ref_direction intermediate_vector
      VEC3_rotate_arbitary_axis lib_sav_kin_4th_axis_vector $rot_angle(0) intermediate_vector insert_rotated_direction
    }
    5_axis_head_table -
    5_axis_dual_table {
      VEC3_rotate_arbitary_axis lib_sav_kin_4th_axis_vector $rot_angle(0) insert_ref_direction intermediate_vector
      VEC3_rotate_arbitary_axis lib_sav_kin_5th_axis_vector $rot_angle(1) intermediate_vector insert_rotated_direction
    }
    4_axis_head -
    4_axis_table {
      VEC3_rotate_arbitary_axis lib_sav_kin_4th_axis_vector $rot_angle(0) insert_ref_direction insert_rotated_direction
    }
    default { }
  }
  MTX3_vec_multiply insert_rotated_direction matrix insert_rotated_direction_rot_mcs
  VEC3_unitize insert_rotated_direction_rot_mcs insert_rotated_direction_rot_mcs
  set dot [VEC3_dot insert_rotated_direction_rot_mcs feature_ref_axis]
  if { [EQ_is_ge $dot 1.0] } {
    set angle 0.0
  } elseif { [EQ_is_le $dot -1.0] } {
    set angle 180.0
  } else {
    set angle [expr $RAD2DEG * acos($dot)]
  }
  VEC3_cross feature_ref_axis insert_rotated_direction_rot_mcs cross_vector
  set dot [VEC3_dot cross_vector mom_tool_axis]
  if {  $dot > 0.0 } { set angle [expr -1 * $angle] }
  set angle [expr ((($angle + $input_angle) * [CONF_CTRL_spindle spindle_positive_direction]) + [CONF_CTRL_spindle spindle_insert_zero])]
  set angle [LIMIT_ANGLE $angle]

  # <NX1201 cam16012> new prereatment local csys
  # Do not call convert_point with new pretreatment local csys
  if {$lib_flag(local_namespace_output) == 0} {
    LIB_SPF_convert_point "reload"
  }
  return $angle
}
# <Internal Documentation>
# The proc is used to calculate spindle orient output angle value.
# It should be called in MOM_spindle_orient handler.
#
# Input:
#   spindle_orient_ref_axis - X axis of feature csys respect to MCS
#   input_angle               - angle between desired insert direction and X axis of feature csys
#   rotate_matrix             - matrix between MTCS and local MCS
#
# Return:
#   angle value of spindle stop position
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_spindle_rpm {} {

  if {![info exists ::first_spindle_rpm($::mom_path_name)]} {set ::first_spindle_rpm($::mom_path_name) $::mom_spindle_rpm}
  if {![info exists ::first_spindle_direction($::mom_path_name)]} {set ::first_spindle_direction($::mom_path_name) $::mom_spindle_direction}
  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_machine_mode

  if {[llength [info commands LIB_CTRL_handle_cycle_check]]} {LIB_CTRL_handle_cycle_check spindle}

  LIB_SPF_spindle_set

  if {$mom_machine_mode == "TURN"} {
    #PR9610827: preset only apply for SFM or SMM mode
    if {$::mom_spindle_mode == "SFM" || $::mom_spindle_mode == "SMM"} {
    LIB_SPINDLE_start preset
    }
    LIB_SPINDLE_start limit

  }
  LIB_SPINDLE_start

}
# <Internal Documentation>
# This procedure is executed for spindle rpm
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_spindle_css {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_machine_mode
  global mom_spindle_maximum_rpm_defined
  global mom_spindle_maximum_rpm_toggle

  LIB_SPF_spindle_set

  if {$mom_machine_mode == "TURN"} {

    if {$mom_spindle_maximum_rpm_defined == 1} {
      set mom_spindle_maximum_rpm_toggle 1
    } else {
      set mom_spindle_maximum_rpm_toggle 0
    }

    LIB_SPINDLE_start limit

  }
  LIB_SPINDLE_start

}
# <Internal Documentation>
# This procedure is executed for spindle css
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_spindle_off {} {
  global mom_spindle_direction

  if {$::lib_ge_pretreatment_runtime} {return}

  LIB_SPINDLE_end

  set mom_spindle_direction "OFF"
}
# <Internal Documentation>
# This procedure is executed for spindle off
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_spindle_set {{option default}} {

  global lib_parameter lib_template x_factor

  set commandcheck(LIB_SPF_spindle_set_ENTRY) [llength [info commands LIB_SPF_spindle_set_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_spindle_set_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_spindle_set_ENTRY)} {LIB_SPF_spindle_set_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_spindle_range
  LIB_SPF_spindle_max_min
  LIB_SPF_spindle_direction

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_spindle_set_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_spindle_set_ENTRY)} {LIB_SPF_spindle_set_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_spindle_range {{option default}} {
  global mom_machine_mode mom_spindle_rpm mom_sys_spindle_range_code mom_sys_spindle_param mom_spindle_range
  global lib_machine_mode lib_parameter lib_template x_factor lib_flag

  if {![llength [info commands CONF_CTRL_spindle]] || [CONF_CTRL_spindle range] == 0} {
    MOM_disable_address M_range
    return
  }

  switch -- $option {
    "INIT" {
      for {set i 1} {$i <= [CONF_CTRL_spindle ranges_number]} {incr i} {
        if {![info exists mom_sys_spindle_range_code($i)] || ![info exists mom_sys_spindle_param($i,min)] || ![info exists mom_sys_spindle_param($i,max)]} {
          LIB_GE_abort_message "Spindle Range $i need to be defined" "Please verify mom_sys_spindle_range_code($i), mom_sys_spindle_param($i,min) and mom_sys_spindle_param($i,max)"
        }

        if {![EQ_is_zero $mom_sys_spindle_param($i,min)] || ![EQ_is_zero $mom_sys_spindle_param($i,max)]} {
          if {[EQ_is_ge $mom_sys_spindle_param($i,min) $mom_sys_spindle_param($i,max)]} {
            LIB_SPF_add_warning  "Minimum rpm range INS->$i<- should be less than INS->$mom_sys_spindle_param($i,max)<-"
          }
          if {[EQ_is_lt $mom_sys_spindle_param($i,min) [CONF_CTRL_spindle min]]} {
            LIB_SPF_add_warning  "Minimum rpm range INS->$i<- should be more than INS->[CONF_CTRL_spindle min]<-"
          }
          if {[EQ_is_gt $mom_sys_spindle_param($i,max) [CONF_CTRL_spindle max]]} {
            LIB_SPF_add_warning  "Maximum rpm range INS->$i<- should be less than INS->[CONF_CTRL_spindle max]<-"
          }
        }
      }
    }
    "default" {
      if {$lib_machine_mode != "MILL_TURN" || $mom_machine_mode == "MILL"} {
        if {$mom_spindle_range != "" && $mom_spindle_range != 0 && [EQ_is_le $mom_spindle_range [CONF_CTRL_spindle ranges_number]]} {
          # keep current value
          return
        }
        for {set i 1} {$i <= [CONF_CTRL_spindle ranges_number]} {incr i} {
          if {$i == 1 && [EQ_is_lt $mom_spindle_rpm $mom_sys_spindle_param($i,min)]} {
            set mom_spindle_range $i
            break
          }
          if {[EQ_is_ge $mom_spindle_rpm $mom_sys_spindle_param($i,min)] &&\
          [EQ_is_le $mom_spindle_rpm $mom_sys_spindle_param($i,max)]} {
            set mom_spindle_range $i
            break
          }
          if {$i == [CONF_CTRL_spindle ranges_number] && [EQ_is_gt $mom_spindle_rpm $mom_sys_spindle_param($i,max)]} {
            set mom_spindle_range $i
          }
        }
      }
    }
  }
}
# <Internal Documentation>
# Spindle range automatic setting (lib_flag(spindle_range) = 1)
# It's supported for turning or milling. For MILLTURN machine, only with milling mode
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_msys {} {
  global mom_operation_is_interop

  if {$::lib_ge_pretreatment_runtime} {PT_msys ; return}

  set commandcheck(MOM_msys_LIB_ENTRY) [llength [info commands MOM_msys_LIB_ENTRY]]



  LIB_GE_command_buffer MOM_msys_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_msys_LIB_ENTRY)} {MOM_msys_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  # <cam17013.16 Interop path> Call real kinematic parameter to caculate machine position
  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 1} {
    LIB_SPF_calc_4th5th_axis_points
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_msys_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_msys_LIB_ENTRY)} {MOM_msys_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed if msys is set
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_before_motion {} {

  if {$::lib_ge_pretreatment_runtime} {PT_before_motion ; return}

  global lib_flag mom_motion_event mom_motion_type lib_motion_type_list mom_programmed_feed_rate mom_feed_rate_dpm
  global mom_operation_is_interop

  # <17013.16 Interop path> Skip mom_before_motion for every rapid motion event in transition path
  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 1 } {
    return
  }

  LIB_SPF_execute_op_tool_param_condition "MOM_before_motion"

  set commandcheck(MOM_before_motion_ENTRY) [llength [info commands MOM_before_motion_ENTRY]]

  foreach type $lib_motion_type_list {
    set commandcheck(LIB_CTRL_[string tolower ${type}]_move_LIB) [llength [info commands LIB_CTRL_[string tolower ${type}]_move_LIB]]
  }

  LIB_GE_command_buffer MOM_before_motion_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_before_motion_ENTRY)} {MOM_before_motion_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[CONF_SPF_pt lib_spf_analyze_each_before_motion]} {
    if {$mom_motion_type != $::lib_prev_motion_type} {
      LIB_GE_command_buffer LIB_CTRL_[string tolower ${mom_motion_type}]_move_LIB
      LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_[string tolower ${mom_motion_type}]_move_LIB)} {LIB_CTRL_[string tolower ${mom_motion_type}]_move_LIB}} @DEFAULT_ENTRY
      LIB_GE_command_buffer_output
    }
  }

  if {$::lib_prev_feed_rate_dpm != $mom_feed_rate_dpm || $::lib_prev_cycle_feed_rate != $::mom_cycle_feed_rate || $mom_programmed_feed_rate != $::lib_prev_programmed_feed_rate || $mom_motion_type != $::lib_prev_motion_type || ([info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE")} {
    LIB_SPF_feedrate_set
    if {$mom_motion_event != "rapid_move"} {LIB_CTRL_feed_output}
  }
  set ::lib_prev_motion_type $mom_motion_type
  set ::lib_prev_programmed_feed_rate $mom_programmed_feed_rate
  set ::lib_prev_feed_rate_dpm $mom_feed_rate_dpm
  set ::lib_prev_cycle_feed_rate $::mom_cycle_feed_rate
  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message}
  LIB_SPF_center_of_ball_output
  LIB_SPF_check_tool_axis
  LIB_SPF_check_cutcom_condition
  LIB_SPF_polar_cart
  LIB_SPF_first_tool_path_motion
      # save prev pos so that could check if some motion is skipped
      array set ::lib_prev_pos [array get ::mom_pos]
  if {[llength [info commands LIB_CTRL_calculate_cutcom]]} {LIB_CTRL_calculate_cutcom}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_before_motion_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_before_motion_ENTRY)} {MOM_before_motion_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# *POLAR
# *CHECK spindle/feed max
# *CHECK toolaxis (e.g. to define drilling direction)
# *(time_calculation)
# *....
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_output_event_message {{messagelist ""} {pointer 0}} {

  global lib_spf mom_motion_type

  if {!$pointer} {set messagelist [list $messagelist]}
  foreach message $messagelist {

    if {[string length $message]} {set mom_motion_type $message}
    if {![info exists lib_spf(pre_motion_type)]} {set lib_spf(pre_motion_type) "NULL"}

    if {![string match [LIB_GE_string_toupper $mom_motion_type] [LIB_GE_string_toupper $lib_spf(pre_motion_type)]]} {
      switch -- $mom_motion_type {
        "FIRSTCUT" -
        "STEPOVER" -
        "CUT" {
          if {![string match "FIRSTCUT" $lib_spf(pre_motion_type)] && ![string match "CUT" $lib_spf(pre_motion_type)] && ![string match "STEPOVER" $lib_spf(pre_motion_type)]} {
            LIB_GE_message "Cutting"
          }
        }
        default {
          if {[string length $message]} {
            LIB_GE_message "$message"
          } else {
            set motion_type_first [LIB_GE_string_toupper [string index $mom_motion_type 0]]
            set motion_type_end [string tolower [string range $mom_motion_type 1 end]]
            LIB_GE_message "$motion_type_first$motion_type_end Move"
          }

        }
      }
      set lib_spf(pre_motion_type) $mom_motion_type
    }
  }
}
# <Internal Documentation>
# This command is used to output motion type information messages before movements
# controlled via flag CONF_SPF_msg output_event_message
#
# Without arguments
# Output the correct motion type
#
# With one argument
#   Outputed the defined string with LIB_GE_message
#
# With two arguments
# Argument one: Textsting
# Argument two: Pointer to indicates a list (set it to 1)
#
# <Internal Example>
# LIB_SPF_output_event_message "Tool Change"
# LIB_SPF_output_event_message [list " " "Operation : $::mom_operation_name" " "] 1
#____________________________________________________________________________________________
proc MOM_from_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_from_move ; return}

  LIB_SPF_add_general_motion_handling

  MOM_from_move_LIB

}
# <Internal Documentation>
# This procedure is executed at from move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_initial_move {} {


  if {$::lib_ge_pretreatment_runtime} {PT_initial_move ; return}

  global mom_programmed_feed_rate mom_motion_event mom_operation_is_interop

  LIB_SPF_add_general_motion_handling

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Initial Move"}

  set commandcheck(MOM_initial_move_ENTRY) [llength [info commands MOM_initial_move_ENTRY]]

  LIB_GE_command_buffer MOM_initial_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_ENTRY)} {MOM_initial_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global lib_flag

  # Subprogram output should be started in initial move, in order to list until first tool in main output
  if {[info exists ::mom_process_patterning_pattern_mcs] && \
    [info exists ::mom_process_pattern_index] && \
          $lib_flag(pattern_output_sub) } {

    LIB_GE_command_buffer LIB_SPF_sub_output_start
    LIB_GE_command_buffer {LIB_SPF_sub_output_operation_start} @SUB_OUTPUT_START
    LIB_GE_command_buffer_output

  }
  if {[llength [info commands MOM_initial_move_LIB]]} {MOM_initial_move_LIB}

  LIB_GE_doc_tree_show_turbo_active

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_initial_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_initial_move_ENTRY)} {MOM_initial_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  # Prepare the blocks will be used in advanced turbo mode
  if {[llength [info commands LIB_CTRL_config_turbo]]} { LIB_CTRL_config_turbo }
}
# <Internal Documentation>
# This procedure is executed at initial move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_first_move ; return}

  LIB_SPF_add_general_motion_handling

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "First Move"}
  LIB_SPF_spindle_set

  if { [info exists ::mom_process_patterning_pattern_mcs] && $::mom_process_patterning_pattern_mcs == "Yes" && \
     $::mom_process_patterning_subroutine_program == "No"&& !$::mom_process_pattern_index == 0 } {

    LIB_GE_command_buffer SET_CSYS_START_PATTERN_MCS_ONLY
    LIB_GE_command_buffer {
      LIB_SPF_get_mcs_info
    } @MCS_INFO
    LIB_GE_command_buffer {
      LIB_local_origin_call
    } @LOCAL_ORIGIN_CALL
    LIB_GE_command_buffer {
      LIB_ROTARY_positioning_init
    } @POSITIONING_INIT
    LIB_GE_command_buffer_output

  }

  # In order to put operations within the same group in to the same subprogram for patterning, do not start new subprogram in first_move.

  if {[llength [info commands MOM_first_move_LIB]]} {MOM_first_move_LIB}

  if {[llength [info commands LIB_CTRL_config_turbo]]} {LIB_CTRL_config_turbo}

  LIB_GE_doc_tree_show_turbo_active
}
# <Internal Documentation>
# This procedure is executed at first move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rapid_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_rapid_move ; return}

  LIB_SPF_add_general_motion_handling

  MOM_rapid_move_LIB

}
# <Internal Documentation>
# This procedure is executed at rapid move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_linear_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  global lib_flag

  LIB_SPF_add_general_motion_handling

  if {!$lib_flag(first_linear_move)} {
    incr lib_flag(first_linear_move)
  }

  MOM_linear_move_LIB

}
# <Internal Documentation>
# This procedure is executed at linear move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_load_tool {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_load_tool_LIB_ENTRY) [llength [info commands MOM_load_tool_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_load_tool_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_load_tool_LIB_ENTRY)} {MOM_load_tool_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_load_tool_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_load_tool_LIB_ENTRY)} {MOM_load_tool_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at UDE tool_change_marker
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_length_compensation {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_length_compensation_ENTRY) [llength [info commands MOM_length_compensation_ENTRY]]

  LIB_GE_command_buffer MOM_length_compensation_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_length_compensation_ENTRY)} {MOM_length_compensation_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_CHECK_adjust_register

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_length_compensation_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_length_compensation_ENTRY)} {MOM_length_compensation_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at UDE Tool Length Compensation
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_circular_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_circular_move ; return}

  set commandcheck(MOM_circular_move_ENTRY) [llength [info commands MOM_circular_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_circular_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_ENTRY)} {MOM_circular_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_circular_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_circular_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_circular_move_ENTRY)} {MOM_circular_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at circular move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_helix_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_helix_move ; return}

  set commandcheck(MOM_helix_move_ENTRY) [llength [info commands MOM_helix_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_helix_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_ENTRY)} {MOM_helix_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_helix_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_helix_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_helix_move_ENTRY)} {MOM_helix_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at helix move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_nurbs_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_nurbs_move ; return}

  set commandcheck(MOM_nurbs_move_ENTRY) [llength [info commands MOM_nurbs_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_nurbs_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_ENTRY)} {MOM_nurbs_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_nurbs_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_nurbs_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_nurbs_move_ENTRY)} {MOM_nurbs_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at nurbs move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_gohome_move {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_gohome_move_ENTRY) [llength [info commands MOM_gohome_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_gohome_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_ENTRY)} {MOM_gohome_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_gohome_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_gohome_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_gohome_move_ENTRY)} {MOM_gohome_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at gohome move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_program_control {{switch ""}} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_group_name mom_ctrl_program_control mom_operation_name
  global lib_spf lib_flag mom_output_file_full_name

  set commandcheck(MOM_program_control_ENTRY) [llength [info commands MOM_program_control_ENTRY]]

  if {$switch != ""} {
    set lib_spf(subprogram_output) $switch
  } else {
    switch -- $mom_ctrl_program_control {
      "TRUE"  {set lib_spf(subprogram_output) 1}
      "FALSE" {set lib_spf(subprogram_output) 0}
    }
  }

  LIB_GE_command_buffer MOM_program_control_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_program_control_ENTRY)} {MOM_program_control_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------



  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_program_control_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_program_control_ENTRY)} {MOM_program_control_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
# This command is called based on a UDE
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_sub_output_operation_start {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_spf

  set commandcheck(LIB_SPF_sub_output_operation_start_ENTRY) [llength [info commands LIB_SPF_sub_output_operation_start_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_sub_output_operation_start_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_output_operation_start_ENTRY)} {LIB_SPF_sub_output_operation_start_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_GE_command_buffer SUB_OUTPUT_SETTINGS
  LIB_GE_command_buffer {LIB_SPF_subprogram_output_setting 1} @DEFAULT_SETTINGS
  LIB_GE_command_buffer_output

  global lib_spf
  global mom_sequence_number mom_sequence_increment mom_sequence_frequency mom_seqnum

  LIB_GE_command_buffer START_OF_EXTCALL_OP
  LIB_GE_command_buffer {
    lappend lib_spf(subprogram_upper_level_program_seqnum) $mom_seqnum
  } @RECORD_UPPER_LEVEL_PROGRAM_SEQNUM
  LIB_GE_command_buffer {

    # Close the current level output file, if upper level is None, then close main output file
    if {[lindex $lib_spf(subprogram_output_file_namelist) {}] == ""} {
      MOM_close_output_file [file nativename $lib_spf(value,output_file_full_name)]
    } else {
      set file_to_close [lindex $lib_spf(subprogram_output_file_namelist) end]
      MOM_close_output_file [file nativename $file_to_close]
    }
    if {![string equal -nocase $lib_spf(initial,output_file_full_name) $lib_spf(value,output_file_full_name)] && \
         [string length $lib_spf(initial,output_file_full_name)] > 0} {
      MOM_close_output_file [file nativename $lib_spf(initial,output_file_full_name)]
    }

  } @CLOSE_OUTPUT_FILE
  LIB_GE_command_buffer {
    # Create the file in advance if an error occurs that it would be closed
    LIB_FH_create_file $lib_spf(value,subprogram_output_file_full_name)
    # Update two lists: The output file path list and the subprogram name list by adding the newly opened one to the end of the list.
    MOM_open_output_file $lib_spf(value,subprogram_output_file_full_name)
    lappend lib_spf(subprogram_output_file_namelist) $lib_spf(value,subprogram_output_file_full_name)
    lappend lib_spf(subprogram_output_name_list) $lib_spf(value,subprogram_output_file_basename)
  } @OPEN_SUBPROGRAM_FILE
  LIB_GE_command_buffer {
    MOM_reset_sequence $mom_sequence_number $mom_sequence_increment $mom_sequence_frequency
    MOM_set_seq_on
    MOM_start_subroutine $lib_spf(value,subprogram_output_name)
  } @START_SUBROUTINE
  LIB_GE_command_buffer {
    MOM_start_of_program_LIB
  } @START_OF_PROGRAM
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_sub_output_operation_start_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_output_operation_start_ENTRY)} {LIB_SPF_sub_output_operation_start_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command is used to create sub program files
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_sub_output_operation_end { } {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_spf

  set commandcheck(LIB_SPF_sub_output_operation_end_ENTRY) [llength [info commands LIB_SPF_sub_output_operation_end_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_sub_output_operation_end_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_output_operation_end_ENTRY)} {LIB_SPF_sub_output_operation_end_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  # Heidenhain subprogram file end needs the name of the current subprogram name for def block "end_of_subprogram"
  set lib_spf(subprogram_call_end_name) [lindex $lib_spf(subprogram_output_name_list) end]

  LIB_GE_command_buffer END_OF_EXTCALL_OP
  LIB_GE_command_buffer {
    MOM_do_template end_of_subprogram
  } @END_OF_SUBPROGRAM
  LIB_GE_command_buffer {
    #Close the current level output file, if upper level is None, then close main output file.
    if {[lindex $lib_spf(subprogram_output_file_namelist) {}] == ""} {
      MOM_close_output_file [file nativename $lib_spf(value,output_file_full_name)]
    } else {
      set file_to_close [lindex $lib_spf(subprogram_output_file_namelist) end]
      MOM_close_output_file [file nativename $file_to_close]
    }
    if {![string equal -nocase $lib_spf(initial,output_file_full_name) $lib_spf(value,output_file_full_name)] && \
         [string length $lib_spf(initial,output_file_full_name)] > 0} {
      MOM_close_output_file [file nativename $lib_spf(initial,output_file_full_name)]
    }
    # Remove the last file item in the list after closing it.
    set lib_spf(subprogram_output_file_namelist) [lreplace $lib_spf(subprogram_output_file_namelist) end end]

    # Update name list to be used in extcall
    set lib_spf(value,subprogram_output_file_basename) [lindex $lib_spf(subprogram_output_name_list) end]
    set lib_spf(subprogram_output_name_list) [lreplace $lib_spf(subprogram_output_name_list) end end]

    MOM_end_subroutine
  } @CLOSE_SUBPROGRAM_FILE
  LIB_GE_command_buffer {
    #Open the upper level output file, if upper level is None, then open the main level output file.
    if {[lindex $lib_spf(subprogram_output_file_namelist) {}] == ""} {
      MOM_open_output_file [file nativename $lib_spf(value,output_file_full_name)]
    } else {
      set file_to_open [lindex $lib_spf(subprogram_output_file_namelist) end]
      MOM_open_output_file [file nativename $file_to_open]
    }
    if {![string equal -nocase $lib_spf(initial,output_file_full_name) $lib_spf(value,output_file_full_name)] && \
         [string length $lib_spf(initial,output_file_full_name)] > 0} {
      MOM_open_output_file [file nativename $lib_spf(initial,output_file_full_name)]
    }
    MOM_set_seq_off
  } @OPEN_OUTPUT_FILE
  LIB_GE_command_buffer {
    # Check if the current output file is empty
    if {$lib_spf(value,subprogram_output_file_basename) != ""} {
      global mom_sequence_increment mom_sequence_frequency mom_seqnum

      set mom_seqnum [lindex $lib_spf(subprogram_upper_level_program_seqnum) end]
      set lib_spf(subprogram_upper_level_program_seqnum) [lreplace $lib_spf(subprogram_upper_level_program_seqnum) end end]
      MOM_reset_sequence $mom_seqnum $mom_sequence_increment $mom_sequence_frequency
      MOM_set_seq_on
      MOM_do_template external_subprogram
    }
  } @EXTERNAL_SUBPROGRAM
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_sub_output_operation_end_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_sub_output_operation_end_ENTRY)} {LIB_SPF_sub_output_operation_end_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This command is used to close sub program for each operation and output e.g. EXTCALL into main program
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_end_of_extcall_program { } {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_spf lib_flag

  if {([info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1) ||\
        ([info exists lib_flag(pattern_output_sub)] && $lib_flag(pattern_output_sub))} {

    set commandcheck(LIB_SPF_end_of_extcall_program_ENTRY) [llength [info commands LIB_SPF_end_of_extcall_program_ENTRY]]

    LIB_GE_command_buffer LIB_SPF_end_of_extcall_program_ENTRY_start
    LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_end_of_extcall_program_ENTRY)} {LIB_SPF_end_of_extcall_program_ENTRY start}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output
    #---------------------------------------------------------------------------------

    LIB_GE_command_buffer END_OF_EXTCALL_PGM
    LIB_GE_command_buffer {
      MOM_open_output_file [file nativename $lib_spf(value,output_file_full_name)]
    } @OPEN_OUTPUT_FILE
    LIB_GE_command_buffer_output

    #---------------------------------------------------------------------------------
    LIB_GE_command_buffer LIB_SPF_end_of_extcall_program_ENTRY_end
    LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_end_of_extcall_program_ENTRY)} {LIB_SPF_end_of_extcall_program_ENTRY end}} @DEFAULT_ENTRY
    LIB_GE_command_buffer_output

  }
}
# <Internal Documentation>
# This command is used to close sub program at end of program
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_generic_cycle {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_generic_cycle_LIB_ENTRY) [llength [info commands MOM_generic_cycle_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_generic_cycle_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_generic_cycle_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_generic_cycle_LIB_ENTRY)} {MOM_generic_cycle_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at generic cycle
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_contour_start {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_contour_start_LIB_ENTRY) [llength [info commands MOM_contour_start_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_contour_start_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_start_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_start_LIB_ENTRY)} {MOM_contour_start_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at contour start
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_contour_end {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_contour_end_LIB_ENTRY) [llength [info commands MOM_contour_end_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_contour_end_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_contour_end_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_contour_end_LIB_ENTRY)} {MOM_contour_end_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at contour end
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_drill_LIB_ENTRY) [llength [info commands MOM_drill_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_LIB_ENTRY)} {MOM_drill_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_LIB_ENTRY)} {MOM_drill_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_drill_move ; return}

  set commandcheck(MOM_drill_move_ENTRY) [llength [info commands MOM_drill_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_ENTRY)} {MOM_drill_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_move_ENTRY)} {MOM_drill_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_drill_dwell_LIB_ENTRY) [llength [info commands MOM_drill_dwell_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_dwell_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_LIB_ENTRY)} {MOM_drill_dwell_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill_dwell_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_LIB_ENTRY)} {MOM_drill_dwell_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_dwell_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_drill_dwell_move ; return}

  set commandcheck(MOM_drill_dwell_move_ENTRY) [llength [info commands MOM_drill_dwell_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_dwell_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_ENTRY)} {MOM_drill_dwell_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_dwell_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_dwell_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_dwell_move_ENTRY)} {MOM_drill_dwell_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_counter_sink {} {

  set commandcheck(MOM_drill_counter_sink_LIB_ENTRY) [llength [info commands MOM_drill_counter_sink_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_counter_sink_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_counter_sink_LIB_ENTRY)} {MOM_drill_counter_sink_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_counter_sink_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_counter_sink_LIB_ENTRY)} {MOM_drill_counter_sink_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Is this event exist now ????
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_counter_sink_move {} {

  set commandcheck(MOM_drill_counter_sink_move_ENTRY) [llength [info commands MOM_drill_counter_sink_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_counter_sink_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_counter_sink_move_ENTRY)} {MOM_drill_counter_sink_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_counter_sink_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_counter_sink_move_ENTRY)} {MOM_drill_counter_sink_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Is this event exist now ????
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_csink_dwell {} {

  set commandcheck(MOM_drill_csink_dwell_LIB_ENTRY) [llength [info commands MOM_drill_csink_dwell_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_csink_dwell_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_csink_dwell_LIB_ENTRY)} {MOM_drill_csink_dwell_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill_dwell

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_csink_dwell_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_csink_dwell_LIB_ENTRY)} {MOM_drill_csink_dwell_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Is this event exist now ????
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_csink_dwell_move {} {

  set commandcheck(MOM_drill_csink_dwell_move_ENTRY) [llength [info commands MOM_drill_csink_dwell_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_csink_dwell_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_csink_dwell_move_ENTRY)} {MOM_drill_csink_dwell_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_dwell_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_csink_dwell_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_csink_dwell_move_ENTRY)} {MOM_drill_csink_dwell_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# Is this event exist now ????
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_drill_deep_LIB_ENTRY) [llength [info commands MOM_drill_deep_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_deep_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_LIB_ENTRY)} {MOM_drill_deep_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill_deep_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_LIB_ENTRY)} {MOM_drill_deep_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_deep_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_drill_deep_move ; return}

  set commandcheck(MOM_drill_deep_move_ENTRY) [llength [info commands MOM_drill_deep_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_deep_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_ENTRY)} {MOM_drill_deep_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_deep_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_deep_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_deep_move_ENTRY)} {MOM_drill_deep_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_break_chip {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_drill_break_chip_LIB_ENTRY) [llength [info commands MOM_drill_break_chip_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_break_chip_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_LIB_ENTRY)} {MOM_drill_break_chip_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill_break_chip_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_LIB_ENTRY)} {MOM_drill_break_chip_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_break_chip_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_drill_break_chip_move ; return}

  set commandcheck(MOM_drill_break_chip_move_ENTRY) [llength [info commands MOM_drill_break_chip_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_break_chip_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_ENTRY)} {MOM_drill_break_chip_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_break_chip_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_break_chip_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_break_chip_move_ENTRY)} {MOM_drill_break_chip_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tap_LIB_ENTRY) [llength [info commands MOM_tap_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_LIB_ENTRY)} {MOM_tap_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_tap_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_LIB_ENTRY)} {MOM_tap_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_tap_move ; return}

  set commandcheck(MOM_tap_move_ENTRY) [llength [info commands MOM_tap_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_tap_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_ENTRY)} {MOM_tap_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_tap_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_move_ENTRY)} {MOM_tap_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tap_float_LIB_ENTRY) [llength [info commands MOM_tap_float_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_float_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_LIB_ENTRY)} {MOM_tap_float_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_tap_float_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_LIB_ENTRY)} {MOM_tap_float_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_float_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_tap_float_move ; return}

  set commandcheck(MOM_tap_float_move_ENTRY) [llength [info commands MOM_tap_float_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_tap_float_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_ENTRY)} {MOM_tap_float_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_tap_float_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_float_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_float_move_ENTRY)} {MOM_tap_float_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tap_deep_LIB_ENTRY) [llength [info commands MOM_tap_deep_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_deep_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_LIB_ENTRY)} {MOM_tap_deep_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_tap_deep_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_LIB_ENTRY)} {MOM_tap_deep_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_deep_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_tap_deep_move ; return}

  set commandcheck(MOM_tap_deep_move_ENTRY) [llength [info commands MOM_tap_deep_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_tap_deep_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_ENTRY)} {MOM_tap_deep_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_tap_deep_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_deep_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_deep_move_ENTRY)} {MOM_tap_deep_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tap_break_chip_LIB_ENTRY) [llength [info commands MOM_tap_break_chip_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_tap_break_chip_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_LIB_ENTRY)} {MOM_tap_break_chip_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_tap_break_chip_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_LIB_ENTRY)} {MOM_tap_break_chip_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tap_break_chip_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_tap_break_chip_move ; return}

  set commandcheck(MOM_tap_break_chip_move_ENTRY) [llength [info commands MOM_tap_break_chip_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_tap_break_chip_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_ENTRY)} {MOM_tap_break_chip_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_tap_break_chip_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tap_break_chip_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tap_break_chip_move_ENTRY)} {MOM_tap_break_chip_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_LIB_ENTRY) [llength [info commands MOM_bore_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_LIB_ENTRY)} {MOM_bore_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_LIB_ENTRY)} {MOM_bore_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_move ; return}

  set commandcheck(MOM_bore_move_ENTRY) [llength [info commands MOM_bore_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_ENTRY)} {MOM_bore_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_move_ENTRY)} {MOM_bore_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_dwell_LIB_ENTRY) [llength [info commands MOM_bore_dwell_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_dwell_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_LIB_ENTRY)} {MOM_bore_dwell_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_dwell_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_LIB_ENTRY)} {MOM_bore_dwell_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_dwell_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_dwell_move ; return}

  set commandcheck(MOM_bore_dwell_move_ENTRY) [llength [info commands MOM_bore_dwell_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_dwell_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_ENTRY)} {MOM_bore_dwell_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_dwell_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_dwell_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_dwell_move_ENTRY)} {MOM_bore_dwell_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_drag_LIB_ENTRY) [llength [info commands MOM_bore_drag_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_drag_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_LIB_ENTRY)} {MOM_bore_drag_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_drag_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_LIB_ENTRY)} {MOM_bore_drag_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_drag_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_drag_move ; return}

  set commandcheck(MOM_bore_drag_move_ENTRY) [llength [info commands MOM_bore_drag_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_drag_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_ENTRY)} {MOM_bore_drag_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_drag_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_drag_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_drag_move_ENTRY)} {MOM_bore_drag_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_no_drag_LIB_ENTRY) [llength [info commands MOM_bore_no_drag_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_no_drag_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_LIB_ENTRY)} {MOM_bore_no_drag_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_no_drag_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_LIB_ENTRY)} {MOM_bore_no_drag_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_no_drag_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_no_drag_move ; return}

  set commandcheck(MOM_bore_no_drag_move_ENTRY) [llength [info commands MOM_bore_no_drag_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_no_drag_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_ENTRY)} {MOM_bore_no_drag_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_no_drag_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_no_drag_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_no_drag_move_ENTRY)} {MOM_bore_no_drag_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_back_LIB_ENTRY) [llength [info commands MOM_bore_back_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_back_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_LIB_ENTRY)} {MOM_bore_back_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_back_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_LIB_ENTRY)} {MOM_bore_back_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_back_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_back_move ; return}

  set commandcheck(MOM_bore_back_move_ENTRY) [llength [info commands MOM_bore_back_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_back_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_ENTRY)} {MOM_bore_back_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_back_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_back_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_back_move_ENTRY)} {MOM_bore_back_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_manual_LIB_ENTRY) [llength [info commands MOM_bore_manual_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_bore_manual_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_LIB_ENTRY)} {MOM_bore_manual_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_manual_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_LIB_ENTRY)} {MOM_bore_manual_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_manual_move ; return}

  set commandcheck(MOM_bore_manual_move_ENTRY) [llength [info commands MOM_bore_manual_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_manual_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_ENTRY)} {MOM_bore_manual_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_manual_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_move_ENTRY)} {MOM_bore_manual_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_bore_manual_dwell_LIB_ENTRY) [llength [info commands MOM_bore_manual_dwell_LIB_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_manual_dwell_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_LIB_ENTRY)} {MOM_bore_manual_dwell_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_bore_manual_dwell_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_LIB_ENTRY)} {MOM_bore_manual_dwell_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_bore_manual_dwell_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_bore_manual_dwell_move ; return}

  set commandcheck(MOM_bore_manual_dwell_move_ENTRY) [llength [info commands MOM_bore_manual_dwell_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_bore_manual_dwell_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_ENTRY)} {MOM_bore_manual_dwell_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_bore_manual_dwell_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_bore_manual_dwell_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_bore_manual_dwell_move_ENTRY)} {MOM_bore_manual_dwell_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_drill_text_LIB_ENTRY) [llength [info commands MOM_drill_text_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_drill_text_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_LIB_ENTRY)} {MOM_drill_text_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_drill_text_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_LIB_ENTRY)} {MOM_drill_text_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_drill_text_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_drill_text_move ; return}

  set commandcheck(MOM_drill_text_move_ENTRY) [llength [info commands MOM_drill_text_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_drill_text_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_ENTRY)} {MOM_drill_text_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_combine_cycle_rapid
  MOM_drill_text_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_drill_text_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_drill_text_move_ENTRY)} {MOM_drill_text_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_thread_LIB_ENTRY) [llength [info commands MOM_thread_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_thread_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_LIB_ENTRY)} {MOM_thread_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_thread_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_LIB_ENTRY)} {MOM_thread_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_thread_move {} {

  if {$::lib_ge_pretreatment_runtime} {if {[info proc PT_thread_move] == "PT_thread_move"} {PT_thread_move} ; return}

  set commandcheck(MOM_thread_move_ENTRY) [llength [info commands MOM_thread_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_thread_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_ENTRY)} {MOM_thread_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_thread_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_thread_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_thread_move_ENTRY)} {MOM_thread_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_off {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_cycle_off_LIB_ENTRY) [llength [info commands MOM_cycle_off_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_cycle_off_LIB

  global mom_prev_cycle_clearance_pos mom_cycle_type

  if {[info exists mom_prev_cycle_clearance_pos]} {
    unset mom_prev_cycle_clearance_pos
  }
  if {[info exists mom_cycle_type]} {
    unset mom_cycle_type
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_off_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_off_LIB_ENTRY)} {MOM_cycle_off_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end of drilling
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_on {} {

  if {$::lib_ge_pretreatment_runtime} {PT_cutcom_on ; return}

  global mom_cutcom_status mom_cutcom_mode
  global lib_flag

  set commandcheck(MOM_cutcom_on_ENTRY) [llength [info commands MOM_cutcom_on_ENTRY]]

  LIB_GE_command_buffer MOM_cutcom_on_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_on_ENTRY)} {MOM_cutcom_on_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {$mom_cutcom_status != "UNDEFINED"} {
    if {$mom_cutcom_status != "OFF"} {set mom_cutcom_status ON}
    if {$mom_cutcom_status == "ON"} {
      if {$mom_cutcom_mode != ""} {set mom_cutcom_status $mom_cutcom_mode}
    }
  }

  if {![info exists lib_flag(check_cutcom_start_move)]} {
    set lib_flag(check_cutcom_start_move) 1
  } else {
    incr lib_flag(check_cutcom_start_move)
  }

  MOM_cutcom_on_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cutcom_on_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_on_ENTRY)} {MOM_cutcom_on_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the cutcom_on event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cutcom_off {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_flag

  set commandcheck(MOM_cutcom_off_ENTRY) [llength [info commands MOM_cutcom_off_ENTRY]]

  LIB_GE_command_buffer MOM_cutcom_off_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_off_ENTRY)} {MOM_cutcom_off_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set lib_flag(check_cutcom_start_move) 0
  set lib_flag(check_cutcom_end_move) 1

  MOM_cutcom_off_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cutcom_off_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cutcom_off_ENTRY)} {MOM_cutcom_off_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the cutcom_off event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_first_turret {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_first_turret_LIB_ENTRY) [llength [info commands MOM_first_turret_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_first_turret_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_turret_LIB_ENTRY)} {MOM_first_turret_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_first_turret_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_first_turret_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_first_turret_LIB_ENTRY)} {MOM_first_turret_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the first_turret event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_turret_change {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_turret_change_LIB_ENTRY) [llength [info commands MOM_turret_change_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_turret_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_turret_change_LIB_ENTRY)} {MOM_turret_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_turret_change_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_turret_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_turret_change_LIB_ENTRY)} {MOM_turret_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the turret_change event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_head_change {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_head_change_LIB_ENTRY) [llength [info commands MOM_head_change_LIB_ENTRY]]

  LIB_GE_command_buffer MOM_head_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_head_change_LIB_ENTRY)} {MOM_head_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_head_change_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_head_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_head_change_LIB_ENTRY)} {MOM_head_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the first_turret event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_path {} {


  if {$::lib_ge_pretreatment_runtime} {PT_end_of_path ; return}

  global lib_flag lib_spf prev_convert_mom_out_angle_pos lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos
  if {$::lib_flag(load_pretreatment)} {
    if {[LIB_SPF_get_pretreatment op_with_no_move] == 1} {LIB_SPF_add_warning "Operations with no moves"}
  }

  if {[llength [info commands LIB_CTRL_structure_representation]] && [CONF_CTRL_setting op_representation_structured]} {LIB_CTRL_structure_representation}
  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "End of Path"}

  if {![info exists lib_flag(pattern_output_sub)] || $lib_flag(pattern_output_sub) == 0} {
    MOM_end_of_path_LIB
  }

  # In end of path, subprogram output is ended under the following condition:
  # Subprogram output ON in PC and no pattern feature output is needed, close subprogram at end of path of every operation.
  if {[info exists lib_spf(subprogram_output)] && $lib_spf(subprogram_output) == 1 && \
      (![info exists ::mom_process_patterning_pattern_mcs] || $::mom_process_patterning_pattern_mcs == "No")} {
      LIB_GE_command_buffer LIB_SPF_sub_output
      LIB_GE_command_buffer {LIB_SPF_sub_output_operation_end} @SUB_OUTPUT_END
      LIB_GE_command_buffer {LIB_SPF_pattern_positioning_reset} @PATTERN_POSITIONING_RESET
      LIB_GE_command_buffer_output
  }

  LIB_SPF_reset_control_mode
  LIB_SPF_reset_before_tool_change_in_end_of_path
  LIB_SPF_reset_options_of_lock_axis

  if {[string match "*Machine Control*" $::mom_operation_type] && $::mom_machine_mode == "TURN" \
    && [LIB_SPF_get_pretreatment mom_machine_mode +1] == "MILL"} {

    LIB_TURNING_mode end
  }

  if {[CONF_CTRL_setting turbo_mode] == 2 && [info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE"} {LIB_SPF_turbo_status "false" "advanced"}
  if {$::mom_current_oper_is_last_oper_in_program == "YES"} {LIB_SPF_turbo_status "disable"}

  if {[info exists prev_convert_mom_out_angle_pos]} {unset prev_convert_mom_out_angle_pos}
  if {[info exists lib_prev_cycle_retract_to_pos]} {unset lib_prev_cycle_retract_to_pos}
  if {[info exists lib_prev_cycle_rapid_to_pos]} {unset lib_prev_cycle_rapid_to_pos}

  set lib_flag(in_operation) 0

}
# <Internal Documentation>
# This procedure is executed end of path
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_merged_path {} {

  global mom_operation_id
  global lib_pretreatment

  if {$::lib_ge_pretreatment_runtime} {PT_start_of_merged_path ; return}
  if {[llength [info commands MOM_start_of_merged_path_LIB]]} {MOM_start_of_merged_path_LIB}

  # Set turbo at start of each merged path operation, according to result from pretreatment
  set index [lsearch -exact [LIB_SPF_get_pretreatment oper_tag_list_of_merged_group] $mom_operation_id]
  set oper_tag [lindex [LIB_SPF_get_pretreatment oper_tag_list_of_merged_group 0] $index]
  LIB_SPF_advanced_turbo_setting $lib_pretreatment($oper_tag,mom_kin_is_turbo_output)
  LIB_SPF_turbo_setting_by_feedrate_mode

}
proc MOM_end_of_merged_path {} {
    if {$::lib_ge_pretreatment_runtime} {PT_end_of_merged_path ; return}
  if {[llength [info commands MOM_end_of_merged_path_LIB]]} {MOM_end_of_merged_path_LIB}
}
# <Internal Documentation>
# This procedure is executed at end of merged path
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_reset_before_tool_change_in_end_of_path {} {

  global mom_next_oper_has_tool_change mom_tool_number mom_tool_name mom_tool_change_type
  global lib_flag lib_sav_tool_change_type

  if {$mom_next_oper_has_tool_change == "YES"} {
    if {[lsearch [CONF_CTRL_probe toolnr] $mom_tool_number] > -1 || \
      [lsearch [CONF_CTRL_probe toolname] $mom_tool_name] > -1} {
      set lib_flag(ignore_spindle_rpm) 0
      MOM_enable_address M_spindle
      if {[info exists mom_tool_change_type] && [info exists lib_sav_tool_change_type]} {
        set mom_tool_change_type $lib_sav_tool_change_type
        unset lib_sav_tool_change_type
      }
    }
  }

}
# <Internal Documentation>
# This procedure is executed inside end of path
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_reset_options_of_lock_axis {} {
  #PR9239197 Fix. Reset the options back
  global lib_flag
  if {[info exists lib_flag(plane_output_supported_all)] && $lib_flag(plane_output_supported_all) == 1} {
    CONF_CTRL_setting set plane_output_supported "ALL"
    set lib_flag(plane_output_supported_all) 0
  }
  if {[info exists lib_flag(polar_feedrate_off)] && $lib_flag(polar_feedrate_off) == 1} {
    CONF_CTRL_moves set polar_feedrate 0
    set lib_flag(polar_feedrate_off) 0
  }
}
# <Internal Documentation>
# This procedure is executed inside end of path
#
# <Internal Example>
#
#____________________________________________________________________________________________
#@.pce@
proc LIB_SPF_reset_arc_output {} {
  global mom_kin_arc_output_mode mom_kin_helical_arc_output_mode
  global lib_sav_kin_arc_output_mode lib_sav_kin_helical_arc_output_mode
  set mom_kin_arc_output_mode $lib_sav_kin_arc_output_mode
  set mom_kin_helical_arc_output_mode $lib_sav_kin_helical_arc_output_mode
  MOM_reload_kinematics
}
# <Internal Documentation>
# This procedure is executed inside end of path
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_reset_control_mode {} {

  global lib_spf

  set lib_spf(pre_motion_type) "end"

}
# <Internal Documentation>
# This procedure is executed inside end of path
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_program {} {

  if {$::lib_ge_pretreatment_runtime} {PT_end_of_program ; return}

  global lib_pretreatment lib_ge_line_info lib_ge_tclversion lib_flag mom_operation_name lib_spf

  if {[info exists lib_ge_line_info]} {
    LIB_SPF_add_warning "$lib_ge_line_info" 1
  }

  if {[info exists lib_flag(first_start_of_path)]} {
    set lib_flag(first_start_of_path) 0
  }

  if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "End of Program"}
  LIB_SPF_end_of_extcall_program
  if {[llength [info commands MOM_end_of_program_LIB]]} {MOM_end_of_program_LIB}

  LIB_GE_show_source_of_proc

  if {[CONF_GE_debug show_where_output_comes_from] == 2} {
    LIB_SPF_write_buffer_visualisation_file "xml"
  } elseif {[CONF_GE_debug show_where_output_comes_from] == 3} {
    LIB_SPF_write_buffer_visualisation_file "json"
  }
  CLOSE_files

  if {[llength [info commands LIB_SPF_ini_rename_files]]} {LIB_SPF_ini_rename_files}

  if {[CONF_GE_debug post_time] && [info exists lib_spf(clock,start)]} {LIB_GE_posttime_output}

  # Monitor all files that are opened
  trace remove execution MOM_open_output_file enter LIB_SPF_trace_open_output_file
  # Monitor all files that have been closed in order not to have to close them in the end
  trace remove execution MOM_close_output_file enter LIB_SPF_trace_close_output_file

}
# <Internal Documentation>
# This procedure is executed at end of program
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_path_region_marker_start {} {
}
# <Internal Documentation>
# This is currently not part of the NX documentation,
# so we need more information here, should functionality be necessary.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_path_region_marker_end {} {
}
# <Internal Documentation>
# This is currently not part of the NX documentation,
# so we need more information here, should functionality be necessary.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_GE_posttime_output {} {

  global lib_spf lib_ge_tclversion listing_info lib_ge_not_monitored_files
  global env lib_spf mom_output_file_full_name tcl_platform

  if {!$lib_spf(clock,exists)} {
    LIB_GE_command_buffer LISTING_INFO

    LIB_GE_command_buffer {MOM_output_to_listing_device "$listing_info(line,1)"} @SEPARATIONLINE1

    LIB_GE_command_buffer {MOM_output_to_listing_device "[LIB_DC_format_string $listing_info(line,3) [list "Can not output the Post Time, because TCL8.6 does not support the command 'CLOCK'"]]"} @timeline
    LIB_GE_command_buffer {MOM_output_to_listing_device "$listing_info(line,1)"} @SEPARATIONLINE2

    LIB_GE_command_buffer_output
    return
  }

  LIB_GE_posttime_config
  LIB_GE_posttime_stop

  if {$lib_ge_tclversion > 8.3} {
    set lib_spf(clock,end)  [format %.01f [clock clicks -milliseconds]]
  } else {
    set lib_spf(clock,end)  [format %.01f [clock clicks]]
  }
  if {$lib_spf(nx_version) >= 1202 && [string match "*windows*" $tcl_platform(platform)]} {
    set sessionfile $env(TEMP)\\PostConfigurator\\Sessionfile[pid].tcl
    if {[string match "" $mom_output_file_full_name]} {
      if {![file exist $env(TEMP)\\PostConfigurator]} {
        set error [file mkdir $env(TEMP)\\PostConfigurator]
        set error [file attribute $env(TEMP)\\PostConfigurator -hidden 1]
      }
      LIB_FH_create_file $sessionfile "w+" [list "set lib_spf(clock,start) $lib_spf(clock,start)"]
      return
    } elseif {![string match "" $mom_output_file_full_name] && [file exist $sessionfile]} {
      set lib_ge_not_monitored_files 1
      LIB_GE_source_file $sessionfile
      LIB_Shell_file_delete $sessionfile
    }
  }

  set lib_spf(clock,sum) [format %.0f [expr $lib_spf(clock,end)-$lib_spf(clock,start)]]

  set lib_spf(posttime) "[LIB_GE_MSG "Post Runtime"] [LIB_GE_posttime_format $lib_spf(clock,sum)]"

  LIB_GE_command_buffer LISTING_INFO

  LIB_GE_command_buffer {MOM_output_to_listing_device "$listing_info(line,1)"} @SEPARATIONLINE1

  LIB_GE_command_buffer {MOM_output_to_listing_device "[LIB_DC_format_string $listing_info(line,2) [list "[LIB_GE_split_listing_line $lib_spf(posttime) "start"]" "[LIB_GE_split_listing_line $lib_spf(posttime) "end"]"]]"} @timeline
  LIB_GE_command_buffer {MOM_output_to_listing_device "$listing_info(line,1)"} @SEPARATIONLINE2

  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Output time for display
#____________________________________________________________________________________________
proc LIB_GE_posttime_stop {} {

  global lib_ge_tclversion lib_spf

  if {!$lib_spf(clock,exists)} {return}

  # By using either msecs or secs as the underlying quantum, we can get
  # accuracy where we want it.
  if {$lib_ge_tclversion > 8.3} {
    set lib_spf(clock,end)    [clock clicks -milliseconds]
  } else {
    set lib_spf(clock,end)    [clock clicks]
  }

}
# <Internal Documentation>
#
# Stop time for display
#____________________________________________________________________________________________
proc LIB_GE_posttime_config {} {

  global lib_ge_tclversion lib_spf

  # By using either msecs or secs as the underlying quantum, we can get
  # accuracy where we want it.
  if {$lib_ge_tclversion > 8.3} {
    set lib_spf(msecsPerTick) 1
    set lib_spf(ticksPerSec)    1000
    set lib_spf(ticksPerMin)    60000
    set lib_spf(ticksPerHr)   3600000
  } else {
    set lib_spf(msecsPerTick)   1000
    set lib_spf(ticksPerSec)  1
    set lib_spf(ticksPerMin)  60
    set lib_spf(ticksPerHr)   3600
  }

}
# <Internal Documentation>
#
# Cofig time for display
#____________________________________________________________________________________________
proc LIB_GE_posttime_format {ticks} {

  global lib_ge_tclversion lib_spf

  if {$ticks < 0} {
    set sign "-"
    set ticks [expr {abs($ticks)}]
  } else {
    set sign ""
  }

  set r [format %03d:%02d:%02d \
           [expr {$ticks /3600000}] \
           [expr {($ticks % 3600000 )/60000}] \
           [expr {($ticks % 60000)/1000}]]
  if {$lib_ge_tclversion > 8.3} {
    append r [format ".%03d" [expr {$ticks % 1000}]]
  }

  return $r
}
# <Internal Documentation>
#
# Format time for display
#____________________________________________________________________________________________
proc LIB_GE_log_message_output {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global lib_ge_log_message

  if {$::lib_flag(nottranslated) > 0} {
    lappend lib_ge_log_message "\n"
    lappend lib_ge_log_message "[LIB_GE_MSG "The following messages are not translated"]:"
    lappend lib_ge_log_message "============================================================"
    foreach i $::lib_flag(not_translated) {
      lappend lib_ge_log_message "--> $i"
    }
    lappend lib_ge_log_message "\n"
  }
  CONF_GE_language set message_is_not_translated 0
}
# <Internal Documentation>
#
# Add messages to the logfile
#____________________________________________________________________________________________
proc LIB_SPF_KINEMATICS_set_rot_axis_kin {axis_to_set axis_def} {

  if {$axis_to_set == "4th"} {
    LIB_GE_copy_var_range mom_kin_4th $axis_def
  } elseif {$axis_to_set == "5th"} {
    LIB_GE_copy_var_range mom_kin_5th $axis_def
  } else {
    LIB_GE_abort_message "Error setting rot_axis parameters" "only '4th' or '5th' axis can be defined"
  }

  MOM_reload_kinematics

}
# <Internal Documentation>
#
# set the parameters for the 4th or 5th axis based on a predefined variable set
# the new kinematics definition will be activated by MOM_reload_kinematics
#
# arguments:
# axis_to_set : defines the axis for which the parameters should be set
# (valid options: "4th" , "5th"
# axis_def    : the prefix of the variale range containing the parameter information
#
# <Internal Example>
# LIB_SPF_KINEMATICS_set_rot_axis_kin "4th" kin_rot3
#
# This will set the "mom_kin_4th*" variables to the values of the "kin_rot3*" variables
# The command will activate the new configuration by
# MOM_reload_kinematics
#____________________________________________________________________________________________
proc LIB_SPF_set_kin_axis_vector {ax_nbr axis} {

  global mom_kin_4th_axis_vector
  global mom_kin_5th_axis_vector
  global mom_kin_4th_axis_rotation
  global mom_kin_5th_axis_rotation
  global lib_sav_kin_4th_axis_vector lib_sav_kin_5th_axis_vector
  global lib_sav_kin_4th_axis_rotation lib_sav_kin_5th_axis_rotation

  set update_axis 1

  if {[llength $axis] == 3} {
    set axis_list $axis
  } else {
    set axis_list [split $axis ","]
  }

  if {[regexp {^([-]?)([XYZ]{1})$} $axis dummy sign name]} {
    if {$name == "X"} {
      array set vec "0 ${sign}1 1 0 2 0"
    } elseif {$name == "Y"} {
      array set vec "0 0 1 ${sign}1 2 0"
    } elseif {$name == "Z"} {
      array set vec "0 0 1 0 2 ${sign}1"
    }
  } elseif {[llength $axis_list] == 3} {
      set vec(0) [lindex $axis_list 0]
      set vec(1) [lindex $axis_list 1]
      set vec(2) [lindex $axis_list 2]
  } elseif {$axis == "real"} {
    if {$ax_nbr == "4th"} {
      array set mom_kin_4th_axis_vector "0 $lib_sav_kin_4th_axis_vector(0) 1 $lib_sav_kin_4th_axis_vector(1) 2 $lib_sav_kin_4th_axis_vector(2)"
      set mom_kin_4th_axis_rotation $lib_sav_kin_4th_axis_rotation
    } elseif {$ax_nbr == "5th"} {
      array set mom_kin_5th_axis_vector "0 $lib_sav_kin_5th_axis_vector(0) 1 $lib_sav_kin_5th_axis_vector(1) 2 $lib_sav_kin_5th_axis_vector(2)"
      set mom_kin_5th_axis_rotation $lib_sav_kin_5th_axis_rotation
    }
    MOM_reload_kinematics_variable mom_kin_4th_axis_vector mom_kin_4th_axis_rotation mom_kin_5th_axis_vector mom_kin_5th_axis_rotation
    set update_axis 0
  } else {
          LIB_GE_abort_message "PP definition error in LIB_SPF_set_kin_axis_vector" "Check lib_parameter(inclined_plane_4th_axis) and/or lib_parameter(inclined_plane_5th_axis) definition"
          set update_axis 0
  }

  if {$update_axis == 1} {
    if {$ax_nbr == "4th"} {
      set mom_kin_4th_axis_vector(0) $vec(0)
      set mom_kin_4th_axis_vector(1) $vec(1)
      set mom_kin_4th_axis_vector(2) $vec(2)
      set mom_kin_4th_axis_rotation "standard"
    } elseif {$ax_nbr == "5th"} {
      set mom_kin_5th_axis_vector(0) $vec(0)
      set mom_kin_5th_axis_vector(1) $vec(1)
      set mom_kin_5th_axis_vector(2) $vec(2)
      set mom_kin_5th_axis_rotation "standard"
    }
    MOM_reload_kinematics_variable mom_kin_4th_axis_vector mom_kin_4th_axis_rotation mom_kin_5th_axis_vector mom_kin_5th_axis_rotation
  }
}
# <Internal Documentation>
#
# Sets the 4th or the 5th axis vector
# arguments
# ax_nbr: 4th or 5th
# axis: can be one of the fallowing
#   X, -X, Y, -Y, Z, -Z
#   or
#   0,0,1.0 (vector)
# <Internal Example>
#
# LIB_SPF_set_kin_axis_vector 4th -Y
# LIB_SPF_set_kin_axis_vector 5th 0.,1.0,0.
#
#____________________________________________________________________________________________
proc LIB_SPF_check_cutcom_condition {} {

  global lib_flag
  global mom_motion_event

  if {[info exists lib_flag(check_cutcom_start_move)] && $lib_flag(check_cutcom_start_move) == 1} {

    set lib_flag(check_cutcom_start_move) 2
  } elseif {[info exists lib_flag(check_cutcom_end_move)] && $lib_flag(check_cutcom_end_move) == 1} {

    set lib_flag(check_cutcom_end_move) 0
  }

}
# <Internal Documentation>
#
# This allows to check the first move after cutcom is switched on or off
# This is meant to do checks like first move has not to be a circular move
# The flags lib_flag(check_cutcom_start_move) and lib_flag(check_cutcom_end_move) are triggering this check
# those flags are set in MOM_cutcom_on and MOM_cutcom_off
#
# Proc has to be moved to controller level to implement controller specific checks
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_combine_cycle_rapid {} {
  global lib_flag
  if {![info exists lib_flag(cycle_move_count)]} {
    set lib_flag(cycle_move_count) 0
  }
  incr lib_flag(cycle_move_count)

  if {[LIB_SPF_pt_exists lib_cycle_combine($lib_flag(cycle_move_count)]} {
    if {[LIB_SPF_get_pretreatment lib_cycle_combine($lib_flag(cycle_move_count))]} {
      set ::mom_cycle_clearance_plane_change 0
    }
  }
  if {[LIB_SPF_pt_exists lib_cycle_skip_rapid($lib_flag(cycle_move_count)]} {
    if {[LIB_SPF_get_pretreatment lib_cycle_skip_rapid($lib_flag(cycle_move_count))]} {
      MOM_skip_handler_to_event $::mom_motion_event
    }
  }

}
# <Internal Documentation>
# This procedure is executed at drilling/boring/tapping move to check redundant rapid and
# cycle output for 5-axis NCM drilling cycles. It only works for table machine and when combine rotary
# option of cycle motions is turned on.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_spindle_max_min {} {

  global mom_path_name mom_spindle_rpm mom_sys_spindle_param
  global lib_flag lib_parameter lib_ge_active_chain

  set commandcheck(LIB_SPF_spindle_max_min_ENTRY) [llength [info commands LIB_SPF_spindle_max_min_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_spindle_max_min_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_spindle_max_min_ENTRY)} {LIB_SPF_spindle_max_min_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {![hiset mom_sys_spindle_param($lib_ge_active_chain,min)]} {set mom_sys_spindle_param($lib_ge_active_chain,min) [CONF_CTRL_spindle min]}
  if {![hiset mom_sys_spindle_param($lib_ge_active_chain,max)]} {set mom_sys_spindle_param($lib_ge_active_chain,max) [CONF_CTRL_spindle max]}
  if {![hiset lib_flag(spindle_error_flag)]} {set lib_flag(spindle_error_flag) 0}

  if {[hiset mom_spindle_rpm]} {
    if {[CONF_CTRL_spindle no_spindle_rpm_allowed] != 1 && [EQ_is_zero $mom_spindle_rpm] && ![hiset lib_flag(spindle_error_rpm,$mom_path_name)]} {
      LIB_SPF_add_warning "Spindle Error - Spindle feed = 0 is not allowed"
      set lib_flag(spindle_error_rpm,$mom_path_name) 1
    } else {
      if {[EQ_is_lt $mom_spindle_rpm $mom_sys_spindle_param($lib_ge_active_chain,min)] && ![hiset lib_flag(spindle_error_min,$mom_path_name)]} {
        LIB_SPF_add_warning "Spindle Error - Spindle speed < INS->$mom_sys_spindle_param($lib_ge_active_chain,min)<-, Minimum assumed"
        set lib_flag(spindle_error_min,$mom_path_name) 1
        set mom_spindle_rpm $mom_sys_spindle_param($lib_ge_active_chain,min)
      }
      if {[EQ_is_gt $mom_spindle_rpm $mom_sys_spindle_param($lib_ge_active_chain,max)] && ![hiset lib_flag(spindle_error_max,$mom_path_name)]} {
        LIB_SPF_add_warning "Spindle Error - Spindle speed > INS->$mom_sys_spindle_param($lib_ge_active_chain,max)<-, Maximum assumed"
        set mom_spindle_rpm $mom_sys_spindle_param($lib_ge_active_chain,max)
        set lib_flag(spindle_error_max,$mom_path_name) 1
      }
    }
  }

  MOM_reload_variable mom_spindle_rpm

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_spindle_max_min_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_spindle_max_min_ENTRY)} {LIB_SPF_spindle_max_min_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Check spindle max/min value
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_spindle_direction {} {

  global mom_spindle_direction_automatic mom_spindle_direction_control mom_spindle_direction
  global mom_machine_mode mom_tool_type mom_tool_axis mom_tool_direction
  global lib_parameter lib_flag
  global mom_spindle_startup_status mom_spindle_status
  global mom_sys_turning_spindle_direction_mode

  set commandcheck(LIB_SPF_spindle_direction_ENTRY) [llength [info commands LIB_SPF_spindle_direction_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_spindle_direction_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_spindle_direction_ENTRY)} {LIB_SPF_spindle_direction_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  #For back counter sinking and new deep hole drilling operations
  if { [info exists mom_spindle_startup_status] && [info exists mom_spindle_direction] } {
    if { ![string compare "OFF" $mom_spindle_startup_status] &&\
    (![string compare "OFF" $mom_spindle_status] || ![string compare "LOCK" $mom_spindle_status]) } {
      set mom_spindle_direction "OFF"
    }
  }
  if {$mom_spindle_direction == "NONE"} {set mom_spindle_direction "OFF"} ;# ude spindle
  # If post lib is legacy version, NX always outputs reversed spindle direction as mom_sys_turning_spindle_direction_mode is not set.
  # If both NX and post are new version, the conversion is done in NX according to the mom_sys_turning_spindle_direction_mode value, nothing to do.
  # Using new post on old NX version requires following workaround.
  if {$mom_machine_mode == "TURN" && ![string compare "Normal" $mom_sys_turning_spindle_direction_mode] && $::lib_ge_env(major_version) < 1980} {
    if {$::mom_spindle_direction == "CLW"} {
      set ::mom_spindle_direction "CCLW"
    } elseif {$::mom_spindle_direction == "CCLW"} {
      set ::mom_spindle_direction "CLW"
    }
  }
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_spindle_direction_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_spindle_direction_ENTRY)} {LIB_SPF_spindle_direction_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Check spindle direction
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_check_x_factor {mill_turn} {
  global mom_machine_mode x_factor mom_sys_advanced_turbo_output
  global lib_ge_active_chain
  if {![string match "" $lib_ge_active_chain]} {
    set active_chain "@$lib_ge_active_chain"
  } else {
    set active_chain ""
  }

  if {$mom_machine_mode == "MILL" || [LIB_GE_string_toupper $mill_turn] == "MILL"} {
    if {[CONF_CTRL_setting exists x_factor_mill$active_chain]} {
      if {[CONF_CTRL_setting x_factor_mill$active_chain] != 1} {
        if {($::lib_ge_env(major_version) < 11)} {
          CONF_CTRL_setting set turbo_mode 0
        } elseif {[LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
          LIB_SPF_turbo_status "enable" "advanced"
        }
      }
      set x_factor [CONF_CTRL_setting x_factor_mill$active_chain]
    } else {
      if {[CONF_CTRL_setting x_factor_mill] != 1} {
        if {($::lib_ge_env(major_version) < 11)} {
          CONF_CTRL_setting set turbo_mode 0
        } elseif {[LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
          LIB_SPF_turbo_status "enable" "advanced"
        }
      }
      set x_factor [CONF_CTRL_setting x_factor_mill]
    }
  } else {
    if {[CONF_CTRL_setting exists x_factor$active_chain]} {
      if {[CONF_CTRL_setting x_factor$active_chain] != 1} {
        if {($::lib_ge_env(major_version) < 11)} {
          CONF_CTRL_setting set turbo_mode 0
        } elseif {[LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
          LIB_SPF_turbo_status "enable" "advanced"
        }
      }
      set x_factor [CONF_CTRL_setting x_factor$active_chain]
    } else {
      if {[CONF_CTRL_setting x_factor] != 1} {
        if {($::lib_ge_env(major_version) < 11)} {
          CONF_CTRL_setting set turbo_mode 0
        } elseif {[LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
          LIB_SPF_turbo_status "enable" "advanced"
        }
      }
      set x_factor [CONF_CTRL_setting x_factor]
    }
  }
  return $x_factor
}
# <Internal Documentation>
# Set x_factor and activate advanced turbo mode when
# [CONF_CTRL_setting x_factor] == 2
# Or
# [CONF_CTRL_setting x_factor_mill] == 2
# <Internal Example>
#
# set results [LIB_SPF_check_x_factor MILL]
#____________________________________________________________________________________________
proc LIB_SPF_init_sys_tool_change_pos {} {
  global mom_sys_home_pos lib_sys_tool_change_pos
  if {![info exists lib_sys_tool_change_pos(0)] && [info exists mom_sys_home_pos(0)]} {
    set lib_sys_tool_change_pos(0) $mom_sys_home_pos(0)
  }
  if {![info exists lib_sys_tool_change_pos(1)] && [info exists mom_sys_home_pos(1)]} {
    set lib_sys_tool_change_pos(1) $mom_sys_home_pos(1)
  }
  if {![info exists lib_sys_tool_change_pos(2)] && [info exists mom_sys_home_pos(2)]} {
    set lib_sys_tool_change_pos(2) $mom_sys_home_pos(2)
  }

}
# <Internal Documentation>
# Set intermetiate point for motion between home_pos and tool change pos
# Init this variable if the are not defined with mom_sys_home_pos
# e.g. Hermle C-Series
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_rotary_axis_limit {} {

  global mom_kin_retract_type mom_kin_retract_distance mom_kin_reengage_distance mom_reposition_safety_retract
  global mom_kin_4th_axis_plane mom_kin_is_turbo_output mom_kin_machine_type
  global mom_prev_alt_pos mom_kin_4th_axis_direction mom_kin_4th_axis_leader mom_kin_5th_axis_direction mom_kin_5th_axis_leader mom_sys_leader
  global mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_motion_event mom_tool_axis mom_prev_tool_axis mom_pos mom_out_angle_pos mom_prev_out_angle_pos mom_alt_pos
  global mom_feed_rate mom_warning_info mom_reposition_retract mom_feed_engage_value mom_feed_retract_value
  global lib_current_pos lib_template lib_parameter lib_flag lib_current_out_angle_pos lib_current_feed_rate

  if {[info level 1] == "MOM_catch_warning"} {
    set _degenerated_warning 0

    if {[regexp -nocase -- "Previous rotary axis solution degenerated!" $mom_warning_info] == 1} {
      set _degenerated_warning 1
    } elseif {[LIB_SPF_get_pretreatment axis_mode] == "CONSTANT" || ![regexp -nocase -- "ROTARY CROSSING LIMIT." $mom_warning_info] && ![regexp -nocase -- "secondary rotary position" $mom_warning_info]} {
      return
    }

    if {[CONF_CTRL_setting turbo_mode] == 1 && $mom_kin_is_turbo_output == "TRUE"} {
      LIB_SPF_turbo_status "disable"
      if {[CONF_SPF_msg output_event_message]} {LIB_SPF_output_event_message "Turbomode disable"}
    }
    if {[EQ_is_zero $lib_flag(tool_path_motion)]} {return}
    if {(![hiset mom_motion_event] || $mom_motion_event != "linear_move") && [CONF_CTRL_moves rot_limit_action_only_linear_move] == 1} {return}
    if {$::mom_kin_read_ahead_next_motion == "TRUE" && $_degenerated_warning == 0} {
      if {![hiset lib_flag(spf_rotary_axis_count_event)]} {set lib_flag(spf_rotary_axis_count_event) 0}
    } else {
      set lib_flag(output_spf_rotary_axis) 1
    }

  } else {
    if {![hiset lib_flag(spf_rotary_axis_count_event)]} {return}
    incr lib_flag(spf_rotary_axis_count_event)
    if {([regexp -nocase -- "secondary rotary position" $mom_warning_info] == 1 && $lib_flag(spf_rotary_axis_count_event) == 1) ||\
         ([regexp -nocase -- "ROTARY CROSSING LIMIT." $mom_warning_info] == 1 && $lib_flag(spf_rotary_axis_count_event) == 2)} {
      unset lib_flag(spf_rotary_axis_count_event)
      set lib_flag(output_spf_rotary_axis) 1
    }
  }

  if {![hiset lib_flag(output_spf_rotary_axis)]} {return}
  unset lib_flag(output_spf_rotary_axis)

  # "Warning"
  if {[CONF_CTRL_moves rot_limit_action] == 0} {
    # 8420783 Suppress warning message if plane output is enabled and current mode is positioning
    if {[CONF_CTRL_setting plane_output_supported] != "NONE" && $lib_flag(mode_current_status) == "pos"} {
      #Do not show warning message if it's plane output positioning
    } elseif {$_degenerated_warning == 1} {
      #Solution degenerated may not indicate rotary axis limit violation
      LIB_SPF_add_warning "Previous rotary axis solution degenerated!"
    } else {
      LIB_SPF_add_warning "Rotary axis limit violated, discontinuous motion may result.\
          Rotary axes move from \([format %.3f $::mom_prev_rot_ang_4th],[format %.3f $::mom_prev_rot_ang_5th]\)\
          to \([format %.3f $::mom_out_angle_pos(0)],[format %.3f $::mom_out_angle_pos(1)]\)."
    }
    return
  }

  # "User Defined"
  if {[CONF_CTRL_moves rot_limit_action] != 1} {
    LIB_CONF_do_prop_custom_proc CONF_CTRL_moves rot_limit_action
    return
  }

  # "Engage Retract"
  if {[info exists _degenerated_warning] && $_degenerated_warning == 1} {return}

  # default values
  if {![hiset mom_kin_retract_type]} {set mom_kin_retract_type "DISTANCE"}
  if {![hiset mom_kin_retract_distance]} {set mom_kin_retract_distance 10.0}
  if {![hiset mom_reposition_safety_retract]} {set mom_reposition_safety_retract "TRUE"}
  if {![hiset mom_kin_reengage_distance]} {set mom_kin_reengage_distance .20}

  LIB_GE_message "Automatic repositioning $mom_warning_info"

  # save mom_pos
  array set lib_sav_pos "0 $mom_pos(0) 1 $mom_pos(1) 2 $mom_pos(2)"
  array set lib_sav_out_angle_pos "0 $mom_out_angle_pos(0) 1 $mom_out_angle_pos(1)"

  # save addresses values
  array set lib_current_pos "0 [MOM_ask_address_value X] 1 [MOM_ask_address_value Y] 2 [MOM_ask_address_value Z]"
  array set lib_current_out_angle_pos "0 [MOM_ask_address_value fourth_axis] 1 [MOM_ask_address_value fifth_axis]"
  set lib_current_feed_rate $mom_feed_rate

  ######################################################################
  #Retract along tool axis
  LIB_GE_command_buffer RETRACT
  LIB_GE_command_buffer {
    if {![EQ_is_zero $mom_kin_retract_distance]} {
      set mom_pos(0) [expr $lib_current_pos(0) + ($mom_prev_tool_axis(0) * $mom_kin_retract_distance)]
      set mom_pos(1) [expr $lib_current_pos(1) + ($mom_prev_tool_axis(1) * $mom_kin_retract_distance)]
      set mom_pos(2) [expr $lib_current_pos(2) + ($mom_prev_tool_axis(2) * $mom_kin_retract_distance)]
      set mom_out_angle_pos(0) $lib_current_out_angle_pos(0)
      set mom_out_angle_pos(1) $lib_current_out_angle_pos(1)
      set mom_feed_rate $mom_feed_retract_value
      if {![hiset mom_motion_event] || $mom_motion_event != "linear_move"} {
        MOM_do_template [CONF_CTRL_moves rapid_template]
      } else {
        MOM_do_template [CONF_CTRL_moves linear_template]
      }
    }
  } @RAPID

  #Retract safety motion # UDE Retract Z machine
  LIB_GE_command_buffer {
    if {[hiset mom_reposition_safety_retract] && $mom_reposition_safety_retract == "TRUE"} {
      if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
        LIB_ROTARY_absolute_reset
      } else {
        LIB_ROTARY_simultaneous_reset
      }
      if {[CONF_CTRL_moves return_safety_pos] != ""} {LIB_RETURN_move [CONF_CTRL_moves return_safety_pos]}
    }
  } @RESET
  LIB_GE_command_buffer_output

  ######################################################################
  #Calcutate rotary motion
  #
  # --> Implementation should be dependent of current kinematics settings 4th/5th axis (machine type)
  #
  if {[regexp -- "secondary rotary position" $mom_warning_info] == 1} {
    #secondary rotary position
    set mom_pos(0)  $mom_prev_alt_pos(0)
    set mom_pos(1)  $mom_prev_alt_pos(1)
    set mom_pos(2)  $mom_prev_alt_pos(2)
    set mom_out_angle_pos(0) [LIB_SPF_rotset $mom_prev_alt_pos(3) $lib_sav_out_angle_pos(0) $mom_kin_4th_axis_direction $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis) $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit 1]
    set mom_out_angle_pos(1) [LIB_SPF_rotset $mom_prev_alt_pos(4) $lib_sav_out_angle_pos(1) $mom_kin_5th_axis_direction $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis) $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit 1]
  } else {
    # rotary cross limit
    if {![EQ_is_zero $mom_out_angle_pos(1)]} {
      if {$lib_current_out_angle_pos(0) < 0} {
        set mom_out_angle_pos(0) [expr [MOM_ask_address_value fourth_axis] + 360]
      } else {
        set mom_out_angle_pos(0) [expr [MOM_ask_address_value fourth_axis] - 360]
      }
      if {[EQ_is_lt $::mom_out_angle_pos(0)  $::mom_kin_4th_axis_min_limit] || [EQ_is_gt $::mom_out_angle_pos(0)  $::mom_kin_4th_axis_max_limit]} {
        LIB_GE_abort_message "Error repositioning rotary axes in 'INS->$::mom_path_name<-' LIB_SPF_rotary_axis_limit" "Please increase steps in operation"
      }

    } else {
      set mom_out_angle_pos(0) $lib_sav_out_angle_pos(0)
    }
  }

  ######################################################################
  #Rotary_motion
  LIB_GE_command_buffer REPOSITIONING
  LIB_GE_command_buffer {
    MOM_do_template [CONF_CTRL_moves rapid_rotary]
  } @RAPID_ROTARY

  ######################################################################
  #Approach_motion
  LIB_GE_command_buffer {
    if {[hiset mom_reposition_safety_retract] && $mom_reposition_safety_retract == "TRUE"} {
      if {[CONF_CTRL_setting tcpm_output_supported] == "NONE"} {
        LIB_ROTARY_absolute_init
      } else {
        LIB_ROTARY_simultaneous_init
      }
      MOM_force once X Y Z
      MOM_do_template [CONF_CTRL_moves rapid_rotary] CREATE
      # position with a distance before path (mom_kin_reengage_distance)
      set mom_pos(0) [expr $lib_current_pos(0) + ($mom_prev_tool_axis(0) * $mom_kin_reengage_distance)]
      set mom_pos(1) [expr $lib_current_pos(1) + ($mom_prev_tool_axis(1) * $mom_kin_reengage_distance)]
      set mom_pos(2) [expr $lib_current_pos(2) + ($mom_prev_tool_axis(2) * $mom_kin_reengage_distance)]
      MOM_do_template [CONF_CTRL_moves rapid_template]
    }
  } @ROTARY_INIT

  ######################################################################
  #Positioning_motion
  LIB_GE_command_buffer {
    set mom_pos(0) $lib_current_pos(0)
    set mom_pos(1) $lib_current_pos(1)
    set mom_pos(2) $lib_current_pos(2)
    set mom_feed_rate $mom_feed_engage_value

    if {![hiset mom_motion_event] || $mom_motion_event != "linear_move"} {
      MOM_do_template [CONF_CTRL_moves rapid_template]
    } else {
      MOM_do_template [CONF_CTRL_moves linear_template]
    }
  } @ROTARY_ENGAGE

  ######################################################################
  LIB_GE_command_buffer {
    LIB_GE_message "End of the automatic repositioning"
  } @MESSAGE

  ######################################################################
  LIB_GE_command_buffer {
    set mom_pos(0) $lib_sav_pos(0)
    set mom_pos(1) $lib_sav_pos(1)
    set mom_pos(2) $lib_sav_pos(2)
    set mom_out_angle_pos(0) $lib_sav_out_angle_pos(0)
    set mom_out_angle_pos(1) $lib_sav_out_angle_pos(1)
    set mom_feed_rate $lib_current_feed_rate
  } @ROTARY_END
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
#
# Repositioning for 4 and 5 axis (dual_head kinematics always used for simultanious)
# [CONF_CTRL_moves rot_limit_action]:
#   0:"Warning" / 1:"EngageRetract" / 2:*VALUE*: "UserDefined"
#
#  mom_kin_retract_distance --- specifies the distance or radius for
#                               defining the geometry of retraction.
#
#  mom_kin_reengage_distance -- specifies the re-engage point above
#                               the part.
#
# this procedure is called from MOM_catch_warning and LIB_SPF_check_tool_axis
#
# "ROTARY CROSSING LIMIT." / fourth_axis / (MOM_catch_warning, MOM_before_motion, output , MOM_before_motion)
# "secondary rotary position" / fifth_axis / (MOM_catch_warning, MOM_before_motion, MOM_catch_warning, MOM_catch_warning, output , MOM_before_motion)
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_rotset {angle prev_angle dir kin_leader sys_leader min max {tol_flag 0}} {

  upvar $sys_leader lead

  #
  #  Make sure angle is 0-360 to start with.
  #
  set angle [expr fmod($angle,360)]
  set angle [expr ($angle < 0) ? ($angle + 360) : $angle]

  # if axis has no limits than set the min and max to 0/360 degree
  # 4th axis has always limits
  if {[string match "*5th*" $min] && $::mom_sys_5th_axis_has_limits == 0} {
    set min 0.0
    set max 360.0
  }

  set check_solution 0

  if {![string compare "MAGNITUDE_DETERMINES_DIRECTION" $dir]} {

    #
    #  If magnitude determines direction and total travel is less than or equal
    #  to 360, we can assume there is at most one valid solution.  Find it and
    #  leave.  Check for the total travel being less than 360 and give a warning
    #  if a valid position cannot be found.
    #
    set travel [expr abs($max - $min)]

    if {$travel <= 360.0} {

      set check_solution 1

    } else {

      if {$tol_flag == 0} { ;# Exact comparison
        while {[expr abs([expr $angle - $prev_angle])] > 180.0} {
          if {[expr $angle - $prev_angle] < -180.0} {
            set angle [expr $angle + 360.0]
          } elseif {[expr $angle - $prev_angle] > 180.0} {
            set angle [expr $angle - 360.0]
          }
        }
      } else { ;# Tolerant comparison
        while {[EQ_is_gt [expr abs([expr $angle - $prev_angle])] 180.0]} {
          if {[EQ_is_lt [expr $angle - $prev_angle] -180.0]} {
            set angle [expr $angle + 360.0]
          } elseif {[EQ_is_gt [expr $angle - $prev_angle] 180.0]} {
            set angle [expr $angle - 360.0]
          }
        }
      }
    }

    if {$tol_flag == 1} { ;# Tolerant comparison
      while {[EQ_is_lt $angle $min]} {set angle [expr $angle + 360.0]}
      while {[EQ_is_gt $angle $max]} {set angle [expr $angle - 360.0]}
    } else { ;# Legacy direct comparison
      while {$angle < $min} {set angle [expr $angle + 360.0]}
      while {$angle > $max} {set angle [expr $angle - 360.0]}
    }

  } elseif {![string compare "SIGN_DETERMINES_DIRECTION" $dir]} {

    #
    #  Sign determines direction.  Determine whether the shortest distance is
    #  clockwise or counterclockwise. If counterclockwise append a "-" sign
    #  to the address leader.
    #
    set check_solution 1

    #<09-15-09 wbh> If angle is negative, we add 360 to it instead of getting the absolute value of it.
    if {$angle < 0} {
      set angle [expr $angle + 360]
    }

    set minus_flag 0
    # set angle [expr abs($angle)]  ;# This line was not in ROTSET of xzc post.

    set del [expr $angle - $prev_angle]
    if {$tol_flag == 0} { ;# Exact comparison
      if {($del < 0.0 && $del > -180.0) || $del > 180.0} {
        # set lead "$kin_leader-"
        set minus_flag 1
      } else {
        set lead $kin_leader
      }
    } else { ;# Tolerant comparison
      if {([EQ_is_lt $del 0.0] && [EQ_is_gt $del -180.0]) || [EQ_is_gt $del 180.0]} {
        # set lead "$kin_leader-"
        set minus_flag 1
      } else {
        set lead $kin_leader
      }
    }

    #Check the rotary axis is 4th axis or 5th axis
    global mom_kin_4th_axis_leader mom_kin_5th_axis_leader
    global mom_rotary_direction_4th mom_rotary_direction_5th
    global mom_prev_rotary_dir_4th mom_prev_rotary_dir_5th

    set is_4th 1
    if {[info exists mom_kin_5th_axis_leader] && [string match "$mom_kin_5th_axis_leader" "$kin_leader"]} {
      set is_4th 0
    }

    #
    if {$minus_flag && [EQ_is_gt $angle 0.0]} {
      set lead "$kin_leader-"

      #<04-27-11 wbh> Since the leader should add a minus, the rotary direction need be reset
      if {$is_4th} {
        set mom_rotary_direction_4th -1
      } else {
        set mom_rotary_direction_5th -1
      }
    }

    # If the delta angle is 0 or 180, there has no need to change the rotary direction,
    #               we should reset the current direction with the previous direction
    if {[EQ_is_zero $del] || [EQ_is_equal $del 180.0] || [EQ_is_equal $del -180.0]} {
      if {$is_4th} {
        if {[info exists mom_prev_rotary_dir_4th]} {
          set mom_rotary_direction_4th $mom_prev_rotary_dir_4th
        }
      } else {
        if {[info exists mom_prev_rotary_dir_5th]} {
          set mom_rotary_direction_5th $mom_prev_rotary_dir_5th
        }
      }
    } else {
      # Set the previous direction
      if {$is_4th} {
        set mom_prev_rotary_dir_4th $mom_rotary_direction_4th
      } else {
        set mom_prev_rotary_dir_5th $mom_rotary_direction_5th
      }
    }
  }

  #
  #  There are no alternate solutions.
  #  If the position is out of limits, give a warning and leave.
  #
  if {$check_solution} {
    if {$tol_flag == 1} {
      if {[EQ_is_gt $angle $max] || [EQ_is_lt $angle $min]} {
        LIB_SPF_add_warning "$kin_leader-axis is under minimum or over maximum. Assumed default."
      }
    } else {
      if {($angle > $max) || ($angle < $min)} {
        LIB_SPF_add_warning "$kin_leader-axis is under minimum or over maximum. Assumed default."
      }
    }
  }

  return $angle
}
# <Internal Documentation>
#  This command will take an input angle and format for a specific machine.
#  It will also validate that the angle is within the specified limits of
#  machine.
#
#  angle        angle to be output.
#  prev_angle   previous angle output.  It should be mom_out_angle_pos
#  dir          can be either MAGNITUDE_DETERMINES_DIRECTION or
#               SIGN_DETERMINES_DIRECTION
#  kin_leader   leader (usually A, B or C) defined by Post Configurator
#  sys_leader   leader that is created by ROTSET.  It could be "C-".
#  min          minimum degrees of travel for current axis
#  max          maximum degrees of travel for current axis
#
#  tol_flag     performance comparison with tolerance
#                 0 : No (default)
#                 1 : Yes
#
# <Internal Example>
#   set mom_out_angle_pos(0)  [LIB_SPF_rotset $mom_pos(3) $mom_prev_rot_ang_4th $mom_kin_4th_axis_direction\
#                                     $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis)\
#                                     $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]
#
#
#____________________________________________________________________________________________
proc MOM_origin {} {

  global mom_X
  global mom_Y
  global mom_Z
  global mom_origin_text

}
# <Internal Documentation>
#
# This procedure is executed when the Origin command is activated.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_retract_to_pos {} {

  global mom_cycle_retract_mode mom_cycle_retract_to_pos mom_cycle_retract_to
  global mom_pos lib_last_rapid_pos
  global tool_axis mom_namespace_name mom_output_pos_type

  if {$mom_cycle_retract_mode == "AUTO"} {
    # <NX1201 cam16012> new prereatment local csys
    if {[hiset lib_last_rapid_pos($tool_axis)]} {
      if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
        namespace eval $::mom_namespace_name {
          if {[info exists mom_output_pos_type] && $mom_output_pos_type == "mom_mcs_goto"} {
      set mom_cycle_retract_to_pos($tool_axis) $lib_last_rapid_pos($tool_axis)
            set mom_cycle_retract_to [expr $lib_last_rapid_pos($tool_axis) - $mom_mcs_goto($tool_axis)]
          } else {
            set mom_cycle_retract_to_pos($tool_axis) $lib_last_rapid_pos($tool_axis)
      set mom_cycle_retract_to [expr $lib_last_rapid_pos($tool_axis) - $mom_pos($tool_axis)]
          }
        }
      } else {
        set mom_cycle_retract_to_pos($tool_axis) $lib_last_rapid_pos($tool_axis)
        set mom_cycle_retract_to [expr $lib_last_rapid_pos($tool_axis) - $mom_pos($tool_axis)]
      }
    }
  }
}
# <Internal Documentation>
#
# Check & setup the retract to pos parameters
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_cycle_plane_change {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  MOM_cycle_plane_change_LIB

}
# <Internal Documentation>
#
# This procedure is executed at the end of cycle motion when there is a cycle
# move occuring at a different level than the previous position
# or if tool axis change during cycle.
# set mom_kin_cycle_plane_change_per_axis       "1"
# set mom_kin_cycle_plane_change_to_lower       "1"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_cycle_plane_change_LIB {} {
  if {$::lib_flag(local_namespace_output)} {
    LIB_SPF_recalculate_cycle_pos
  }

  set commandcheck(MOM_cycle_plane_change_LIB_ENTRY) [llength [info commands MOM_cycle_plane_change_LIB_ENTRY]]
  set commandcheck(LIB_main_origin_call) [llength [info commands LIB_main_origin_call]]

  LIB_GE_command_buffer MOM_cycle_plane_change_LIB_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_plane_change_LIB_ENTRY)} {MOM_cycle_plane_change_LIB_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  global mom_cycle_retract_to_pos mom_cycle_rapid_to_pos mom_pos mom_out_angle_pos
  global mom_prev_tool_axis mom_tool_axis mom_cycle_clearance_plane_change
  global tool_axis lib_template lib_prev_cycle_retract_to_pos lib_prev_cycle_rapid_to_pos lib_flag
  global mom_prev_pos lib_last_rapid_pos mom_cycle_retract_mode mom_namespace_name


  LIB_GE_command_buffer CHECK_CLEARANCE_PLANE_CHANGE
  LIB_GE_command_buffer {
    if {![info exist mom_cycle_clearance_plane_change]} {
      if {[EQ_is_gt $mom_prev_pos($tool_axis) $mom_pos($tool_axis)]} {
        set mom_cycle_clearance_plane_change -1
      } elseif {[EQ_is_lt $mom_prev_pos($tool_axis) $mom_pos($tool_axis)]} {
        set mom_cycle_clearance_plane_change 1
      } else {
        set mom_cycle_clearance_plane_change 0
      }
    }
  } @CLEARANCE_PLANE_CHANGE
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer SECOND_CHECK_CLEARANCE_PLANE_CHANGE
  LIB_GE_command_buffer {
    # 13.11.14 UR Most likely a bug in MOM
    # Now it is checked whether the tool axis and the safety distance changes, if not also the level not changed.
    if {[LIB_SPF_get_pretreatment axis_mode] == "CONSTANT" && $mom_cycle_clearance_plane_change} {
      if {[EQ_is_equal $mom_prev_tool_axis($tool_axis) $mom_tool_axis($tool_axis)] && \
        [info exists lib_prev_cycle_rapid_to_pos($tool_axis)] && \
        [EQ_is_equal $lib_prev_cycle_rapid_to_pos($tool_axis) $mom_cycle_rapid_to_pos($tool_axis) [expr 0.5*pow(10,-1*[CONF_SPF_cycle max_decimal_place])]]} {
        set mom_cycle_clearance_plane_change 0
        set lib_prev_cycle_rapid_to_pos($tool_axis) $mom_cycle_rapid_to_pos($tool_axis)
        return
      }
    }
  } @SECOND_CLEARANCE_PLANE_CHANGE
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer RETRACT_TO_POS
  LIB_GE_command_buffer {
    LIB_SPF_retract_to_pos
  } @RETRACT
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer SPINDLE
  LIB_GE_command_buffer {
    LIB_SPINDLE_start
  } @START
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer CHECK_CYCLE_RETRACT
  LIB_GE_command_buffer {
    if {![info exists lib_prev_cycle_retract_to_pos]} {return -code return}
  } @CYCLE_RETRACT
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer CHECK_TOOL_AXIS
  LIB_GE_command_buffer {
    if {![VEC3_is_equal mom_prev_tool_axis mom_tool_axis]} {
      if {$lib_flag(abs_move_for_orthogonal) == 1} {return -code return}
      set lib_flag(output_cycle_call) 1
      MOM_cycle_off_LIB
      return
    }
  } @TOOL_AXIS
  LIB_GE_command_buffer_output

  # 15.07.14 HES Output Cycle definition again when mom_pos(spindle_axis) has changed
  set lib_flag(output_cycle_call) 1

  LIB_GE_command_buffer CHECK_CYCLE_RETRACT_MODE
  LIB_GE_command_buffer {
    # 23.10.17 ZHX In "Auto" mode, previous retract to position should be changed to the last rapid position
    # 08.09.2018 GB That isn't true for all ctrl
    if { [info exists mom_cycle_retract_mode] && [string match -nocase "Auto" $mom_cycle_retract_mode] } {
      switch -- $tool_axis {
        0 {if {[EQ_is_equal [MOM_ask_address_value X] $mom_cycle_rapid_to_pos($tool_axis)]} {return -code return}}
        1 {if {[EQ_is_equal [MOM_ask_address_value Y] $mom_cycle_rapid_to_pos($tool_axis)]} {return -code return}}
        2 {if {[EQ_is_equal [MOM_ask_address_value Z] $mom_cycle_rapid_to_pos($tool_axis)]} {return -code return}}
      }
    }
  } @CYCLE_RETRACT_MODE
  LIB_GE_command_buffer_output

  LIB_GE_command_buffer CHECK_DECOMPOSE_RETRACT_MODE
  LIB_GE_command_buffer {
    # 22.12.15 UR (Bug #868) We have also to check is the mom_pos value less then the cycle value
    # Is this the case we don't have to output this value, otherwise the machine tool can be generate an crash.
    # <NX1201 cam16012> new prereatment local csys
    if {[info exists mom_namespace_name] && $mom_namespace_name == "::LOCAL_CSYS"} {
      namespace eval $::mom_namespace_name {
        if {![EQ_is_gt $lib_prev_cycle_retract_to_pos($tool_axis) $mom_cycle_rapid_to_pos($tool_axis) 0.001] || \
        ![EQ_is_gt $lib_prev_cycle_retract_to_pos($tool_axis) $mom_pos($tool_axis) 0.001]} {
          MOM_cycle_off_LIB
          set tmp_pos $mom_mcs_goto($tool_axis)
          set mom_mcs_goto($tool_axis) $mom_cycle_rapid_to_pos($tool_axis)
          switch -- $tool_axis {
            0 {LIB_SPF_decompose_block_template "X" [CONF_CTRL_moves rapid_template] FORCE "Y Z"}
            1 {LIB_SPF_decompose_block_template "Y" [CONF_CTRL_moves rapid_template] FORCE "X Z"}
            2 {LIB_SPF_decompose_block_template "Z" [CONF_CTRL_moves rapid_template] FORCE "X Y"}
          }
          set mom_mcs_goto($tool_axis) $tmp_pos
        }
      }
    } else {
      if {![EQ_is_gt $lib_prev_cycle_retract_to_pos($tool_axis) $mom_cycle_rapid_to_pos($tool_axis) 0.001] || \
      ![EQ_is_gt $lib_prev_cycle_retract_to_pos($tool_axis) $mom_pos($tool_axis) 0.001]} {
        MOM_cycle_off_LIB
        set tmp_pos $mom_pos($tool_axis)
        set mom_pos($tool_axis) $mom_cycle_rapid_to_pos($tool_axis)
        switch -- $tool_axis {
          0 {LIB_SPF_decompose_block_template "X" [CONF_CTRL_moves rapid_template] FORCE "Y Z"}

          1 {LIB_SPF_decompose_block_template "Y" [CONF_CTRL_moves rapid_template] FORCE "X Z"}

          2 {LIB_SPF_decompose_block_template "Z" [CONF_CTRL_moves rapid_template] FORCE "X Y"}
        }
        set mom_pos($tool_axis) $tmp_pos
      }
    }
  } @DECOMPOSE_RETRACT_MODE
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_cycle_plane_change_LIB_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_cycle_plane_change_LIB_ENTRY)} {MOM_cycle_plane_change_LIB_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure it's called from MOM_cycle_plane_change
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_csys_3D_rotation {{lib_3d_rot_order ""} {lib_3d_rot_mode ""} {lib_3d_rot_address ""}} {

  global mom_kin_machine_type mom_tool_axis_type
  global mom_pos mom_out_angle_pos mom_init_pos
  global mom_kin_4th_axis_point mom_kin_5th_axis_point
  global mom_kin_4th_axis_vector mom_kin_5th_axis_vector
  global mom_kin_4th_axis_zero mom_kin_5th_axis_zero
  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global lib_coord_main_X lib_coord_main_Y lib_coord_main_Z
  global mom_csys_matrix rotation_matrix mom_msys_matrix
  global RAD2DEG DEG2RAD
  global lib_flag lib_parameter mres m_tmp
  global mom_sys_leader lib_mcs_output_type
  global tmp_csys_matrix mom_msys_origin
  global mom_sys_control_out mom_sys_control_in
  global mom_sorigin mom_origin
  global mom_kin_iks_usage
  global oper_mcs_matrix

  #Checking
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [LIB_SPF_csys_examine_local] == "rotation"} {
    #<lili> should not abort
    LIB_GE_abort_message "5-Axis simultanous operation with Local CSYS orientation other than Main CSYS not allowed - CSYS-Name: $::mom_oper_geom"
  }

  if {[info exist lib_mcs_output_type] && $lib_mcs_output_type == 3} {
    if {[LIB_SPF_get_pretreatment axis_mode] == "CONSTANT" && [EQ_is_equal [LIB_SPF_get_pretreatment mom_tool_axis,2] 1.0]} {
      set mom_out_angle_pos(0) 0
      set mom_out_angle_pos(1) 0
    } elseif {[llength [info commands MOM_convert_point]]} {
      if {[CONF_Tombstone tombstone_allowed] == 0} {
        #??what if tombstone is not allowed?
        LIB_GE_abort_message "Local CSYS with special output CSYS Rotation is not allowed, toolaxis must be +ZM - Operation: $::mom_path_name"
      }
    }
  }

  if {$lib_3d_rot_order == ""} {set lib_3d_rot_order [CONF_SPF_csys_3d_rot rot_order]}
  if {$lib_3d_rot_mode == ""} {set lib_3d_rot_mode [CONF_SPF_csys_3d_rot rot_mode]}
  if {$lib_3d_rot_address == ""} {set lib_3d_rot_address [CONF_SPF_csys_3d_rot rot_address]}

  if {[CONF_SPF_csys_3d_rot adv_plane_calc] == 1 && ([CONF_SPF_csys_3d_rot rot_real_axis] == 1 || [LIB_GE_string_toupper $lib_3d_rot_mode] == "AXIAL") && [LIB_SPF_csys_examine_local] == "rotation"} {
    # in the calculation of the rotation angle there are A,B,C Angles but the machine have only 2 axis so i abort the calculation
    LIB_GE_abort_message "Local CSYS with special output CSYS Rotation is not allowed with rotation about real axis (AXIAL) - Operation: $::mom_path_name"
  }

  if {[info exists oper_mcs_matrix(0)]} {
    LIB_GE_copy_var_range tmp_csys_matrix oper_mcs_matrix
    # lib_coord_ref_xx and lib_coord_main_xx are defined in the LIB_SPF_get_mcs_info
  } else {
    # For legacy

    if {[info exist mom_special_output] && ($mom_special_output == 1)} {
      # If "Use Main"
      LIB_GE_copy_var_range tmp_csys_matrix mom_msys_matrix
      set tmp_csys_matrix(9) 0.0
      set tmp_csys_matrix(10) 0.0
      set tmp_csys_matrix(11) 0.0
    } else {
      LIB_GE_copy_var_range tmp_csys_matrix mom_csys_matrix
    }
    set lib_coord_ref_X $tmp_csys_matrix(9)
    set lib_coord_ref_Y $tmp_csys_matrix(10)
    set lib_coord_ref_Z $tmp_csys_matrix(11)
    set lib_coord_main_X 0.0
    set lib_coord_main_Y 0.0
    set lib_coord_main_Z 0.0
  }

  # Reset lib_coord_ref_X for smart origin
  if {[LIB_SPF_csys_examine_local] == "default" && [info exist mom_sorigin(0)]} {
    # calc offset
    LIB_GE_copy_var_range mom_origin mom_sorigin
    MOM_reload_variable -a mom_origin
    set lib_coord_ref_X $mom_sorigin(0)
    set lib_coord_ref_Y $mom_sorigin(1)
    set lib_coord_ref_Z $mom_sorigin(2)

  } elseif {[info exist mom_sorigin(0)]} {
    if {![EQ_is_zero $mom_sorigin(0)] || ![EQ_is_zero $mom_sorigin(1)] || ![EQ_is_zero $mom_sorigin(2)]} {
      LIB_GE_abort_message "Local CSYS and Smart Origin cannot be combined - CSYS-Name: $::mom_oper_geom"
    }
  } else {
    # do nothing
    if {[CONF_SPF_csys_3d_rot adv_plane_calc] == 0 && [LIB_SPF_csys_examine_local] == "rotation" && [CONF_SPF_csys_3d_rot rot_real_axis] == 1} {
      LIB_GE_abort_message "Advanced Plane Calculation not active and Local MCS orientation not equal to Main MCS orientation - CSYS-Name: $::mom_oper_geom"
    }
  }

  if {([CONF_SPF_csys_3d_rot rot_real_axis] == 1 || [LIB_GE_string_toupper $lib_3d_rot_mode] == "AXIAL") && [LIB_SPF_csys_examine_local] == "rotation"} {
    # in the calculation of the rotation angle there are A,B,C Angles but the machine have only 2 axis so i abort the calculation
    LIB_GE_abort_message "Local CSYS with special output CSYS Rotation is not allowed with rotation about real axis (AXIAL) - Operation: $::mom_path_name"
  }

  foreach n {4 5} {
    VEC3_unitize ::mom_kin_${n}th_axis_vector _${n}th_vector
    set ${n}th_axis_orthogonal "FALSE"
    for {set i 0} {$i<3} {incr i} {
      if {[EQ_is_equal [expr abs([set _${n}th_vector($i)])] 1.0]} {
        set ${n}th_axis_orthogonal "TRUE"
        break
      }
    }
  }


  if {[CONF_SPF_csys_3d_rot adv_plane_calc] == 1 && [CONF_SPF_csys_3d_rot rot_real_axis] != 1 && ([LIB_SPF_csys_examine_local] == "rotation" || [LIB_GE_string_toupper $lib_3d_rot_mode] == "EULER" || \
  $4th_axis_orthogonal == "FALSE" || $5th_axis_orthogonal == "FALSE")} {

    # Get initial/first point by rotation
    if {[string match "5_axis_dual_head" $mom_kin_machine_type] && (![info exists mom_kin_iks_usage] || $mom_kin_iks_usage != 1)} {
      set rot0 [expr ($mom_pos(4)-$mom_kin_5th_axis_zero)*$DEG2RAD]
      set rot1 [expr ($mom_pos(3)-$mom_kin_4th_axis_zero)*$DEG2RAD]
    } else {
      set rot0 [expr ($mom_pos(3)-$mom_kin_4th_axis_zero)*$DEG2RAD]
      set rot1 [expr ($mom_pos(4)-$mom_kin_5th_axis_zero)*$DEG2RAD]
    }

    # Initialize coordinate rotation angles
    set lib_coord_ang_A 0.0 ; set lib_coord_ang_B 0.0 ; set lib_coord_ang_C 0.0
    set lib_coord_ang_1 0.0 ; set lib_coord_ang_2 0.0 ; set lib_coord_ang_3 0.0
    set X(0) 1.0; set X(1) 0.0; set X(2) 0.0
    set Y(0) 0.0; set Y(1) 1.0; set Y(2) 0.0
    set Z(0) 0.0; set Z(1) 0.0; set Z(2) 1.0

    # Calculate rotation matrix
    VEC3_rotate_arbitary_axis mom_kin_4th_axis_vector [expr 1*$rot0] X v1
    VEC3_rotate_arbitary_axis mom_kin_4th_axis_vector [expr 1*$rot0] Y v2
    VEC3_rotate_arbitary_axis mom_kin_4th_axis_vector [expr 1*$rot0] Z v3

    VEC3_rotate_arbitary_axis mom_kin_5th_axis_vector [expr 1*$rot1] v1 X
    VEC3_rotate_arbitary_axis mom_kin_5th_axis_vector [expr 1*$rot1] v2 Y
    VEC3_rotate_arbitary_axis mom_kin_5th_axis_vector [expr 1*$rot1] v3 Z

    if {![MTX3_init_x_y_z X Y Z rotation_matrix]} {
      LIB_GE_abort_message "Can't initialize Matrix in Operation 'INS->$::mom_path_name<-'" " Check tolerance and 4(5)th axis angles"
    }

    if {[LIB_GE_string_toupper $lib_3d_rot_mode] == "SPATIAL"} {
      set lib_3d_rot_order [string trim [LIB_GE_string_toupper $lib_3d_rot_order]]
      switch -regexp -- $lib_3d_rot_order {
          ^-  {regsub "^-" $lib_3d_rot_order "+" lib_3d_rot_order}
          ^\\+  {regsub "^\\+" $lib_3d_rot_order "-" lib_3d_rot_order}
        ^[^-+]  {set lib_3d_rot_order "-$lib_3d_rot_order"}
      }
      MTX3_multiply tmp_csys_matrix rotation_matrix mres
      MTX3_transpose mres m_tmp
    } elseif {[LIB_GE_string_toupper $lib_3d_rot_mode] == "EULER"} {
      MTX3_multiply tmp_csys_matrix rotation_matrix m_tmp
    }

    for { set i 0 } { $i < 9 } { incr i } {
      # 14.07.2014 Hes Fix if Value is greater than 1 or less than -1
      # for ex $m_tmp(2) == 1.0000000000002
      if {$m_tmp($i) > 1.0} {set m_tmp($i) 1.0}
      if {$m_tmp($i) < -1.0} {set m_tmp($i) -1.0}
      set rotation_matrix($i) $m_tmp($i)
    }

    LIB_SPF_calculate_coord_rot_angle $lib_3d_rot_order $lib_3d_rot_address

  } else {
    # For heiheain AXIAL mode or legacy adv_plane_calc=0
    # Get 4th_axis and 5th_axis leader
    # the axis so we can use this proc as a general proc
    array set x_vec "0 1 1 0 2 0"
    array set y_vec "0 0 1 1 2 0"
    array set z_vec "0 0 1 0 2 1"
    set 4th_axis $mom_sys_leader(fourth_axis)
    set 5th_axis $mom_sys_leader(fifth_axis)

    if {[CONF_SPF_csys_3d_rot rot_real_axis] == 1} {

      set 4th_axis $::mom_sys_leader(fourth_axis)
      set 5th_axis $::mom_sys_leader(fifth_axis)

    } else {
      if {[VEC3_is_parallel mom_kin_4th_axis_vector x_vec]} {
        set 4th_axis A
      } elseif {[VEC3_is_parallel mom_kin_4th_axis_vector y_vec]} {
        set 4th_axis B
      } elseif {[VEC3_is_parallel mom_kin_4th_axis_vector z_vec]} {
        set 4th_axis C
      }
      if {[VEC3_is_parallel mom_kin_5th_axis_vector x_vec]} {
        set 5th_axis A
      } elseif {[VEC3_is_parallel mom_kin_5th_axis_vector y_vec]} {
        set 5th_axis B
      } elseif {[VEC3_is_parallel mom_kin_5th_axis_vector z_vec]} {
        set 5th_axis C
      }
    }

    # Take the values from mom_out_angle_pos because here we have no CSYS_Rotation
    set lib_coord_ang_A 0.0
    set lib_coord_ang_B 0.0
    set lib_coord_ang_C 0.0

    set [subst [subst lib_coord_ang_$4th_axis]] [expr $mom_out_angle_pos(0)]
    set [subst [subst lib_coord_ang_$5th_axis]] [expr $mom_out_angle_pos(1)]

    set tmp_rot_order [string trim [LIB_GE_string_toupper $lib_3d_rot_order]]
    set tmp_rot_order [string trim $tmp_rot_order "+"]
    set tmp_rot_order [string trim $tmp_rot_order "-"]

    for {set ii 0} {$ii < 3} {incr ii} {
      if {[string range $tmp_rot_order $ii $ii] == "X"} {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_A
      } elseif {[string range $tmp_rot_order $ii $ii] == "Y"} {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_B
      } else {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_C
      }
    }
  }
}
# <Internal Documentation>
# This command is used to get the rotation angles from a matrix translation.
# First it calculate a matrix from the tool-axis vector.
# then it checks if a local_csys exists and if it has different direction as the
# main_csys. Then combine the two matrix and calculate the rotation angles
# if there is no Coordinate Rotation (CSYS Rotation) then the mom_out_angle_pos are
# used instead of Tool_axis_vector
#
# Input:  lib_3d_rot_order of the rotation and direction (left handed (-) or right handed (+))
#         (+/-)XYZ (+/-)XZY (+/-)YZX (+/-)YXZ (+/-)ZXY (+/-)ZYX
#         (+/-)XYX (+/-)XZX (+/-)YZY (+/-)YXY (+/-)ZXZ (+/-)ZYZ
#
#         lib_3d_rot_mode = spatial  rotation is about fixed machine axis
#                     = euler    rotation is about the resulting axis
#                     = axial    rotation is about the rotation axis
#
#         lib_3d_rot_address  = first  rotation is about first axis in the lib_3d_rot_order (if possible)
#                             = last   rotation is about last  axis in the lib_3d_rot_order (if possible)
#
# Return values:
#         lib_coord_ang_A  rotation about X
#         lib_coord_ang_B  rotation about Y
#         lib_coord_ang_C  rotation about Z
#         lib_coord_ang_1  rotation about first axis in lib_3d_rot_order
#         lib_coord_ang_2  rotation about second axis in lib_3d_rot_order
#         lib_coord_ang_3  rotation about third axis in lib_3d_rot_order
#         lib_coord_ref_X  translation in X from Fixture to Local
#         lib_coord_ref_Y  translation in Y from Fixture to Local
#         lib_coord_ref_Z  translation in Z from Fixture to Local
#         lib_coord_main_X  translation in X from Main to Fixture
#         lib_coord_main_Y  translation in Y from Main to Fixture
#         lib_coord_main_Z  translation in Z from Main to Fixture
#
# This command is used to get auto 3D coordinate rotation by tool axis vector.
#
# <Internal Example>
#         LIB_SPF_csys_3D_rotation "+XYX" "spatial"
#         LIB_SPF_csys_3D_rotation "-ZYX" "euler"
#
#____________________________________________________________________________________________
proc LIB_SPF_calc_4th5th_axis_points {} {

  global mom_kin_4th_axis_point mom_kin_5th_axis_point
  global mom_sys_4th_axis_has_limits mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_sys_5th_axis_has_limits mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_kin_pivot_gauge_offset mom_kin_pivot_dist_vec
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global lib_coord_main_X lib_coord_main_Y lib_coord_main_Z
  global mom_kin_machine_type mom_csys_matrix mom_kin_iks_usage
  global mom_kin_spindle_axis mom_tool_extension_length mom_tool_holder_overall_length
  global mom_isv_tool_x_correction mom_isv_tool_y_correction mom_isv_tool_z_correction
  global mom_isv_tool_count mom_isv_tracking_point_count mom_tool_tracking_point
  global mom_isv_tool_name mom_tool_name mom_operation_is_interop

  set tmp_tool_overall_length 0

  set custom_classification NONE
  if {[info exists mom_operation_is_interop] && $mom_operation_is_interop == 1} {
    # <17013.16 Interop path> For subop with automatic option, the default NC code output in tcpm mode
  } else {
    if {![string compare "5_axis_dual_head" $mom_kin_machine_type] || ![string compare "5_axis_head_table" $mom_kin_machine_type]} {
      if {$mom_kin_pivot_gauge_offset == 0} {set mom_kin_pivot_gauge_offset 0.001}

      if {[CONF_CTRL_setting absolute_ref_point] == "TOOL_TIP"} {
        for {set i 0} {$i<$mom_isv_tool_count} {incr i} {
          if {$mom_isv_tool_name($i) == $mom_tool_name} {
            if {$mom_isv_tracking_point_count($i)==0} {set mom_isv_tracking_point_count($i) 1}
            if {![info exist mom_tool_tracking_point]} {set mom_tool_tracking_point 0}
            for {set j 0} {$j<$mom_isv_tracking_point_count($i)} {incr j} {
              if {![info exists mom_isv_tracking_point_count($i,$j)]} {set mom_isv_tracking_point_count($i,$j) 0}
              if {$mom_isv_tracking_point_count($i,$j) == $mom_tool_tracking_point} {
                if {[info exists mom_isv_tool_z_correction($i,$j)]} {
                  set tmp_tool_overall_length $mom_isv_tool_x_correction($i,$j)
                }
              }
            }
          }
        }
      }
    }
  }

  if {[info exists mom_kin_iks_usage] && $mom_kin_iks_usage == 1} {
    if [info exists mom_csys_matrix] {
      if {![LIB_SPF_check_multiple_channels] && [llength [info commands MOM_validate_machine_model]] && ![string compare "TRUE" [MOM_validate_machine_model]]} {
        if {$mom_sys_4th_axis_has_limits == 1} {
          set sav_kin_4th_axis_min_limit $mom_kin_4th_axis_min_limit
          set sav_kin_4th_axis_max_limit $mom_kin_4th_axis_max_limit
        }
        if {$mom_sys_5th_axis_has_limits == 1} {
          set sav_kin_5th_axis_min_limit $mom_kin_5th_axis_min_limit
          set sav_kin_5th_axis_max_limit $mom_kin_5th_axis_max_limit
        }
        MOM_reload_iks_parameters "$custom_classification"
        if {[hiset sav_kin_4th_axis_max_limit]} {
          set mom_kin_4th_axis_min_limit $sav_kin_4th_axis_min_limit
          set mom_kin_4th_axis_max_limit $sav_kin_4th_axis_max_limit
        }
        if {[hiset sav_kin_5th_axis_max_limit]} {
          set mom_kin_5th_axis_min_limit $sav_kin_5th_axis_min_limit
          set mom_kin_5th_axis_max_limit $sav_kin_5th_axis_max_limit
        }
        if {![string compare "5_axis_dual_table" $mom_kin_machine_type]} {
          #
        } elseif {![string compare "5_axis_head_table" $mom_kin_machine_type]} {
          set mom_kin_4th_axis_point(0) [expr $mom_kin_4th_axis_point(0) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(0))]
          set mom_kin_4th_axis_point(1) [expr $mom_kin_4th_axis_point(1) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(1))]
          set mom_kin_4th_axis_point(2) [expr $mom_kin_4th_axis_point(2) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(2))]
        } elseif {![string compare "5_axis_dual_head" $mom_kin_machine_type]} {
          set mom_kin_4th_axis_point(0) [expr $mom_kin_4th_axis_point(0) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(0))]
          set mom_kin_4th_axis_point(1) [expr $mom_kin_4th_axis_point(1) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(1))]
          set mom_kin_4th_axis_point(2) [expr $mom_kin_4th_axis_point(2) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(2))]
          set mom_kin_5th_axis_point(0) [expr $mom_kin_5th_axis_point(0) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(0))]
          set mom_kin_5th_axis_point(1) [expr $mom_kin_5th_axis_point(1) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(1))]
          set mom_kin_5th_axis_point(2) [expr $mom_kin_5th_axis_point(2) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(2))]
        }

      } else {
        if {![string compare "5_axis_dual_table" $mom_kin_machine_type]} {
          set mom_kin_4th_axis_point(0) [expr [LIB_PT_get_header_var mom_kin_4th_axis_point(0)] - $lib_coord_main_X - $lib_coord_ref_X]
          set mom_kin_4th_axis_point(1) [expr [LIB_PT_get_header_var mom_kin_4th_axis_point(1)] - $lib_coord_main_Y - $lib_coord_ref_Y]
          set mom_kin_4th_axis_point(2) [expr [LIB_PT_get_header_var mom_kin_4th_axis_point(2)] - $lib_coord_main_Z - $lib_coord_ref_Z]
          set mom_kin_5th_axis_point(0) [expr [LIB_PT_get_header_var mom_kin_5th_axis_point(0)] - $lib_coord_main_X - $lib_coord_ref_X]
          set mom_kin_5th_axis_point(1) [expr [LIB_PT_get_header_var mom_kin_5th_axis_point(1)] - $lib_coord_main_Y - $lib_coord_ref_Y]
          set mom_kin_5th_axis_point(2) [expr [LIB_PT_get_header_var mom_kin_5th_axis_point(2)] - $lib_coord_main_Z - $lib_coord_ref_Z]
        } elseif {![string compare "5_axis_head_table" $mom_kin_machine_type]} {
          set mom_kin_4th_axis_point(0) [expr $mom_kin_4th_axis_point(0) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(0))]
          set mom_kin_4th_axis_point(1) [expr $mom_kin_4th_axis_point(1) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(1))]
          set mom_kin_4th_axis_point(2) [expr $mom_kin_4th_axis_point(2) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(2))]
          set mom_kin_5th_axis_point(0) [expr [LIB_PT_get_header_var mom_kin_5th_axis_point(0)] - $lib_coord_main_X - $lib_coord_ref_X]
          set mom_kin_5th_axis_point(1) [expr [LIB_PT_get_header_var mom_kin_5th_axis_point(1)] - $lib_coord_main_Y - $lib_coord_ref_Y]
          set mom_kin_5th_axis_point(2) [expr [LIB_PT_get_header_var mom_kin_5th_axis_point(2)] - $lib_coord_main_Z - $lib_coord_ref_Z]

        } elseif {![string compare "5_axis_dual_head" $mom_kin_machine_type]} {
          set mom_kin_4th_axis_point(0) [expr $mom_kin_4th_axis_point(0) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(0))]
          set mom_kin_4th_axis_point(1) [expr $mom_kin_4th_axis_point(1) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(1))]
          set mom_kin_4th_axis_point(2) [expr $mom_kin_4th_axis_point(2) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(2))]
          set mom_kin_5th_axis_point(0) [expr $mom_kin_5th_axis_point(0) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(0))]
          set mom_kin_5th_axis_point(1) [expr $mom_kin_5th_axis_point(1) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(1))]
          set mom_kin_5th_axis_point(2) [expr $mom_kin_5th_axis_point(2) + ($tmp_tool_overall_length * $mom_kin_spindle_axis(2))]
        }
      }
      MOM_reload_kinematics
    }
  }
}
# <Internal Documentation>
#
# To define the mom_kin_xth_axis_points for this operation
# The mom_kin_xth_axis_points should be defined from Machine Zero to center of axis
# If the kinematic is calculated in the controller than this values should be set to zero
# This is the case if you use PLANE,CYCL800,G68.5 etc.
# Should be executed in MOM_set_csys and MOM_start_of_path because plane and simultanous kin
# reset the xth_points to zero
#
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_ask_mcs_info {} {

  global lib_parameter lib_flag lib_spf lib_mcs_info
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global lib_coord_main_X lib_coord_main_Y lib_coord_main_Z
  global mom_operation_name_list
  global mom_mcsname_attach_opr
  global mom_mcs_info
  global mom_kin_output_unit
  global mom_part_unit
  global mom_sim_result mom_sim_result1

  # Convert mom_mcs_info if the rigth unit as outputed
  if {![string match $::mom_output_unit $::mom_part_unit] && !$lib_flag(mcs_info,is_converted)} {
    LIB_SPF_convert_unit INIT ",part"
    set lib_flag(mcs_info,is_converted) 1
  }

  # Get Mcs tree for current operation, oper_mcs_list doesn't include Main MCS
  set lib_mcs_info(mcs_list) [list]

  foreach path_name $mom_operation_name_list {
    set oper_mcs_list [list]

    # NX1980 : Set operation mcs to output MCS if inherit MCS is used, mom_output_mcs_name is new variable
    if {![info exists ::mom_output_mcs_name($path_name)]} {
      set ::mom_output_mcs_name($path_name) $mom_mcsname_attach_opr($path_name)
    }
    set mcs $::mom_output_mcs_name($path_name)

    if {$mcs != "" && [lsearch -exact $lib_mcs_info(mcs_list) $mcs] < 0} {
      lappend lib_mcs_info(mcs_list) $mcs
    } else {
        continue
    }

    if {![info exists mom_mcs_info($mcs,parent)]} {
      continue
    }

    # Get oper_mcs_list, oper_mcs_list includes all output MCS in the tree
    lappend oper_mcs_list $mcs
    # Workaround. There was a case where  mom_mcs_info($mcs,purpose) does not exist
    # For that case we take the purpose from parent object.
    # (old part (NX7.5) opened with NX8.5, 2 main MCS in sequence. If purpose is changed to local and back to main in second main MCS, everthing is ok)

    if {$mcs != "" && ![info exists mom_mcs_info($mcs,purpose)]} {
      if {![info exists mom_mcs_info($mom_mcs_info($mcs,parent),purpose)]} {
        set mom_mcs_info($mcs,purpose) 0
      } else {
        set mom_mcs_info($mcs,purpose) $mom_mcs_info($mom_mcs_info($mcs,parent),purpose)
      }
    }

    set oper_mcs $mcs
    while {$oper_mcs != "" && $mom_mcs_info($oper_mcs,parent) != "" && $mom_mcs_info($oper_mcs,purpose)==0 && $mom_mcs_info($mom_mcs_info($oper_mcs,parent),purpose)!=1} {
      set oper_mcs $mom_mcs_info($oper_mcs,parent)
      lappend oper_mcs_list $oper_mcs
    }

    set lib_mcs_info($mcs,oper_mcs_list) $oper_mcs_list

    # Get main MCS
    # Insert when no machine is loaded and the MCS structure is not Siemens conform. (No MAIN MCS or only one Coordinate system)
    # PR#9407287: If operation doesn't attach to a MCS, check MCS existence firstly
    if {$lib_flag(machine_loaded) == 0 && $mcs != "" && ($mom_mcs_info($mcs,parent) == "" || $mom_mcs_info($mcs,purpose) == 1) || ![info exists mom_mcs_info([lindex $oper_mcs_list end],parent)]} {
      set main_mcs [lindex $oper_mcs_list end]
    } else {
      set main_mcs $mom_mcs_info([lindex $oper_mcs_list end],parent)
    }
    set lib_mcs_info($mcs,main_mcs) $main_mcs

    # Get fixture MCS
    # Ask mom_fixture_offset_value from the top_level LOCAL_CSYS
    # and check the values in the mcs tree.
    set fixture_mcs [lindex $oper_mcs_list end]
    # Omit MCS if fixture offset is 0, purpose and special output is Local None in order to match millturn best practice
    if {$mom_mcs_info($fixture_mcs,purpose) == 0 && (![info exists mom_mcs_info($fixture_mcs,output_type)] || $mom_mcs_info($fixture_mcs,output_type) == 0) && $mom_mcs_info($fixture_mcs,offset_val) == 0 && [lindex $oper_mcs_list end-1] != ""} {
      set fixture_mcs [lindex $oper_mcs_list end-1]
    }
    foreach imcs $oper_mcs_list {
            # NX1953 for sim09 sinumerik turnmill part, turing spindle mcs is local none with fixture 0. don't check its offset value consistant
      if {[info exists mom_mcs_info($imcs,offset_val)] && [info exists mom_mcs_info($fixture_mcs,offset_val)] && $mom_mcs_info($imcs,offset_val) !=0} {
        if {$mom_mcs_info($imcs,offset_val) != $mom_mcs_info($fixture_mcs,offset_val) && ![CONF_SPF_warning ignore_fixture_offset_value_warning]} {
        LIB_GE_message "Fixture offset values are not unique for Operation $path_name  -- please fix"
        }
      }
    }
    set lib_mcs_info($mcs,fixture_mcs) $fixture_mcs
  }

}
# <Documentation>
# Examine the current,fixture,main coordinate System of all operations
# This function is called from start of program
#
# <Returnvalue>
#   - lib_mcs_info(mcs_list) includes output MCS name of all operations
#   - lib_mcs_info($mcs_name,oper_mcs_list) include all Local MCS names of output MCS in Geometry tree
#   - lib_mcs_info($mcs_name,fixture_mcs) fixture MCS name of output MCS, which is top level Local MCS.
#         for millturn opeartion, may have a Local NONE and fixture number 0 top level Local MCS, then fixture MCS is its children.
#   - lib_mcs_info($mcs_name,main_mcs)  main MCS name,which is Main MCS or top level local MCS
#
#
#____________________________________________________________________________________________
proc LIB_SPF_call_cycle {cycle {prefix ""} {exclusion ""} {seperator ""} {trailer ""}} {
  global lib_ge_macro_arr lib_flag line

  if {[string match "DEF" [CONF_SPF_cycle regulation]] && [lsearch -exact $lib_ge_macro_arr $cycle] == -1} {
    if {[catch {set output [CONF_CTRL_cycle output]}]} {set output "DIREKT"}
    switch -- $output {
      "LINE"    {
          MOM_disable_address cycle_comment cycle_seperator cycle_description
          }
      "TABLE"   {
          MOM_disable_address cycle_comment cycle_description
          }
    }
    set block $cycle ; regsub -all "," $block "_" block
    set lib_flag(cycle_type) $cycle

    switch -- [LIB_SPF_exists_block_template $block] {
      1 -
      -1  {
          if {[catch {set line [MOM_do_template $block CREATE]} err]} {
            LIB_GE_log_message "Cycle Call for '$block' not available: '$err'"
            LIB_SPF_call_macro $cycle $prefix ; return
          }
          if {[string match "*$*" $line]} {
            set lib_flag(lib_spf_call_cycle,return) 0
            uplevel #0 {
              if {[catch {set line [subst $line]} err]} {
                LIB_GE_log_message "Cycle Call have an error in Block_Template $lib_flag(cycle_type): '$err'"
                LIB_SPF_add_warning "Cycle Call have an error at MOM_do_template $lib_flag(cycle_type): '$err'"
                set lib_flag(lib_spf_call_cycle,return) 1
              }
            }
            if {$lib_flag(lib_spf_call_cycle,return)} {
              LIB_SPF_call_macro $cycle $prefix ; return
            }
          }
        }
      0   {
          LIB_SPF_call_macro $cycle $prefix ; return
        }
    }

    switch -- $output {
      "LINE"    {
          if {[CONF_SPF_cycle output_cleanup]} {set line [LIB_SPF_eliminate_zero_inline $line [CONF_SPF_cycle word_separator] [CONF_SPF_cycle max_decimal_place]]}
            LIB_SPF_list_to_output [LIB_SPF_check_line_cycle $line [CONF_SPF_file max_line_length]] "0 0" "1 end"
            }
      "TABLE"   {
          set line [LIB_SPF_list_trim_elements [LIB_SPF_divide_list $line $trailer $exclusion $seperator $trailer]]
          if {[CONF_SPF_cycle output_cleanup]} {set line [LIB_SPF_eliminate_zero_inline $line [CONF_SPF_cycle word_separator] [CONF_SPF_cycle max_decimal_place]]}
            LIB_SPF_list_to_output [LIB_SPF_list_to_table $line 0 1 "   " 1] "0 0" "1 end" ; #UNTOUCHED#
          }
      "TABLEWD" {
          set line [LIB_SPF_list_trim_elements [LIB_SPF_divide_list $line $trailer $exclusion $seperator $trailer]]
          if {[CONF_SPF_cycle output_cleanup]} {
            set line [LIB_SPF_eliminate_zero_inline $line [CONF_SPF_cycle word_separator] [CONF_SPF_cycle max_decimal_place]]
          }
          LIB_SPF_list_to_output [LIB_SPF_list_to_table $line 0 1 "   " 1] "0 0" "1 end" ; #UNTOUCHED#
          }
      default   {
          if {[CONF_SPF_cycle output_cleanup] && ![catch {set line [LIB_SPF_eliminate_zero_inline $line [CONF_SPF_advanced_settings word_separator] [CONF_SPF_cycle max_decimal_place]]} err]} {
            if {[string length $prefix] > 0} {set start "$prefix "} else {set start ""}
            MOM_output_literal "$start$line"
            return
          }
          if {[string length $prefix] > 0} {MOM_add_to_line_buffer start "$prefix "}
          MOM_do_template $block
          }
    }
  } else {
    LIB_SPF_call_macro $cycle $prefix
  }

}
# <Documentation>
# This procedure writes a machining cycle call in the NC code output file by considering the respective
# format settings in the Post Configurator user interface. It is used for Heidenhain
# multi-line cycle output and for Sinumerik cycle output.
#
# <Arguments>
# cycle
#   name of the cycle to be written. The given address must be defined as block template
#   in a specific format. Please refer to the ctrl_xx_base.def of the controller
#   to see the proper structure. It is suggested to copy an existing cycle (for example BLOCK_TEMPLATE CYCLE81
#   for Sinumerik or BLOCK_TEMPLATE CYCL_200 for Heidenhain) and modify it to create a new cycle.
#   Valid and necessary elements for the cycle block templates are for Heidenhain are:
#   cycle_call, cycle_comment, cycle_seperator, Q..., cycle_description
#   Cycle elements for Sinumerik are: cycle_call, cycle_start_character, cycle_text_first, cycle_text, cycle_end_character
# prefix
#   Reserved. Do not use it (define as "").
# exclusion
#   Reserved for multi-line cycle output for Heidenhain controller specify "CYCL."
#   For all other cases do not use it (define as "").
# seperator
#   Reserved for multi-line cycle output for Heidenhain controller specify ";"
#   in order to separate cycle comment from the cycle parameters.
#   For all other cases do not use it (define as "").
# trailer
#   Reserved for multi-line cycle output for Heidenhain controller specify "~"
#   in order to output ~ at the end of every line except the last line.
#   For all other cases do not use it (define as "").
#
# <Example>
# name: Example for CYCL DEF 200 on Heidenhain
# code: LIB_SPF_call_cycle CYCL_200 "" "CYCL" ";" "~"
# desc: Result is something like the following, provided that in the Post Configurator
# UI Cycles Control at General Cycle Settings is set to Definition File and
# Cycles Representation is set to Table with Description:
# CYCL DEF 200 DRILLING ~
# Q200=3.175  ;SETUP CLEARANCE        ~
# Q201=-2.54  ;DEPTH                  ~
# Q206=250    ;FEED RATE FOR PLUNGING ~
# Q202=2.54   ;PLUNGING DEPTH         ~
# Q210=0      ;DWELL TIME AT TOP      ~
# Q203=0      ;SURFACE COORDINATE     ~
# Q204=30.641 ;2ND SETUP CLEARANCE    ~
# Q211=0      ;DWELL TIME AT BOTTOM
# <Example>
# name: Example for Cycle81 on Sinumerik
# code: LIB_SPF_call_cycle CYCLE81 MCALL
# desc: The result is something like the following, provided that in the Post Configurator
# UI Cycles Control at General Cycle Settings is set to Definition File:
# MCALL CYCLE81(30.641,0,3.175,-2.54,,,0,1,0)
#____________________________________________________________________________________________
proc LIB_SPF_check_line_cycle {line max {splitter "~"}} {

  global mom_sys_leader

  if {[MOM_set_seq_on] == "on"} {
    if {![info exist mom_sys_leader(N)]} {
      set add_char 0
    } else {
      set add_char [string length $mom_sys_leader(N)]
    }
    set max [expr $max - 1 - [string length [expr int($::mom_seqnum)]] - $add_char]
  } else {
    MOM_set_seq_off
  }

  if {[string length $line] <= $max} {
    return [list $line]
  } else {
    set linetemp $line
    while {[string length $linetemp] > $max} {
      set find [string last " " [string range $linetemp 0 [expr $max-[string length $splitter]]]]
      if {$find != -1} {
        set sub [string range $linetemp 0 [expr $find-1]]
        set linetemp [string trim [string range $linetemp [expr $find+1] end]]
        lappend list "$sub $splitter"
      }
    }
    if {[string length $linetemp] > 0} {lappend list "$linetemp"}
    return $list
  }
}
# <Internal Documentation>
#
# Check if a outputline is longer as alowed. If this is the case we break that in multible output lines.
#
# e.g. CYCL DEF 267 Q335=12 Q239=0.251 Q201=-2.5 Q355=1 Q253=0 Q351=+1 Q200=2 Q358=0.5 Q359=2 Q203=0 Q204=5 Q254=120 Q207=120
#
# CYCL DEF 267 Q335=12 Q239=0.251 Q201=-2.5 Q355=1 Q253=0 Q351=+1 Q200=2 ~
# Q358=0.5 Q359=2 Q203=0 Q204=5 Q254=120 Q207=120
#
# <Internal Example>
# LIB_SPF_check_line_cycle "CYCL DEF 267 Q335=12 Q239=0.251 Q201=-2.5 Q355=1 Q253=0 Q351=+1 Q200=2 Q358=0.5 Q359=2 Q203=0 Q204=5 Q254=120 Q207=120" 75
#
#____________________________________________________________________________________________
proc LIB_SPF_call_macro {macro_name {prefix ""} {suppress_seqno 0} args} {

  global mom_pb_macro_arr mom_warning_info lib_modality_params lib_isset_params

  if {[info exists lib_ge_pretreatment_runtime] && $lib_ge_pretreatment_runtime} {return}

      if {![info exists mom_pb_macro_arr($macro_name)]} {
    LIB_SPF_add_warning "Macro INS->$macro_name<- is not defined."
    return
  }

  set macro_attr_list $mom_pb_macro_arr($macro_name)

  foreach {com_attr_list param_list} $macro_attr_list {break}
  foreach {disp_name start_char separator_char end_char link_flag link_char} $com_attr_list {break}

  set text_string ""
  if {[string compare $prefix ""] != 0} {
    append text_string $prefix " "
  }

  append text_string $disp_name $start_char

  set g_vars_list [list]
  set param_text_list [list]
  set last_index 0
  set count 0
  foreach param_attr $param_list {
    incr count
    if {[llength $param_attr] > 0} {

      foreach {exp dtype is_double int_width is_decimal} $param_attr {break}
      if {$exp == ""} {
        lappend param_text_list ""
        continue
      }

      # reset data_type to string if the variable is defined as MAX or AUTO
      if {![catch {if {1} "set tmp $exp"} res_val]} {
        if {[string match "MAX" [string toupper $res_val]]} { set dtype 0}
        if {[string match "AUTO" [string toupper $res_val]]} { set dtype 0}
      }

      if {$dtype} {
        set temp_cmd "set data_val \[expr \$exp\]"
      } else {
        set temp_cmd "set data_string $exp"
      }

      set break_flag 0
      while {1} {
        if {[catch {if {1} $temp_cmd} res_val]} {
          if [string match "*no such variable*" $res_val] {
            set __idx [string first ":" $res_val]
            if {$__idx >= 0} {
              set temp_res [string range $res_val 0 [expr int($__idx - 1)]]
              set temp_var [lindex $temp_res end]
              set temp_var [string trim $temp_var "\""]
              if {[string index $temp_var [expr [string length $temp_var] - 1]] == ")"} {
                set __idx [string first "(" $temp_var]
                set temp_var [string range $temp_var 0 [expr int($__idx - 1)]]
                    }

              foreach one $g_vars_list {
                if {[string compare $temp_var $one] == 0} {
                  set break_flag 1
                }
              }
              lappend g_vars_list $temp_var
              global $temp_var
            } else {
              set break_flag 1
            }
          } elseif [string match "*no such element*" $res_val] {
            set break_flag 1
          } else {
            # LIB_SPF_add_warning "Error to evaluate expression $exp in $macro_name: $res_val"
            return
          }
        } else {
          break
        }

        if $break_flag {
          # LIB_SPF_add_warning "Error to evaluate expression $exp in $macro_name: $res_val"
          set data_string ""
          break
        }
      }

      if {!$break_flag && $dtype} {

        set is_double [subst $is_double]

        set max_val "1"
        set min_val "-1"
        set zero_char [string range "000000000" 0 [expr $int_width - 1]]
        append max_val $zero_char
        append min_val $zero_char

        if {[catch {expr $data_val >= $max_val} comp_res]} {
          set data_string ""
          # LIB_SPF_add_warning "Wrong data type to evaluate expression $exp in $macro_name: $comp_res"
        } elseif {$comp_res} {
          set data_string [expr $max_val - 1]
          # LIB_SPF_add_warning "MAX/MIN WARNING to evaluate expression $exp in $macro_name: MAX: $data_string"
        } elseif {[expr $data_val <= $min_val]} {
          set data_string [expr $min_val + 1]
          # LIB_SPF_add_warning "MAX/MIN WARNING to evaluate expression $exp in $macro_name: MIN: $data_string"
        } else {
          if {$is_double} {
            set total_width [expr $int_width + $is_double]
            if {$is_decimal} {set com $is_double} else {set com ""}
            catch {set data_string [LIB_SPF_eliminate_zero [string trim [format "%${total_width}.${is_double}f" $data_val]] $com]}
          } else {
            set int_data [expr {int($data_val)}]
            catch {set data_string [format "%${int_width}d" $int_data]}
            set data_string [string trimleft $data_string]
            if {$is_decimal} {
              append data_string "."
            }
          }
        }
      }

      if {$link_flag} {
        set temp_str "" ; set endvalue [lindex $param_attr end]
        append temp_str $endvalue $link_char $data_string
        if {![info exists lib_modality_params($endvalue)]} {set lib_modality_params($endvalue) 0}
        if {![info exists lib_isset_params($endvalue)]} {set lib_isset_params($endvalue) "n/a"}
        if {$lib_modality_params($endvalue) == 1 && $lib_isset_params($endvalue) == $data_string} {
          set data_string ""
        } else {
          set lib_isset_params($endvalue)  $data_string
          set tmp_empty 1
        set data_string $temp_str
        }
      } else {
        set tmp_empty 1
      }
      lappend param_text_list $data_string

      if ![string match "" $data_string] {
        set last_index $count
      }
    } else {
      lappend param_text_list ""
    }
  }
  if {$param_list == ""} {
    set tmp_empty 1
  }

  if {$last_index > 0} {
    if {$last_index < $count} {
      set param_text_list [lreplace [K $param_text_list [set list {}]] $last_index end]
    }
    append text_string [join $param_text_list $separator_char]
  }

  append text_string $end_char
  if {[info exists tmp_empty]} {
    if {$suppress_seqno} {
      MOM_suppress once N
      MOM_output_literal $text_string
    } else {
      MOM_output_literal $text_string
    }
  }
}
# <Internal Documentation>
#
# DEFINE_MACROS (procedure build automatically with PostBuilder)
#
#   set mom_pb_macro_arr(CYCL_200) \
# --> CYCL_200       Macro_name
#
#       [list {{CYCL DEF 200} { bb } { xx } { cc} 1 =} \
# --> bb             Start Character
# --> xx             Separator
# --> cc             End Character
# --> 1              Output Parameter name  like Q201
# --> =              Link Character Q201=   if Space { } None {} or Text {xxx}
# example Siemens 840d "( , ) 0 {}"
# example Heidenhain   "{ } { } {} 1 ="
#
#
#        {{$mom_cycle_rapid_to} 1 4 4 1 1 8 4 Q200} \
# --> $mom_cycle_rapid_to      variable
# --> 1                        Numerical   0 = Text;  1 = Numerical
# --> 4                        Fraction
# --> 4                        Integer
# --> 1                        Decimal Point    1 = Output; 0 = NoOutput
# --> 1                        I don't know     1 = for numeric;  "" = for text (Not Implement in the evaluation)
# --> 8                        Number digits Integer + Fraction
# --> 4                        Fraction
#
# --> Q200                     Parameter Name
#
# example "0 1 4 2 1 1 6 4 Q210"   output Q210=0.
# example "0 0 Q210"               output Q210=0  output 0 as text
# example "{$mom_pos(2)} 1 4 2 1 1 6 4 Q210"   output Q210=12.1234
#
# LIB_SPF_call_macro:
#
# add the next proc also to tcl-File
# this proc output the Macro if it is called
# for example
#
#      LIB_SPF_call_macro CYCL_200 Prefix 1
#     CYCL_200      Macro_name
#     Prefix
#     1 = Suppress Sequence_number 0 = no suppress Seq_Number
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_polar_cart {} {

  global mom_tool_axis mom_coordinate_output_mode mom_pos mom_out_angle_pos mom_prev_pos
  global mom_motion_type mom_motion_event mom_prev_out_angle_pos
  global mom_kin_arc_output_mode mom_kin_helical_arc_output_mode
  global pt_kin_machine_type
  global pt_kin_4th_axis_vector pt_kin_5th_axis_vector
  global lib_spf lib_flag polar_vector_ref
  global mom_kin_4th_axis_min_limit mom_kin_4th_axis_max_limit
  global mom_kin_5th_axis_min_limit mom_kin_5th_axis_max_limit
  global mom_kin_4th_axis_direction mom_kin_5th_axis_direction
  global mom_kin_4th_axis_leader    mom_kin_5th_axis_leader
  global mom_kin_4th_axis_type      mom_kin_5th_axis_type
  global mom_polar_pos
  global mom_current_motion mom_cycle_feed_to mom_cycle_retract_to
  global mom_sys_cycle_after_initial mom_cycle_rapid_to mom_spindle_axis mom_kin_spindle_axis
  global mom_kin_4th_axis_plane mom_sys_spindle_axis mom_cycle_feed_to_pos mom_cycle_retract_to_pos
  global mom_cycle_rapid_to_pos lib_flag
  global mom_arc_tolerance mom_kin_linearization_tol mom_kin_4th_axis_point mom_kin_5th_axis_point

  if {![CONF_SPF_pt lib_spf_pretreatment]||$lib_flag(optimized_mode)} {
    return
  }

  # PR#9877960 Skip polar for turning
  if {$::mom_machine_mode == "TURN"} { return }

  set commandcheck(LIB_SPF_polar_cart_ENTRY) [llength [info commands LIB_SPF_polar_cart_ENTRY]]

  # initialize and check variables
  if {![hiset mom_coordinate_output_mode]} {set mom_coordinate_output_mode "OFF"}
  if {[regexp -- "table" $pt_kin_machine_type] == 0} {return ;# no table}
  if {[regexp -- "5_axis" $pt_kin_machine_type] == 1} {
    set lib_flag(polar_rotary_axis) 1
    if {[EQ_is_equal [expr abs($pt_kin_5th_axis_vector(0))] 1.0]} {
      set lib_flag(polar_tool_axis) 0
    } elseif {[EQ_is_equal [expr abs($pt_kin_5th_axis_vector(1))] 1.0]} {
      set lib_flag(polar_tool_axis) 1
    } elseif {[EQ_is_equal [expr abs($pt_kin_5th_axis_vector(2))] 1.0]} {
      set lib_flag(polar_tool_axis) 2
    } else {
      return ;# not orthogonal plane
    }
  } else {
    set lib_flag(polar_rotary_axis) 0
    if {[EQ_is_equal [expr abs($pt_kin_4th_axis_vector(0))] 1.0]} {
      set lib_flag(polar_tool_axis) 0
    } elseif {[EQ_is_equal [expr abs($pt_kin_4th_axis_vector(1))] 1.0]} {
      set lib_flag(polar_tool_axis) 1
    } elseif {[EQ_is_equal [expr abs($pt_kin_4th_axis_vector(2))] 1.0]} {
      set lib_flag(polar_tool_axis) 2
    } else {
      return ;# not orthogonal plane
    }
  }

  if {![EQ_is_equal [expr abs($mom_tool_axis($lib_flag(polar_tool_axis)))] 1 0.0000001] || $mom_coordinate_output_mode != "ON"} {return}

  LIB_GE_command_buffer LIB_SPF_polar_cart_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_polar_cart_ENTRY)} {LIB_SPF_polar_cart_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  set commandcheck(LIB_CTRL_polar_transmit) [llength [info commands LIB_CTRL_polar_transmit]]
  LIB_GE_command_buffer LIB_CTRL_polar_transmit
  LIB_GE_command_buffer {if {$commandcheck(LIB_CTRL_polar_transmit)} {LIB_CTRL_polar_transmit}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {$lib_flag(first_transmit_move) == 1} {return}

  LIB_GE_command_buffer ENABLE_MOTION
  LIB_GE_command_buffer {
    switch [CONF_CTRL_moves polar_allowed_moves] {
      "ALL" {
        set lib_flag(polar_motions_types) {"TRAVERSAL" "RETURN" "RAPID" "ENGAGE" "DEPARTURE" "RETRACT" "APPROACH" "CYCLE"}
      }
      "RAPID_CYCLE" {
        set lib_flag(polar_motions_types) {"RAPID" "CYCLE"}
      }
    }
  } @MOTION_TYPE
  LIB_GE_command_buffer_output
  if {![info exist lib_flag(polar_motions_types)]} {
    set lib_flag(polar_motions_types) {"TRAVERSAL" "RETURN" "RAPID" "ENGAGE" "DEPARTURE" "RETRACT" "APPROACH" "CYCLE"}
  }
  set found 0
  foreach el $lib_flag(polar_motions_types) {if {$mom_motion_type == $el} {set found 1}}
  if {$mom_motion_event == "linear_move" || $mom_motion_event == "helix_move" || $mom_motion_event == "circular_move"} {set found 0}
  if {[CONF_CTRL_moves polar_feedrate] == 0 && $found == 0} {return}

  if {[CONF_CTRL_moves polar_feedrate] != 0} {
    if {$mom_kin_arc_output_mode != "LINEAR"} {
      set mom_kin_arc_output_mode "LINEAR"
      MOM_reload_kinematics_variable mom_kin_arc_output_mode
    }
    if {$mom_kin_helical_arc_output_mode != "LINEAR"} {
      set mom_kin_helical_arc_output_mode "LINEAR"
      MOM_reload_kinematics_variable mom_kin_helical_arc_output_mode
    }
  }
  if {$mom_motion_event == "initial_move" && $mom_motion_type == "CYCLE"} {
    LIB_GE_abort_message "With polar mode, approach motion is required before first cycle" "Please verify"
  }

  switch [CONF_CTRL_moves polar_vector_ref] {
    "X+" {array set polar_vector_ref "0 1.0 1 0.0 2 0.0"}
    "X-" {array set polar_vector_ref "0 -1.0 1 0.0 2 0.0"}
    "Y+" {array set polar_vector_ref "0 0.0 1 1.0 2 0.0"}
    "Y-" {array set polar_vector_ref "0 0.0 1 -1.0 2 0.0"}
    "Z+" {array set polar_vector_ref "0 0.0 1 0.0 2 1.0"}
    "Z-" {array set polar_vector_ref "0 0.0 1 0.0 2 -1.0"}
  }
  if {$lib_flag(mode_current_status) == "pos"} {
    LIB_SPF_add_warning "With positioning mode, polar mode is unactivated"
    return
  } elseif {$lib_flag(mode_current_status) == "sim"} {
    LIB_SPF_add_warning "With simultanous mode, polar mode is unactivated"
    return
  }

  if {$lib_flag(polar_tool_axis) == 0} {
    if {[CONF_CTRL_moves polar_vector_ref] == "X+" || [CONF_CTRL_moves polar_vector_ref] == "X-"} {
      LIB_GE_abort_message "Polar reference vector [CONF_CTRL_moves polar_vector_ref] not compatible with YZ plane" "Please check"
    }
    array set polar_vector_prev_pos "0 0.0 1 $mom_prev_pos(1) 2 $mom_prev_pos(2)"
    array set polar_vector_pos "0 0.0 1 $mom_pos(1) 2 $mom_pos(2)"
  } elseif {$lib_flag(polar_tool_axis) == 1} {
    if {[CONF_CTRL_moves polar_vector_ref] == "Y+" || [CONF_CTRL_moves polar_vector_ref] == "Y-"} {
      LIB_GE_abort_message "Polar reference vector [CONF_CTRL_moves polar_vector_ref] not compatible with ZX plane" "Please check"
    }
    array set polar_vector_prev_pos "0 $mom_prev_pos(0) 1 0.0 2 $mom_prev_pos(2)"
    array set polar_vector_pos "0 $mom_pos(0) 1 0.0 2 $mom_pos(2)"
  } elseif {$lib_flag(polar_tool_axis) == 2} {
    if {[CONF_CTRL_moves polar_vector_ref] == "Z+" || [CONF_CTRL_moves polar_vector_ref] == "Z-"} {
      LIB_GE_abort_message "Polar reference vector [CONF_CTRL_moves polar_vector_ref] not compatible with XY plane" "Please check"
    }
    array set polar_vector_prev_pos "0 $mom_prev_pos(0) 1 $mom_prev_pos(1) 2 0.0"
    array set polar_vector_pos "0 $mom_pos(0) 1 $mom_pos(1) 2 0.0"
  }

  # <09-Nov-2018 Jintao> 9299972 make sure the tolerance is small enough
  if {[info exists mom_arc_tolerance] && $mom_arc_tolerance < $mom_kin_linearization_tol} {
    set mom_kin_linearization_tol $mom_arc_tolerance
    MOM_reload_kinematics_variable mom_kin_linearization_tol
  }

  # Use new MOM extension to convert polar mode after NX1201.
  # Syntax: MOM_polar_motion polar_block_template init_vector target_pos
  # Param:
  # @polar_block_template: The block template used in polar output, it must contain mom_pos and mom_out_angle_pos
  # @init_vector: The initial vector of polar mode, when the rotary axis is zero, like {i, j, k}
  # @target_pos: The target position of polar motion, like {X, Y, Z, 4th_angle, 5th_angle}
  # Return: 0/1, 1 for success, 0 if it fails.
  #
  # Syntax: MOM_polar_convert_point init_vector point
  # Param:
  # @ init_vector: The initial vector of polar mode, like {i, j , k}
  # @point: The point to be converted, like {X, Y, Z, 4th_angle, 5th_angle}
  # Return: 0/1, 1 for success, 0 if it fails.

  if {[llength [info commands MOM_polar_motion]]} {
    if {![info exists mom_sys_cycle_after_initial]} {
      set mom_sys_cycle_after_initial "FALSE"
    }
    if {[regexp -- "5_axis" $pt_kin_machine_type] == 1} {
      if {[VEC3_is_zero mom_kin_5th_axis_point] == 0} {
        LIB_SPF_add_warning "With MOM_polar_motion, mom_kin_5th_axis_point array should be set to zero for calculation"
      }
    } else {
      if {[VEC3_is_zero mom_kin_4th_axis_point] == 0} {
        LIB_SPF_add_warning "With MOM_polar_motion, mom_kin_4th_axis_point array should be set to zero for calculation"
      }
    }

    if {![info exists mom_prev_out_angle_pos(1)] } { set mom_prev_out_angle_pos(1) 0.0}
    if {![info exists mom_prev_out_angle_pos(0)] } { set mom_prev_out_angle_pos(0) 0.0}

    if {[string match "FALSE" $mom_sys_cycle_after_initial]} {
      MOM_polar_convert_point polar_vector_ref mom_pos
      #PR9425862
      if {[info exists mom_polar_pos(3)] && [info exists mom_polar_pos(4)]} {
        set mom_out_angle_pos(0)  [LIB_SPF_rotset $mom_polar_pos(3) $mom_prev_out_angle_pos(0) $mom_kin_4th_axis_direction\
        $mom_kin_4th_axis_leader mom_sys_leader(fourth_axis)\
        $mom_kin_4th_axis_min_limit $mom_kin_4th_axis_max_limit]
        set mom_out_angle_pos(1)  [LIB_SPF_rotset $mom_polar_pos(4) $mom_prev_out_angle_pos(1) $mom_kin_5th_axis_direction\
        $mom_kin_5th_axis_leader mom_sys_leader(fifth_axis)\
        $mom_kin_5th_axis_min_limit $mom_kin_5th_axis_max_limit]
        VMOV 5 mom_polar_pos mom_pos
      }
    }

    if {[string match "CYCLE" $mom_motion_type]} {

      if { [string match "initial_move" $mom_motion_event] } {
        set mom_sys_cycle_after_initial "TRUE"
      } else {

        if { [string match "TRUE" $mom_sys_cycle_after_initial] } {
          set mom_pos(0) [expr $mom_pos(0) - $mom_cycle_rapid_to * $mom_tool_axis(0)]
          set mom_pos(1) [expr $mom_pos(1) - $mom_cycle_rapid_to * $mom_tool_axis(1)]
          set mom_pos(2) [expr $mom_pos(2) - $mom_cycle_rapid_to * $mom_tool_axis(2)]
        }

        set mom_sys_cycle_after_initial "FALSE"

        if { [string match "Table" $mom_kin_4th_axis_type] } {

          if [info exists mom_spindle_axis] {
            VMOV 3 mom_spindle_axis mom_sys_spindle_axis
          } else {
            VMOV 3 mom_kin_spindle_axis mom_sys_spindle_axis
          }

        } elseif { [string match "Table" $mom_kin_5th_axis_type] } {

          VMOV 3 mom_tool_axis vec

          switch $mom_kin_4th_axis_plane {
            XY { set vec(2) 0.0 }
            ZX { set vec(1) 0.0 }
            YZ { set vec(0) 0.0 }
          }

          set len [VEC3_mag vec]
          if { [EQ_is_gt $len 0.0] } {
            VEC3_unitize vec mom_sys_spindle_axis
          } else {
            set mom_sys_spindle_axis(0) 0.0
            set mom_sys_spindle_axis(1) 0.0
            set mom_sys_spindle_axis(2) 1.0
          }
        } else {
          VMOV 3 mom_tool_axis mom_sys_spindle_axis
        }

        set mom_cycle_feed_to_pos(0)    [expr $mom_pos(0) + $mom_cycle_feed_to    * $mom_sys_spindle_axis(0)]
        set mom_cycle_feed_to_pos(1)    [expr $mom_pos(1) + $mom_cycle_feed_to    * $mom_sys_spindle_axis(1)]
        set mom_cycle_feed_to_pos(2)    [expr $mom_pos(2) + $mom_cycle_feed_to    * $mom_sys_spindle_axis(2)]

        set mom_cycle_rapid_to_pos(0)   [expr $mom_pos(0) + $mom_cycle_rapid_to   * $mom_sys_spindle_axis(0)]
        set mom_cycle_rapid_to_pos(1)   [expr $mom_pos(1) + $mom_cycle_rapid_to   * $mom_sys_spindle_axis(1)]
        set mom_cycle_rapid_to_pos(2)   [expr $mom_pos(2) + $mom_cycle_rapid_to   * $mom_sys_spindle_axis(2)]

        set mom_cycle_retract_to_pos(0) [expr $mom_pos(0) + $mom_cycle_retract_to * $mom_sys_spindle_axis(0)]
        set mom_cycle_retract_to_pos(1) [expr $mom_pos(1) + $mom_cycle_retract_to * $mom_sys_spindle_axis(1)]
        set mom_cycle_retract_to_pos(2) [expr $mom_pos(2) + $mom_cycle_retract_to * $mom_sys_spindle_axis(2)]
      }
    }

    if {[CONF_CTRL_moves polar_feedrate] != 0 && $mom_current_motion == "linear_move" } {
      MOM_polar_motion linear_move polar_vector_ref mom_pos
      MOM_suppress once G_motion
    }

    MOM_reload_variable -a mom_pos
    MOM_reload_variable -a mom_out_angle_pos

  } else {
    if {![VEC3_is_equal polar_vector_prev_pos polar_vector_pos]} {LIB_linearize_motion}

    if {[EQ_is_equal [expr $mom_out_angle_pos($lib_flag(polar_rotary_axis)) - 360] $mom_pos([expr 3+$lib_flag(polar_rotary_axis)])]} {
      set mom_out_angle_pos($lib_flag(polar_rotary_axis)) $mom_pos([expr 3+$lib_flag(polar_rotary_axis)])
    }
    if {![VEC3_is_zero polar_vector_pos]} {
      LIB_SPF_polar_cart_calculation polar_vector_ref polar_vector_pos $mom_out_angle_pos($lib_flag(polar_rotary_axis))

      MOM_reload_variable -a mom_pos
      set mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)
      set mom_prev_out_angle_pos(1) $mom_out_angle_pos(1)
    }
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer LIB_SPF_polar_cart_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_polar_cart_ENTRY)} {LIB_SPF_polar_cart_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
# Polar conversion. Called in MOM_before_motion.
# mom_pos is updated
#
# Needed variables:
#
# mom_polar_status      :ON,OFF     /polar status
# [CONF_CTRL_moves polar_feedrate]  :1,0      /mode polar activated with linear motion or not
# [CONF_CTRL_moves polar_transmit]  :ON,OFF     /transmit mode
#
# Optionnal variables:
#
# Rotary axes kinematic is taken into account (stroke & direction)
# If "MAGNITUDE_DETERMINES_DIRECTION", axes limits should be +- 99999.99
# To avoid rounds addition, MOM_end_of_path should reset rotary axis value for 1st move of next op.
# (set mom_prev_pos(3) 0 / set mom_prev_pos(4) 0 ; MOM_reload_variable -a mom_prev_pos)
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_modulo_sign {first second {max_value 359.9999}} {
  set first [expr abs($first)]
  set second [expr abs($second)]

  if {[EQ_is_ge $first 180 0.0001] && [EQ_is_le $first $max_value 0.0001] && \
          [EQ_is_ge $second 0 0.0001] && [EQ_is_lt $second 180 0.0001] && \
          [EQ_is_ge [expr $first - $second] 180 0.0001]} {
    return 1
  } elseif {[EQ_is_equal $first $max_value 0.001] && [EQ_is_equal $second 180 0.0001]} {
    return -1
  } elseif {[EQ_is_gt $second 180 0.0001] && [EQ_is_le $second $max_value 0.0001] && \
      [EQ_is_ge $first 0 0.0001] && [EQ_is_lt $first 180 0.0001] && \
      [EQ_is_gt [expr $second - $first] 180 0.0001]} {
    return -1
  } elseif {[EQ_is_gt $first $second 0.0001]} {
    return -1
  } else {
    return 1
  }
}
# <Documentation>
#   This procedure determines the sign of rotary motion with a modulo axis.
# <Arguments>
# first
#   First axis position.
# second
#   Second axis position.
# max_value
#   Maximum allowed value for the rotary axis.
# <Returnvalue>
#  1 - CLW motion.
# -1 - CCLW motion.
# <Example>
# set result [LIB_SPF_modulo_sign $mom_prev_out_angle_pos(0) $mom_out_angle_pos(0)]
#____________________________________________________________________________________________
proc LIB_SPF_atan_polar {v1 v2} {

  global RAD2DEG

  set x $v2
  set y $v1

  if {[EQ_is_zero $x] && [EQ_is_zero $y]} {
    set angle 0.0
    return $angle
  }

  set angle [expr atan2($y,$x) * $RAD2DEG]

  if {[EQ_is_lt $angle 0.0]} {
    set angle [expr $angle + 360]
  }

  return $angle
}
# <Documentation>
# This procedure converts a cartesian coordinate to a polar coordinate.
# <Arguments>
# v1
#    X value in cartesian coordinate format.
# v2
#    Y value in cartesian coordinate format.
# <Returnvalue>
# Angle in polar coordinate format.
# <Example>
# set result [LIB_SPF_atan_polar $mom_pos(0) $mom_pos(1)]
#____________________________________________________________________________________________
proc LIB_SPF_ask_delta_4th_or_5th {axis_no} {

  global   mom_pos mom_prev_pos
  global   mom_rotary_delta_4th mom_rotary_delta_5th

  if {$axis_no == 4 && [hiset mom_rotary_delta_4th]} {
    return $mom_rotary_delta_4th
  }
  if {$axis_no == 5 && [hiset mom_rotary_delta_5th]} {
    return $mom_rotary_delta_5th
  }
  incr axis_no -1 ; set a180 180.0
  set abs_pos [expr sqrt($mom_pos($axis_no) * $mom_pos($axis_no))]
  set abs_prev_pos [expr sqrt($mom_prev_pos($axis_no) * $mom_prev_pos($axis_no))]
  set rotdel [expr $abs_pos - $abs_prev_pos]
  set abs_rotdel [expr sqrt($rotdel * $rotdel)]
  if {[EQ_is_gt $abs_rotdel $a180]} {
    set rotdel [expr 360.0 - $abs_rotdel]
  } else {
    set rotdel $abs_rotdel
  }

  return $rotdel
}
# <Documentation>
# This procedure returns the delta rotation angle in degrees of the 4th or 5th axis.
# <Arguments>
# axis_no
#   Rotary axis ID. Valid values are 4 or 5.
# <Returnvalue>
# Delta rotation angle in degrees.
# <Example>
# set result [LIB_SPF_ask_delta_4th_or_5th 4]
#_____________________________________________________________________________________________
proc LIB_SPF_ask_smaller_of_4th_5th {} {

  global   mom_kin_machine_type rot_cnt

  set minrot 0.0
  set machine_type [string tolower $mom_kin_machine_type]
  if {![hiset rot_cnt]} {
    switch $machine_type {
      4_axis_head -
      4_axis_table -
      3_axis_mill_turn -
      mill_turn   {set rot_cnt 1}
      5_axis_dual_table -
      5_axis_dual_head  -
      5_axis_head_table   {set rot_cnt 2}
      default       {set rot_cnt 0}
    }
  }

  # determine minrot: shortest of the 4th and 5th rotations
  if {$rot_cnt > 0} {
    set minrot [LIB_SPF_ask_delta_4th_or_5th 4]
  }

  if {$rot_cnt == 2} {
    set tmprot [LIB_SPF_ask_delta_4th_or_5th 5]
    if {![EQ_is_zero $tmprot] && $tmprot < $minrot} {
      set minrot $tmprot
    }
  }

  return $minrot
}
# <Documentation>
# This procedure returns the shortest delta degrees rotation out of 4th and 5th axis.
# <Returnvalue>
# Shortest delta rotation in degrees.
# <Example>
# set result [LIB_SPF_ask_smaller_of_4th_5th]
#_____________________________________________________________________________________________
proc LIB_SPF_LIB_SPF_ask_delta_move {} {
  global mom_motion_distance

  if {[hiset mom_motion_distance]} {return $mom_motion_distance} else {return 0.0}
}
# <Internal Documentation>
#
# Returns the delta distance(IN or MM) for the current move
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_ask_feedrate_fpm {} {

  global mom_feed_rate

  if {[hiset mom_feed_rate]} {
    return $mom_feed_rate
  } else {
    set mom_warning_info "FEED RATE UNDEFINED"
    MOM_catch_warning
    return 0.0
  }
}
# <Internal Documentation>
#
# Returns feed rate IN or MM per min
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_ask_feedrate_fpr {} {

  global mom_feed_rate_per_rev

  if {[hiset mom_feed_rate_per_rev]} {
    return $mom_feed_rate_per_rev
  } else {
    return 0.0
  }
}
# <Internal Documentation>
#
# Returns feed rate IN or MM per rev
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_feedrate_number {} {

  global mom_feed_rate_number mom_feed_rate

  if {[hiset mom_feed_rate_number]} {
    return $mom_feed_rate_number
  } elseif {![hiset mom_feed_rate]} {
    return 0.0
  }
  set delta_distance [LIB_SPF_ask_delta_move]
  if {[EQ_is_zero $delta_distance] || [EQ_is_zero $mom_feed_rate]} {
    return 0.0
  } else {
    set f_rn [expr $mom_sys_frn_factor * $mom_feed_rate / $delta_distance]
    return $f_rn
  }
}
# <Internal Documentation>
#
# Returns feed rate number in inverse time
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_feedrate_dpm {} {

  global mom_feed_rate_dpm

  if {[hiset mom_feed_rate_dpm]} {
    return $mom_feed_rate_dpm
  } else {
    set f_rn [LIB_SPF_feedrate_number]
    set minrot [LIB_SPF_ask_smaller_of_4th_5th]
    set d_pm [expr $minrot * $f_rn]
    return $d_pm
  }
}
# <Internal Documentation>
#
# Returns feed rate in degrees per min
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_feed_mode_set {feed_type} {

  global mom_sys_contour_feed_mode mom_sys_rapid_feed_mode
  global mom_pos mom_prev_pos mom_kin_machine_type
  global super_feed_mode
  global mom_output_unit mom_feed_set_mode
  global mom_motion_event
  global mom_kin_machine_resolution
  global mom_kin_4th_axis_min_incr mom_kin_5th_axis_min_incr

  # Fetch feed rate modes defined in post
  switch $feed_type {
    "CONTOUR" {
        if {[hiset mom_sys_contour_feed_mode(LINEAR)]} {
          set feed_mode(LINEAR) $mom_sys_contour_feed_mode(LINEAR)
        }
        if {[hiset mom_sys_contour_feed_mode(ROTARY)]} {
          set feed_mode(ROTARY) $mom_sys_contour_feed_mode(ROTARY)
        }
        if {[hiset mom_sys_contour_feed_mode(LINEAR_ROTARY)]} {
          set feed_mode(LINEAR_ROTARY) $mom_sys_contour_feed_mode(LINEAR_ROTARY)
        }
      }
    "RAPID" {
        if {[hiset mom_sys_rapid_feed_mode(LINEAR)]} {
          set feed_mode(LINEAR) $mom_sys_rapid_feed_mode(LINEAR)
        }
        if {[hiset mom_sys_rapid_feed_mode(ROTARY)]} {
          set feed_mode(ROTARY) $mom_sys_rapid_feed_mode(ROTARY)
        }
        if {[hiset mom_sys_rapid_feed_mode(LINEAR_ROTARY)]} {
          set feed_mode(LINEAR_ROTARY) $mom_sys_rapid_feed_mode(LINEAR_ROTARY)
        }
      }
  }

  if {[hiset mom_kin_machine_type]} {

    set machine_type [string tolower $mom_kin_machine_type]
    if {[string match "*wedm" $machine_type]} {return}

    switch $machine_type {

      "lathe" -
      "2_axis_lathe" -
      "3_axis_mill" {

          if {[hiset mom_feed_set_mode]} {
            if {[string match "OFF" $mom_feed_set_mode]} {
              if {[hiset feed_mode(LINEAR)]}  {
                set super_feed_mode $feed_mode(LINEAR)
              } else {
                if {[string match "IN" $mom_output_unit]} {
                  set super_feed_mode "IPM"
                } else {
                  set super_feed_mode "MMPM"
                }
              }
            }
          }
        }

      default {

          # Multi-axis
          if {[string match "OFF" $mom_feed_set_mode] || [string match "RAPID" $feed_type]} {

            set islinear_move 0 ; set isrotary_move 0

            if {![info exists mom_motion_event]} {
              set mom_motion_event UNDEFINED
            }

            # Get the linear and rotary resolution in post
            set tol_linear $mom_kin_machine_resolution
            set tol_rot4 $mom_kin_4th_axis_min_incr

            if {[string match "circular_move" $mom_motion_event]} {
              set islinear_move 1
            }

            switch $machine_type {
                4_axis_head -
                4_axis_table -
                3_axis_mill_turn -
                mill_turn {

                    #Use EQ_is_equal instead of EQ_is_equal
                    if {![EQ_is_equal $mom_pos(3) $mom_prev_pos(3) $tol_rot4]} {
                      set isrotary_move 1
                    }

                    if {![EQ_is_equal $mom_pos(0) $mom_prev_pos(0) $tol_linear] || \
                    ![EQ_is_equal $mom_pos(1) $mom_prev_pos(1) $tol_linear] || \
                    ![EQ_is_equal $mom_pos(2) $mom_prev_pos(2) $tol_linear]} {
                      set islinear_move 1
                    }
                  }
                5_axis_dual_table -
                5_axis_dual_head  -
                5_axis_head_table {

                    set tol_rot5 $mom_kin_5th_axis_min_incr

                    if {![EQ_is_equal $mom_pos(3) $mom_prev_pos(3) $tol_rot4] || \
                    ![EQ_is_equal $mom_pos(4) $mom_prev_pos(4) $tol_rot5]} {
                      set isrotary_move 1
                    }

                    if {![EQ_is_equal $mom_pos(0) $mom_prev_pos(0) $tol_linear] || \
                    ![EQ_is_equal $mom_pos(1) $mom_prev_pos(1) $tol_linear] || \
                    ![EQ_is_equal $mom_pos(2) $mom_prev_pos(2) $tol_linear]} {
                      set islinear_move 1
                    }
                  }
            }

            if {$islinear_move} {

              if {$isrotary_move} {

                if {[hiset feed_mode(LINEAR_ROTARY)]} {
                  set super_feed_mode $feed_mode(LINEAR_ROTARY)
                } elseif {[hiset feed_mode(ROTARY)]} {
                  set super_feed_mode $feed_mode(ROTARY)
                } elseif {[hiset feed_mode(LINEAR)]} {
                  set super_feed_mode $feed_mode(LINEAR)
                } else {
                  if {[string match "CONTOUR" $feed_type]} {
                    if {[string match "IN" $mom_output_unit]} {
                      set super_feed_mode "IPM"
                    } else {
                      set super_feed_mode "MMPM"
                    }
                  }
                }

              } else {

                if {[hiset feed_mode(LINEAR)]} {
                  set super_feed_mode $feed_mode(LINEAR)
                } else {

                  if {[string match "CONTOUR" $feed_type]} {
                    if {[string match "IN" $mom_output_unit]} {
                      set super_feed_mode "IPM"
                    } else {
                      set super_feed_mode "MMPM"
                    }
                  }
                }
              }

            } else { # islinear_move

              if {$isrotary_move} {

                if {[hiset feed_mode(ROTARY)]} {
                  set super_feed_mode $feed_mode(ROTARY)
                } elseif {[hiset feed_mode(LINEAR_ROTARY)]} {
                  set super_feed_mode $feed_mode(LINEAR_ROTARY)
                } elseif {[hiset feed_mode(LINEAR)]} {
                  set super_feed_mode $feed_mode(LINEAR)
                } else {
                  if {[string match "CONTOUR" $feed_type]} {
                    if {[string match "IN" $mom_output_unit]} {
                      set super_feed_mode "IPM"
                    } else {
                      set super_feed_mode "MMPM"
                    }
                  }

                }

              }  ;# isrotary_move

            }  ;# !islinear_move

          }  ;# mom_feed_set_mode == "OFF" || feed_type == "RAPID"

        }

    }  ;# switch machine_type

  } else {

    # It's not likely mom_kin_machine_type is not defined.
    if {[hiset feed_mode(LINEAR)] } {
      set super_feed_mode $feed_mode(LINEAR)
    }
  }
}
# <Internal Documentation>
#
# This procedure selects the proper feed rate mode into super_feed_mode
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_feedrate_set {} {

  global mom_feed_rate_output_mode super_feed_mode feed_mode
  global mom_cycle_feed_rate_mode mom_cycle_feed_rate
  global mom_cycle_feed_rate_per_rev
  global mom_sys_rapid_feed_mode mom_sys_contour_feed_mode
  global mom_motion_type mom_kin_output_unit mom_output_unit
  global Feed_IPM Feed_IPR Feed_MMPM Feed_MMPR Feed_INV
  global mom_sys_feed_param feed
  global mom_sys_cycle_feed_mode mom_current_motion
  global mom_machine_mode mom_spindle_mode

  set super_feed_mode $mom_feed_rate_output_mode

  set f_pm [LIB_SPF_ask_feedrate_fpm]
  set f_pr [LIB_SPF_ask_feedrate_fpr]

  switch -- $mom_motion_type {

    CYCLE {
      if {[info exists mom_sys_cycle_feed_mode]} {
        if {![string match "AUTO" $mom_sys_cycle_feed_mode]} {
          set mom_cycle_feed_rate_mode $mom_sys_cycle_feed_mode
        } elseif {![info exist mom_cycle_feed_rate_mode] || [string trim $mom_cycle_feed_rate_mode] == ""} {
          set mom_cycle_feed_rate_mode $mom_feed_rate_output_mode
        }
      }
      if {[info exists mom_cycle_feed_rate_mode] && [string length $mom_cycle_feed_rate_mode] > 0} {
        set super_feed_mode $mom_cycle_feed_rate_mode
      }
      if {[info exists mom_cycle_feed_rate]} {
        set f_pm $mom_cycle_feed_rate
      }
      if {[info exists mom_cycle_feed_rate_per_rev]} {
        set f_pr $mom_cycle_feed_rate_per_rev
      }
    }
    RETRACT {
      if {[info exists ::mom_sys_retract_feed_mode]} {
        if {$::mom_sys_retract_feed_mode == "CONTOUR"} {
          LIB_SPF_feed_mode_set CONTOUR
        } elseif {$::mom_sys_retract_feed_mode == "RAPID"} {
          LIB_SPF_feed_mode_set RAPID
        }
      } elseif {$mom_sys_rapid_feed_mode(LINEAR) != "AUTO"} {
        if {[EQ_is_zero $f_pm] && [EQ_is_zero $f_pr]} {
          LIB_SPF_feed_mode_set RAPID
        } else {
          LIB_SPF_feed_mode_set CONTOUR
        }
      }
    }

    default {
      if {[info exist ::mom_current_motion] && $::mom_current_motion == "rapid_move"} {
        LIB_SPF_feed_mode_set RAPID
      } elseif {$mom_sys_rapid_feed_mode(LINEAR) != "AUTO"} {
        if {[EQ_is_zero $f_pm] && [EQ_is_zero $f_pr]} {
          LIB_SPF_feed_mode_set RAPID
        } else {
          LIB_SPF_feed_mode_set CONTOUR
        }
      }
    }
  }

  if {$super_feed_mode == "AUTO"} {
    set feed_mode $mom_feed_rate_output_mode
  } else {
    set feed_mode $super_feed_mode
  }

  # Adjust feedrate format per Post output unit again.
  if {([info exists mom_kin_output_unit] && $mom_kin_output_unit == "IN" && (![info exists mom_output_unit] || $mom_output_unit == "IN")) || ([info exists mom_output_unit] && $mom_output_unit == "IN")} {
    switch -- $feed_mode {
      MMPM {
        set feed_mode "IPM"
        LIB_SPF_add_warning "Feedrate mode MMPM changed to IPM"
      }
      MMPR {
        set feed_mode "IPR"
        LIB_SPF_add_warning "Feedrate mode MMPR changed to IPR"
      }
    }
  } else {
    switch -- $feed_mode {
      IPM {
        set feed_mode "MMPM"
        LIB_SPF_add_warning "Feedrate mode IPM changed to MMPM"
      }
      IPR {
        set feed_mode "MMPR"
        LIB_SPF_add_warning "Feedrate mode IPR changed to MMPR"
      }
    }
  }
  switch -- $feed_mode {
    IPM     -
    MMPM    {
      set feed $f_pm
    }
    IPR     -
    MMPR    {set feed $f_pr}
    DPM     {set feed [LIB_SPF_feedrate_dpm]}
    FRN     -
    INVERSE {set feed [LIB_SPF_feedrate_number]}
    default {
      LIB_SPF_add_warning "INVALID FEED RATE MODE"
      return
    }
  }

  # Post Configurator provided format for the current mode:
  if {[info exists mom_sys_feed_param(${feed_mode},format)]} {
    MOM_set_address_format F $mom_sys_feed_param(${feed_mode},format)
  } else {
    switch -- $feed_mode {
      IPM     -
      MMPM    -
      IPR     -
      MMPR    -
      DPM     -
      FRN     {MOM_set_address_format F Feed_${feed_mode}}
      INVERSE {MOM_set_address_format F Feed_INV}
    }
  }

  if {[llength [info commands LIB_CTRL_convert_feed_unit]]} {LIB_CTRL_convert_feed_unit}

  # mom_feedrate and mom_feedrate_mode are used in advanced turbo mode, they are caculated in Post Core
  # and the result of MOM extension "MOM_set_feedrate"
  set ::mom_feedrate        $feed
  set ::mom_feedrate_mode   $feed_mode
}
# <Internal Documentation>
#
# It's a copy of PB_CMD_kin_feedrate_set from PB
# PB_CMD_kin_feedrate_set replaces FEEDRATE_SET proc in ugpost_base.tcl
# replace feed_mode with mom_feed_rate_output_mode (need to be updated (2012/08/09 GB)
# This is a copy from ugpost_base.tcl without any checks !!
#
# <Internal Example>
#
#_____________________________________________________________________________________________
proc LIB_SPF_check_compatibility {} {

  global mom_channel_id mom_post_in_simulation
  global mom_machine_mode
  global lib_machine_mode lib_channel_id

  set commandcheck(LIB_SPF_check_compatibility_ENTRY) [llength [info commands LIB_SPF_check_compatibility_ENTRY]]

  LIB_GE_command_buffer LIB_SPF_check_compatibility_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_check_compatibility_ENTRY)} {LIB_SPF_check_compatibility_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  if {$mom_channel_id != ""} {
    if {$mom_post_in_simulation != "SYN" && [hiset lib_channel_id] && $mom_channel_id != $lib_channel_id} {
      LIB_GE_abort_message "2 channels detected" "Please use Synch Manager"
    }
    set lib_channel_id $mom_channel_id
  }

  if {![info exists lib_machine_mode]} {set lib_machine_mode "NONE"}

  global mom_template_subtype
  if {[info exists mom_template_subtype] && $mom_template_subtype == "DOCUMENTATION"} {
    #PR9661705 Skip compatibility check for Documentation operation
  } else {
    switch -- $lib_machine_mode {
      "MILL" {
        if {$mom_machine_mode != "MILL"} {LIB_GE_abort_message "Operation type incompatible with Milling Postprocessor" "Please verify"}
      }
      "TURN" {
        if {$mom_machine_mode != "TURN"} {LIB_GE_abort_message "Operation type incompatible with Turning Postprocessor" "Please verify"}
      }
      "3_AXIS_MILL_TURN" -
      "MILL_TURN" {
        if {$mom_machine_mode != "MILL" && $mom_machine_mode != "TURN"} {
          LIB_GE_abort_message "Operation type incompatible with MillTurn Postprocessor"
        }
      }
      "WEDM" {
        if {$mom_machine_mode != "WEDM"} {LIB_GE_abort_message "Operation type incompatible with Wire EDM Postprocessor" "Please verify"}
      }
      "NONE" {
        if {[string match "file_based" [CONF_SPF_machine machine_mode]]} {
          MOM_output_to_listing_device "There is no machine mode property defined. Check machinehandler.\n--> Milling is defined as a standard <--"
          set lib_machine_mode "MILL"
        } else {
          LIB_GE_error_message "There is no machine mode defined" "Check machinehandler"
        }
      }
    }
  }

  LIB_GE_command_buffer LIB_SPF_check_compatibility_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_check_compatibility_ENTRY)} {LIB_SPF_check_compatibility_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
}
# <Internal Documentation>
#
# Check compatibility:
# - multichannels without synchro manager
# - mom_machine_mode and lib_machine_mode
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_set_op_tool_param_condition {param args} {

  global lib_spf_op_tool_param_check_list
  global lib_spf_op_tool_param_check_array
  global lib_spf_valid_param_check_entires

  if {[llength $args] == 2} {
  #this is the case if the proc is called with 3 arguments
    if {[string tolower [lindex $args 1]] != "remove"} {
      #abort
    } else {
      set calling_proc [lindex $args 0]

      if {[info exists lib_spf_op_tool_param_check_list($calling_proc)]} {
      set list_pos [lsearch -exact $lib_spf_op_tool_param_check_list($calling_proc) $param]

      set lib_spf_op_tool_param_check_list($calling_proc) [lreplace [K $lib_spf_op_tool_param_check_list($calling_proc) [set list {}]] $list_pos $list_pos]
      }
    }
  } elseif {[llength $args] == 6} {
  #this is the case if the proc is called with 7 arguments

    foreach {condition exception action msg frequency calling_proc} $args {break}

    if {1 == 1 || [lsearch $lib_spf_valid_param_check_entires $calling_proc] > -1} {

      if {![info exists lib_spf_op_tool_param_check_list($calling_proc)] || [lsearch -exact $lib_spf_op_tool_param_check_list($calling_proc) $param] == -1} {
        lappend lib_spf_op_tool_param_check_list($calling_proc) $param
      }

      if {$exception != ""} {
        regsub -all "\\$" $exception "\\\$::" exception
        regsub -all "\\$" $condition "\\\$::" condition
        set tmp_condition "\[expr (\$::$param$condition) && !($exception)\]"
        regsub -all "\"" $tmp_condition "\\\"" tmp_condition
      } else {
        regsub -all "\\$" $condition "\\\$::" condition
        set tmp_condition "\[expr (\$::$param$condition)\]"
        regsub -all "\"" $tmp_condition "\\\"" tmp_condition
      }

      switch -- $action {
        "ERROR" {
          if {[llength $msg] != 2} {
            #Abort
          } else {
            regsub -all "\\$" $msg "\$::" msg
            set tmp_action "LIB_GE_error_message $msg"
            #puts tmp_action=$tmp_action
          }
        }
        "ABORT" {
          if {[llength $msg] != 2} {
            #Abort
          } else {
            regsub -all "\\$" $msg "\$::" msg
            set tmp_action "LIB_GE_abort_message $msg"
            #puts tmp_action=$tmp_action
          }
        }
        default {
          regsub -all "\\$" $msg "\$::" msg
          set tmp_action "$action $msg"
        }
      }

      switch [LIB_GE_string_toupper $frequency] {
        "ONCE_PER_OP" {
          set lib_spf_op_tool_param_check_array($param,$calling_proc) "if {!\[info exists lib_spf_op_tool_param_check_marker($param,$calling_proc,\$::mom_path_name)\]} {\nif {$tmp_condition} {\n$tmp_action ; set lib_spf_op_tool_param_check_marker($param,$calling_proc,\$::mom_path_name) 1 \n} \n}"
        }
        "ONCE_PER_TOOL" {
          set lib_spf_op_tool_param_check_array($param,$calling_proc) "if {!\[info exists lib_spf_op_tool_param_check_marker($param,$calling_proc,\$::mom_tool_name)\]} {\nif {$tmp_condition} {\n$tmp_action ; set lib_spf_op_tool_param_check_marker($param,$calling_proc,\$::mom_tool_name) 1 \n} \n}"
        }
        default {
          set lib_spf_op_tool_param_check_array($param,$calling_proc) "if {$tmp_condition} {\n$tmp_action\n}"
        }
      }

    } else {
      #Abort
    }
  } else {

    #Abort
  }

}
# <Documentation>
# This procedure checks the state of global variables at a specific position in the postprocessing run.
# For example, this procedure can be used to check if mom_tool_number ! = 0 or if mom_spindle_rpm > 0 in an operation.
#
# The procedure can be called in 2 ways:
#
# 1. To define a new check condition.
#
#   LIB_SPF_set_op_tool <param> <condition> <param> <condition> <exception> <action> <msg> <frequency> <calling_proc>
#
# 2. To disable a predefined check.
#
#   LIB_SPF_set_op_tool <param> <condition> <param> <calling_proc> <action>
#
# <Arguments>
# param
#   Global variable to be checked.
# args
#   List of arguments:
# condition
#   Condition to check the param argument against.
# exception
#   Logical expression that defines an exception for the previous defined condition
#   (if logical expression evaluates to 0 the condition is skipped).
# action
#   Defines the action to be performed if the condition evaluates to 1.
#   Valid options for Case 1 are:
#   ERROR - Calls the procedure LIB_GE_error_message with argument msg.
#   ABORT - Calls the procedure LIB_GE_abort_message with argument msg.
#   <other> - Value is treated as a TCLcommand. The argument msg is passed as an argument to that command.
#
# Valid options for Case 2 are:
#   Remove - Disable the previously defined check. This is the only valid option.
#
# msg
#   Message that is used in the action argument.
# frequency
#   Frequency with which the check is executed.
#   Valid options:
#   ONCE_PER_OP - Once for each operation.
#   ONCE_PER_TOOL - Once for each tool.
#   <other values> - Execute the default case without restrictions for the check
#   (for example, if the check is done in MOM_before_motion, then it happens for each motion).
#
# calling_proc
#   The procedure in the postprocessor this check executes.
#   (The entry points have to be predefined in the postprocessor procedures. The valid entries are listed
#   in lib_spf_valid_param_check_entires, see LIB_SPF_op_tool_param_condition.)
# <Returnvalue>
# None.
# <Example>
# name: Define a new check condition.
# code: LIB_SPF_set_op_tool_param_condition mom_tool_number {<1} {$mom_tool_name == "DUMMY"} {ERROR} {"THIS IS THE MESSAGE $mom_tool_name" "LINE2"} {ONCE_PER_TOOL} {MOM_before_motion}
# desc:
# This example generates a check like this:
#
#   if {![info exists lib_spf_op_tool_param_check_marker(mom_tool_number,MOM_before_motion,$::mom_tool_name)]} {
#     if {[expr ($::mom_tool_number<1) && !(\$::mom_tool_name == \"DUMMY\")]} {
#       LIB_GE_error_message "THIS IS THE MESSAGE $::mom_tool_name" "LINE2" ; set lib_spf_op_tool_param_check_marker(mom_tool_number,MOM_before_motion,$::mom_tool_name) 1
#     }
#   }
# <Example>
# name: Remove an existing check condition.
# code: LIB_SPF_set_op_tool_param_condition mom_tool_number MOM_before_motion remove
# desc: This example disables the check defined in Example 1.
#____________________________________________________________________________________________
proc LIB_SPF_op_tool_param_condition {} {

  global lib_spf_valid_param_check_entires
  global lib_spf_op_tool_param_check_array
  global lib_spf_op_tool_param_check_list
  global lib_flag

  set lib_spf_valid_param_check_entires "MOM_before_motion MOM_tool_change"

  if {[CONF_CTRL_tool check_zero_tool_number]} {
    #LIB_SPF_set_op_tool_param_condition param condition exception action msg frequency calling_proc
    LIB_SPF_set_op_tool_param_condition mom_tool_number {== 0} {} {ERROR} {"Tool number is missing at the INS->$mom_tool_name<- definition" "Please verify"} {ONCE_PER_TOOL} {MOM_tool_change}
  }

  LIB_SPF_custom_op_tool_param_condition

}
# <Internal Documentation>
#
#
#
# <Internal Example>
#
#
#
#____________________________________________________________________________________________
proc LIB_SPF_execute_op_tool_param_condition {calling_proc {position ""}} {

  global lib_spf_op_tool_param_check_array
  global lib_spf_op_tool_param_check_list
  global lib_spf_op_tool_param_check_marker

  if {$calling_proc == [info level -1]} {
    if {$position == ""} {
      set array_element $calling_proc
    } else {
      set array_element ${calling_proc},$position
    }

    if {[info exists lib_spf_op_tool_param_check_list($array_element)]} {
      foreach param $lib_spf_op_tool_param_check_list($array_element) {
        #puts $lib_spf_op_tool_param_check_array($param,$array_element)
        if {1} $lib_spf_op_tool_param_check_array($param,$array_element)
      }
    }

  } else {
    LIB_GE_error_message "MESSAGE FOR POSTWRITER" "the argument to 'LIB_SPF_execute_op_tool_param_condition' has to be the name of the calling proc"
  }
}
# <Documentation>
# This procedure executes the predefined condition checks, set in LIB_SPF_op_tool_param_condition and LIB_SPF_custom_op_tool_param_condition.
# The procedure can be called in any procedure. The argument has to be the name of the calling procedure.
# <Arguments>
# calling_proc
#   Name of the calling procedure.
# position
#   Defines the position to be checked.
# <Example>
# name: Example 1
# code: proc MOM_before_motion {} {
#   LIB_SPF_execute_op_tool_param_condition [info level 0]
#       }
# desc: [info level 0] uses the name of the current proc, in this example MOM_before_motion.
#____________________________________________________________________________________________
proc LIB_SPF_get_partnname {} {

  global lib_flag mom_part_name

  if {![info exists lib_flag(partname_type)]} {
    return [file tail $mom_part_name]
  }
}
# <Documentation>
# This procedure returns the part name.
# <Returnvalue>
# Part name.
# <Example>
# name: Example 1
# code: set result [LIB_SPF_get_partnname]
# desc: The variable result contains the name of the part
#____________________________________________________________________________________________
proc LIB_SPF_reset_motions_to_zero {{option "default"}} {
  global mom_prev_pos
  global mom_pos
  global mom_prev_out_angle_pos
  global mom_out_angle_pos
  global mom_prev_rot_ang_4th
  global mom_prev_rot_ang_5th
  global mom_rotation_angle
  switch $option {
    "trans" {
      set mom_prev_pos(0) 0.0
      set mom_prev_pos(1) 0.0
      set mom_prev_pos(2) 0.0
      set mom_pos(0) 0.0
      set mom_pos(1) 0.0
      set mom_pos(2) 0.0
    }
    "rot" {
      set mom_prev_pos(3) 0.0
      set mom_prev_pos(4) 0.0
      set mom_pos(3) 0.0
      set mom_pos(4) 0.0
      set mom_prev_out_angle_pos(0) 0.0
      set mom_prev_out_angle_pos(1) 0.0
      set mom_out_angle_pos(0) 0.0
      set mom_out_angle_pos(1) 0.0
      set mom_prev_rot_ang_4th 0.0
      set mom_prev_rot_ang_5th 0.0
      set mom_rotation_angle 0.0
    }
    "all" {
      set mom_prev_pos(0) 0.0
      set mom_prev_pos(1) 0.0
      set mom_prev_pos(2) 0.0
      set mom_prev_pos(3) 0.0
      set mom_prev_pos(4) 0.0
      set mom_pos(0) 0.0
      set mom_pos(1) 0.0
      set mom_pos(2) 0.0
      set mom_pos(3) 0.0
      set mom_pos(4) 0.0
      set mom_prev_out_angle_pos(0) 0.0
      set mom_prev_out_angle_pos(1) 0.0
      set mom_out_angle_pos(0) 0.0
      set mom_out_angle_pos(1) 0.0
      set mom_prev_rot_ang_4th 0.0
      set mom_prev_rot_ang_5th 0.0
      set mom_rotation_angle 0.0
    }
    "default" {
      set mom_prev_pos(3) 0.0
      set mom_prev_pos(4) 0.0
      set mom_pos(3) 0.0
      set mom_pos(4) 0.0
      set mom_prev_out_angle_pos(0) 0.0
      set mom_prev_out_angle_pos(1) 0.0
      set mom_out_angle_pos(0) 0.0
      set mom_out_angle_pos(1) 0.0
      set mom_prev_rot_ang_4th 0.0
      set mom_prev_rot_ang_5th 0.0
      set mom_rotation_angle 0.0
    }
  }
    MOM_reload_variable -a mom_prev_pos
    MOM_reload_variable -a mom_pos
    MOM_reload_variable -a mom_prev_out_angle_pos
    MOM_reload_variable -a mom_out_angle_pos
    MOM_reload_variable mom_prev_rot_ang_4th
    MOM_reload_variable mom_prev_rot_ang_5th
    MOM_reload_variable mom_rotation_angle
    MOM_reload_kinematics
}
# <Documentation>
# This procedure resets the values of the motion axes to zero. This is useful to calculate the kinematic
# values of the next operation based from zero.
# <Arguments>
# option
#   Axes values to be reset. Valid options are:
# trans - Reset translation values.
# rot - Reset rotary values.
# all - Reset all values.
# <Returnvalue>
# Nothing.
# <Example>
# LIB_SPF_reset_motions_to_zero rot
#____________________________________________________________________________________________
proc MOM_rotate {} {

  if {$::lib_ge_pretreatment_runtime} {
    return
  }

  set commandcheck(MOM_rotate_ENTRY) [llength [info commands MOM_rotate_ENTRY]]

  LIB_GE_command_buffer MOM_rotate_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_rotate_ENTRY)} {MOM_rotate_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_rotate_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_rotate_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_rotate_ENTRY)} {MOM_rotate_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the UDE Rotate is activated.
# mom_rotate_axis_type        : "TABLE","HEAD","AAXIS","BAXIS","CAXIS","FOURTH_AXIS","FIFTH_AXIS"
# mom_rotation_mode           : "NONE","ANGLE","ABSOLUTE","INCREMENTAL"
# mom_rotation_direction      : "CLW","CCLW","NONE"
# mom_rotation_angle          : <decimal value>
# mom_rotation_reference_mode : "FALSE" or "TRUE"
# mom_rotation_text           : <string value>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_rotate_LIB {} {

  global mom_rotate_axis_type mom_rotation_mode mom_rotation_direction
  global mom_rotation_angle mom_rotation_reference_mode mom_rotation_text
  global mom_machine_mode mom_prev_pos mom_pos mom_out_angle_pos
  global mom_prev_rot_ang_4th mom_prev_rot_ang_5th
  global lib_flag
  global pt_kin_4th_axis_type pt_kin_5th_axis_type
  global pt_kin_5th_axis_direction pt_kin_4th_axis_direction
  global pt_kin_machine_type pt_kin_4th_axis_leader pt_kin_5th_axis_leader
  global pt_kin_4th_axis_min_limit pt_kin_4th_axis_max_limit
  global pt_kin_5th_axis_min_limit pt_kin_5th_axis_max_limit
  global lib_rotate_angle lib_rotate_axis
  global mom_kin_4th_axis_vector pt_kin_5th_axis_vector

  if {![info exists pt_kin_machine_type]} {
    LIB_SPF_add_warning "UDE Rotate is not attached to an operation, this is not supported."
    return
  }

  if {$mom_machine_mode == "TURN" || $pt_kin_machine_type == "3_axis_mill"} {return}
  if {![info exists mom_rotation_angle]} {return}

  if {[string match "5_axis*" $pt_kin_machine_type] && [VEC3_is_equal mom_kin_4th_axis_vector pt_kin_5th_axis_vector]} {
    set 4th_axis_type $pt_kin_5th_axis_type
    set 5th_axis_type $pt_kin_4th_axis_type
    set 4th_axis_leader $pt_kin_5th_axis_leader
    set 5th_axis_leader $pt_kin_4th_axis_leader
  } else {
    set 4th_axis_type $pt_kin_4th_axis_type
    set 5th_axis_type $pt_kin_5th_axis_type
    set 4th_axis_leader $pt_kin_4th_axis_leader
    set 5th_axis_leader $pt_kin_5th_axis_leader
  }

  switch $mom_rotate_axis_type {
    "TABLE" {
      if {$4th_axis_type != "Table" && $5th_axis_type != "Table"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "No table rotary axis defined"
      }
      if {$4th_axis_type == "Table" && $5th_axis_type == "Table"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "2 table rotary axes defined as a table"
      }
      if {$4th_axis_type == "Table"} {
        set lib_rotate_axis 3
      } else {
        set lib_rotate_axis 4
      }
    }
    "HEAD" {
      if {$4th_axis_type != "Head" && $5th_axis_type != "Head"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "No head rotary axis defined"
      }
      if {$4th_axis_type == "Head" && $5th_axis_type == "Head"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "2 head rotary axes defined"
      }
      if {4th_axis_type == "Head"} {
        set lib_rotate_axis 3
      } else {
        set lib_rotate_axis 4
      }
    }
    "AAXIS" {
      if {$4th_axis_leader != "A" && $5th_axis_leader != "A"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "No rotary axis A defined"
      }
      if {$4th_axis_leader == "A"} {
        set lib_rotate_axis 3
      } else {
        set lib_rotate_axis 4
      }
    }
    "BAXIS" {
      if {$4th_axis_leader != "B" && $5th_axis_leader != "B"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "No rotary axis B defined"
      }
      if {$4th_axis_leader == "B"} {
        set lib_rotate_axis 3
      } else {
        set lib_rotate_axis 4
      }
    }
    "CAXIS" {
      if {$4th_axis_leader != "C" && $5th_axis_leader != "C"} {
        LIB_GE_abort_message "Wrong parameter with UDE Rotate" "No rotary axis C defined"
      }
      if {$4th_axis_leader == "C"} {
        set lib_rotate_axis 3
      } else {
        set lib_rotate_axis 4
      }
    }
    "FOURTH_AXIS" {
      if {[string match "5_axis*" $pt_kin_machine_type] && [VEC3_is_equal mom_kin_4th_axis_vector pt_kin_5th_axis_vector]} {
        set lib_rotate_axis 4
      } else {
        set lib_rotate_axis 3
      }
    }
    "FIFTH_AXIS" {
      if {[string match "5_axis*" $pt_kin_machine_type] && [VEC3_is_equal mom_kin_4th_axis_vector pt_kin_5th_axis_vector]} {
        set lib_rotate_axis 3
      } else {
        set lib_rotate_axis 4
      }
    }
    "default" {
      LIB_GE_abort_message "Wrong parameter with UDE Rotate" "INS->$mom_rotate_axis_type<- not supported"
    }
  }

  switch $mom_rotation_mode {
    "NONE" -
    "ATANGLE" -
    "ANGLE" -
    "ABSOLUTE" {
      set lib_rotate_angle $mom_rotation_angle
    }
    "INCREMENTAL" {
      if {$mom_rotation_direction == "CCLW"} {
        set lib_rotate_angle [expr $mom_pos($lib_rotate_axis) - $mom_rotation_angle]
      } else {
        set lib_rotate_angle [expr $mom_pos($lib_rotate_axis) + $mom_rotation_angle]
      }
    }
  }

  switch $lib_rotate_axis {
    3  {
      if { ![info exists mom_prev_rot_ang_4th] } {set mom_prev_rot_ang_4th 0.0}

      set mom_prev_pos(3) [LIMIT_ANGLE $lib_rotate_angle]
      if {$mom_rotation_reference_mode} {
        ## Hes 01.03.2019 following lines are only needed if we output the angle (this is for reference only)
        ##if {[EQ_is_lt $lib_rotate_angle $pt_kin_4th_axis_min_limit] || [EQ_is_gt $lib_rotate_angle $pt_kin_4th_axis_max_limit]} {
        ##  LIB_GE_abort_message "Wrong parameter with UDE Rotate" "Position is outside of rotary axis limits"
        ##}
      } else {
        set mom_pos(3) [LIMIT_ANGLE $lib_rotate_angle]
        set mom_out_angle_pos(0) $lib_rotate_angle
        if {[EQ_is_lt $mom_out_angle_pos(0) $pt_kin_4th_axis_min_limit] || [EQ_is_gt $mom_out_angle_pos(0) $pt_kin_4th_axis_max_limit]} {
          LIB_GE_abort_message "Wrong parameter with UDE Rotate" "Position is outside of rotary axis limits"
        }
      }
      set mom_prev_rot_ang_4th $lib_rotate_angle
    }
    4  {
      if { ![info exists mom_prev_rot_ang_5th] } {set mom_prev_rot_ang_5th 0.0}

      set mom_prev_pos(4) [LIMIT_ANGLE $lib_rotate_angle]
      if {$mom_rotation_reference_mode} {
        ## Hes 01.03.2019 following lines are only needed if we output the angle (this is for reference only)
        ##if {[EQ_is_lt $lib_rotate_angle $pt_kin_5th_axis_min_limit] || [EQ_is_gt $lib_rotate_angle $pt_kin_5th_axis_max_limit]} {
        ##  LIB_GE_abort_message "Wrong parameter with UDE Rotate" "Position is outside of rotary axis limits"
        ##}
      } else {
        set mom_pos(4) [LIMIT_ANGLE $lib_rotate_angle]
        set mom_out_angle_pos(1) $lib_rotate_angle
        if {[EQ_is_lt $mom_out_angle_pos(1) $pt_kin_5th_axis_min_limit] || [EQ_is_gt $mom_out_angle_pos(1) $pt_kin_5th_axis_max_limit]} {
          LIB_GE_abort_message "Wrong parameter with UDE Rotate" "Position is out of the rotary axis limit"
        }
      }
      set mom_prev_rot_ang_5th $lib_rotate_angle
    }
  }

  if {$mom_rotation_reference_mode == "OFF"} {
    LIB_CTRL_rotate_axis
  }

  #force rewrite plane after rotate ude - bug #1356
  set lib_flag(tool_path_motion) 0
  if {$lib_flag(mode_current_status) == "pos"} {
    LIB_ROTARY_positioning_reset
  } elseif {$lib_flag(mode_current_status) == "sim"} {
    LIB_ROTARY_simultaneous_reset
  } else {
    set lib_flag(mode_current_status) "std"
  }

  MOM_reload_variable -a mom_prev_pos
  MOM_reload_variable -a mom_out_angle_pos
  MOM_reload_variable mom_prev_rot_ang_4th
  MOM_reload_variable mom_prev_rot_ang_5th

}
# <Internal Documentation>
# This procedure is executed when the UDE Rotate is activated.
# mom_rotate_axis_type        : "TABLE","HEAD","AAXIS","BAXIS","CAXIS","FOURTH_AXIS","FIFTH_AXIS"
# mom_rotation_mode           : "NONE","ANGLE","ABSOLUTE","INCREMENTAL"
# mom_rotation_direction      : "CLW","CCLW","NONE"
# mom_rotation_angle          : <decimal value>
# mom_rotation_reference_mode : "FALSE" or "TRUE"
# mom_rotation_text           : <string value>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_zero {} {

  if {$::lib_ge_pretreatment_runtime} {PT_zero ; return}

  set commandcheck(MOM_zero_ENTRY) [llength [info commands MOM_zero_ENTRY]]

  LIB_GE_command_buffer MOM_zero_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_zero_ENTRY)} {MOM_zero_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_zero_LIB]]} {
    MOM_zero_LIB
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_zero_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_zero_ENTRY)} {MOM_zero_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the synch event
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_clamp {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_clamp_ENTRY) [llength [info commands MOM_clamp_ENTRY]]

  LIB_GE_command_buffer MOM_clamp_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_clamp_ENTRY)} {MOM_clamp_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_clamp_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_clamp_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_clamp_ENTRY)} {MOM_clamp_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the UDE Clamp is activated.
# mom_clamp_axis    : "XAXIS","YAXIS","ZAXIS","AAXIS","BAXIS","CAXIS","AUTO"
# mom_clamp_status  : "ON","OFF","AXIS ON","AXIS OFF"
# mom_clamp_text    : <string value>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_clamp_LIB {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_clamp_axis mom_clamp_status mom_clamp_text
  global pt_kin_4th_axis_leader pt_kin_5th_axis_leader mom_kin_machine_type

  switch -- $mom_clamp_axis {
    "XAXIS" -
    "YAXIS" -
    "ZAXIS" {
      LIB_SPF_add_warning "Parameter INS->$mom_clamp_axis<- with UDE Clamp not yet supported"
    }
    "AAXIS" -
    "BAXIS" -
    "CAXIS" {
      if {[string range $pt_kin_4th_axis_leader 0 0] != [string range $mom_clamp_axis 0 0] && [string range $pt_kin_5th_axis_leader 0 0] != [string range $mom_clamp_axis 0 0]} {
        LIB_GE_abort_message "Wrong parameter with UDE Clamp" "No rotary axis [string range $mom_clamp_axis 0 0] defined"
      }
      if {[string range $pt_kin_4th_axis_leader 0 0] == [string range $mom_clamp_axis 0 0]} {
        switch -- $mom_clamp_status {
          "ON" -
          "AXISON" -
          "AXIS ON" {
            CONF_CTRL_clamp set fourth_axis 1
          }
          "OFF" -
          "AXISOFF" -
          "AXIS OFF" {
            CONF_CTRL_clamp set fourth_axis 0
          }
        }
      } else {
        switch -- $mom_clamp_status {
          "ON" -
          "AXISON" -
          "AXIS ON" {
            CONF_CTRL_clamp set fifth_axis 1
          }
          "OFF" -
          "AXISOFF" -
          "AXIS OFF" {
            CONF_CTRL_clamp set fifth_axis 0
          }
        }
      }
    }

    "AUTO"  {
      switch -- $mom_clamp_status {
        "ON" -
        "AXISON" -
        "AXIS ON" {
          CONF_CTRL_clamp set status 1
          # PR9233392: Output right clamp code in auto mode according to machine type
          if {[string match "4th_axis*" $mom_kin_machine_type]} {
            CONF_CTRL_clamp set fourth_axis 1
          } elseif {[string match "*5_axis*" $mom_kin_machine_type]} {
            CONF_CTRL_clamp set fourth_axis 1
            CONF_CTRL_clamp set fifth_axis  1
          }
        }
        "OFF" -
        "AXISOFF" -
        "AXIS OFF" {
          CONF_CTRL_clamp set status 0
          if {[string match "4th_axis*" $mom_kin_machine_type]} {
            CONF_CTRL_clamp set fourth_axis 0
          } elseif {[string match "*5_axis*" $mom_kin_machine_type]} {
            CONF_CTRL_clamp set fourth_axis 0
            CONF_CTRL_clamp set fifth_axis  0
          }
        }
      }
    }
  }
}
# <Internal Documentation>
# This procedure is executed when the UDE Clamp is activated.
# mom_clamp_axis    : "XAXIS","YAXIS","ZAXIS","AAXIS","BAXIS","CAXIS","AUTO"
# mom_clamp_status  : "ON","OFF","AXIS ON","AXIS OFF"
# mom_clamp_text    : <string value>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lock_axis {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_lock_axis_ENTRY) [llength [info commands MOM_lock_axis_ENTRY]]

  LIB_GE_command_buffer MOM_lock_axis_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lock_axis_ENTRY)} {MOM_lock_axis_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_lock_axis_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lock_axis_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lock_axis_ENTRY)} {MOM_lock_axis_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the UDE Lock Axis is activated.
# mom_lock_axis   : "XAXIS","YAXIS","ZAXIS","AAXIS","BAXIS","CAXIS","FOURTH","FIFTH","OFF"
# mom_lock_axis_plane : "NONE","XYPLANE","YZPLANE","ZXPLANEF"
# mom_lock_axis_value : <string value>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lock_axis_LIB {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_lock_axis mom_lock_axis_plane mom_lock_axis_value mom_coordinate_output_mode mom_kin_is_turbo_output
  global mom_polar_status lib_flag polar_vector_ref mom_lock_axis_value_defined

  # default
  set mom_polar_status ON
  if {$lib_flag(first_transmit_move) == 0} {set lib_flag(tool_path_motion) 0}

  switch -- $mom_lock_axis {
    "XAXIS" {
      switch -- $mom_lock_axis_plane {
        "XYPLAN" {CONF_CTRL_moves set polar_vector_ref "Y+"}
        "YZPLAN" {LIB_SPF_add_warning "UDE \"Lock Axis\" $mom_lock_axis and $mom_lock_axis_plane not supported"}
        "ZXPLAN" {CONF_CTRL_moves set polar_vector_ref "Z+"}
        "NONE"    {CONF_CTRL_moves set polar_vector_ref "Y+"}
        }
      }
    "YAXIS" {
      switch -- $mom_lock_axis_plane {
        "XYPLAN" {CONF_CTRL_moves set polar_vector_ref "X+"}
        "YZPLAN" {CONF_CTRL_moves set polar_vector_ref "Z+"}
        "ZXPLAN" {LIB_SPF_add_warning "UDE \"Lock Axis\" $mom_lock_axis and $mom_lock_axis_plane not supported"}
        "NONE"    {CONF_CTRL_moves set polar_vector_ref "X+"}
        }
      }
    "ZAXIS" {
      switch -- $mom_lock_axis_plane {
        "XYPLAN" {LIB_SPF_add_warning "UDE \"Lock Axis\" $mom_lock_axis and $mom_lock_axis_plane not supported"}
        "YZPLAN" {CONF_CTRL_moves set polar_vector_ref "Y+"}
        "ZXPLAN" {CONF_CTRL_moves set polar_vector_ref "X+"}
        "NONE"    {CONF_CTRL_moves set polar_vector_ref "X+"}
        }
      }
    "AAXIS" -
    "BAXIS" -
    "CAXIS" -
    "FOURTH" -
    "FIFTH" {
      LIB_SPF_add_warning "UDE \"Lock Axis\" $mom_lock_axis not supported"
    }
    "OFF" {
      set mom_polar_status OFF
    }
  }
  if {[info exist mom_lock_axis_value_defined] && $mom_lock_axis_value_defined == 1} {
    switch -- $mom_lock_axis_plane {
      "XYPLAN" {array set polar_vector_ref "0 [expr cos($mom_lock_axis_value * $::DEG2RAD)] 1 [expr sin($mom_lock_axis_value * $::DEG2RAD)] 2 0.0"}
      "YZPLAN" {array set polar_vector_ref "0 0.0 1 [expr cos($mom_lock_axis_value * $::DEG2RAD)] 2 [expr sin($mom_lock_axis_value * $::DEG2RAD)]"}
      "ZXPLAN" {array set polar_vector_ref "0 [expr sin($mom_lock_axis_value * $::DEG2RAD)] 1 0.0 2 [expr cos($mom_lock_axis_value * $::DEG2RAD)]"}
    }
    CONF_CTRL_moves set polar_vector_ref "ANGLE"
  } else {
    set mom_lock_axis_value 0
  }
  set mom_coordinate_output_mode $mom_polar_status

  if {[CONF_CTRL_moves polar_feedrate] == 0} {
    CONF_CTRL_moves set polar_feedrate 1
    set ::lib_flag(polar_feedrate_off) 1
  }

  if {$mom_polar_status == "ON"} {
      if { [info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE" } {
        if {[llength [info commands LIB_CTRL_config_turbo]]} {
          set ::mom_sys_linear_turbo_command "TRUE"
          set ::mom_sys_rapid_turbo_command "TRUE"
          LIB_CTRL_config_turbo
        } else {
          LIB_SPF_turbo_status "disable"
        }
      } elseif {$::mom_kin_is_turbo_output == "TRUE"} {
        LIB_SPF_turbo_status "disable"
    }
  }
}
# <Internal Documentation>
# This procedure is executed when the UDE Lock Axis is activated.
# mom_lock_axis   : "XAXIS","YAXIS","ZAXIS","AAXIS","BAXIS","CAXIS","FOURTH","FIFTH","OFF"
# mom_lock_axis_plane : "NONE","XYPLANE","YZPLANE","ZXPLANEF"
# mom_lock_axis_value : <string value>
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_polar {} {

  if {$::mom_coordinate_output_mode == "ON"} {
    LIB_SPF_reset_motions_to_zero "rot"
  }

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_set_polar_ENTRY) [llength [info commands MOM_set_polar_ENTRY]]

  LIB_GE_command_buffer MOM_set_polar_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_polar_ENTRY)} {MOM_set_polar_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_set_polar_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_set_polar_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_set_polar_ENTRY)} {MOM_set_polar_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the UDE Set Polar is activated.
# mom_coordinate_output_mode  : "ON","OFF"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_set_polar_LIB {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  global mom_coordinate_output_mode
  global mom_polar_status
  global lib_flag

  # default
  set mom_polar_status $mom_coordinate_output_mode

  if {$mom_polar_status == "ON"} {
    if {$lib_flag(first_transmit_move) == 0} {set lib_flag(tool_path_motion) 0}
    if { [info exists ::mom_sys_advanced_turbo_output] && $::mom_sys_advanced_turbo_output == "TRUE" } {
      if {[llength [info commands LIB_CTRL_config_turbo]]} {
        set ::mom_sys_linear_turbo_command "TRUE"
        set ::mom_sys_rapid_turbo_command "TRUE"
        LIB_CTRL_config_turbo
      } else {
        LIB_SPF_turbo_status "disable"
      }
    } elseif {$::mom_kin_is_turbo_output == "TRUE"} {
      LIB_SPF_turbo_status "disable"
    }
  }
}
# <Internal Documentation>
# This procedure is executed when the UDE Set Polar is activated.
# mom_coordinate_output_mode  : "ON","OFF"
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lintol {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_lintol_ENTRY) [llength [info commands MOM_lintol_ENTRY]]

  LIB_GE_command_buffer MOM_lintol_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lintol_ENTRY)} {MOM_lintol_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_lintol_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lintol_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lintol_ENTRY)} {MOM_lintol_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when the UDE lintol is activated.
# mom_lintol_status : "ON","OFF"
# mom_lintol    : tolerance value
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lintol_LIB {} {

  global mom_kin_linearization_flag
  global mom_kin_linearization_tol
  global mom_lintol_status
  global mom_lintol

  if { ![string compare "ON" $mom_lintol_status] } {
    set mom_kin_linearization_flag "1"
    if { [info exists mom_lintol] } {
      set mom_kin_linearization_tol $mom_lintol
    }
  } elseif { ![string compare "OFF" $mom_lintol_status] } {
    set mom_kin_linearization_flag "0"
  }

}

# <Internal Documentation>
# This procedure is called with MOM_lintol.
# mom_lintol_status : "ON","OFF"
# mom_lintol    : tolerance value
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIMIT_ANGLE {a} {

  set a [expr fmod($a,360)]
  set a [expr ($a < 0) ? ($a + 360) : $a]

  return $a
}
# <Internal Documentation>
# Procedure defined in tcl file with post configurator structure
# Copied in NGMK environment and necessary when post configurator structure is not used
#
# <Internal Example>
# [LIMIT_ANGLE $lib_rotate_angle]
#____________________________________________________________________________________________
proc LIB_SPF_check_decompose_first_move {} {
  global mom_prev_pos mom_pos
  global tool_axis lib_flag

  if {$lib_flag(decompose_first_move_for_each_tool_path) == 0 || [LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS"} {return}

  if {$lib_flag(tool_path_motion) != 0} {
    # check level previous plane / current plane
    if {[EQ_is_lt $mom_prev_pos($tool_axis) $mom_pos($tool_axis)]} {
      set lib_flag(tool_path_motion) 1
      set lib_flag(current_plane_upper_than_previous) 1
    } elseif {[EQ_is_gt $mom_prev_pos($tool_axis) $mom_pos($tool_axis)]} {
      set lib_flag(tool_path_motion) 1
      set lib_flag(current_plane_upper_than_previous) 0
    }
  }
}
# <Internal Documentation>
# This proc is called with MOM_first_move_LIB and set lib_flag(current_plane_upper_than_previous) if it's necessary
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_change {} {
  if {$::lib_ge_pretreatment_runtime} {PT_tool_change ; return}

  set commandcheck(MOM_probe_change_ENTRY) [llength [info commands MOM_probe_change_ENTRY]]

  LIB_GE_command_buffer MOM_probe_change_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_change_ENTRY)} {MOM_probe_change_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_probe_change_LIB]]} {
    MOM_probe_change_LIB
  } else {
    MOM_tool_change
  }

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_change_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_change_ENTRY)} {MOM_probe_change_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe tool change
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_protected_move {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  LIB_SPF_add_general_motion_handling

  set commandcheck(MOM_probe_protected_move_ENTRY) [llength [info commands MOM_probe_protected_move_ENTRY]]

  LIB_GE_command_buffer MOM_probe_protected_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_protected_move_ENTRY)} {MOM_probe_protected_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_protected_move_LIB]]} {MOM_probe_protected_move_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_protected_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_protected_move_ENTRY)} {MOM_probe_protected_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe protected move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_single_direction_point {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_probe_single_direction_point_ENTRY) [llength [info commands MOM_probe_single_direction_point_ENTRY]]

  LIB_GE_command_buffer MOM_probe_single_direction_point_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_single_direction_point_ENTRY)} {MOM_probe_single_direction_point_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_single_direction_point_LIB]]} {MOM_probe_single_direction_point_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_single_direction_point_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_single_direction_point_ENTRY)} {MOM_probe_single_direction_point_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe single direction point
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_angled_surface_point {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_probe_angled_surface_point_ENTRY) [llength [info commands MOM_probe_angled_surface_point_ENTRY]]

  LIB_GE_command_buffer MOM_probe_angled_surface_point_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_angled_surface_point_ENTRY)} {MOM_probe_angled_surface_point_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_angled_surface_point_LIB]]} {MOM_probe_angled_surface_point_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_angled_surface_point_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_angled_surface_point_ENTRY)} {MOM_probe_angled_surface_point_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe single direction point
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_three_point_bore {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_probe_three_point_bore_ENTRY) [llength [info commands MOM_probe_three_point_bore_ENTRY]]

  LIB_GE_command_buffer MOM_probe_three_point_bore_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_three_point_bore_ENTRY)} {MOM_probe_three_point_bore_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_three_point_bore_LIB]]} {MOM_probe_three_point_bore_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_three_point_bore_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_three_point_bore_ENTRY)} {MOM_probe_three_point_bore_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe three point bore
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_three_point_boss {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_probe_three_point_boss_ENTRY) [llength [info commands MOM_probe_three_point_boss_ENTRY]]

  LIB_GE_command_buffer MOM_probe_three_point_boss_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_three_point_boss_ENTRY)} {MOM_probe_three_point_boss_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_three_point_boss_LIB]]} {MOM_probe_three_point_boss_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_three_point_boss_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_three_point_boss_ENTRY)} {MOM_probe_three_point_boss_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe three point boss
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_four_point_bore {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_probe_four_point_bore_ENTRY) [llength [info commands MOM_probe_four_point_bore_ENTRY]]

  LIB_GE_command_buffer MOM_probe_four_point_bore_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_four_point_bore_ENTRY)} {MOM_probe_four_point_bore_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_four_point_bore_LIB]]} {MOM_probe_four_point_bore_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_four_point_bore_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_four_point_bore_ENTRY)} {MOM_probe_four_point_bore_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe four point hole
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_four_point_boss {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_probe_four_point_boss_ENTRY) [llength [info commands MOM_probe_four_point_boss_ENTRY]]

  LIB_GE_command_buffer MOM_probe_four_point_boss_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_four_point_boss_ENTRY)} {MOM_probe_four_point_boss_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_probe_four_point_boss_LIB]]} {MOM_probe_four_point_boss_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_four_point_boss_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_four_point_boss_ENTRY)} {MOM_probe_four_point_boss_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe four point boss
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_calibrate_sphere {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_calibrate_sphere_ENTRY) [llength [info commands MOM_calibrate_sphere_ENTRY]]

  LIB_GE_command_buffer MOM_calibrate_sphere_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_sphere_ENTRY)} {MOM_calibrate_sphere_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_calibrate_sphere_LIB]]} {MOM_calibrate_sphere_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_calibrate_sphere_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_sphere_ENTRY)} {MOM_calibrate_sphere_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at calibrate sphere
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_calibrate_stylus_radius {} {
  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_calibrate_stylus_radius_ENTRY) [llength [info commands MOM_calibrate_stylus_radius_ENTRY]]

  LIB_GE_command_buffer MOM_calibrate_stylus_radius_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_stylus_radius_ENTRY)} {MOM_calibrate_stylus_radius_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_calibrate_stylus_radius_LIB]]} {MOM_calibrate_stylus_radius_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_calibrate_stylus_radius_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_stylus_radius_ENTRY)} {MOM_calibrate_stylus_radius_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at calibrate stylus radius
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_calibrate_stylus_offsets {} {
  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_calibrate_stylus_offsets_ENTRY) [llength [info commands MOM_calibrate_stylus_offsets_ENTRY]]

  LIB_GE_command_buffer MOM_calibrate_stylus_offsets_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_stylus_offsets_ENTRY)} {MOM_calibrate_stylus_offsets_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_calibrate_stylus_offsets_LIB]]} {MOM_calibrate_stylus_offsets_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_calibrate_stylus_offsets_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_stylus_offsets_ENTRY)} {MOM_calibrate_stylus_offsets_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at calibrate stylus offsets
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_multi_stylus_load {} {
  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_probe_multi_stylus_load_ENTRY) [llength [info commands MOM_probe_multi_stylus_load_ENTRY]]

  LIB_GE_command_buffer MOM_probe_multi_stylus_load_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_multi_stylus_load_ENTRY)} {MOM_probe_multi_stylus_load_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_probe_multi_stylus_load_LIB]]} {MOM_probe_multi_stylus_load_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_multi_stylus_load_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_multi_stylus_load_ENTRY)} {MOM_probe_multi_stylus_load_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe multi stylus load
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_probe_multi_stylus_store {} {
  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_probe_multi_stylus_store_ENTRY) [llength [info commands MOM_probe_multi_stylus_store_ENTRY]]

  LIB_GE_command_buffer MOM_probe_multi_stylus_store_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_multi_stylus_store_ENTRY)} {MOM_probe_multi_stylus_store_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_probe_multi_stylus_store_LIB]]} {MOM_probe_multi_stylus_store_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_probe_multi_stylus_store_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_probe_multi_stylus_store_ENTRY)} {MOM_probe_multi_stylus_store_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at probe multi stylus load
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_calibrate_probe_length {} {
  if {$::lib_ge_pretreatment_runtime} {PT_linear_move ; return}

  set commandcheck(MOM_calibrate_probe_length_ENTRY) [llength [info commands MOM_calibrate_probe_length_ENTRY]]

  LIB_GE_command_buffer MOM_calibrate_probe_length_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_probe_length_ENTRY)} {MOM_calibrate_probe_length_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling

  if {[llength [info commands MOM_calibrate_probe_length_LIB]]} {MOM_calibrate_probe_length_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_calibrate_probe_length_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_calibrate_probe_length_ENTRY)} {MOM_calibrate_probe_length_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at calibrate probe length
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_start_of_thread {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_start_of_thread_ENTRY) [llength [info commands MOM_start_of_thread_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_thread_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_ENTRY)} {MOM_start_of_thread_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_start_of_thread_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_thread_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_thread_ENTRY)} {MOM_start_of_thread_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at start of thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_lathe_thread_ENTRY) [llength [info commands MOM_lathe_thread_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_ENTRY)} {MOM_lathe_thread_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_lathe_thread_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_ENTRY)} {MOM_lathe_thread_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at lathe thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_lathe_thread_move {} {

  global mom_machine_control_use_machine_cycle
  global mom_return_status mom_return_method

  if {$::lib_ge_pretreatment_runtime} {return}

  if {[info exists mom_machine_control_use_machine_cycle] && $mom_machine_control_use_machine_cycle == 1} {
    # Bug #2224
    LIB_GE_command_buffer FIX_THREAD_MOVE_FOR_MACHINE_CYCLE
    LIB_GE_command_buffer {
      # mom_return_method :
      #0=auto
      #1=direct
      #2=radial>axial
      #3=axial>radial
      #4=clear-radial>direct
      #5=clear-axial>direct
      #6=clear-radial
      #7=clear-axial

      MOM_force once X Z
      #suprress Z when first return move is an radial move because end of Cycle97 is at start of thread, not at end of thread.
      # (NX toolpath is wrong for this case, (IR 10035813) )
      if {$mom_return_status == 1 && ($mom_return_method == 2 || $mom_return_method == 4 || $mom_return_method == 6)} {
        MOM_suppress once Z
      }
      MOM_rapid_move
    } @FIX_THREAD_CYCLE
    LIB_GE_command_buffer_output
    return
  }

  set commandcheck(MOM_lathe_thread_move_ENTRY) [llength [info commands MOM_lathe_thread_move_ENTRY]]

  LIB_GE_command_buffer MOM_lathe_thread_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_ENTRY)} {MOM_lathe_thread_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  LIB_SPF_add_general_motion_handling
  MOM_lathe_thread_move_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_lathe_thread_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_lathe_thread_move_ENTRY)} {MOM_lathe_thread_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at lathe thread move
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_end_of_thread {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_end_of_thread_ENTRY) [llength [info commands MOM_end_of_thread_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_thread_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_ENTRY)} {MOM_end_of_thread_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  MOM_end_of_thread_LIB

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_thread_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_thread_ENTRY)} {MOM_end_of_thread_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at end of thread
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc MOM_tracking_point_change {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_tracking_point_change_ENTRY) [llength [info commands MOM_tracking_point_change_ENTRY]]

  LIB_GE_command_buffer MOM_tracking_point_change_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_tracking_point_change_ENTRY)} {MOM_tracking_point_change_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer TOOL_ADJUST
  LIB_GE_command_buffer {
    if {[info exists ::lib_tool_length_adjust_template]} {
      MOM_do_template $::lib_tool_length_adjust_template
    } else {
      MOM_do_template tool_length_adjust
    }
  } @OUTPUT
  LIB_GE_command_buffer_output
  LIB_GE_command_buffer FORCE
  LIB_GE_command_buffer {
    # Foce output of linear axes, to make sure if only tracking point changed without linear axes
    # position change, there is a motion.
    MOM_force Once X Y Z
  } @OUTPUT
  LIB_GE_command_buffer_output

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_tracking_point_change_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_tracking_point_change_ENTRY)} {MOM_tracking_point_change_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed when tracking point changed in Generic motion operation.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_center_of_ball_output {} {

  global lib_ge_env mom_contact_status mom_cut_data_type

  # The calculation is automated done after NX10
  if {$lib_ge_env(major_version) > 10} {return}
  # Workaround
  # Ball center output is only allowed in surface contouring with contact data
  if {![info exist mom_cut_data_type] || $mom_cut_data_type != "centerline and contact point" } {return}

  # When desired, compute ball center points for non cutting moves
  if {[CONF_SPF_setting output_ball_center] && ![string match "ON" $mom_contact_status]} {

    LIB_SPF_compute_ball_center

    # Fake contact status to trigger calculation below
    set mom_contact_status ON
  }

  if { [string match "ON" $mom_contact_status] } {

    global mom_pos mom_motion_type
    global mom_ball_center
    global mom_current_motion
    global mom_arc_center
    global mom_prev_pos

    # Special handling for ENGAGE
    if { [string match "ENGAGE" $mom_motion_type] } {
      LIB_SPF_compute_ball_center
    }

    if { [string match "circular_move" $mom_current_motion] } {

      set d(0) [expr $mom_pos(0) - $mom_ball_center(0)]
      set d(1) [expr $mom_pos(1) - $mom_ball_center(1)]
      set d(2) [expr $mom_pos(2) - $mom_ball_center(2)]

      set mom_arc_center(0) [expr $mom_arc_center(0) - $d(0)]
      set mom_arc_center(1) [expr $mom_arc_center(1) - $d(1)]
      set mom_arc_center(2) [expr $mom_arc_center(2) - $d(2)]

      set mom_prev_pos(0) [expr $mom_prev_pos(0) - $d(0)]
      set mom_prev_pos(1) [expr $mom_prev_pos(1) - $d(1)]
      set mom_prev_pos(2) [expr $mom_prev_pos(2) - $d(2)]
    }

    set mom_pos(0) $mom_ball_center(0)
    set mom_pos(1) $mom_ball_center(1)
    set mom_pos(2) $mom_ball_center(2)
  }

}
# <Internal Documentation>
# This command will output center of ball in every linear,
# circular and rapid move block.
#
# This function is only valid for the Fixed and Variable Axis
# Surfacing Contouring modules in NX2 or newer.
#
# You will also need to toggle on the Output Contact Data option
# on the Machine Control or Non Cutting Moves (More tab) dialog.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_compute_ball_center { } {

  global mom_kin_machine_type mom_tool_axis mom_spindle_axis
  global mom_ball_center mom_pos mom_tool_corner1_radius

  if [string match "3_axis*" $mom_kin_machine_type] {
    VMOV 3 mom_tool_axis spindle_axis
  } else {
    VMOV 3 mom_spindle_axis spindle_axis
  }

  foreach i {0 1 2} {
    set mom_ball_center($i) [expr $mom_pos($i) + $mom_tool_corner1_radius*$spindle_axis($i)]
  }
}
# <Internal Documentation>
# This procedure is executed at LIB_SPF_center_of_ball_output
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_ini_open_files {} {

  global lib_spf mom_multi_channel_mode

  set commandcheck(LIB_SPF_ini_init_files) [llength [info commands LIB_SPF_ini_init_files]]

  LIB_SPF_ini_init_files

  if {![info exists lib_spf(ini,multi_channel)]} {
      set lib_spf(ini,multi_channel) "No"
        }
  if {[info exists mom_multi_channel_mode]} {
      set lib_spf(ini,multi_channel) "Yes"
  }


  LIB_GE_command_buffer LIB_SPF_ini_init_files
  LIB_GE_command_buffer {if {$commandcheck(LIB_SPF_ini_init_files)} {LIB_SPF_ini_init_files}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

  switch -- $lib_spf(ini,create) {
    "No" -
    0 {}
    "Yes" -
    1 -
    default {
      LIB_CONF_do_prop_custom_proc CONF_SPF_file ctrl_ini_get_tool_info
      LIB_CONF_do_prop_custom_proc CONF_SPF_file ctrl_ini_get_mcs_info
      LIB_SPF_ini_output_file
    }
  }
}
proc LIB_SPF_ini_output_file {} {

  global mom_output_file_basename
  global mom_part_name lib_ge_env lib_spf
  global mom_event_handler_file_name
  global isv_ini_tool_info
  global isv_ini_mcs_info
  global mom_kin_output_unit
  global mom_warning_info
  global isv_ini_file_dir
  global isv_ini_tool_count
  global mom_multi_channel_mode
  global mom_definition_file_name
  global ini_file_channel_number

  # Check to see if mom_part_name contains '\.prt' char - if so must not be runnning in Teamcenter (IMAN type string)
  set extension [file extension $mom_part_name]
  if {[string match -nocase "\.prt" $extension]} {
    set isv_ini_run_mode "NATIVE"
  } else {
    set isv_ini_run_mode "TEAMCENTER"
  }

  # Get ini file output directory
  #2015-11-20 szl - Enhance ini file output directory handling
  #2016-01-15 lili - Reset lib_spf(ini,location) by checking if UGII_CSE_USER_DIR is set up
  #                  UGII_CSE_USER_DIR is setup  --  set lib_spf(ini,location) to ENV
  if {![info exists lib_spf(ini,location)]} {set lib_spf(ini,location) "Part"}
  if {$lib_ge_env(cam_cse_user_dir) != ""} {
    set lib_spf(ini,location) "ENV"
  }
  switch -- $lib_spf(ini,location) {
    "CSE" {
            set post_dir "[file dirname $mom_definition_file_name]/"
      regsub "/postprocessor/" $post_dir "/cse_driver/" ini_dir
    }
    "ENV" {
            set ini_dir [LIB_SPF_ini_get_env_dir_info]
    }
    "Part" -
    default {
            if {$isv_ini_run_mode == "TEAMCENTER"} {
              set part_dir [LIB_SPF_ini_get_env_dir_info]
              set ini_dir $part_dir
            } else {
              set part_dir [LIB_GE_format_path_names [file dirname $mom_part_name] 1]
              set ini_dir [LIB_GE_format_path_names [file join $part_dir "cse_files"] 1]
            }

            if {[catch {file mkdir $ini_dir}]} {
              LIB_SPF_add_warning "INS->$part_dir<- : No write access!"
        return
      }
    }
  }
  set ini_dir [LIB_GE_format_path_names [file join $ini_dir "subprog"] 1]
  if {![LIB_Shell_directory_exists $ini_dir]} {
    if {[catch {file mkdir $ini_dir}]} {
      LIB_SPF_add_warning "INS->$ini_dir<- : No write access!"
      return
    }
  }

  # Rename to_ini to {customized_name}
  set ini_name "to_ini"
  if {[info exists lib_spf(ini,name)]} {
    set ini_name $lib_spf(ini,name)
  }

  #Handle exsiting ini files in place where the one will be created.
  if {![info exists lib_spf(ini,existing)]} {set lib_spf(ini,existing) "Rename"}
  if {$isv_ini_tool_count(1)!=0 || ![info exists mom_multi_channel_mode]} {
    set current_dir [pwd]
    switch -- $lib_spf(ini,existing) {
      "Keep" {}
      "Delete" {
        cd $ini_dir
        set ini_file_list [glob -nocomplain *.ini]
        foreach existing_file $ini_file_list {
          if {![info exists mom_multi_channel_mode] || [string compare $existing_file "${ini_name}_2.ini"]} {
            if {[catch {file delete $existing_file }]} {
                          LIB_SPF_add_warning "INS->$existing_file<- : No write access!"
              cd $current_dir
              return
            }
          }
        }
        cd $current_dir
      }
      "Rename" -
      default {
        cd $ini_dir
        set ini_file_list [glob -nocomplain *.ini]
        foreach backup $ini_file_list {
          if {![info exists mom_multi_channel_mode] || [string compare $backup "${ini_name}_2.ini"]} {
            if {[catch {file rename -force $backup $backup.bck}]} {
                          LIB_SPF_add_warning "INS->$backup<- : No write access!"
              cd $current_dir
              return
            }
          }
        }
        cd $current_dir
      }
    }
  } else {
    if {[string compare $lib_spf(ini,existing) "Keep"] && [string compare $lib_spf(ini,existing) "Delete"]} {
      set current_dir [pwd]
      cd $ini_dir
      if {[LIB_Shell_file_exists "${ini_name}_2.ini" 1]} {
        if {[catch {file rename -force "${ini_name}_2.ini" "${ini_name}_2.ini.bck"}]} {
                      LIB_SPF_add_warning "INS->$backup<- : No write access!"
          cd $current_dir
          return
        }
      }
      cd $current_dir
    }
  }

  if {$ini_file_channel_number == 1} {
    set ini_file_name "${ini_dir}${ini_name}.ini"
    if {[catch {open "$ini_file_name" w} ini_file]} {
            LIB_SPF_add_warning "INS->$ini_file_name<- : No write access!"
      return
    }
        LIB_GE_command_buffer LIB_SPF_ini_output
        LIB_GE_command_buffer {
      if {[info exists isv_ini_mcs_info(0)]} {
        puts $ini_file $isv_ini_mcs_info(0)
      }
    } @ini_mcs_info
        LIB_GE_command_buffer {
      if {[info exists isv_ini_tool_info(0)]} {
        puts $ini_file $isv_ini_tool_info(0)
      }
    } @ini_tool_info
        LIB_GE_command_buffer {
      puts $ini_file "M17"
    } @ini_M17
        LIB_GE_command_buffer_output
    close $ini_file
    set isv_ini_file_dir $ini_dir
  } else {
    if {$isv_ini_tool_count(1)!=0 || ![info exists mom_multi_channel_mode]} {
      set ini_file_name "${ini_dir}${ini_name}_1.ini"
      if {[catch {open "$ini_file_name" w} ini_file]} {
          LIB_SPF_add_warning "INS->$ini_file_name<- : No write access!"
        return
      }
      LIB_GE_command_buffer LIB_SPF_ini_1_output
      LIB_GE_command_buffer {
        puts $ini_file "CHANDATA(1)"
      } @ini_channel_number
      LIB_GE_command_buffer {
        if {[info exists isv_ini_mcs_info(1)]} {
          puts $ini_file $isv_ini_mcs_info(1)
        }
      } @ini_mcs_info
      LIB_GE_command_buffer {
        if {[info exists isv_ini_tool_info(1)]} {
          puts $ini_file $isv_ini_tool_info(1)
        }
      } @ini_tool_info
      LIB_GE_command_buffer {
        puts $ini_file "M17"
      } @ini_M17
      LIB_GE_command_buffer_output
      close $ini_file
      set isv_ini_file_dir $ini_dir
    }
    if {$isv_ini_tool_count(2)!=0 || ![info exists mom_multi_channel_mode]} {
      set ini_file_name "${ini_dir}${ini_name}_2.ini"
      if {[catch {open "$ini_file_name" w} ini_file]} {
          LIB_SPF_add_warning "INS->$ini_file_name<- : No write access!"
        return
      }
      LIB_GE_command_buffer LIB_SPF_ini_2_output
      LIB_GE_command_buffer {
        puts $ini_file "CHANDATA(2)"
      } @ini_channel_number
      LIB_GE_command_buffer {
        if {[info exists isv_ini_mcs_info(2)]} {
          puts $ini_file $isv_ini_mcs_info(2)
        }
      } @ini_mcs_info
      LIB_GE_command_buffer {
        if {[info exists isv_ini_tool_info(2)]} {
          puts $ini_file $isv_ini_tool_info(2)
        }
      } @ini_tool_info
      LIB_GE_command_buffer {
        puts $ini_file "M17"
      } @ini_M17
      LIB_GE_command_buffer_output
      close $ini_file
      set isv_ini_file_dir $ini_dir
    }
  }

}
# <Internal Documentation>
# Output the inifile for CSE
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_ini_rename_files {} {

  global isv_ini_file_dir

  set ini_file_name [list]
  if {[info exists isv_ini_file_dir]} {
    global lib_spf
    global isv_ini_tool_count
    global mom_multi_channel_mode
    global ini_file_channel_number

    # Rename to_ini.ini to {customized_name.ini}
    set ini_name "to_ini"
    if {[info exists lib_spf(ini,name)]} {
      set ini_name $lib_spf(ini,name)
    }

    if {$ini_file_channel_number == 1} {
      lappend ini_file_name "${isv_ini_file_dir}${ini_name}.ini"
    } else {
      lappend ini_file_name "${isv_ini_file_dir}${ini_name}_1.ini"
      lappend ini_file_name "${isv_ini_file_dir}${ini_name}_2.ini"
    }
    if {![info exists mom_multi_channel_mode]} {
      if {[info exists lib_spf(ini,end_status)]} {
        if {![string compare $lib_spf(ini,end_status) "Rename"]} {
          foreach file_name $ini_file_name {
            catch {file rename -force $file_name $file_name.bck}
          }
        } elseif {![string compare $lib_spf(ini,end_status) "Delete"]} {
          foreach file_name $ini_file_name {
            catch {file delete $file_name}
          }
        }
      }
    }
  }
}
proc LIB_SPF_ini_init_files {} {

  global lib_spf

  set lib_spf(ini,create)     [CONF_SPF_file create_cse_ini_file]
  set lib_spf(ini,location)   [CONF_SPF_file ctrl_ini_location]
  set lib_spf(ini,existing)   [CONF_SPF_file ctrl_ini_existing]
  set lib_spf(ini,end_status) [CONF_SPF_file ctrl_ini_end_status]
  set lib_spf(ini,name)     [CONF_SPF_file ctrl_ini_custom_name]

}
# <Internal Documentation>
# This procedure is automatically called in order to define how the ini file for the cse simulation should be handled.
# The following mom variables are to be set with the options for the simulation.ini file output.
# lib_spf(ini,create)
#    "Yes"          ini files will be created
#    "No "          ini files will not be created
#
# lib_spf(ini,location)
#    "Part"         ini files will be output to a subfolder \cse_files\subprog
#                   of cam part file location. If \cse_files\subprog does not exist,
#                   post will create this folder.
#    "CSE"          ini files will be output to sub folder \subprog of \cse_driver
#                   folder which is located in same directory of \postprocessor in
#                   the respective machine ki.
#    "ENV"          ini files will be output to a sub folder \subprog in a directory
#                   specified over the environment variable UGII_CAM_CSE_USER_DIR.
#
# lib_spf(ini,existing)
#    "Rename"       Rename existing ini files in place where the one is created.
#    "Keep"         Keep ini files in place where the one is created.
#    "Delete"       Delete ini files in place where the one is created.
#
# lib_spf(ini,end_status)
#    "Rename"       Rename created ini file after post run.
#    "Keep"         Keep created ini files after post run.
#    "Delete"       Delete created ini files after post run.
#
# lib_spf(ini,name)
#    "to_ini"   Definition of the name to_ini.ini
#
# <Internal Example>
# name: Example 1
# code: proc LIB_SPF_ini_init_files {} {
# global lib_spf(ini,create)
# global lib_spf(ini,location)
# global lib_spf(ini,keep_existing)
# global lib_spf(ini,end_status)
# global lib_spf(ini,name)
#
# set lib_spf(ini,create)     "Yes"
# set lib_spf(ini,location)   "Part"
# set lib_spf(ini,existing)   "Rename"
# set lib_spf(ini,end_status) "Keep"
# set lib_spf(ini,name)   "to_ini"
# }
# desc: This example will activate the creation of simulation.ini at the same location as the
#      partfile. If a simulation.ini file already exists, it will be renamed with a suffix.
#      The newly created simulation.ini file will be conserved at the end of post processor
#____________________________________________________________________________________________
proc LIB_SPF_ini_get_env_dir_info {} {

  global lib_ge_env

  # Check to see if ENV Var UGII_CAM_CSE_USER_DIR exists - if so then use this for temp file location
  # otherwise use dirname obtained from mom_definition_file_name.
  set part_dir $lib_ge_env(cam_cse_user_dir)
  if {$part_dir == ""} {
    #ENV var UGII_CAM_CSE_USER_DIR is NOT set!
    MOM_output_to_listing_device "Environment variable UGII_CAM_CSE_USER_DIR is not set! to_ini.ini file will not be generated!"
  } else {

    set part_dir2 [LIB_GE_format_path_names $lib_ge_env(cam_cse_user_dir) 1]
    regsub -all {\\} $part_dir2 {/} part_dir
  }
  return $part_dir
}
# <Documentation>
# This function returns the path, defined with the environment variable UGII_CAM_CSE_USER_DIR.
# If the variable is not set it returns an empty string and displays an information in the listing window.
# <Returnvalue>
# String with the value of the environment variable or empty string if not defined.
# <Example>
# set cse_dir [LIB_SPF_ini_get_env_dir_info]
#____________________________________________________________________________________________
proc LIB_SPF_ini_map_tool_type {tool_index} {

  global mom_tool_ug_subtype
  global mom_tool_ug_type
  global mom_tool_diameter
  global mom_tool_length
  global mom_tool_corner1_radius
  global mom_tool_taper_angle mom_tool_name mom_tool_tip_angle
  global mom_isv_tool_type
  global mom_isv_tool_diameter
  global mom_isv_tool_x_correction
  global mom_isv_tool_r_correction
  global mom_isv_tool_corner1_radius
  global mom_isv_tool_point_angle

  switch -- $mom_isv_tool_type($tool_index) {
    "Milling" {
      if {[info exists mom_isv_tool_corner1_radius($tool_index)] && $mom_isv_tool_corner1_radius($tool_index) > 0.0} {
        #121 End mill (with fillet)
        return 121
      } else {
        #120 End mill (without fillet)
        return 120
      }
    }
    "Drilling" {
      return 200
    }
    "Turning" {
      return 500
    }
    "Grooving" {
      return 520
    }
    "Threading" {
      return 540
    }
    default {
      return 100
    }
  }
}
# <Internal Documentation>
# Return the type num for tool;
# default mill tool 121;
# default lathe tool 500;
# default drill tool 200.
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_local_coord_on {{lib_3d_rot_order ""} {lib_3d_rot_mode ""}} {
  global mom_kin_machine_type mom_kin_coordinate_system_type
  global mom_tool_axis oper_mcs_matrix
  global lib_flag lib_parameter local_rotation_matrix
  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3
  global RAD2DEG DEG2RAD
  global mom_feature_matrix  mom_feature_origin
  global lib_coord_ref_abs_X lib_coord_ref_abs_Y lib_coord_ref_abs_Z
  global mom_operation_type mom_nxt_event_data
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z rotation_matrix
  global mom_machine_csys_matrix mom_csys_matrix mom_cycle_type
  global mom_advanced_postprocessing_status mom_spindle_axis

  if {![string match "*5_axis*" $mom_kin_machine_type]} {
    return 1
  }
  set ang_mode $lib_3d_rot_order
  if {[LIB_GE_string_toupper $lib_3d_rot_mode] == "SPATIAL"} {
    if {[string match "-*" $lib_3d_rot_order]} {
      set ang_mode [string range $lib_3d_rot_order 1 end]
    } elseif {[string match "\+*" $lib_3d_rot_order]} {
      set ang_mode [string range $lib_3d_rot_order 1 end]
      set ang_mode [string reverse $ang_mode]
    } else {
      set ang_mode [string reverse $ang_mode]
    }
  } else {
    if {[string match "\+*" $lib_3d_rot_order]} {
      set ang_mode [string range $lib_3d_rot_order 1 end]
    } elseif {[string match "-*" $lib_3d_rot_order]} {
      set ang_mode [string range $lib_3d_rot_order 1 end]
      set ang_mode [string reverse $ang_mode]
    }
  }

  if {[info exists mom_advanced_postprocessing_status] && $mom_advanced_postprocessing_status == 3} {return}

  set cycle_event_name [LIB_SPF_get_cycle_event_name]

  if {$cycle_event_name != "No_Cycle"} {
    set cycle_event_name [lindex [split $cycle_event_name "_"] 1]
  }

  if {[llength [info commands MOM_ask_next_event_data]] && $cycle_event_name != "No_Cycle" &&\
    [MOM_ask_next_event_data -e $cycle_event_name mom_feature_matrix mom_feature_origin] == 1} {
    for {set ii 0} {$ii < 9} {incr ii} {
      set mom_feature_matrix($ii) $mom_nxt_event_data(mom_feature_matrix,$ii)
    }
    for {set ii 0} {$ii < 3} {incr ii} {
      set mom_feature_origin($ii) $mom_nxt_event_data(mom_feature_origin,$ii)
    }
    # get local csys from feature on the tilted work plane
    if {[info exists mom_feature_matrix] && [info exists mom_feature_origin]} {
      #Get G54 matrix and origin relative to absolute coordinate system
      MTX3_multiply mom_csys_matrix mom_machine_csys_matrix mcs_matrix
      set u(0) $mom_csys_matrix(9)
      set u(1) $mom_csys_matrix(10)
      set u(2) $mom_csys_matrix(11)
      MTX3_vec_multiply u mom_machine_csys_matrix w
      set mcs_origin(0) [expr $mom_machine_csys_matrix(9)  + $w(0)]
      set mcs_origin(1) [expr $mom_machine_csys_matrix(10) + $w(1)]
      set mcs_origin(2) [expr $mom_machine_csys_matrix(11) + $w(2)]
      #G54_matrix X local_rotation_matrix = Feature_matrix(Rank by column)
      MTX3_transpose mcs_matrix Mom_mcs_matrix
      MTX3_multiply Mom_mcs_matrix mom_feature_matrix local_rotation_matrix
      #Get feature origin relative to G54 coordinate
      MTX3_vec_multiply mom_feature_origin Mom_mcs_matrix local_origin
      set u(0) [expr $mcs_origin(0)-$local_origin(0)]
      set u(1) [expr $mcs_origin(1)-$local_origin(1)]
      set u(2) [expr $mcs_origin(2)-$local_origin(2)]
      #Translation reference point in Feature coordinate system
      MTX3_vec_multiply u local_rotation_matrix w
      set lib_coord_ref_abs_X $w(0)
      set lib_coord_ref_abs_Y $w(1)
      set lib_coord_ref_abs_Z $w(2)
      LIB_GE_copy_var_range rotation_matrix local_rotation_matrix
      #Translation reference point in G54 coordinate system
      set lib_coord_ref_X [expr $local_origin(0)-$mcs_origin(0)]
      set lib_coord_ref_Y [expr $local_origin(1)-$mcs_origin(1)]
      set lib_coord_ref_Z [expr $local_origin(2)-$mcs_origin(2)]
      return 0
    }
  }
  set v0 0.0; set v1 1.0
  VEC3_init v1 v0 v0 X0
  VEC3_init v0 v1 v0 Y0
  VEC3_init v0 v0 v1 Z0
  set lib_coord_ang_A 0.0
  set lib_coord_ang_B 0.0
  set lib_coord_ang_C 0.0

  if {[info exists lib_flag(plane_reference_direction)] && $lib_flag(plane_reference_direction) == 1} {
    # Spindle axis is paralleled to Z axis of rotated workpiece coordinate system
    VMOV 3 mom_spindle_axis Z
  } else {
    VMOV 3 mom_tool_axis Z
  }

  # calc rotation matrix of local csys according to tool axis
  if {[EQ_is_zero [VEC3_dot Z X0]] && [string match "*X*" $ang_mode]} {
    VEC3_cross Z X0 Y
    VMOV 3 X0 X
    set lib_coord_ang_C 0
    set lib_coord_ang_B 0
    set lib_coord_ang_A [expr atan2($Z(1),$Z(2))*$RAD2DEG*-1]
    for {set ii 0} {$ii < 3} {incr ii} {
      if {[string range $ang_mode $ii $ii] == "X"} {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_A
      } elseif {[string range $ang_mode $ii $ii] == "Y"} {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_B
      } else {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_C
      }
    }
  } elseif {[EQ_is_zero [VEC3_dot Z Y0]] && [string match "*Y*" $ang_mode]} {
    VEC3_cross Y0 Z X
    VMOV 3 Y0 Y
    set lib_coord_ang_C 0
    set lib_coord_ang_B [expr atan2($Z(0),$Z(2))*$RAD2DEG]
    set lib_coord_ang_A 0
    for {set ii 0} {$ii < 3} {incr ii} {
      if {[string range $ang_mode $ii $ii] == "X"} {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_A
      } elseif {[string range $ang_mode $ii $ii] == "Y"} {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_B
      } else {
        set [subst [subst lib_coord_ang_[expr $ii+1]]] $lib_coord_ang_C
      }
    }
  } else {
    #Euler conversion around two different axis to get Auto3D rotation matrix
    #rot_order: ZY - "ZYX"|"ZYZ"|"YZY"  ZX - "ZXY"|"ZXZ"|"XZX"  XY - "XYZ"|"XYX"|"XZY"  YX - "YXZ"|"YXY"|"YZX"

    switch -- $ang_mode {
      "ZYX" {
        set lib_coord_ang_C [expr atan2($Z(1),$Z(0))*$RAD2DEG]
        set lib_coord_ang_B [expr acos($Z(2))*$RAD2DEG]
        set lib_coord_ang_A 0
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_C] X0 U
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_C] Y0 Y
        VEC3_rotate_arbitary_axis Y [expr $DEG2RAD*$lib_coord_ang_B] U X
        }
      "YXZ" -
      "YZX" {
        set lib_coord_ang_B [expr atan2($Z(0),$Z(2))*$RAD2DEG]
        set lib_coord_ang_A [expr asin(-1*$Z(1))*$RAD2DEG]
        set lib_coord_ang_C 0
        VEC3_rotate_arbitary_axis Y0 [expr $DEG2RAD*$lib_coord_ang_B] X0 X
        VEC3_rotate_arbitary_axis X [expr $DEG2RAD*$lib_coord_ang_A] Y0 Y
        }
      "XZY" -
      "XYZ" {
        set lib_coord_ang_A [expr atan2(-1*$Z(1),$Z(2))*$RAD2DEG]
        set lib_coord_ang_C 0
        set lib_coord_ang_B [expr asin($Z(0))*$RAD2DEG]
        VEC3_rotate_arbitary_axis X0 [expr $DEG2RAD*$lib_coord_ang_A] Y0 Y
        VEC3_rotate_arbitary_axis Y [expr $DEG2RAD*$lib_coord_ang_B] X0 X
        }
      "ZXY" {
        set lib_coord_ang_C [expr atan2($Z(0),-1*$Z(1))*$RAD2DEG]
        set lib_coord_ang_A [expr acos($Z(2))*$RAD2DEG]
        set lib_coord_ang_B 0
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_C] X0 X
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_C] Y0 V
        VEC3_rotate_arbitary_axis X [expr $DEG2RAD*$lib_coord_ang_A] V Y
        }
      "XZX" {
        set lib_coord_ang_1 0
        set lib_coord_ang_2 [expr atan2($Z(0),-1*$Z(1))*$RAD2DEG]
        set lib_coord_ang_3 [expr acos(1*$Z(2))*$RAD2DEG]
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_2] X0 X
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_2] Y0 V
        VEC3_rotate_arbitary_axis X [expr $DEG2RAD*$lib_coord_ang_3] V Y
        }
      "XYX" {
        set lib_coord_ang_1 [expr atan2(-1*$Z(1),$Z(2))*$RAD2DEG]
        set lib_coord_ang_2 [expr asin($Z(0))*$RAD2DEG]
        set lib_coord_ang_3 0
        VEC3_rotate_arbitary_axis X0 [expr $DEG2RAD*$lib_coord_ang_1] Y0 Y
        VEC3_rotate_arbitary_axis Y [expr $DEG2RAD*$lib_coord_ang_2] X0 X
        }
      "YXY" {
        set lib_coord_ang_1 [expr atan2($Z(0),$Z(2))*$RAD2DEG]
        set lib_coord_ang_2 [expr asin(-1*$Z(1))*$RAD2DEG]
        set lib_coord_ang_3 0
        VEC3_rotate_arbitary_axis Y0 [expr $DEG2RAD*$lib_coord_ang_1] X0 X
        VEC3_rotate_arbitary_axis X [expr $DEG2RAD*$lib_coord_ang_2] Y0 Y
        }
      "YZY" {
        set lib_coord_ang_1 0
        set lib_coord_ang_2 [expr atan2($Z(1),$Z(0))*$RAD2DEG]
        set lib_coord_ang_3 [expr acos(1*$Z(2))*$RAD2DEG]
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_2] X0 U
        VEC3_rotate_arbitary_axis Z0  [expr $DEG2RAD*$lib_coord_ang_2] Y0 Y
        VEC3_rotate_arbitary_axis Y [expr $DEG2RAD*$lib_coord_ang_3] U X
        }
      "ZYZ" {
        set lib_coord_ang_1 [expr atan2($Z(1),$Z(0))*$RAD2DEG]
        set lib_coord_ang_2 [expr acos($Z(2))*$RAD2DEG]
        set lib_coord_ang_3 0
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_1] X0 U
        VEC3_rotate_arbitary_axis Z0 [expr $DEG2RAD*$lib_coord_ang_1] Y0 Y
        VEC3_rotate_arbitary_axis Y [expr $DEG2RAD*$lib_coord_ang_2] U X
        }
      "ZXZ" {
        set lib_coord_ang_1 [expr atan2($Z(0),-1*$Z(1))*$RAD2DEG]
        set lib_coord_ang_2 [expr acos($Z(2))*$RAD2DEG]
        set lib_coord_ang_3 0
        VEC3_rotate_arbitary_axis Z0 [expr $lib_coord_ang_1*$DEG2RAD] X0 X
        VEC3_rotate_arbitary_axis Z0 [expr $lib_coord_ang_1*$DEG2RAD] Y0 V
        VEC3_rotate_arbitary_axis X [expr $lib_coord_ang_2*$DEG2RAD] V Y
        }
    }
  }

  # PR#9779569 YD: Check if rotary axis is in same direction with tool axis, if so, rotate the local CSYS to current pos
  if {[EQ_is_zero $lib_coord_ang_A] && [EQ_is_zero $lib_coord_ang_B] && [EQ_is_zero $lib_coord_ang_C] && \
      [EQ_is_zero $lib_coord_ang_1] && [EQ_is_zero $lib_coord_ang_2] && [EQ_is_zero $lib_coord_ang_3] &&
      [CONF_CTRL_setting plane_output_supported] == "ALL"} {
    if {[info exists ::mom_kin_5th_axis_type] && \
      ![string compare "Table" $::mom_kin_5th_axis_type] && \
      [EQ_is_ge [VEC3_dot Z ::mom_kin_5th_axis_vector] 1.0]} {
      set lib_coord_ang_3 $::mom_pos(4)
      set lib_coord_ang_C $::mom_pos(4)
      VEC3_rotate_arbitary_axis Z [expr $DEG2RAD*$lib_coord_ang_3] X0 X
      VEC3_rotate_arbitary_axis Z [expr $DEG2RAD*$lib_coord_ang_3] Y0 Y
    } elseif {[info exists ::mom_kin_4th_axis_type] && \
      ![string compare "Table" $::mom_kin_4th_axis_type] && \
      [EQ_is_ge [VEC3_dot Z ::mom_kin_4th_axis_vector] 1.0]} {
      set lib_coord_ang_3 $::mom_pos(3)
      set lib_coord_ang_C $::mom_pos(3)
      VEC3_rotate_arbitary_axis Z [expr $DEG2RAD*$lib_coord_ang_3] X0 X
      VEC3_rotate_arbitary_axis Z [expr $DEG2RAD*$lib_coord_ang_3] Y0 Y
    }
  }

  if {![MTX3_init_x_y_z X Y Z local_rotation_matrix]} {
    LIB_GE_abort_message "Can't get Local Rotation Matrix in Operation 'INS->$::mom_path_name<-'" " Check tolerance and 4(5)th axis vector"
  }
  return 1
}
# <Internal Documentation>
# <NX1201 cam16012> new prereatment local csys
# This procedure is used to detect if operation is 3+2 operation without Local CSYS rotation coordinate system.
# It will return rotation matrix respect to local coordinate system which is defined by Auto 3D.
# Rotation matrix calculated by feature coordinate system, known axis vector of MCS
# or Euler angle conversion in specified rotate order. It will be called by LIB_CSYS_plane_output_init.
# Input:
#  lib_3d_rot_mode - coordinate matrix rotation method. Possible value: XYZ XZY YZX YXZ ZXY ZYX XYX XZX YXY YZY ZXZ ZYZ
# Output:
# local_rotation_matrix - Variable name where rotated matrix respect to local csys by auto 3D will be stored
# Return value:
#  1 - Euler angles have got, no need to recalculate in LIB_SPF_calculate_coord_rot_angle.
#  0 - Only get rotation matrix.
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_local_pos_set {} {
  global lib_coord_ref_abs_X lib_coord_ref_abs_Y lib_coord_ref_abs_Z
  global local_rotation_matrix local_pos lib_flag mom_namespace_name
  global lib_mcs_output_type lib_flag
  global mom_operation_name_list mom_operation_name_with_optim_list

    if {[info exists lib_flag(local_csys)] && $lib_flag(local_csys) == "no_local_namespace"} {
          return
    }

  #In optimized group, the mom_pos is overrided, no need to switch output type
  if {[info exists mom_operation_name_list] && [info exists mom_operation_name_with_optim_list] &&\
  [string compare $mom_operation_name_list $mom_operation_name_with_optim_list]} {
    return
  }
  if {$lib_flag(local_namespace_output) && \
  [llength [info commands MOM_set_local_csys_matrix]] && [array exists local_rotation_matrix]} {
    set local_pos "mom_pos mom_mcs_goto mom_alt_pos mom_prev_pos mom_pos_arc_center \
    mom_cycle_rapid_to_pos mom_cycle_retract_to_pos mom_cycle_feed_to_pos\
    mom_prev_mcs_goto mom_arc_center"
    set local_vector "mom_tool_axis mom_spindle_axis mom_pos_arc_axis mom_arc_axis"
    MOM_set_local_csys_matrix $lib_coord_ref_abs_X $lib_coord_ref_abs_Y $lib_coord_ref_abs_Z \
    $local_rotation_matrix(0) $local_rotation_matrix(1) $local_rotation_matrix(2) \
    $local_rotation_matrix(3) $local_rotation_matrix(4) $local_rotation_matrix(5) \
    $local_rotation_matrix(6) $local_rotation_matrix(7) $local_rotation_matrix(8)
    MOM_set_local_csys_vars position mom_pos mom_mcs_goto mom_alt_pos mom_prev_pos mom_pos_arc_center \
    mom_cycle_rapid_to_pos mom_cycle_retract_to_pos mom_cycle_feed_to_pos\
    mom_prev_mcs_goto mom_arc_center
    MOM_set_local_csys_vars vector mom_tool_axis mom_spindle_axis mom_pos_arc_axis mom_arc_axis
    set mom_namespace_name "::LOCAL_CSYS"
    MOM_set_evaluate_address_expr ON
    # current event need variables under LOCAL_CSYS namespace
    foreach a $local_pos {
      global $a
      if {[array exists $a]} {
        VMOV 3 $a tmp
        set LOCAL_CSYS::[subst $a](0) [expr $lib_coord_ref_abs_X + $local_rotation_matrix(0) * $tmp(0) +\
        $local_rotation_matrix(1) * $tmp(1) + $local_rotation_matrix(2) * $tmp(2)]
        set LOCAL_CSYS::[subst $a](1) [expr $lib_coord_ref_abs_Y + $local_rotation_matrix(3) * $tmp(0) +\
        $local_rotation_matrix(4) * $tmp(1) + $local_rotation_matrix(5) * $tmp(2)]
        set LOCAL_CSYS::[subst $a](2) [expr $lib_coord_ref_abs_Z + $local_rotation_matrix(6) * $tmp(0) +\
        $local_rotation_matrix(7) * $tmp(1) + $local_rotation_matrix(8) * $tmp(2)]
      }
    }
    foreach a $local_vector {
      global $a
      if {[array exists $a]} {
        VMOV 3 $a tmp
        set LOCAL_CSYS::[subst $a](0) [expr $local_rotation_matrix(0) * $tmp(0) +\
        $local_rotation_matrix(1) * $tmp(1) + $local_rotation_matrix(2) * $tmp(2)]
        set LOCAL_CSYS::[subst $a](1) [expr $local_rotation_matrix(3) * $tmp(0) +\
        $local_rotation_matrix(4) * $tmp(1) + $local_rotation_matrix(5) * $tmp(2)]
        set LOCAL_CSYS::[subst $a](2) [expr $local_rotation_matrix(6) * $tmp(0) +\
        $local_rotation_matrix(7) * $tmp(1) + $local_rotation_matrix(8) * $tmp(2)]
      }
    }
    set lib_flag(local_pos_set) 1
    if {[info exist lib_flag(plane_output_pos_type)] && $lib_flag(plane_output_pos_type) == 1} {
      LIB_SPF_set_output_pos "::LOCAL_CSYS" "mom_mcs_goto"
    } else {
      LIB_SPF_set_output_pos "::LOCAL_CSYS" "mom_pos"
    }
    if {![info exist lib_mcs_output_type] || $lib_mcs_output_type != 3} {
      LIB_SPF_check_tool_axis
    }
  }
}
# <Internal Documentation>
# <NX1201 cam16012> new prereatment local csys
# This command is used to set local_csys automatically with MOM_extension MOM_set_local_csys_matrix
# and MOM_set_local_csys_vars.
# It will enable local pos output under namespace LOCAL_CSYS.
# It is called by lib_csys_plane_output_init
#____________________________________________________________________________________________
proc LIB_SPF_local_pos_reset {} {
  global lib_flag mom_namespace_name local_rotation_matrix
  # In new local csys mode, exit local nameapce and reset global variables here.
  if {$lib_flag(local_namespace_output)} {
    if {[info exists lib_flag(local_pos_set)] && $lib_flag(local_pos_set) == 1} {
      if {[llength [info commands MOM_set_local_csys_vars]]} {MOM_set_local_csys_vars}
      LIB_SPF_set_output_pos
      set lib_flag(local_pos_set) 0
    }
  }
}
# <Internal Documentation>
# <NX1201 cam16012> new prereatment local csys
# This command is used to deactivate the MOM_set_local_csys function.
# It is called by lib_csys_plane_output_reset
#____________________________________________________________________________________________
proc LIB_SPF_set_output_pos {{namespace_name "::"} {output_pos_type "mom_pos"}} {

  global mom_namespace_name mom_output_pos_type

  set mom_namespace_name $namespace_name
  set mom_output_pos_type $output_pos_type
  # Set output pos type for turbo off/advanced mode in local csys
  if {[llength [info commands MOM_set_output_pos]]} {
    if {$namespace_name == "::"} {
      MOM_set_output_pos $output_pos_type
    } else {
      MOM_set_output_pos $output_pos_type LOCAL
    }
  }
  # <CAM17013.21> Set output pos type for turbo auto/on mode in local csys
  if {[llength [info commands MOM_set_turbo_pos_output]]} {
    if {$namespace_name == "::"} {
      MOM_set_turbo_pos_output $output_pos_type
    } else {
      MOM_set_turbo_pos_output [eval set type ${namespace_name}::$output_pos_type]
    }
  }
}
# <Internal Documentation>
# <NX1201 cam16012> new prereatment local csys
# This procedure is used to customize the output pos's type and it's namespace.
# Set mom_namespace_name and mom_output_pos_type. It could works in proc PB_CMD__evaluate_address_expr.
#
# <Internal Example>
# namespace_name: "::" or "::LOCAL_CSYS"
# output_pos_type: "mom_pos" or "mom_mcs_goto"
# LIB_SPF_set_output_pos "::LOCAL_CSYS" "mom_mcs_goto"
#____________________________________________________________________________________________
proc LIB_SPF_calculate_coord_rot_angle {lib_3d_rot_order lib_3d_rot_address} {

  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3
  global RAD2DEG
  global lib_parameter rotation_matrix
  global mom_sys_control_out mom_sys_control_in

  set coord_rot_order $lib_3d_rot_order
  set coord_rot_address $lib_3d_rot_address
  set m0 $rotation_matrix(0)
  set m1 $rotation_matrix(1)
  set m2 $rotation_matrix(2)
  set m3 $rotation_matrix(3)
  set m4 $rotation_matrix(4)
  set m5 $rotation_matrix(5)
  set m6 $rotation_matrix(6)
  set m7 $rotation_matrix(7)
  set m8 $rotation_matrix(8)
  switch -- $coord_rot_order {
    "+ZYX" -
    "ZYX" {
      #ZYX
      #    ClC2           C1S2S3-S1C3     S1S3+C1S2C3
      #    SlC2           S1S2S3+C1C3     S1S2C3-C1S3
      #    -S2            C2S3            C2C3
      set sin_b [expr (-1*$m2)]
      set cos_b [expr (1*cos(asin(-1*$m2)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr -1*$m3]
          set cos_a $m4
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (-1*$m7)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr $m0/$cos_b]
        set sin_a [expr (1*$m1)/$cos_b]
        set cos_c [expr $m8/$cos_b]
        set sin_c [expr (1*$m5)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) - ($cos_c*$sin_a)) - $m3]
      set tmpval [expr (($sin_a*$sin_c) + ($cos_a*$cos_c*$sin_b)) + $tmpval - $m6]
      set tmpval [expr (($cos_a*$cos_c) + ($sin_a*$sin_b*$sin_c)) + $tmpval - $m4]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) - ($cos_a*$sin_c)) + $tmpval - $m7]
      set lib_coord_ang_C [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "-ZYX" {
      #-ZYX
      #    ClC2           C1S2S3+S1C3     S1S3-C1S2C3
      #    -SlC2          -S1S2S3+C1C3    S1S2C3+C1S3
      #    S2             -C2S3           C2C3
      set sin_b [expr (1*$m2)]
      set cos_b [expr (1*cos(asin(1*$m2)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr 1*$m3]
          set cos_a $m4
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (1*$m7)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr $m0/$cos_b]
        set sin_a [expr (-1*$m1)/$cos_b]
        set cos_c [expr $m8/$cos_b]
        set sin_c [expr (-1*$m5)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) + ($cos_c*$sin_a)) - $m3]
      set tmpval [expr (($sin_a*$sin_c) - ($cos_a*$cos_c*$sin_b)) + $tmpval - $m6]
      set tmpval [expr (($cos_a*$cos_c) - ($sin_a*$sin_b*$sin_c)) + $tmpval - $m4]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) + ($cos_a*$sin_c)) + $tmpval - $m7]
      set lib_coord_ang_C [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "+YXZ" -
    "YXZ" {
      #YXZ
      #    C1C3+S1S2S3    C3S1S2-C1S3    C2S1
      #    C2S3           C2C3           -C2
      #    ClS2S3-C3S1    S1S3+C1C3S2    C1C2
      set sin_b [expr (-1*$m7)]
      set cos_b [expr (1*cos(asin(-1*$m7)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr -1*$m2]
          set cos_a $m0
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (-1*$m3)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (1*$m8)/$cos_b]
        set sin_a [expr (1*$m6)/$cos_b]
        set cos_c [expr (1*$m4)/$cos_b]
        set sin_c [expr (1*$m1)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) - ($cos_c*$sin_a)) - $m2]
      set tmpval [expr ((1)*($sin_a*$sin_c) + ($cos_a*$cos_c*$sin_b)) + $tmpval - $m5]
      set tmpval [expr ((1)*($cos_a*$cos_c) + ($sin_a*$sin_b*$sin_c)) + $tmpval - $m0]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) - ($cos_a*$sin_c)) + $tmpval - $m3]
      set lib_coord_ang_B [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "-YXZ" {
      #-YXZ
      #    C1C3-S1S2S3    C3S1S2+C1S3    -C2S1
      #    -C2S3          C2C3           S2
      #    ClS2S3+C3S1    S1S3-C1C3S2    C1C2
      set sin_b [expr (1*$m7)]
      set cos_b [expr (1*cos(asin(1*$m7)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr 1*$m2]
          set cos_a $m0
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (1*$m3)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (1*$m8)/$cos_b]
        set sin_a [expr (-1*$m6)/$cos_b]
        set cos_c [expr (1*$m4)/$cos_b]
        set sin_c [expr (-1*$m1)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) + ($cos_c*$sin_a)) - $m2]
      set tmpval [expr ((1)*($sin_a*$sin_c) - ($cos_a*$cos_c*$sin_b)) + $tmpval - $m5]
      set tmpval [expr ((1)*($cos_a*$cos_c) - ($sin_a*$sin_b*$sin_c)) + $tmpval - $m0]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) + ($cos_a*$sin_c)) + $tmpval - $m3]
      set lib_coord_ang_B [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "+XZY" -
    "XZY" {
      #XZY
      #    C2C3           -S2            C2S3
      #    S1S3+C3C1S2    C1C2           C1S2S3-C3S1
      #    C3S1S2-C1S3    C2S1           S1S2S3+C1C3
      set sin_b [expr (-1*$m3)]
      set cos_b [expr (1*cos(asin(-1*$m3)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr -1*$m7]
          set cos_a $m8
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (-1*$m2)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (1*$m4)/$cos_b]
        set sin_a [expr (1*$m5)/$cos_b]
        set cos_c [expr (1*$m0)/$cos_b]
        set sin_c [expr (1*$m6)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) - ($cos_c*$sin_a)) - $m7]
      set tmpval [expr ((1)*($sin_a*$sin_c) + ($cos_a*$cos_c*$sin_b)) + $tmpval - $m1]
      set tmpval [expr ((1)*($cos_a*$cos_c) + ($sin_a*$sin_b*$sin_c)) + $tmpval - $m8]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) - ($cos_a*$sin_c)) + $tmpval - $m2]
      set lib_coord_ang_A [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "-XZY" {
      #-XZY
      #    C2C3           S2             -C2S3
      #    S1S3-C3C1S2    C1C2           C1S2S3+C3S1
      #    C3S1S2+C1S3    -C2S1          -S1S2S3+C1C3
      set sin_b [expr (1*$m3)]
      set cos_b [expr (1*cos(asin(1*$m3)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m7)]
          set cos_a $m8
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (1*$m2)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (1*$m4)/$cos_b]
        set sin_a [expr (-1*$m5)/$cos_b]
        set cos_c [expr (1*$m0)/$cos_b]
        set sin_c [expr (-1*$m6)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) + ($cos_c*$sin_a)) - $m7]
      set tmpval [expr ((1)*($sin_a*$sin_c) - ($cos_a*$cos_c*$sin_b)) + $tmpval - $m1]
      set tmpval [expr ((1)*($cos_a*$cos_c) - ($sin_a*$sin_b*$sin_c)) + $tmpval - $m8]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) + ($cos_a*$sin_c)) + $tmpval - $m2]
      set lib_coord_ang_A [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "+XYZ" -
    "XYZ" {
      #XYZ
      #    C2C3           -C2S3          S2
      #    C1S3+C3S1S2    C1C3-S1S2S3    -C2S1
      #    S1S3-C1C3S2    C1S2S3+C3S1    C1C2
      set sin_b [expr (1*$m6)]
      set cos_b [expr (1*cos(asin(1*$m6)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m5)]
          set cos_a $m4
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (1*$m1)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr (1*$m8)/$cos_b]
        set sin_a [expr (-1*$m7)/$cos_b]
        set cos_c [expr (1*$m0)/$cos_b]
        set sin_c [expr (-1*$m3)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) + ($cos_c*$sin_a)) - $m5]
      set tmpval [expr ((1)*($sin_a*$sin_c) - ($cos_a*$cos_c*$sin_b)) + $tmpval - $m2]
      set tmpval [expr ((1)*($cos_a*$cos_c) - ($sin_a*$sin_b*$sin_c)) + $tmpval - $m4]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) + ($cos_a*$sin_c)) + $tmpval - $m1]
      set lib_coord_ang_A [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "-XYZ" {
      #-XYZ
      #    C2C3           C2S3           -S2
      #    C3S1S2-C1S3    C1C3+S1S2S3    C2S1
      #    S1S3+C1C3S2    C1S2S3-C3S1    C1C2
      set sin_b [expr (-1*$m6)]
      set cos_b [expr (1*cos(asin(-1*$m6)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m5)]
          set cos_a $m4
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (-1*$m1)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr (1*$m8)/$cos_b]
        set sin_a [expr (1*$m7)/$cos_b]
        set cos_c [expr (1*$m0)/$cos_b]
        set sin_c [expr (1*$m3)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) - ($cos_c*$sin_a)) - $m5]
      set tmpval [expr ((1)*($sin_a*$sin_c) + ($cos_a*$cos_c*$sin_b)) + $tmpval - $m2]
      set tmpval [expr ((1)*($cos_a*$cos_c) + ($sin_a*$sin_b*$sin_c)) + $tmpval - $m4]
      set tmpval [expr ((1)*($cos_c*$sin_a*$sin_b) - ($cos_a*$sin_c)) + $tmpval - $m1]
      set lib_coord_ang_A [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "+YZX" -
    "YZX" {
      #YZX
      #    C1C2           S1S3-C1C3S2     C1S2S3+C3S1
      #    S2             C2C3            -C2S3
      #    -C2S1          C1S3+C3S1S2     C1C3-S1S2S3
      set sin_b [expr (1*$m1)]
      set cos_b [expr (1*cos(asin(1*$m1)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m6)]
          set cos_a $m8
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (1*$m5)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (1*$m0)/$cos_b]
        set sin_a [expr (-1*$m2)/$cos_b]
        set cos_c [expr (1*$m4)/$cos_b]
        set sin_c [expr (-1*$m7)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) + ($cos_c*$sin_a)) - $m6]
      set tmpval [expr ((1)*($sin_a*$sin_c) - ($cos_a*$cos_c*$sin_b)) + $tmpval - $m3]
      set tmpval [expr ((1)*($cos_a*$cos_c) - ($sin_a*$sin_b*$sin_c)) + $tmpval - $m8]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) + ($cos_a*$sin_c)) + $tmpval - $m5]
      set lib_coord_ang_B [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "-YZX" {
      #-YZX
      #    C1C2           S1S3+C1C3S2     C1S2S3-C3S1
      #    -S2            C2C3            C2S3
      #    C2S1           -C1S3+C3S1S2    C1C3+S1S2S3
      set sin_b [expr (-1*$m1)]
      set cos_b [expr (1*cos(asin(-1*$m1)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m6)]
          set cos_a $m8
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (-1*$m5)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (1*$m0)/$cos_b]
        set sin_a [expr (1*$m2)/$cos_b]
        set cos_c [expr (1*$m4)/$cos_b]
        set sin_c [expr (1*$m7)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) - ($cos_c*$sin_a)) - $m6]
      set tmpval [expr ((1)*($sin_a*$sin_c) + ($cos_a*$cos_c*$sin_b)) + $tmpval - $m3]
      set tmpval [expr ((1)*($cos_a*$cos_c) + ($sin_a*$sin_b*$sin_c)) + $tmpval - $m8]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) - ($cos_a*$sin_c)) + $tmpval - $m5]
      set lib_coord_ang_B [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_C [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "+ZXY" -
    "ZXY" {
      #ZXY
      #    C1C3-SlS2S3    -SlC2           C1S3+SlS2C3
      #    C1S2S3+S1C3    C1C2            S1S3-C1S2C3
      #    -C2S3          S2              C2C3
      set sin_b [expr (1*$m5)]
      set cos_b [expr (1*cos(asin(1*$m5)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m1)]
          set cos_a $m0
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (1*$m6)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (1*$m4)/$cos_b]
        set sin_a [expr (-1*$m3)/$cos_b]
        set cos_c [expr (1*$m8)/$cos_b]
        set sin_c [expr (-1*$m2)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) + ($cos_c*$sin_a)) - $m1]
      set tmpval [expr ((1)*($sin_a*$sin_c) - ($cos_a*$cos_c*$sin_b)) + $tmpval - $m7]
      set tmpval [expr ((1)*($cos_a*$cos_c) - ($sin_a*$sin_b*$sin_c)) + $tmpval - $m0]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) + ($cos_a*$sin_c)) + $tmpval - $m6]
      set lib_coord_ang_C [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "-ZXY" {
      #-ZXY
      #    C1C3+SlS2S3    SlC2            -C1S3+SlS2C3
      #    C1S2S3-S1C3    C1C2            S1S3+C1S2C3
      #    C2S3           -S2             C2C3
      set sin_b [expr (-1*$m5)]
      set cos_b [expr (1*cos(asin(-1*$m5)))]
      if {[EQ_is_zero $cos_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m1)]
          set cos_a $m0
          set cos_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set cos_b 0.0
          set sin_c [expr (-1*$m6)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (1*$m4)/$cos_b]
        set sin_a [expr (1*$m3)/$cos_b]
        set cos_c [expr (1*$m8)/$cos_b]
        set sin_c [expr (1*$m2)/$cos_b]
      }
      set tmpval [expr (($cos_a*$sin_b*$sin_c) - ($cos_c*$sin_a)) - $m1]
      set tmpval [expr ((1)*($sin_a*$sin_c) + ($cos_a*$cos_c*$sin_b)) + $tmpval - $m7]
      set tmpval [expr ((1)*($cos_a*$cos_c) + ($sin_a*$sin_b*$sin_c)) + $tmpval - $m0]
      set tmpval [expr (($cos_c*$sin_a*$sin_b) - ($cos_a*$sin_c)) + $tmpval - $m6]
      set lib_coord_ang_C [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
      set lib_coord_ang_A [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
      set lib_coord_ang_B [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
    }
    "+XZX" -
    "XZX" {
      #  +XZX
      #    C2             -C3S2          S3S2
      #    C1S2           C1C2C3-S1S3    -C2C1S3-C3S1
      #    S2S1           C1S3+C3C2S1    C1C3-C2S1S3
      set cos_b [expr (1*$m0)]
      set sin_b [expr (1*sin(acos(1*$m0)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m7)]
          set cos_a $m8
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (1*$m5)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (1*$m1)/$sin_b]
        set sin_a [expr (1*$m2)/$sin_b]
        set cos_c [expr (-1*$m3)/$sin_b]
        set sin_c [expr (1*$m6)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_c*$sin_a)) - $m4]
      set tmpval [expr (($cos_a*$sin_c) + ($sin_a*$cos_c*$cos_b)) + $tmpval - $m5]
      set tmpval [expr ((-1)*($sin_a*$cos_c) - ($cos_a*$cos_b*$sin_c)) + $tmpval - $m7]
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) + $tmpval - $m8]
    }
    "-XZX" {
      #-XZX
      #    C2             C3S2           S3S2
      #    -C1S2          C1C2C3-S1S3    C2C1S3+C3S1
      #    S2S1           -C1S3-C3C2S1   C1C3-C2S1S3
      set cos_b [expr (1*$m0)]
      set sin_b [expr (1*sin(acos(1*$m0)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m7)]
          set cos_a $m8
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (-1*$m5)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (-1*$m1)/$sin_b]
        set sin_a [expr (1*$m2)/$sin_b]
        set cos_c [expr (1*$m3)/$sin_b]
        set sin_c [expr (1*$m6)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_c*$sin_a)) - $m4]
      set tmpval [expr ((-1)*($cos_a*$sin_c) - ($sin_a*$cos_c*$cos_b)) + $tmpval - $m5]
      set tmpval [expr ((1)*($sin_a*$cos_c) + ($cos_a*$cos_b*$sin_c)) + $tmpval - $m7]
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) + $tmpval - $m8]
    }
    "+XYX" -
    "XYX" {
      #XYX
      #    C2             S3S2           C3S2
      #    S2S1           C1C3-C2S1S3    -C1S3-C3C2S1
      #    -ClS2          C1C2S3+C3S1    C1C2C3-S1S3
      set cos_b [expr (1*$m0)]
      set sin_b [expr (1*sin(acos(1*$m0)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m5)]
          set cos_a $m4
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (-1*$m7)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr (-1*$m2)/$sin_b]
        set sin_a [expr (1*$m1)/$sin_b]
        set cos_c [expr (1*$m6)/$sin_b]
        set sin_c [expr (1*$m3)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m4]
      set tmpval [expr (($cos_a*$cos_b*$sin_c) + ($cos_c*$sin_a)) + $tmpval - $m5]
      set tmpval [expr ((-1)*($cos_a*$sin_c) - ($cos_b*$cos_c*$sin_a)) + $tmpval - $m7]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m8]
    }
    "-XYX" {
      #-XYX
      #    C2             S3S2           -C3S2
      #    S2S1           C1C3-C2S1S3    C1S3+C3C2S1
      #    ClS2           -C1C2S3-C3S1   C1C2C3-S1S3
      set cos_b [expr (1*$m0)]
      set sin_b [expr (1*sin(acos(1*$m0)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m5)]
          set cos_a $m4
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (1*$m7)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr (1*$m2)/$sin_b]
        set sin_a [expr (1*$m1)/$sin_b]
        set cos_c [expr (-1*$m6)/$sin_b]
        set sin_c [expr (1*$m3)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m4]
      set tmpval [expr ((-1)*($cos_a*$cos_b*$sin_c) - ($cos_c*$sin_a)) + $tmpval - $m5]
      set tmpval [expr ((1)*($cos_a*$sin_c) + ($cos_b*$cos_c*$sin_a)) + $tmpval - $m7]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m8]
    }
    "+YXY" -
    "YXY" {
      #YXY
      #    C1C3-C2S1S3    S2S1           C1S3+S1C2C3
      #    S3S2           C2             -C3S2
      #    -C2C1S3-C3S1   C1S2           C1C2C3-SlS3
      set cos_b [expr (1*$m4)]
      set sin_b [expr (1*sin(acos(1*$m4)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m2)]
          set cos_a $m0
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (1*$m6)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (1*$m5)/$sin_b]
        set sin_a [expr (1*$m3)/$sin_b]
        set cos_c [expr (-1*$m7)/$sin_b]
        set sin_c [expr (1*$m1)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m0]
      set tmpval [expr ((-1)*($cos_a*$cos_b*$sin_c) - ($cos_c*$sin_a)) + $tmpval - $m2]
      set tmpval [expr ((1)*($cos_a*$sin_c) + ($cos_b*$cos_c*$sin_a)) + $tmpval - $m6]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m8]
    }
    "-YXY" {
      #-YXY
      #    C1C3-C2S1S3    S2S1           -C1S3-S1C2C3
      #    S3S2           C2             C3S2
      #    C2C1S3+C3S1    -C1S2          C1C2C3-SlS3
      set cos_b [expr (1*$m4)]
      set sin_b [expr (1*sin(acos(1*$m4)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m2)]
          set cos_a $m0
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (-1*$m6)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (-1*$m5)/$sin_b]
        set sin_a [expr (1*$m3)/$sin_b]
        set cos_c [expr (1*$m7)/$sin_b]
        set sin_c [expr (1*$m1)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m0]
      set tmpval [expr ((1)*($cos_a*$cos_b*$sin_c) + ($cos_c*$sin_a)) + $tmpval - $m2]
      set tmpval [expr ((-1)*($cos_a*$sin_c) - ($cos_b*$cos_c*$sin_a)) + $tmpval - $m6]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m8]
    }
    "+YZY" -
    "YZY" {
      #YZY
      #    C1C2C3-S1S3    -C1S2          C2C1S3+C3S1
      #    C3S2           C2             S3S2
      #    -C1S3-C3C2S1   S2S1           C1C3-C2S1S3
      set cos_b [expr (1*$m4)]
      set sin_b [expr (1*sin(acos(1*$m4)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m6)]
          set cos_a $m8
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (-1*$m2)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (-1*$m3)/$sin_b]
        set sin_a [expr (1*$m5)/$sin_b]
        set cos_c [expr (1*$m1)/$sin_b]
        set sin_c [expr (1*$m7)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m8]
      set tmpval [expr ((1)*($cos_a*$cos_b*$sin_c) + ($cos_c*$sin_a)) + $tmpval - $m6]
      set tmpval [expr ((-1)*($cos_a*$sin_c) - ($cos_b*$cos_c*$sin_a)) + $tmpval - $m2]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m0]
    }
    "-YZY" {
      #-YZY
      #    C1C2C3-S1S3    C1S2           -C2C1S3-C3S1
      #    -C3S2          C2             S3S2
      #    C1S3+C3C2S1    S2S1           C1C3-C2S1S3
      set cos_b [expr (1*$m4)]
      set sin_b [expr (1*sin(acos(1*$m4)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m6)]
          set cos_a $m8
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (1*$m2)]
          set cos_c $m8
        }
      } else {
        set cos_a [expr (1*$m3)/$sin_b]
        set sin_a [expr (1*$m5)/$sin_b]
        set cos_c [expr (-1*$m1)/$sin_b]
        set sin_c [expr (1*$m7)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m8]
      set tmpval [expr ((-1)*($cos_a*$cos_b*$sin_c) - ($cos_c*$sin_a)) + $tmpval - $m6]
      set tmpval [expr ((1)*($cos_a*$sin_c) + ($cos_b*$cos_c*$sin_a)) + $tmpval - $m2]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m0]
    }
    "+ZYZ" -
    "ZYZ" {
      #ZYZ
      #    C1C2C3-S1S3    -C2S3C1-C3S1    C1S2
      #    C1S3+C3C2S1    C1C3-C2S1S3     S2S1
      #    -C3S2          S3S2            C2
      set cos_b [expr (1*$m8)]
      set sin_b [expr (1*sin(acos(1*$m8)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m3)]
          set cos_a $m5
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (1*$m1)]
          set cos_c $m4
        }
      } else {
        set cos_a [expr (1*$m6)/$sin_b]
        set sin_a [expr (1*$m7)/$sin_b]
        set cos_c [expr (-1*$m2)/$sin_b]
        set sin_c [expr (1*$m5)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m4]
      set tmpval [expr ((-1)*($cos_a*$cos_b*$sin_c) - ($cos_c*$sin_a)) + $tmpval - $m3]
      set tmpval [expr ((1)*($cos_a*$sin_c) + ($cos_b*$cos_c*$sin_a)) + $tmpval - $m1]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m0]
    }
    "-ZYZ" {
      #-ZYZ
      #    C1C2C3-S1S3    C2S3C1+C3S1     -C1S2
      #    -C1S3-C3C2S1   C1C3-C2S1S3     S2S1
      #    C3S2           S3S2            C2
      set cos_b [expr (1*$m8)]
      set sin_b [expr (1*sin(acos(1*$m8)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m3)]
          set cos_a $m5
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (-1*$m1)]
          set cos_c $m5
        }
      } else {
        set cos_a [expr (-1*$m6)/$sin_b]
        set sin_a [expr (1*$m7)/$sin_b]
        set cos_c [expr (1*$m2)/$sin_b]
        set sin_c [expr (1*$m5)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m4]
      set tmpval [expr ((1)*($cos_a*$cos_b*$sin_c) + ($cos_c*$sin_a)) + $tmpval - $m3]
      set tmpval [expr ((-1)*($cos_a*$sin_c) - ($cos_b*$cos_c*$sin_a)) + $tmpval - $m1]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m0]
    }
    "+ZXZ" -
    "ZXZ" {
      #ZXZ
      #    ClC3-C2S1S3    -C1S3-C3C2S1    S2S1
      #    C2ClS3+C3S1    C1C2C3-S1S3     -C1S2
      #    S3S2           C3S2            C2
      set cos_b [expr (1*$m8)]
      set sin_b [expr (1*sin(acos(1*$m8)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (1*$m1)]
          set cos_a $m0
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (-1*$m3)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (-1*$m7)/$sin_b]
        set sin_a [expr (1*$m6)/$sin_b]
        set cos_c [expr (1*$m5)/$sin_b]
        set sin_c [expr (1*$m2)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m0]
      set tmpval [expr ((1)*($cos_a*$cos_b*$sin_c) + ($cos_c*$sin_a)) + $tmpval - $m1]
      set tmpval [expr ((-1)*($cos_a*$sin_c) - ($cos_b*$cos_c*$sin_a)) + $tmpval - $m3]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m4]
    }
    "-ZXZ" {
      #-ZXZ
      #    ClC3-C2S1S3    C1S3+C3C2S1     S2S1
      #    -C2ClS3-C3S1   C1C2C3-S1S3     C1S2
      #    S3S2           -C3S2           C2
      set cos_b [expr (1*$m8)]
      set sin_b [expr (1*sin(acos(1*$m8)))]
      if {[EQ_is_zero $sin_b]} {
        if {$coord_rot_address == "first"} {
          set sin_a [expr (-1*$m1)]
          set cos_a $m0
          set sin_b 0.0
          set sin_c 0.0
          set cos_c 1.0
        } else {
          set sin_a 0.0
          set cos_a 1.0
          set sin_b 0.0
          set sin_c [expr (1*$m3)]
          set cos_c $m0
        }
      } else {
        set cos_a [expr (1*$m7)/$sin_b]
        set sin_a [expr (1*$m6)/$sin_b]
        set cos_c [expr (-1*$m5)/$sin_b]
        set sin_c [expr (1*$m2)/$sin_b]
      }
      set tmpval [expr (($cos_a*$cos_c) - ($cos_b*$sin_a*$sin_c)) - $m0]
      set tmpval [expr ((-1)*($cos_a*$cos_b*$sin_c) - ($cos_c*$sin_a)) + $tmpval - $m1]
      set tmpval [expr ((1)*($cos_a*$sin_c) + ($cos_b*$cos_c*$sin_a)) + $tmpval - $m3]
      set tmpval [expr (($cos_a*$cos_b*$cos_c) - ($sin_a*$sin_c)) + $tmpval - $m4]
    }
  }
  if {![EQ_is_zero $tmpval]} {
    # MOM_abort "CSYS_Calculation wrong"
    MOM_output_literal "$mom_sys_control_out CSYS_Calculation wrong $mom_sys_control_in"
  }
  set lib_coord_ang_1 [expr (1)*atan2($sin_a,$cos_a)*$RAD2DEG]
  set lib_coord_ang_2 [expr (1)*atan2($sin_b,$cos_b)*$RAD2DEG]
  set lib_coord_ang_3 [expr (1)*atan2($sin_c,$cos_c)*$RAD2DEG]
}
# <Internal Documentation>
# This procedure is used to calculate coordinate rotation angle by given rotation matrix.
#
# Input:
#  coord_rot_order - coordinate system rotation method.
#                    Possible value: XYZ XZY YZX YXZ ZXY ZYX XYX XZX YXY YZY ZXZ ZYZ
#  coord_rot_address - first/last
# Output:
#  Euler Angle:
#  (1) rotate around three different axis:
#        lib_coord_ang_A --- X Axis | lib_coord_ang_B --- Y Axis | lib_coord_ang_C --- Z Axis
#  (2) rotate around two different axis:
#        lib_coord_ang_1 --- First Axis | lib_coord_ang_2 --- Second Axis | lib_coord_ang_3 --- Third Axis
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_local_csys_rotation {{lib_3d_rot_order ""} {lib_3d_rot_mode ""} {lib_3d_rot_address ""}} {
  global mom_kin_machine_type
  global mom_pos mom_out_angle_pos mom_init_pos
  global mom_kin_4th_axis_point mom_kin_5th_axis_point
  global mom_kin_4th_axis_vector mom_kin_5th_axis_vector
  global mom_kin_4th_axis_zero mom_kin_5th_axis_zero
  global lib_coord_ang_A lib_coord_ang_B lib_coord_ang_C
  global lib_coord_ang_1 lib_coord_ang_2 lib_coord_ang_3
  global lib_coord_ref_X lib_coord_ref_Y lib_coord_ref_Z
  global lib_coord_ref_abs_X lib_coord_ref_abs_Y lib_coord_ref_abs_Z
  global lib_coord_main_X lib_coord_main_Y lib_coord_main_Z
  global mom_csys_matrix rotation_matrix mom_msys_matrix mom_parent_csys_matrix local_rotation_matrix
  global RAD2DEG DEG2RAD
  global lib_flag lib_parameter mres m_tmp
  global mom_sys_leader lib_mcs_output_type
  global mom_msys_origin
  global mom_sys_control_out mom_sys_control_in
  global mom_sorigin mom_origin
  global mom_kin_iks_usage
  global oper_mcs_matrix tmp_csys_matrix
  global mom_tool_z_offset_defined mom_tool_z_offset
  global mom_tool_y_offset_defined mom_tool_y_offset
  global mom_tool_x_offset_defined mom_tool_x_offset
  global lib_coord_ref_X_instance lib_coord_ref_Y_instance lib_coord_ref_Z_instance
  global operation_mcs_matrix_instance
  global mom_process_patterning_pattern_mcs mom_pattern_instance_csys_matrix

  if {$lib_3d_rot_order == ""} {
    set lib_3d_rot_order [CONF_SPF_csys_3d_rot rot_order]
  }
  if {$lib_3d_rot_mode == ""} {
    set lib_3d_rot_mode [CONF_SPF_csys_3d_rot rot_mode]
  }
  if {$lib_3d_rot_address == ""} {
    set lib_3d_rot_address [CONF_SPF_csys_3d_rot rot_address]
  }
  LIB_GE_copy_var_range tmp_csys_matrix oper_mcs_matrix
  # lib_coord_ref_xx and lib_coord_main_xx are defined in the LIB_SPF_get_mcs_info
  if {[LIB_SPF_csys_examine_local] == "default" && [info exist mom_sorigin(0)]} {
    # calc offset
    LIB_GE_copy_var_range mom_origin mom_sorigin
    MOM_reload_variable -a mom_origin
    set lib_coord_ref_X $mom_sorigin(0)
    set lib_coord_ref_Y $mom_sorigin(1)
    set lib_coord_ref_Z $mom_sorigin(2)
  } elseif {[info exist mom_sorigin(0)]} {
    if {![EQ_is_zero $mom_sorigin(0)] || ![EQ_is_zero $mom_sorigin(1)] || ![EQ_is_zero $mom_sorigin(2)]} {
      LIB_GE_abort_message "Local CSYS and Smart Origin cannot be combined - CSYS-Name: $::mom_oper_geom"
    }
  } else {
    # do nothing
    if {[CONF_SPF_csys_3d_rot adv_plane_calc] == 0 && [LIB_SPF_csys_examine_local] == "rotation" && [CONF_SPF_csys_3d_rot rot_real_axis] == 1} {
      LIB_GE_abort_message "Advanced Plane Calculation not active and Local MCS orientation not equal to Main MCS orientation - CSYS-Name: $::mom_oper_geom"
    }
  }
  if {[LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [LIB_SPF_csys_examine_local] == "rotation"} {
    LIB_GE_abort_message "5-Axis simultanous operation with Local CSYS orientation other than Main CSYS not allowed - CSYS-Name: $::mom_oper_geom"
  }
  if {![string compare "2_axis_lathe" $mom_kin_machine_type] || ([LIB_SPF_get_pretreatment axis_mode] == "SIMULTANEOUS" && [CONF_SPF_sim_kin tcpm_prepos_plane] == 0)} {
    return
  }

  if {([CONF_SPF_csys_3d_rot rot_real_axis] == 1 || [LIB_GE_string_toupper $lib_3d_rot_mode] == "AXIAL") && [LIB_SPF_csys_examine_local] == "rotation"} {
    # in the calculation of the rotation angle there are A,B,C Angles but the machine have only 2 axis so i abort the calculation
    LIB_GE_abort_message "Local CSYS with special output CSYS Rotation is not allowed with rotation about real axis (AXIAL) - Operation: $::mom_path_name"
  }
  # Initialize coordinate rotation angles
  set lib_coord_ang_A 0.0 ; set lib_coord_ang_B 0.0 ; set lib_coord_ang_C 0.0
  set lib_coord_ang_1 0.0 ; set lib_coord_ang_2 0.0 ; set lib_coord_ang_3 0.0
  set X(0) 1.0; set X(1) 0.0; set X(2) 0.0
  set Y(0) 0.0; set Y(1) 1.0; set Y(2) 0.0
  set Z(0) 0.0; set Z(1) 0.0; set Z(2) 1.0
  # local_rotation_matrix(local csys matrix to set local namespace)
  MTX3_init_x_y_z X Y Z local_rotation_matrix
  # rotation_matrix(local csys matrix to calculate euler angles)
  MTX3_init_x_y_z X Y Z rotation_matrix
  set lib_coord_ref_abs_X 0.0 ; set lib_coord_ref_abs_Y 0.0 ; set lib_coord_ref_abs_Z 0.0
  # In new local csys mode, we need to get rotation matrix and coordinate origin of local coordinate system here, no matter auto3d or user defined.
  if {[info exist lib_mcs_output_type] && $lib_mcs_output_type == 3} {

    if {[info exists mom_process_patterning_pattern_mcs] && $mom_process_patterning_pattern_mcs == "Yes" && [info exists mom_pattern_instance_csys_matrix]} {
      # For process patterning instances, use csys tranlation and rotation saved within lib_mcs_info before resetting
      set u(0) [expr -$lib_coord_ref_X_instance]
      set u(1) [expr -$lib_coord_ref_Y_instance]
      set u(2) [expr -$lib_coord_ref_Z_instance]
      MTX3_vec_multiply u operation_mcs_matrix_instance w
    } else {
      set lib_coord_ref_abs_X $lib_coord_ref_X ; set lib_coord_ref_abs_Y $lib_coord_ref_Y ; set lib_coord_ref_abs_Z $lib_coord_ref_Z
      set u(0) [expr -$lib_coord_ref_abs_X]
      set u(1) [expr -$lib_coord_ref_abs_Y]
      set u(2) [expr -$lib_coord_ref_abs_Z]
      MTX3_vec_multiply u oper_mcs_matrix w
    }
    if {[info exists mom_tool_x_offset_defined] && $mom_tool_x_offset_defined == 1} {
      set lib_coord_ref_abs_X [expr $w(0) + $mom_tool_x_offset]
    } else {
    set lib_coord_ref_abs_X $w(0)
    }
    if {[info exists mom_tool_y_offset_defined] && $mom_tool_y_offset_defined == 1} {
      set lib_coord_ref_abs_Y [expr $w(1) + $mom_tool_y_offset]
    } else {
    set lib_coord_ref_abs_Y $w(1)
    }
    if {[info exists mom_tool_z_offset_defined] && $mom_tool_z_offset_defined == 1} {
      set lib_coord_ref_abs_Z [expr $w(2) + $mom_tool_z_offset]
    } else {
    set lib_coord_ref_abs_Z $w(2)
    }
    if {[info exists mom_process_patterning_pattern_mcs] && $mom_process_patterning_pattern_mcs == "Yes" && [info exists mom_pattern_instance_csys_matrix]} {
      VMOV 9 operation_mcs_matrix_instance local_rotation_matrix
    } else {
      VMOV 9 oper_mcs_matrix local_rotation_matrix
    }
  } else {
    if {[info exists mom_tool_x_offset_defined] && $mom_tool_x_offset_defined == 1} {
      set lib_coord_ref_abs_X [expr $lib_coord_ref_abs_X + $mom_tool_x_offset]
    }
    if {[info exists mom_tool_y_offset_defined] && $mom_tool_y_offset_defined == 1} {
      set lib_coord_ref_abs_Y [expr $lib_coord_ref_abs_Y + $mom_tool_y_offset]
    }
    if {[info exists mom_tool_z_offset_defined] && $mom_tool_z_offset_defined == 1} {
      set lib_coord_ref_abs_Z [expr $lib_coord_ref_abs_Z + $mom_tool_z_offset]
    }
    #Take the rotation matrix and angles from tool axis because here we have no CSYS_Rotation
    if {[LIB_SPF_local_coord_on $lib_3d_rot_order $lib_3d_rot_mode] == 1 } {
    #For process patterning, local csys rotation should be added for each instance even without a csys rotation mcs
      if {![info exists ::mom_process_patterning_pattern_mcs] || $::mom_process_patterning_pattern_mcs == "No" || ![info exists ::mom_pattern_instance_csys_matrix]} {
        return
      }
    }
  }
  # oper_matrix may be exist, need to be taken in.
  if {[LIB_GE_string_toupper $lib_3d_rot_mode] == "SPATIAL"} {
    set lib_3d_rot_order [string trim [LIB_GE_string_toupper $lib_3d_rot_order]]
    switch -regexp -- $lib_3d_rot_order {
      ^-  {regsub "^-" $lib_3d_rot_order "+" lib_3d_rot_order}
      ^\\+  {regsub "^\\+" $lib_3d_rot_order "-" lib_3d_rot_order}
      ^[^-+]  {set lib_3d_rot_order "-$lib_3d_rot_order"}
    }
    MTX3_multiply tmp_csys_matrix rotation_matrix mres
    MTX3_transpose mres m_tmp
  } elseif {[LIB_GE_string_toupper $lib_3d_rot_mode] == "EULER"} {
    MTX3_multiply tmp_csys_matrix rotation_matrix m_tmp
  }

  if {[info exists ::mom_process_patterning_pattern_mcs] && $::mom_process_patterning_pattern_mcs == "Yes" && [info exists ::mom_pattern_instance_csys_matrix]} {
    MTX3_multiply m_tmp local_rotation_matrix m_tmp2
    VMOV 9 m_tmp2 m_tmp
  }

  for { set i 0 } { $i < 9 } { incr i } {
    # 14.07.2014 Hes Fix if Value is greater than 1 or less than -1
      # for ex $m_tmp(2) == 1.0000000000002
      if {$m_tmp($i) > 1.0} {set m_tmp($i) 1.0}
      if {$m_tmp($i) < -1.0} {set m_tmp($i) -1.0}
      set rotation_matrix($i) $m_tmp($i)
    }
    # calculate euler angles according to rotation matrix and order, no matter auto3d or user defined local csys.
    LIB_SPF_calculate_coord_rot_angle $lib_3d_rot_order $lib_3d_rot_address
}
# <Internal Documentation>
# <NX1201 cam16012> new prereatment local csys
# This command is used to get the rotation angles from a matrix translation for local csys.
# First it calculate a matrix from the tool-axis vector.
# then it checks if a local_csys exists and if it has different direction as the
# main_csys. Then combine the two matrix and calculate the rotation angles
# if there is no Coordinate Rotation (CSYS Rotation) then the mom_out_angle_pos are
# used instead of Tool_axis_vector
#
# Input:  lib_3d_rot_order of the rotation and direction (left handed (-) or right handed (+))
#         (+/-)XYZ (+/-)XZY (+/-)YZX (+/-)YXZ (+/-)ZXY (+/-)ZYX
#         (+/-)XYX (+/-)XZX (+/-)YZY (+/-)YXY (+/-)ZXZ (+/-)ZYZ
#
#         lib_3d_rot_mode = spatial  rotation is about fixed machine axis
#                     = euler    rotation is about the resulting axis
#                     = axial    rotation is about the rotation axis
#
#         lib_3d_rot_address  = first  rotation is about first axis in the lib_3d_rot_order (if possible)
#                             = last   rotation is about last  axis in the lib_3d_rot_order (if possible)
#
# Return values:
#     rotation matrix defined by user
#
# This command is used to get auto 3D coordinate rotation by tool axis vector.
#
# <Internal Example>
#     LIB_SPF_local_csys_rotation "+XYX" "spatial"
#     LIB_SPF_local_csys_rotation "-ZYX" "euler"
#
#____________________________________________________________________________________________
proc LIB_SPF_get_cycle_event_name {} {
  global mom_operation_type mom_nxt_event_data mom_cycle_type
  if {![string match "Drilling" $mom_operation_type]} {
    return "No_Cycle"
  }
  if {![info exists mom_cycle_type] && [llength [info commands MOM_ask_next_event_data]] &&\
    [MOM_ask_next_event_data -e msys mom_cycle_type] == 1} {
    set mom_cycle_type $mom_nxt_event_data(mom_cycle_type)
  }
  if {[info exists mom_cycle_type]} {
    switch -- $mom_cycle_type {
      "Drill"     {return "MOM_drill"}
      "Drill_Deep"    {return "MOM_drill_deep"}
      "Drill_Deep_Breakchip"  {return "MOM_drill_break_chip"}
      "Drill_Text"    {return "MOM_drill_text"}
      "Drill_Csink"     {return "MOM_drill_counter_sink"}
      "Drill_Tap"     {return "MOM_tap"}
      "Drill_Tap_Float"   {return "MOM_tap_float"}
      "Drill_Tap_Deep"  {return "MOM_tap_deep"}
      "Drill_Tap_Breakchip"   {return "MOM_tap_break_chip"}
      "Drill_Bore"    {return "MOM_bore"}
      "Drill_Bore_Drag"   {return "MOM_bore_drag"}
      "Drill_Bore_Nodrag"   {return "MOM_bore_no_drag"}
      "Drill_Bore_Back"   {return "MOM_bore_back"}
      "Drill_Bore_Manual"   {return "MOM_bore_manual"}
      default     {return "No_Cycle"}
    }
  }

}
# <Internal Documentation>
# <NX1201 cam16012> new prereatment local csys
# This command is used to get mom event name for local csys in drilling operation.
#
# Return values: mom event name or no cycle
# Cycle Type: 1."Drill" 2."Drill_Deep" 3."Drill_Deep_Breakchip" 4."Drill_Text" 5."Drill_Csink"
#             6."Drill_Tap" 7."Drill_Tap_Float" 8."Drill_Tap_Deep" 9."Drill_Tap_Breakchip"
#             10."Drill_Bore" 11."Drill_Bore_Drag" 12."Drill_Bore_Nodrag" 13."Drill_Bore_Back"
#             14."Drill_Bore_Manual"
# Event name: 1."drill" 2."drill_deep" 3."drill_break_chip" 4."drill_text" 5."drill_counter_sink"
#             6."tap" 7."tap_float" 8."tap_deep" 9."tap_break_chip" 10."bore"
#             11."bore_drag" 12."bore_no_drag" 13."bore_back" 14."bore_manual"
#____________________________________________________________________________________________
proc MOM_transition_rapid_move {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_transition_rapid_move_ENTRY) [llength [info commands MOM_transition_rapid_move_ENTRY]]

  LIB_GE_command_buffer MOM_transition_rapid_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_ENTRY)} {MOM_transition_rapid_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  if {$::mom_move_output_a ==0 && $::mom_move_output_b ==0 && $::mom_move_output_c ==0} {
    set ::lib_ge_transition_rtcp_mode 0
    if {($::mom_kin_machine_type == "5_axis_dual_head" && ![EQ_is_zero $::mom_out_angle_pos(1)]) || \
      (($::mom_kin_machine_type == "4_axis_head" || $::mom_kin_machine_type == "5_axis_head_table") &&\
    ![EQ_is_zero $::mom_out_angle_pos(0)]) } {
      # If there is only linear axes move, for head machine always use RTCP mode to compensate tilt tool length
      if {$::mom_move_output_x !=0 || $::mom_move_output_y !=0 || $::mom_move_output_z !=0} {
        set ::lib_ge_transition_rtcp_mode 1
      }
    }
  } else {
    set ::lib_ge_transition_rtcp_mode $::mom_move_axis_rtcp_mode
  }

  # Set value of output axis
  set 4th [string tolower $::mom_kin_4th_axis_leader]
  set 5th [string tolower $::mom_kin_5th_axis_leader]
  set ::mom_transition_${4th}_axis $::mom_out_angle_pos(0)
  set ::mom_transition_${5th}_axis $::mom_out_angle_pos(1)

  if {$::lib_ge_transition_rtcp_mode == 1} {
    set ::mom_transition_x_axis $::mom_mcs_goto(0)
    set ::mom_transition_y_axis $::mom_mcs_goto(1)
    set ::mom_transition_z_axis $::mom_mcs_goto(2)
  } else {
    set ::mom_transition_x_axis $::mom_pos(0)
    set ::mom_transition_y_axis $::mom_pos(1)
    set ::mom_transition_z_axis $::mom_pos(2)
  }

  if {[llength [info commands MOM_transition_rapid_move_LIB]]} {MOM_transition_rapid_move_LIB}


  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_transition_rapid_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_transition_rapid_move_ENTRY)} {MOM_transition_rapid_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at transition move in inter-operation path
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_start_of_transition_path {} {


  if {$::lib_ge_pretreatment_runtime} {PT_start_of_transition_path ; return}

  set commandcheck(MOM_start_of_transition_path_ENTRY) [llength [info commands MOM_start_of_transition_path_ENTRY]]

  LIB_GE_command_buffer MOM_start_of_transition_path_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_ENTRY)} {MOM_start_of_transition_path_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  #LIB_SPF_operation_header_comment
  if {[llength [info commands LIB_CTRL_parameter_call]]} {LIB_CTRL_parameter_call}

  LIB_SPF_get_mcs_info

  # Set kinematics to absolute
  LIB_SPF_KINEMATICS_reload_real_mach_kin_from_pt

  if {[llength [info commands MOM_start_of_transition_path_LIB]]} {MOM_start_of_transition_path_LIB}
  set ::lib_flag(transition_rtcp_output) 0
  set ::lib_flag(transition_csys_output) 0

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_start_of_transition_path_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_start_of_transition_path_ENTRY)} {MOM_start_of_transition_path_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the start of transtition path
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_end_of_transition_path {} {

  if {$::lib_ge_pretreatment_runtime} {PT_end_of_transition_path ; return}

  set commandcheck(MOM_end_of_transition_path_ENTRY) [llength [info commands MOM_end_of_transition_path_ENTRY]]

  LIB_GE_command_buffer MOM_end_of_transition_path_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_ENTRY)} {MOM_end_of_transition_path_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_end_of_transition_path_LIB]]} {MOM_end_of_transition_path_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_end_of_transition_path_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_end_of_transition_path_ENTRY)} {MOM_end_of_transition_path_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is executed at the end of transition path
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_machine_axis_move {} {


  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_machine_axis_move_ENTRY) [llength [info commands MOM_machine_axis_move_ENTRY]]

  LIB_GE_command_buffer MOM_machine_axis_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_ENTRY)} {MOM_machine_axis_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------
  # mom_transition_()_axis are used in def file as output variable
  set ::mom_transition_x_axis $::mom_xaxis_value
  set ::mom_transition_y_axis $::mom_yaxis_value
  set ::mom_transition_z_axis $::mom_zaxis_value

  set 4th [string tolower $::mom_kin_4th_axis_leader]
  set 5th [string tolower $::mom_kin_5th_axis_leader]
  set ::mom_transition_${4th}_axis $::mom_out_angle_pos(0)
  set ::mom_transition_${5th}_axis $::mom_out_angle_pos(1)

  if {[llength [info commands MOM_machine_axis_move_LIB]]} {MOM_machine_axis_move_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_machine_axis_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_machine_axis_move_ENTRY)} {MOM_machine_axis_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This procedure is called by Move_To_Machine_Position subop with "Machine Limit" or "Specify"
# option in transition path. It outputs given point position in MTCS directly.
#
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_mill_hole_move {} {

  if {$::lib_ge_pretreatment_runtime} {PT_mill_hole_move ; return}

  set commandcheck(MOM_mill_hole_move_ENTRY) [llength [info commands MOM_mill_hole_move_ENTRY]]

  LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_mill_hole_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_ENTRY)} {MOM_mill_hole_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_mill_hole_move_LIB]]} {MOM_mill_hole_move_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_move_ENTRY)} {MOM_mill_hole_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This is handler for mill hole cycle move.
# It is now only used for sinumerik controller to output POCKET4.
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_mill_hole {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_mill_hole_ENTRY) [llength [info commands MOM_mill_hole_ENTRY]]

  LIB_GE_command_buffer MOM_mill_hole_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_ENTRY)} {MOM_mill_hole_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_mill_hole_LIB]]} {MOM_mill_hole_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_ENTRY)} {MOM_mill_hole_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This is handler for mill hole cycle. So far it is do nothing just have entry point for customization.
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_mill_hole_thread_move {} {


  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_mill_hole_thread_move_ENTRY) [llength [info commands MOM_mill_hole_thread_move_ENTRY]]

  #LIB_SPF_add_general_motion_handling

  LIB_GE_command_buffer MOM_mill_hole_thread_move_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_ENTRY)} {MOM_mill_hole_thread_move_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_mill_hole_thread_move_LIB]]} {MOM_mill_hole_thread_move_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_thread_move_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_move_ENTRY)} {MOM_mill_hole_thread_move_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This is handler for mill hole cycle move.
# It is now only used for sinumerik controller to output CYCLE90.
# <Internal Example>
#____________________________________________________________________________________________
proc MOM_mill_hole_thread {} {

  if {$::lib_ge_pretreatment_runtime} {return}

  set commandcheck(MOM_mill_hole_thread_ENTRY) [llength [info commands MOM_mill_hole_thread_ENTRY]]

  LIB_GE_command_buffer MOM_mill_hole_thread_ENTRY_start
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_ENTRY)} {MOM_mill_hole_thread_ENTRY start}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output
  #---------------------------------------------------------------------------------

  if {[llength [info commands MOM_mill_hole_LIB]]} {MOM_mill_hole_LIB}

  #---------------------------------------------------------------------------------
  LIB_GE_command_buffer MOM_mill_hole_thread_ENTRY_end
  LIB_GE_command_buffer {if {$commandcheck(MOM_mill_hole_thread_ENTRY)} {MOM_mill_hole_thread_ENTRY end}} @DEFAULT_ENTRY
  LIB_GE_command_buffer_output

}
# <Internal Documentation>
# This is handler for mill hole cycle. So far it is do nothing just have entry point for customization.
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_turbo_setting_by_feedrate_mode {} {


  global mom_feed_cut_unit mom_feed_rapid_unit mom_feed_approach_unit
  global mom_feed_engage_unit mom_feed_first_cut_unit mom_feed_stepover_unit
  global mom_feed_traversal_unit mom_feed_retract_unit mom_feed_departure_unit

  if {![info exists mom_feed_cut_unit] || ![info exists mom_feed_rapid_unit] ||
    ![info exists mom_feed_approach_unit]  || ![info exists mom_feed_engage_unit] ||
    ![info exists mom_feed_first_cut_unit] || ![info exists mom_feed_stepover_unit] ||
    ![info exists mom_feed_traversal_unit] || ![info exists mom_feed_retract_unit] ||
  ![info exists mom_feed_departure_unit]} {
    return
  }

  set advanced_turbo 0
  if {[string compare $mom_feed_rapid_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_approach_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_engage_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_first_cut_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_stepover_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_traversal_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_retract_unit $mom_feed_cut_unit] ||
    [string compare $mom_feed_departure_unit $mom_feed_cut_unit]} {
    set advanced_turbo 1
  }

  if {[LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE" && ([CONF_CTRL_setting turbo_mode] == 1 || [CONF_CTRL_setting turbo_mode] == 2) && $advanced_turbo == 1} {
    LIB_SPF_turbo_status "enable" "advanced"
  }
}
# <Internal Documentation>
# This procedure is used together with advanced pretreatment
#
# <Internal Example>
#____________________________________________________________________________________________
if {![llength [info commands LIB_PT_get_header_var]]} {
  proc LIB_PT_get_header_var {pt_get_header_var {ask value}} {
    global mom_result lib_pretreatment_header

    if {$ask == "exists"} {
      return 0
    } else {
      return not_defined
    }

    if {![array exists lib_pretreatment_header]} {
      MOM_ask_advanced_pretreatment_data lib_pretreatment_header
      array set lib_pretreatment_header $mom_result
    }

    if {$ask == "exists"} {
      if {[info exists lib_pretreatment_header($pt_get_header_var)]} {
        return 1
      } else {
        return 0
      }
    } else {
      if {[info exists lib_pretreatment_header($pt_get_header_var)]} {
        return [subst $lib_pretreatment_header($pt_get_header_var)]
      } else {
        return not_defined
      }
    }
  }
}

#____________________________________________________________________________________________
# <Internal Documentation>
# This procedure is called by LIB_SPF_KINEMATICS_turbo_setting to set turbo status by feedrate
# mode in turbo "AUTO" or "ON" condition.
# In these cases, feedrate mode may be changed from operation events,
# but it can't be supported by turbo "ON" condition, so use advanced turbo mode instead.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_set_preferred_solution {} {
  if {![llength [info commands MOM_set_preferred_solution]]} {
    if {[CONF_SPF_setting prefer_solution_axis] != "Off"} {
      LIB_SPF_add_warning "Set Preferred Solution only available after NX1953"
    }
    return
  }
  # set variable by conf option
  set axis [CONF_SPF_setting prefer_solution_axis]
  if {$axis == "Off"} {
    set result [MOM_set_preferred_solution $axis]
    set ::lib_flag(preferred_solution) OFF
  } else {
    set min [CONF_SPF_setting prefer_solution_min]
    if {$min == ""} {
      set min [set ::mom_kin_${axis}_axis_min_limit]
    }
    set max [CONF_SPF_setting prefer_solution_max]
    if {$max == ""} {
      set max [set ::mom_kin_${axis}_axis_max_limit]
    }
    set result [MOM_set_preferred_solution $axis $min $max]
    set ::lib_flag(preferred_solution) $axis
    set ::lib_flag(preferred_solution_min) $min
    set ::lib_flag(preferred_solution_max) $max
  }
  return $result
}
# <Internal Documentation>
# This procedure is used to set preferred solution with MOM_set_preferred_solution
# It should be called in start of path after chain selection or UDE handler.
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_check_approach_motion_splitting_type { } {

  global lib_flag mom_operation_type

  set lib_flag(decompose_first_move_for_each_tool_path) 0
  set lib_flag(decompose_first_move)            0
  set lib_flag(decompose_first_move_pos)                0
  set lib_flag(decompose_first_move_sim)                0
  set lib_flag(decompose_first_move_turn)               0

  if {[string match $mom_operation_type "Device Generic Motion"]} {
    return
  }

  set lib_flag(decompose_first_move_for_each_tool_path) [CONF_CTRL_moves decompose_first_move_for_each_tool_path]

  set lib_flag(decompose_first_move) [CONF_CTRL_moves decompose_first_move]

  set lib_flag(decompose_first_move_pos) [CONF_CTRL_moves decompose_first_move_pos]

  set lib_flag(decompose_first_move_sim) [CONF_CTRL_moves decompose_first_move_sim]

  set lib_flag(decompose_first_move_turn) [CONF_CTRL_moves decompose_first_move_turn]
}
# <Internal Documentation>
# This procedure is used to check approach motion splitting type from UI setting
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_set_rotary_axis_plane { } {

  global mom_kin_iks_usage mom_kin_machine_type
  global mom_kin_4th_axis_vector mom_kin_5th_axis_vector
  global mom_kin_4th_axis_plane mom_kin_5th_axis_plane

  if {[info exists mom_kin_iks_usage] && $mom_kin_iks_usage == 1} {
    if {[string match "5_axis*" $mom_kin_machine_type]} {
      foreach n {4 5} {
        VEC3_unitize mom_kin_${n}th_axis_vector _${n}th_vector
        set ${n}th_axis_orthogonal "FALSE"
        for {set i 0} {$i<3} {incr i} {
          if {[EQ_is_equal [set _${n}th_vector($i)] 1.0]} {
            set ${n}th_axis_orthogonal "TRUE"
            break
          }
        }
      }

      if {$4th_axis_orthogonal == "TRUE"} {
        if {[EQ_is_equal $mom_kin_4th_axis_vector(0) 1.0]} {
          set mom_kin_4th_axis_plane "YZ"
        } elseif {[EQ_is_equal $mom_kin_4th_axis_vector(1) 1.0]} {
          set mom_kin_4th_axis_plane "ZX"
        } else {
          set mom_kin_4th_axis_plane "XY"
        }
      } else {
        set mom_kin_4th_axis_plane "Other"
      }

      if {$5th_axis_orthogonal == "TRUE"} {
        if {[EQ_is_equal $mom_kin_5th_axis_vector(0) 1.0]} {
          set mom_kin_5th_axis_plane "YZ"
        } elseif {[EQ_is_equal $mom_kin_5th_axis_vector(1) 1.0]} {
          set mom_kin_5th_axis_plane "ZX"
        } else {
          set mom_kin_5th_axis_plane "XY"
        }
      } else {
        set mom_kin_5th_axis_plane "Other"
      }

    } elseif {[string match "4_axis*" $mom_kin_machine_type]} {
      if {[EQ_is_equal $mom_kin_4th_axis_vector(0) 1.0]} {
        set mom_kin_4th_axis_plane "YZ"
      } elseif {[EQ_is_equal $mom_kin_4th_axis_vector(1) 1.0]} {
        set mom_kin_4th_axis_plane "ZX"
      } elseif {[EQ_is_equal $mom_kin_4th_axis_vector(2) 1.0]} {
        set mom_kin_5th_axis_plane "XY"
      } else {
        set mom_kin_4th_axis_plane "Other"
      }
    }
  }
}
# <Internal Documentation>
# This procedure is used to set rotary axis plane for 4-axis and 5-axis machine
#
# <Internal Example>
#____________________________________________________________________________________________
proc LIB_SPF_feed_turbo_status_set {} {

  global lib_motion_type_list lib_spf lib_flag

  set lib_flag(feed_turbo_mode_disable) 0
  if {[CONF_CTRL_setting turbo_mode] != 0 && [CONF_CTRL_feed feed_linear] == 2} {
    foreach type $lib_motion_type_list {
      set tmp_motion_type [string tolower $type]
      if {[CONF_CTRL_feed exists feed_$tmp_motion_type]} {
        if {[CONF_CTRL_feed feed_$tmp_motion_type] != "NX"} {
          set lib_flag(feed_turbo_mode_disable) 1
          break
        }
      }
    }
  }

  if {$::mom_output_unit == "IN" && [string match "HEIDENHAIN*" $::lib_controller_type]} {
    set lib_flag(feed_turbo_mode_disable) 1
  }
  if {![info exists lib_flag(turbo_callback_status)]} {
    set lib_flag(turbo_callback_status) 0
  }

  if {$lib_flag(feed_turbo_mode_disable) == 1} {
    if {[info exists lib_spf(nx_version)] && $lib_spf(nx_version) >= 1200 && [LIB_SPF_get_pretreatment mom_kin_is_turbo_output] == "TRUE"} {
      # Convert turbo auto/on mode to advanced mode for feed string if output parameterized feed value
      LIB_SPF_turbo_status "enable" "ADVANCED"

      # From NX1899, use callback function in advanced turbo mode
      if {$lib_flag(turbo_callback_status) == 0 && $::lib_ge_env(major_version) >= 1899} {
        if { [CONF_CTRL_feed feed_linear] == 2 } {
          LIB_SPF_turbo_callback_function
        } elseif {$::mom_output_unit == "IN" && [string match "HEIDENHAIN*" $::lib_controller_type]} {
          #MOM_set_turbo_feedrate_set is ON, don't need call feedrate_set in postprocessor
          MOM_set_adv_turbo_callback -observer mom_feed_rate LIB_CTRL_AdvCallBack_feedrate
        }

        set lib_flag(turbo_callback_status) 1
      }
    } else {
      LIB_SPF_turbo_status "disable"
    }
  }

}
# <Internal Documentation>
# called from MOM_start_of_path. Added to check parameterized feed value and set turbo mode
# if properties are set correctly for all controllers
#
# <Internal Example>
#
#____________________________________________________________________________________________
proc LIB_SPF_start_of_program_blank {} {

  global mom_output_unit lib_flag mom_mcs_info
  global mom_blk_point_1  mom_blk_point_2 lib_blk_point_1 lib_blk_point_2
  global lib_blank_cylinder_vector lib_blank_cylinder_center lib_blank_cylinder_height lib_blank_cylinder_diameter

  LIB_GE_command_buffer BLK_form
  LIB_GE_command_buffer {
    if {$mom_output_unit == "IN"} {
      set tmp_blk_point_1(0) -20
      set tmp_blk_point_1(1) -20
      set tmp_blk_point_1(2) -20
      set tmp_blk_point_2(0) +20
      set tmp_blk_point_2(1) +20
      set tmp_blk_point_2(2) +20
    } else {
      set tmp_blk_point_1(0) -500
      set tmp_blk_point_1(1) -500
      set tmp_blk_point_1(2) -500
      set tmp_blk_point_2(0) +500
      set tmp_blk_point_2(1) +500
      set tmp_blk_point_2(2) +500
    }
    if {$lib_flag(load_pretreatment)} {
      if {[LIB_PT_get_header_var mom_blk_point_1(0) exists]} {
        set tmp_blk_point_1(0) [LIB_PT_get_header_var mom_blk_point_1(0)]
        set tmp_blk_point_1(1) [LIB_PT_get_header_var mom_blk_point_1(1)]
        set tmp_blk_point_1(2) [LIB_PT_get_header_var mom_blk_point_1(2)]
        set tmp_blk_point_2(0) [LIB_PT_get_header_var mom_blk_point_2(0)]
        set tmp_blk_point_2(1) [LIB_PT_get_header_var mom_blk_point_2(1)]
        set tmp_blk_point_2(2) [LIB_PT_get_header_var mom_blk_point_2(2)]
      }
    }
  } @BLK_form_setting
  LIB_GE_command_buffer {

    set first_operation [lindex [LIB_SPF_get_pretreatment operation_list] 0]

    if {[LIB_SPF_get_pretreatment mom_blank_block_length 0 $first_operation] != ""} {
          set block_center(0) [LIB_SPF_get_pretreatment "mom_blank_block_center,0" 0 $first_operation]
      set block_center(1) [LIB_SPF_get_pretreatment "mom_blank_block_center,1" 0 $first_operation]
      set block_center(2) [LIB_SPF_get_pretreatment "mom_blank_block_center,2" 0 $first_operation]
      set block_length(0) [LIB_SPF_get_pretreatment mom_blank_block_length 0 $first_operation]
      set block_length(1) [LIB_SPF_get_pretreatment mom_blank_block_width 0 $first_operation]
      set block_length(2) [LIB_SPF_get_pretreatment mom_blank_block_height 0 $first_operation]

      for {set i 0} {$i<9} {incr i} {
        set feature_matrix($i) [LIB_SPF_get_pretreatment "mom_blank_block_feature_matrix,$i" 0 $first_operation]
      }

      set mcs $::mom_output_mcs_name($first_operation)
      set fixture_mcs $::lib_mcs_info($mcs,fixture_mcs)

      for { set ii 0 } { $ii < 3 } { incr ii } {
        set fixture_mcs_matrix($ii) $mom_mcs_info($fixture_mcs,xvec,$ii)
      }
      for { set ii 3 } { $ii < 6 } { incr ii } {
        set fixture_mcs_matrix($ii) $mom_mcs_info($fixture_mcs,yvec,[expr $ii-3])
      }
      for { set ii 6 } { $ii < 9 } { incr ii } {
        set fixture_mcs_matrix($ii) $mom_mcs_info($fixture_mcs,zvec,[expr $ii-6])
      }

      for {set i 0} {$i < 3} {incr i} {
        set fixture_origin($i) $mom_mcs_info($fixture_mcs,org,$i)
      }
      VEC3_sub block_center fixture_origin f_center
      MTX3_vec_multiply f_center fixture_mcs_matrix b_center
      MTX3_transpose feature_matrix acs_feature_matrix
      MTX3_vec_multiply block_length acs_feature_matrix acs_length
      MTX3_vec_multiply acs_length fixture_mcs_matrix b_length

    } elseif {[LIB_SPF_get_pretreatment mom_blank_cylinder_diameter 0 $first_operation] != ""} {
      set block_center(0) [LIB_SPF_get_pretreatment "mom_blank_cylinder_center,0" 0 $first_operation]
      set block_center(1) [LIB_SPF_get_pretreatment "mom_blank_cylinder_center,1" 0 $first_operation]
      set block_center(2) [LIB_SPF_get_pretreatment "mom_blank_cylinder_center,2" 0 $first_operation]

      set mcs $::mom_output_mcs_name($first_operation)
      set fixture_mcs $::lib_mcs_info($mcs,fixture_mcs)

      for { set ii 0 } { $ii < 3 } { incr ii } {
        set fixture_mcs_matrix($ii) $mom_mcs_info($fixture_mcs,xvec,$ii)
      }
      for { set ii 3 } { $ii < 6 } { incr ii } {
        set fixture_mcs_matrix($ii) $mom_mcs_info($fixture_mcs,yvec,[expr $ii-3])
      }
      for { set ii 6 } { $ii < 9 } { incr ii } {
        set fixture_mcs_matrix($ii) $mom_mcs_info($fixture_mcs,zvec,[expr $ii-6])
      }

      for {set i 0} {$i < 3} {incr i} {
        set fixture_origin($i) $mom_mcs_info($fixture_mcs,org,$i)
      }
      VEC3_sub block_center fixture_origin f_center
      MTX3_vec_multiply f_center fixture_mcs_matrix b_center

      for {set i 0} {$i<3} {incr i} {
        set feature_vector($i) [LIB_SPF_get_pretreatment "mom_blank_cylinder_feature_vector,$i" 0 $first_operation]
      }
      MTX3_vec_multiply feature_vector fixture_mcs_matrix f_vector
      set zero 0; set one 1
      VEC3_init one zero zero V0; VEC3_init zero one zero V1; VEC3_init zero zero one V2
      for {set i 0} {$i < 3} {incr i} {
        if {[VEC3_is_parallel f_vector V$i]} {
          set b_length($i) [LIB_SPF_get_pretreatment mom_blank_cylinder_height 0 $first_operation]
        } else {
          set b_length($i) [LIB_SPF_get_pretreatment mom_blank_cylinder_diameter 0 $first_operation]
        }
      }
      VMOV 3 f_vector lib_blank_cylinder_vector
      VMOV 3 b_center lib_blank_cylinder_center
      set lib_blank_cylinder_diameter [LIB_SPF_get_pretreatment mom_blank_cylinder_diameter 0 $first_operation]
      set lib_blank_cylinder_height   [LIB_SPF_get_pretreatment mom_blank_cylinder_height 0 $first_operation]

    }

    if {[info exists b_center(0)]} {
      for {set i 0} {$i < 3} {incr i} {
        set tmp_blk_point_1($i) [expr $b_center($i)+abs($b_length($i))/2]
        set tmp_blk_point_2($i) [expr $b_center($i)-abs($b_length($i))/2]
      }
    }
  } @BLK_form_by_blank

  LIB_GE_command_buffer {
    # Made the first point to the negative and the second to the positive
    # Example point_1(X-10,Y-20 Z-40) ;  point_1(X100,Y50 Z-20
    for {set i 0} {$i < 3} {incr i} {
      if {[EQ_is_ge $tmp_blk_point_1($i) $tmp_blk_point_2($i)]} {
        set tmp_save $tmp_blk_point_1($i)
        set tmp_blk_point_1($i) $tmp_blk_point_2($i)
        set tmp_blk_point_2($i) $tmp_save
      }
    }
    VMOV 3 tmp_blk_point_1 lib_blk_point_1
    VMOV 3 tmp_blk_point_2 lib_blk_point_2

    if {[llength [info commands LIB_start_of_program_blk_form]]} {
    LIB_start_of_program_blk_form
    }
  } @BLK_form_output

  LIB_GE_command_buffer_output
}
# <Documentation>
# This function outputs the BLK FORM definition for simulation purposes on the heidenhain controller.
# The default inch values for the block are -20 and +20 for the XYZ coordinates of the lower left point
# and upper right point respectively (-500 and +500 for metric output).
# The block form may be defined by a UDE  using the array variables mom_blk_point_1 to define
# the lower left point and mom_blk_point_2 to define the upper right point.
#
# from NX1926 up it is possible to define a Quader or Cylinder as an Blank Geometrie
# This is taken now to define the output in the NC-File
# Following Output is available for Heidenhain and Siemens
#    Heidenhain iTNC530
# Quader
#    Heidenhain TNC6xx
# Quader
#       Cylinder
#    Sinumerik S840D
# Quader
#       Cylinder
#
# <Returnvalue>
# None.
# <Example>
# name: Source code
# code: proc LIB_start_of_program_blk_form {} {
# global mom_output_unit
# global mom_blk_point_1  mom_blk_point_1
# if {$mom_output_unit == "IN"} {
#   set tmp_blk_point_1(0) -20
#   set tmp_blk_point_1(1) -20
#   set tmp_blk_point_1(2) -20
#   set tmp_blk_point_2(0) +20
#   set tmp_blk_point_2(1) +20
#   set tmp_blk_point_2(2) +20
# } else {
#   set tmp_blk_point_1(0) -500
#   set tmp_blk_point_1(1) -500
#   set tmp_blk_point_1(2) -500
#   set tmp_blk_point_2(0) +500
#   set tmp_blk_point_2(1) +500
#   set tmp_blk_point_2(2) +500
# }
# if {[LIB_PT_get_header_var mom_blk_point_1(0) exists]} {
#   set tmp_blk_point_1(0) [LIB_PT_get_header_var mom_blk_point_1(0)]
#   set tmp_blk_point_1(1) [LIB_PT_get_header_var mom_blk_point_1(1)]
#   set tmp_blk_point_1(2) [LIB_PT_get_header_var mom_blk_point_1(2)]
#   set tmp_blk_point_2(0) [LIB_PT_get_header_var mom_blk_point_2(0)]
#   set tmp_blk_point_2(1) [LIB_PT_get_header_var mom_blk_point_2(1)]
#   set tmp_blk_point_2(2) [LIB_PT_get_header_var mom_blk_point_2(2)]
# }
# MOM_output_literal "BLK FORM 0.1 Z X[format %.f $tmp_blk_point_1(0)] Y[format %.f $tmp_blk_point_1(1)] Z[format %.f $tmp_blk_point_1(2)]"
# MOM_output_literal "BLK FORM 0.2 X[format %.f $tmp_blk_point_2(0)] Y[format %.f $tmp_blk_point_2(1)] Z[format %.f $tmp_blk_point_2(2)]"
#}
# desc: Default output for metric units:
# BLK FORM 0.1 Z X-500 Y-500 Z-500
# BLK FORM 0.2 X500 Y500 Z500
#____________________________________________________________________________________________

# lib_xml_handling.tcl

proc LIB_XML_tdom_get_nodes {xmlText xpath} {

  global lib_xml

  set doc [dom parse $xmlText]
  set root [$doc documentElement]

  set nodes [$root selectNodes $xpath]

  if {![string length $nodes]} {
    return
  }

  if {!$lib_xml(run)} {

    #<?xml version="1.0" encoding="utf-8"?>
    #<Configuration>
    #  <Copyright>Copyright Statement</Copyright>
    #  <Version>1.0</Version>
    #  <Controller>Sinumerik 840D</Controller>
    #  <MachineName>PrototypPSC</MachineName>
    #  <Sourcing>
    #    ...
    #
    # Read element <Version>

    set rootnode [[$nodes parentNode] parentNode]
    set rootnodename [$rootnode nodeName]
    if {[string match "Configuration" $rootnodename]} {
      set rootnode [lindex [$rootnode getElementsByTagName "Version"] 0]
      LIB_XML_tdom_get_attribute $rootnode "/$rootnodename"
    }
  }

  foreach node [$nodes childNodes] {

    set nodename [$node nodeName]

    if {[string match "Layer" $nodename]} {

      # ...
      # <Layer Name="Template" ReadOnly="true">
      #   <Copyright>Siemens Product Lifecycle Management Software Inc.</Copyright>
      #   <Version>1.0</Version>
      #   <Order>0001</Order>
      #   <Scripts>
      #   ...
      # Read attribute under <Layer>

      # Not yet needed
      # LIB_XML_tdom_get_attribute $node [file join $xpath $nodename]

      foreach subnode [$node childNodes] {

        # ...
        #   <Sequence>
        # <Layer Name="Template" ReadOnly="true">
        #   <Copyright>Siemens Product Lifecycle Management Software Inc.</Copyright>
        #   <Version>1.0</Version>
        #   <Order>0001</Order>
        #   <Scripts>
        #     <Filename Name="new_post" Include="auto" Processing="auto" />
        #   </Scripts>
        #   <DefinedEvents>
        #     <Filename Name="new_post" Include="auto" Processing="auto" />
        #   </DefinedEvents>
        #   <CustomerDialogs>
        #     <Filename Name="new_post" Include="auto" Processing="auto" />
        #   </CustomerDialogs>
        #   <Functions>
        #     <Filename Name="new_post" Extension="pui" Include="false" Processing="auto" />
        #   </Functions>
        #   <Comments>
        #     <Comment>
        #       <Changes>Siemens Product Lifecycle Management Software Inc.</Changes>
        #       <Date>01.01.2019 12:00:00</Date>
        #       <Content>Initial generated by Post Configurator</Content>
        #     </Comment>
        #   </Comments>
        # </Layer>
        # ...
        # Read attributes under <Filename>

        set subnodename [$subnode nodeName]

        set childNodes [[lindex [$subnode childNodes] 0] nodeName]
        if {[string match "Filename" $childNodes]} {
          foreach subnodes [$subnode childNodes] {
            LIB_XML_tdom_get_attribute $subnodes [file join $xpath $nodename $subnodename]
          }
        }
      }

    } elseif {[string match "Filename" $nodename]} {

      #    ...
      #    </Comments>
      #  </Layer>
      #      <Filename Name="My_Testfile" Processing="false"></Filename>
      #    </Sequence>
      #  </Sourcing>
      #  ...
      # Read attributes under <Filename>
      # Situation without Layer

      LIB_XML_tdom_get_attribute $node "${xpath}/Filename"

    }
  }

  $doc delete
  incr lib_xml(run)

}
# <Internal Documentation>
#
# Search the right node and wrote it to lib_xml(tdom)
#
# <Internal Example>
# LIB_XML_tdom_get_nodes $lib_xml_tdom_xmltext "/Configuration/Environment/Variable"
#________________________________________________________________________________
proc LIB_XML_tdom_get_attribute {node xpath} {

  global lib_xml

  set arraylist "" ; set attributes [$node attributes *]
  if {[llength $attributes]} {
    foreach attribute $attributes {
      lappend arraylist $attribute [$node getAttribute $attribute]
      # MOM_output_to_listing_device "attribute='$attribute' '[$node getAttribute $attribute]'"
    }
  } else {
    set attributes [$node nodeName]
    lappend arraylist $attributes [[$node selectNodes text()] nodeValue]
    # MOM_output_to_listing_device "elements='$attributes' '[[$node selectNodes text()] nodeValue]'"
  }
  lappend lib_xml(nodes) [list $node [file tail $xpath] $attributes]
  if {[llength $arraylist]} {array set ::$node [concat $arraylist]}
}
# <Internal Documentation>
#
# Search the right attribute and wrote it to lib_xml(nodes)
#
# <Internal Example>
# LIB_XML_tdom_get_attribute $node "/Configuration/Environment/Variable"
#________________________________________________________________________________
proc LIB_XML_tdom_load {filename} {

  global lib_xml lib_xml_tdom_xmltext

  if {[info exists lib_xml(nodes)]} {return}

  set lib_xml_tdom_filename $filename
  set lib_xml_tdom_file [open $lib_xml_tdom_filename]
  fconfigure $lib_xml_tdom_file -encoding utf-8
  set lib_xml_tdom_xmltext [read $lib_xml_tdom_file]
  close $lib_xml_tdom_file

  LIB_XML_tdom_get

}
# <Internal Documentation>
#
# Loads XML file to the memory
#
# <Internal Example>
# LIB_XML_tdom_load C:\\Temp\\Test.xml
#________________________________________________________________________________
proc LIB_XML_tdom_get {{attribute ""}} {

  global lib_xml lib_xml_tdom lib_xml_tdom_xmltext

  if {[string length $attribute]} {
    set xml_tdom $attribute
  } else {
    set xml_tdom $lib_xml_tdom
  }
  foreach e $xml_tdom {
          LIB_XML_tdom_get_nodes $lib_xml_tdom_xmltext $e
  }

  foreach nodes $lib_xml(nodes) {
    set arraylist ""
    set node [lindex $nodes 0]
    set attribute [lindex $nodes 1]
    set attributes [lindex $nodes 2]
    global $node
    foreach e $attributes {
      lappend arraylist $e [subst $$node\($e\)]
    }
          if {[llength $arraylist]} {lappend lib_xml(tdom) [list $attribute $arraylist]}
  }

}
# <Internal Documentation>
#
# Search in XML to the defined attributes
# Called from LIB_XML_tdom_load
#
# <Internal Example>
# LIB_XML_tdom_get
#________________________________________________________________________________
proc LIB_XML_to_list {filename} {

  global lib_ge_definition_keyword

  if {![LIB_Shell_file_exists $filename]} {
    LIB_GE_log_message "Required file INS->LIB_XML_to_list '$filename' cannot be found\nPlease verify\n>>[info level 1] , [info level -1] , [info level -2]"
    LIB_GE_abort_message "Required file INS->LIB_XML_to_list '$filename' cannot be found" "Please verify"
  }

  set fileid [open $filename r]
  set content [read $fileid]
  close $fileid

  lappend lib_ge_definition_keyword(loop) [file join $filename]
  if {[regsub -all (?q)[file join $filename] $lib_ge_definition_keyword(loop) [file join $filename] lib_ge_definition_keyword(loop)] > 2} {
    #the same file was loaded more than 2 times --> Abort
    LIB_GE_abort_message "File in a loop at LIB_XML_to_list" "It stops..."
  }
  regsub -all "\\\\" $content "/" content
  regsub -all "></Filename>" $content " />" content

  if {$::tcl_version > 8.1} {
    set content [LIB_XML_convert_to_list_tcl82 $content]
  } else {
    set content [LIB_XML_convert_to_list_tcl81 $content]
  }

  return $content

}
# <Internal Documentation>
#
# Loads XML file and converts it into a list
#
# <Internal Example>
# set xmllist [LIB_XML_to_list C:\\Temp\\Test.xml]
#________________________________________________________________________________
proc LIB_XML_get_node {xmllist search {case_sensitive 1}} {

  if {$case_sensitive == 0} {
    if {$::tcl_version > 8.1} {
      set xpr {string compare -nocase [lindex $sublist 0] $search}
    } else {
      set xpr {string compare [LIB_GE_string_toupper [lindex $sublist 0]] [LIB_GE_string_toupper $search]}
    }
  } else {
    set xpr {string compare [lindex $sublist 0] $search}

  }

  set numbers [llength [lindex $xmllist 2]]

  foreach sublist [lindex $xmllist 2] {
    if {[if {1} $xpr] == 0} {
      return $sublist
    }
  }
  return nul
}
# <Internal Documentation>
#
# reads a specific xml node with its childs
# the result is the first found node with the given name. if you expect
# several nodes with the same name, use LIB_XML_get_nodes instead!
# Result 0 - error / node_as_a_list - success
#
# <Internal Example>
# set node [LIB_XML_get_node $xmllist node_name]
#________________________________________________________________________________
proc LIB_XML_get_nodes {xmllist search {case_sensitive 1}} {

  global lib_xml_node_idx

  set i 0 ; set length [llength $search]
  for { set n 0 } { $n < $length } { incr n } {
    if {$case_sensitive == 0} {
      if {$::tcl_version > 8.1} {
        set xpr($n) "string compare -nocase \[lindex \$sublist 0\] \[lindex \$search $n\]"
      } else {
        set xpr($n) "string compare \[LIB_GE_string_toupper \[lindex \$sublist 0\]\] \[LIB_GE_string_toupper \[lindex \$search $n\]\]"
      }
    } else {
      set xpr($n) "string compare \[lindex \$sublist 0\] \[lindex \$search $n\]"
    }
  }

  foreach sublist [lindex $xmllist 2] {
    for { set n 0 } { $n < $length } { incr n } {
      if {[if {1} $xpr($n)] == 0} {
        incr i
        if {$i > $lib_xml_node_idx} {set lib_xml_node_idx $i; return $sublist}
      }
    }
  }
  set lib_xml_node_idx -1
  return
}
# <Internal Documentation>
#
# reads the xth xml node with its childs
# use the global var 'lib_xml_node_idx' to set the starting index for the search
# Result 0 - error / node_as_a_list - success
#
# <Internal Example>
# set lib_xml_node_idx 0
# while {$lib_xml_node_idx > -1} {
#    set node [LIB_XML_get_nodes $xmllist node_name]
#    #do something with node
# }
#________________________________________________________________________________
proc LIB_XML_get_value {node search {case_sensitive 1}} {

  if {$case_sensitive == 0} {
    if {$::tcl_version > 8.1} {
      set xpr {string compare -nocase [lindex $sublist 0] $search}
    } else {
      set xpr {string compare [LIB_GE_string_toupper [lindex $sublist 0]] [LIB_GE_string_toupper $search]}
    }
  } else {
    set xpr {string compare [lindex $sublist 0] $search}
  }
  foreach sublist [lindex $node 2] {
    if {[if {1} $xpr] ==0} {
      set tmp [lindex [lindex $sublist 2] 0]
      regsub {\{#text\} } $tmp {} tmp
      regsub {#text } $tmp {} tmp
      return [string trim $tmp]
    }
  }
  return nul
}
# <Internal Documentation>
#
# gets the value for the key 'search'
# Result 0 - error / value - success
#
# <Internal Example>
# set value [LIB_XML_get_value $node key_name]
#________________________________________________________________________________
proc LIB_XML_get_attribute {node search} {

  set idx [lsearch -exact [lindex $node 1] $search]
  if {$idx > -1} {
    set tmp [lindex [lindex $node 1] [expr $idx+1]]
    return $tmp
  }
  return nul
}
# <Internal Documentation>
#
# gets the value for the attribute 'search'
# Result nul - error / value - success
#
# <Internal Example>
# set value [LIB_XML_get_attribute $node attr_name]
#________________________________________________________________________________
proc LIB_XML_convert_to_list_tcl82 {xml} {

  regsub {^.*<[?]xml.*[?]>} $xml "" xml    ;#remove xml header
  regsub -all "<(!--)(.*?)(-->)" $xml "" xml ;#remove comments
  regsub -all {>\s*<} [string trim $xml " \n\t<>"] "\} \{" xml
  set xml [string map {> "\} \{#text \{" < "\}\} \{"}  $xml]

  set res ""   ;# string to collect the result
  set stack {} ;# track open tags
  set rest {}
  foreach item "{$xml}" {
    switch -regexp -- $item {
      ^# {append res "{[lrange $item 0 end]} " ; #text item}
      ^/ {
        regexp {/(.+)} $item -> tagname ;# end tag
        set expected [lindex $stack end]
        if {$tagname!=$expected} {
          LIB_GE_abort_message "XML parse error at LIB_XML_convert_to_list_tcl82. XML item is not complete" "INS->$item != $expected<-"
        }
        set stack [lrange $stack 0 end-1]
        append res "\}\} "
      }
      /$ { # singleton - start and end in one <> group
        regexp {([^ ]+)( (.+))?/$} $item -> tagname - rest
        set rest [lrange [string map {= " "} $rest] 0 end]
        append res "{$tagname [list $rest] {}} "
      }
      default {
        set tagname [lindex $item 0] ;# start tag
        set rest [lrange [string map {= " "} $item] 1 end]
        lappend stack $tagname
        append res "\{$tagname [list $rest] \{"
      }
    }
    if {[llength $rest]%2} {
      LIB_GE_abort_message "XML parse error at LIB_XML_convert_to_list_tcl82" "attributes not paired: INS->$rest<-"
    }
  }
  if [llength $stack] {
    LIB_GE_abort_message "XML parse error at LIB_XML_convert_to_list_tcl82" "unresolved: INS->$stack<-"
  }
  return [string map {"\} \}" "\}\}"} [lindex $res 0]]

}
# <Internal Documentation>
#
# converts XML structure into a list
# uses capabilities from tcl 8.2 +
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
# called by LIB_XML_to_list
#________________________________________________________________________________
proc LIB_XML_convert_to_list_tcl81 {xml} {

  regsub {^.*<[?]xml.*[?]>} $xml "" xml    ;#remove xml header
  regsub -all "<(!--)(.*?)(-->)" $xml "" xml ;#remove comments
  regsub -all {>\s*<} [string trim $xml " \n\t<>"] "\} \{" xml
  regsub -all > $xml "\} \{#text \{" xml
  regsub -all < $xml "\}\} \{" xml

  set res ""   ;# string to collect the result
  set stack {} ;# track open tags
  set rest {}
  foreach item "{$xml}" {
    switch -regexp -- $item {
      ^# {append res "{[lrange $item 0 end]} " ; #text item}
      ^/ {
        regexp {/(.+)} $item -> tagname ;# end tag
        set expected [lindex $stack end]
        if {$tagname!=$expected} {
          LIB_GE_abort_message "XML parse error at LIB_XML_convert_to_list_tcl81. XML item is not complete" "INS->$item != $expected<-."
        }
        set stack [lrange $stack 0 [expr [llength $stack]-2]]
        append res "\}\} "
      }
      /$ { # singleton - start and end in one <> group
        regexp {([^ ]+)( (.+))?/$} $item -> tagname - rest
      regsub -all = $rest " " rest
      set rest [lrange $rest 0 end]
        append res "{$tagname [list $rest] {}} "
      }
      default {
        set tagname [lindex $item 0] ;# start tag
        regsub -all = $item " " item
        set rest [lrange $item 1 end]
        lappend stack $tagname
        append res "\{$tagname [list $rest] \{"
      }
    }
    if {[llength $rest]%2} {
      LIB_GE_abort_message "XML parse error at LIB_XML_convert_to_list_tcl81" "att's not paired: INS->$rest<-"
    }
  }
  if [llength $stack] {
    LIB_GE_abort_message "XML parse error at LIB_XML_convert_to_list_tcl82" "unresolved: INS->$stack<-"
  }
  return [lindex $res 0]
}
# <Internal Documentation>
#
# converts XML structure into a list
# uses capabilities from tcl 8.1 (tcl version until NX9.0)
#
# <Internal Example>
# >> ONLY USED INTERNALY <<
# called by LIB_XML_to_list
#________________________________________________________________________________

# template.tcl

proc LIB_Shell_environment_handling {} {

  eval global [uplevel #0 info vars]

  # Language file and OS specific values
  if {![info exists lib_ge_slash]} {global lib_ge_slash}
  if {![info exists lib_ge_env]} {global lib_ge_env}

  set lib_ge_env(post_pool_dir)     [LIB_Shell_format_path_names [MOM_ask_env_var "UGII_POST_POOL_DIR_NG"]]
  set lib_ge_env(cam_post_dir)    [LIB_Shell_format_path_names [MOM_ask_env_var "UGII_CAM_POST_DIR"]]
  set lib_ge_env(tmp_dir)                 [LIB_Shell_format_path_names [MOM_ask_env_var "UGII_TMP_DIR"]]
  if {$lib_ge_env(tmp_dir) == ""} {set lib_ge_env(tmp_dir) $lib_ge_temppath}

  global lib_ge_installed_machines
  set lib_ge_installed_machines   [info script]
  set lib_ge_env(installed_machines_dir)  [LIB_Shell_format_path_names [file dirname $lib_ge_installed_machines]]

  set lib_ge_env(installed_machines_dir,recursively) ""
  lappend lib_ge_env(installed_machines_dir,recursively) $lib_ge_env(installed_machines_dir)

  set current_dir [pwd]
  if {![catch {cd [lindex $lib_ge_env(installed_machines_dir,recursively) 0]}]} {
    if {![catch {set dir [string tolower [glob *]]}]} {
      foreach e {libraries controller bin} {
        set index [lsearch -exact $dir $e]
        if {$index > -1} {
          set directory [lindex $dir $index]
          set directory [string toupper [string index $directory 0]][string range $directory 1 end]
          lappend lib_ge_env(installed_machines_dir,recursively) [LIB_Shell_format_path_names "[lindex $lib_ge_env(installed_machines_dir,recursively) 0]$lib_ge_slash$directory"]
              }
      }
    }
  }
  cd $current_dir

  if {![regexp -nocase -- {\w+} $lib_ge_env(post_pool_dir)]} {set lib_ge_env(post_pool_dir) $lib_ge_env(installed_machines_dir)}

  set lib_ge_env(version_bit)     [MOM_ask_env_var "UGII_VERSION_BIT"]
  set lib_ge_env(base_dir)        [MOM_ask_env_var "UGII_BASE_DIR"]

  set lib_ge_env(major_version)     [MOM_ask_env_var "UGII_MAJOR_VERSION"]
  set lib_ge_env(minor_version)       [MOM_ask_env_var "UGII_MINOR_VERSION"]
  set lib_ge_env(subminor_version)      [MOM_ask_env_var "UGII_SUBMINOR_VERSION"]

  if {![info exists lib_ge_dll_version]} {global lib_ge_dll_version}
  if {$lib_ge_env(minor_version) > 0} {
    set lib_ge_dll_version "nx$lib_ge_env(major_version)$lib_ge_env(minor_version)"
  } else {
    set lib_ge_dll_version "nx$lib_ge_env(major_version)"
  }

  regsub -all "/" $lib_ge_env(base_dir) "\\" lib_ge_env(base_dir)

}
# <Documentation>
#
# Handling for the default environment variables
#
# <Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_main {} {

  global lib_ge_env lib_ge_slash
  global lib_cycle_path sourcefile

  LIB_Shell_environment_handling

  lappend ::lib_ge_monitored_files [LIB_Shell_format_path_names [info script]]

  if {[info commands LIB_GE_source] != "LIB_GE_source"} {
    set lib_cycle_path 0
    set searchpath $lib_ge_env(installed_machines_dir,recursively)
    lappend searchpath $lib_ge_env(post_pool_dir)
    foreach path $searchpath {
      if {$lib_cycle_path} {break}
      foreach ext {.tcl .tbc} {
        set sourcefile [LIB_Shell_format_path_names "$path${lib_ge_slash}lib_sourcing$ext"]
        if {[file exists $sourcefile]} {
          if {[string match ".tbc" $ext]} {
            MOM_output_to_listing_device "ByteCode Loader is not available, cannot process lib_sourcing$ext (Provid this file not encrypted)"
            MOM_log_message "ByteCode Loader is not available, cannot process lib_sourcing$ext (Provid this file not encrypted)"
            MOM_abort "ByteCode Loader is not available, cannot process lib_sourcing$ext (Provid this file not encrypted)"
          }
          uplevel #0 {

            if {$::tcl_version >= 8.6} {
              if {[catch {source -encoding utf-8 $sourcefile} err]} {
                set lib_source_error 1
              }
            } else {
              if {[catch {source $sourcefile} err]} {
                set lib_source_error 1
              }
            }

            if {[info exists lib_source_error] && $lib_source_error == 1} {
              if {[info exists ::errorInfo]} {MOM_output_to_listing_device "errorInfo $errorInfo"}
              MOM_output_to_listing_device "File lib_sourcing $err not loadable"
              MOM_log_message "File lib_sourcing $err not loadable"
              MOM_abort "File lib_sourcing not loadable"
            } else {
              set lib_ge_debug(lib_sourcing) "$sourcefile"
              lappend lib_ge_monitored_files "$sourcefile"
              lappend lib_ge_log_message "\n--> $sourcefile loaded"
              set lib_cycle_path 1 ; break
            }

          }
        }
      }
    }
    if {!$lib_cycle_path} {
      MOM_output_to_listing_device "File lib_sourcing not found"
      MOM_log_message "File lib_sourcing not found"
      MOM_abort "File lib_sourcing not found"
    }
  }

  LIB_Shell_init

}
# <Documentation>
#
# Handling for the main shell
#
# <Example>
#
#____________________________________________________________________________________________
proc LIB_Shell_defined_post_environment {} {

  global lib_pp_source_file lib_shell

  #____________________________________________________________________________________________
  #
  # NX Post, load files
  #____________________________________________________________________________________________
  #

  # There are different ways to source each files
  #
  # e.g. Befor LIB_GE_source call
  # lappend lib_pp_source_file "machine,UGII_CAM_POST_DIR"
  #
  # e.g. After LIB_GE_source call
  # LIB_GE_source "Test" "C:/Temp/;d:/tmp/"
  #
  # e.g. To define a searchpath
  # LIB_GE_source "" "C:/Temp/;UGII_CAM_POST_DIR"
  # Allowed is the direct path and/or variable

  # This is the call for PB post files
  # ** internal funktion / Don't remove this line **
  set lib_pp_source_file ""

  # This is the call the PB post LIB_GE files
  # ** internal funktion / Don't remove this line **
  lappend lib_pp_source_file "lib_msg" "lib_file_handling" "lib_standard_post_func" "lib_document"

  # If a XML-file with the same file name found, the referenced files will also loaded
  LIB_Shell_external_source

  if {![info exists lib_shell(load_loader)] || $lib_shell(load_loader)} {
    lappend lib_pp_source_file "[file tail [file rootname $::lib_ge_installed_machines]]_custom"
  } else {
    MOM_log_message "Custom level isn't loaded"
  }


  #############################################################################################

}

# <Documentation>
#
# Handling for the default environment variables
#
# <Example>
#
#____________________________________________________________________________________________
